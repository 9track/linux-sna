diff -ruN linux-2.4.18-clean/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.18-clean/Documentation/Configure.help	Mon Feb 25 14:37:51 2002
+++ linux/Documentation/Configure.help	Fri Jun  7 04:57:39 2002
@@ -5383,6 +5383,23 @@
   The module will be called af_spx.o. If you want to compile it as a
   module, say M here and read <file:Documentation/modules.txt>.
 
+SNA Networking
+CONFIG_SNA
+  Systems Network Architecture (SNA) is a data communication protocol
+  established by IBM to specify common conventions for communication among
+  the wide array of IBM hardware and software data communications products.
+
+  Linux-SNA is the Linux supported version of the IBM SNA protocol
+  specifications. To learn more about Linux-SNA point your web browser
+  to http://www.linux-sna.org
+
+  Many of the Linux-SNA protocol options can be compiled as (M)odules
+  or staticly in the kernel. Please follow the proper Linux-SNA FAQs
+  and HOWTOs in order to select the appropriate options for your SNA
+  enviroment.
+
+  If you don't know what you are doing, say  N.
+
 DECnet networking
 CONFIG_DECNET
   The DECnet networking protocol was used in many products made by
diff -ruN linux-2.4.18-clean/Documentation/networking/sna/node-start.txt linux/Documentation/networking/sna/node-start.txt
--- linux-2.4.18-clean/Documentation/networking/sna/node-start.txt	Wed Dec 31 19:00:00 1969
+++ linux/Documentation/networking/sna/node-start.txt	Fri Jun  7 04:57:40 2002
@@ -0,0 +1,24 @@
+Linux-SNA DLC handling is as follows:
+
+Each system (node) has a pool of non-active DLCs (eth0, tr0, etc).
+
+Once a DLC has been defined 
+
+
+Available DLCs: tr0, sdlc0
+Active DLCs: eth0
+
+Upon start_node command:
+1. IFF_UP interfaces are defined and placed into the DLC_UP state.
+
+Upon port start:
+2. Listener is added for new interface when registered to be defined.
+
+DLC is only active and associated with a node when the start_dlc command
+is issued by the use.
+
+define_dlc + delete_dlc are system commands.
+
+/proc/net/sna/sna-cs-dlc
+
+
diff -ruN linux-2.4.18-clean/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux-2.4.18-clean/arch/i386/kernel/entry.S	Mon Feb 25 14:37:53 2002
+++ linux/arch/i386/kernel/entry.S	Fri Jun  7 04:57:40 2002
@@ -634,6 +634,15 @@
 	.long SYMBOL_NAME(sys_ni_syscall)	/* 235 reserved for removexattr */
 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for lremovexattr */
 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for fremovexattr */
+       	.long SYMBOL_NAME(sys_cpicall)
+       	.long SYMBOL_NAME(sys_appcall)
+       	.long SYMBOL_NAME(sys_tp_register)	/* 240 */
+       	.long SYMBOL_NAME(sys_tp_correlate)
+       	.long SYMBOL_NAME(sys_tp_unregister)
+       	.long SYMBOL_NAME(sys_attach_open)
+       	.long SYMBOL_NAME(sys_attach_listen)
+       	.long SYMBOL_NAME(sys_attach_close)	/* 245 */
+
 
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long SYMBOL_NAME(sys_ni_syscall)
diff -ruN linux-2.4.18-clean/drivers/net/channel/Config.in linux/drivers/net/channel/Config.in
--- linux-2.4.18-clean/drivers/net/channel/Config.in	Wed Dec 31 19:00:00 1969
+++ linux/drivers/net/channel/Config.in	Fri Jun  7 04:57:40 2002
@@ -0,0 +1,13 @@
+#
+# ESCON / BUS/TAG channel adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'Channel driver support'
+
+bool 'Channel driver support' CONFIG_CHANNEL
+if [ "$CONFIG_CHANNEL" = "y" ]; then
+   tristate 'Bus-Tech adapter support' CONFIG_BUSTECH
+fi
+
+endmenu
diff -ruN linux-2.4.18-clean/drivers/net/channel/Makefile linux/drivers/net/channel/Makefile
--- linux-2.4.18-clean/drivers/net/channel/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/drivers/net/channel/Makefile	Fri Jun  7 04:57:40 2002
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/channel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.18-clean/drivers/net/twinax/Config.in linux/drivers/net/twinax/Config.in
--- linux-2.4.18-clean/drivers/net/twinax/Config.in	Wed Dec 31 19:00:00 1969
+++ linux/drivers/net/twinax/Config.in	Fri Jun  7 04:57:40 2002
@@ -0,0 +1,14 @@
+#
+# Twinax adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'TwinAx driver support'
+
+bool 'TwinAx driver support' CONFIG_TWINAX
+if [ "$CONFIG_TWINAX" = "y" ]; then
+   tristate 'Affinity adapter support' CONFIG_AFFINITY
+   tristate 'Praim adapter support' CONFIG_PRAIM
+fi
+
+endmenu
diff -ruN linux-2.4.18-clean/drivers/net/twinax/Makefile linux/drivers/net/twinax/Makefile
--- linux-2.4.18-clean/drivers/net/twinax/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/drivers/net/twinax/Makefile	Fri Jun  7 04:57:40 2002
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/twinax
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.18-clean/include/asm-i386/unistd.h linux/include/asm-i386/unistd.h
--- linux-2.4.18-clean/include/asm-i386/unistd.h	Mon Feb 25 14:38:12 2002
+++ linux/include/asm-i386/unistd.h	Fri Jun  7 04:57:41 2002
@@ -242,6 +242,14 @@
 #define __NR_removexattr	235
 #define __NR_lremovexattr	236
 #define __NR_fremovexattr	237
+#define __NR_cpicall            238
+#define __NR_appcall            239
+#define __NR_tp_register        240
+#define __NR_tp_correlate       241
+#define __NR_tp_unregister      242
+#define __NR_attach_open        243
+#define __NR_attach_listen      244
+#define __NR_attach_close       245
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
 
diff -ruN linux-2.4.18-clean/include/linux/af_netb.h linux/include/linux/af_netb.h
--- linux-2.4.18-clean/include/linux/af_netb.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/af_netb.h	Fri Jun  7 04:57:41 2002
@@ -0,0 +1,192 @@
+#ifndef _LINUX_AF_NETB_H
+#define _LINUX_AF_NETB_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* General definitions */
+#define NETBEUI_MAX_DATALEN  (64 * 1024) /* 64K-bytes max data buffer len */
+#define NETBEUI_MAX_NAMES    255      /* Maximum number of local names */
+#define NETBEUI_MAX_ADAPTERS 16	      /* Maximum number of local adapters */
+#define NETBEUI_MAX_LINKS    256      /* Maximum number of links to others */
+#define NETBEUI_MAX_SESSIONS 255      /* Maximum number of sessions on a link */
+
+#define SOCK_NAME	SOCK_RAW    /* Socket type for Name registration */
+#define NETBEUI_NAME_LEN 16
+
+/* NetBEUI address type definitions */
+typedef enum {
+	NETBEUI_NAME_UNIQUE = 1,
+	NETBEUI_NAME_GROUP
+} name_type_t;
+
+struct netbeui_addr {
+	char		name[NETBEUI_NAME_LEN];
+	unsigned char	reserved;	/* Safety region */
+	name_type_t	name_type;
+};
+
+/* Maximum permitted length of this structure is MAX_SOCK_ADDR defined in
+ * 'net/socket.c' */
+struct sockaddr_netbeui {
+	unsigned short		snb_family;         /* s.b. AF_NETBEUI */
+	struct netbeui_addr	snb_addr;
+};
+
+/* NetBEUI Socket Layer Default Values */
+#define NBSO_DFLT_STO_SEC    0 /* Seconds of 'Send Time Out' value */
+#define NBSO_DFLT_STO_MICSEC 0 /* Micro-Seconds of 'Send Time Out' value */
+
+#define NBSO_DFLT_RTO_SEC    0 /* Seconds of 'Receive Time Out' value */
+#define NBSO_DFLT_RTO_MICSEC 0 /* Micro-Seconds of 'Receive Time Out' value */
+
+/* NetBEUI ioctls */
+/* From 0x89E0 to 0x89EF are protocol private 'ioctl numbers'                 *\
+ * For more information see  SIOCDEVPRIVATE and SIOCPROTOPRIVATE  definitions *
+\* in 'include/linux/sockios.h' file                                          */
+
+/* NetBEUI specific I/O ConTroL calls (ioctl) */
+#define SIOCGSTATE   (SIOCPROTOPRIVATE)     /* Gets NetBEUI socket state */
+#define SIOCTRIMDATA (SIOCPROTOPRIVATE + 1) /* Trims last bytes of current
+					       message */
+#define SIOCSENDZERO (SIOCPROTOPRIVATE + 2) /* Send a dummy session message with
+					       zero size */
+#define SIOCRUWDGF   (SIOCPROTOPRIVATE + 3) /* Removes an UnWanted DataGram
+					       Frames */
+#define NBIOCGSTATUS (SIOCPROTOPRIVATE + 4) /* Gets NetBIOS STATUS of local or
+					       remote node */
+#define NBIOCCONFIG  (SIOCPROTOPRIVATE + 5) /* Configures NetBEUI during
+					       running */
+/* NetBEUI 'SIOCGSTATE' ioctl() Constants */
+typedef enum {
+	NBSO_INIT = 0,
+	NBSO_LISTENING,
+	NBSO_RUNNING
+} nbso_state_t;
+
+/* NetBEUI Configuration (via NBIOCCONFIG ioctl) */
+/* NetBEUI Configuration request constants */
+#define NETBEUI_UNBIND_FLAG_SAFE  0 /* Unbinds device only if no connection
+				       exist on it */
+#define NETBEUI_UNBIND_FLAG_DROP  1 /* Drops connections that exist on device
+				       and then unbinds it */
+#define NETBEUI_CFGCMD_NIF_UNBIND 0
+#define NETBEUI_CFGCMD_NIF_BIND   1
+#define NETBEUI_CFGCMD_DROP_SESS  2
+#define NETBEUI_CFGCMD_DROP_LINK  3
+
+/* NetBEUI Configuration request data structure */
+struct netbeui_cfg {
+	unsigned short	command;	/* NETBEUI_CFGCMD_... */
+	char		nif_name[IFNAMSIZ];
+	unsigned char	reserved;	/* Safety region, always must be zero */
+	unsigned char	flag;		/* NETBEUI_UNBIND_FLAG_... */
+	int		ln_num;		/* 0 <= ln_num < NETBEUI_MAX_LINKS */
+	int		sn_num;		/* 0 < sn_num < NETBEUI_MAX_SESSIONS */
+};
+
+/* NetBEUI setsockopt / getsockopt */
+/*
+ * NetBEUI specific option names for setsockopt() & getsockopt()
+ *
+ * Note: Remainder of option names defined in 'asm/socket.h' from 1 to 15
+ */
+#define SO_URGENTACK 106	
+#define SO_NBPARAM   107
+
+/*
+ * NetBEUI configurable parameters use by SO_NBPARAM
+ *
+ * Note: Setting value of a parameter to zero means no change to the
+ *	 current value.
+ */
+struct netbeui_config {
+	__u8 inactivity_timeout;
+	__u8 transmit_timeout;
+	__u8 transmit_count;
+	__u8 resource_timeout;
+	__u8 data_ack_timeout;
+};
+
+/* Definition of default and maximum value of NetBIOS configurable parameters */
+#define NETBEUI_DFLT_LINK_INACT_TMOUT	30	/* Unit is second */
+#define NETBEUI_MAX_LINK_INACT_TMOUT	255	/* Unit is second */
+#define NETBEUI_DFLT_TX_TMOUT		1	/* Unit is 1/2 second */
+#define NETBEUI_MAX_TX_TMOUT		10	/* Unit is 1/2 second */
+#define NETBEUI_DFLT_TX_COUNT		6
+#define NETBEUI_MAX_TX_COUNT		10
+#define NETBEUI_DFLT_RSRC_TMOUT		1	/* Unit is 1/10 second */
+#define NETBEUI_MAX_RSRC_TMOUT		10	/* Unit is 1/10 second */
+#define NETBEUI_DFLT_DATA_ACK_TMOUT	1	/* Unit is 1/10 second */
+#define NETBEUI_MAX_DATA_ACK_TMOUT	10	/* Unit is 1/10 second */
+
+/* NetBEUI STATUS Service */
+/* NetBEUI status service constants */
+#define NETBEUI_MIN_STATUS_BUFF_LEN 60
+#define NETBEUI_MAX_STATUS_BUFF_LEN (NETBEUI_MIN_STATUS_BUFF_LEN + \
+				     18 * NETBEUI_MAX_NAMES)
+/* NetBEUI STATUS request data structure */
+struct netbeui_status {
+	char called_name[NETBEUI_NAME_LEN];
+	char reserved;       /* Safety region, always must be zero */
+	int  buff_len;
+	char status_buff[0]; /* A dynamic length array for status information */
+};
+
+/* Adapter types in status information */
+enum {
+	NETBEUI_3174_PEER = 0xFB,
+	NETBEUI_IBM_FDDI,
+	NETBEUI_ETHERNET,
+	NETBEUI_PC_NETWORK,
+	NETBEUI_TOKEN_RING
+};
+
+/* Name structure in status information */
+struct nb_status_names {
+	char	name[NETBEUI_NAME_LEN];
+	__u8	name_number;
+	__u8	name_status;
+};
+
+/* STATUS information structure */
+typedef struct {
+	__u8	adptr_addr[6];
+	__u8	sftwr_release_no;
+	__u8	zero;
+	struct {
+		__u8	adptr_type;
+		__u8	sftwr_level;
+	}	adptr_type_AND_sftwr_level;
+	__u16	duration;
+	__u16	no_rx_FRMR;			/* NOT SUPPORTED YET */
+	__u16	no_tx_FRMR;			/* NOT SUPPORTED YET */
+	__u16	no_rx_Iformat_LPDUs;		/* NOT SUPPORTED YET */
+	__u16	no_abrtd_transmissions;		/* NOT SUPPORTED YET */
+	__u32	no_succ_tx_packets;		/* NOT SUPPORTED YET */
+	__u32	no_succ_rx_packets;		/* NOT SUPPORTED YET */
+	__u16	no_tx_Iformat_LPDUs;		/* NOT SUPPORTED YET */
+	__u16	lost_data_OR_buff_fails;	/* NOT SUPPORTED YET */
+	__u16	no_DLC_T1_expired;		/* NOT SUPPORTED YET */
+	__u16	no_DLC_Ti_expired;		/* NOT SUPPORTED YET */
+	__u32	ext_status_inf_addr;		/* NOT SUPPORTED YET */
+	__u16	no_free_NCBs;			/* NOT SUPPORTED YET */
+	__u16	config_max_NCBs;		/* NOT SUPPORTED YET */
+	__u16	max_no_NCBs;			/* NOT SUPPORTED YET */
+	__u16	local_busy_OR_buff_fails;	/* NOT SUPPORTED YET */
+	__u16	max_dgram_packet_size;
+	__u16	no_pend_sess;			/* NOT SUPPORTED YET */
+	__u16	config_max_pend_sess;		/* NOT SUPPORTED YET */
+	__u16	max_no_pend_sess;
+	__u16	max_size_sess_data_packet;
+	__u16	no_names_in_local_name_tbl;
+	struct nb_status_names local_names[NETBEUI_MAX_NAMES];
+} nb_status_buffer_t;
+#endif /* _LINUX_AF_NETB_H */
diff -ruN linux-2.4.18-clean/include/linux/appc.h linux/include/linux/appc.h
--- linux-2.4.18-clean/include/linux/appc.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/appc.h	Fri Jun  7 04:57:41 2002
@@ -0,0 +1,571 @@
+/* appc.h: Advanced Program-to-Program Communications structures and defs.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _APPC_H
+#define _APPC_H
+
+/* Linux-SNA APPC Call OPCODES */
+#define AC_ALLOCATE				0x0001
+#define AC_MC_ALLOCATE				0x0010
+#define AC_DEALLOCATE				0x0020
+#define AC_MC_DEALLOCATE			0x0030
+#define AC_GET_ATTRIBUTES			0x0040
+#define AC_GET_TP_PROPERTIES			0x0050
+#define AC_RECEIVE_AND_WAIT			0x0060
+#define AC_MC_RECEIVE_AND_WAIT			0x0070
+#define AC_REQUEST_TO_SEND			0x0080
+#define AC_MC_REQUEST_TO_SEND			0x0090
+#define AC_SEND_DATA				0x00A0
+#define AC_MC_SEND_DATA				0x00B0
+#define AC_CONFIRM				0x00C0
+#define AC_MC_CONFIRM				0x00D0
+#define AC_CONFIRMED				0x00E0
+#define AC_MC_CONFIRMED				0x00F0
+#define AC_SEND_ERROR				0x0100
+#define AC_MC_SEND_ERROR			0x0110
+#define AC_CHANGE_SESSION_LIMIT			0x0120
+#define AC_INIT_SESSION_LIMIT			0x0130
+#define AC_PROCESS_SESSION_LIMIT		0x0140
+#define AC_RESET_SESSION_LIMIT			0x0150
+#define AC_MC_GET_ATTRIBUTES			0x0160
+#define AC_GET_TYPE				0x0170
+#define AC_SET_SYNCPT_OPTIONS			0x0180
+#define AC_FLUSH				0x0190
+#define AC_MC_FLUSH				0x01A0
+#define AC_POST_ON_RECEIPT			0x01B0
+#define AC_MC_POST_ON_RECEIPT			0x01C0
+#define AC_PREPARE_TO_RECEIVE			0x01D0
+#define AC_MC_PREPARE_TO_RECEIVE		0x01E0
+#define AC_RECEIVE_EXPEDITED_DATA		0x01F0
+#define AC_RECEIVE_IMMEDIATE			0x0200
+#define AC_MC_RECEIVE_IMMEDIATE			0x0210
+#define AC_SEND_EXPEDITED_DATA			0x0220
+#define AC_MC_SEND_EXPEDITED_DATA		0x0230
+#define AC_TEST					0x0240
+#define AC_MC_TEST				0x0250
+#define AC_WAIT					0x0260
+#define AC_WAIT_FOR_COMPLETION			0x0270
+#define AC_BACKOUT				0x0280
+#define AC_PREPARE_FOR_SYNCPT			0x0290
+#define AC_MC_PREPARE_FOR_SYNCPT		0x02A0
+#define AC_ACTIVATE_SESSION			0x02B0
+#define AC_DEACTIVATE_CONVERSATION_GROUP	0x02C0
+#define AC_DEACTIVATE_SESSION			0x02D0
+#define AC_DEFINE_LOCAL_LU			0x02E0
+#define AC_DEFINE_MODE				0x02F0
+#define AC_DEFINE_REMOTE_LU			0x0300
+#define AC_DEFINE_TP				0x0310
+#define AC_DELETE				0x0320
+#define AC_DISPLAY_LOCAL_LU			0x0330
+#define AC_DISPLAY_MODE				0x0340
+#define AC_DISPLAY_REMOTE_LU			0x0350
+#define AC_DISPLAY_TP				0x0360
+#define AC_PROCESS_SIGNOFF			0x0370
+#define AC_SIGNOFF				0x0380
+
+/* Linux-SNA APPC return codes */
+#define AC_OK					0x0000
+#define AC_PARAMETER_CHECK			0x0001
+#define AC_BAD_TP_ID				0x0010
+#define AC_BAD_CONV_ID				0x0020
+#define AC_BAD_LU_ALIAS				0x0030
+#define AC_INVALID_DATA_SEGMENT			0x0040
+#define AC_BAD_CONV_TYPE			0x0050
+#define AC_BAD_SYNC_LEVEL			0x0060
+#define AC_BAD_SECURITY				0x0070
+#define AC_BAD_RETURN_CONTROL			0x0080
+#define AC_PIP_LEN_INCORRECT			0x0090
+#define AC_NO_USE_OF_SNASVCMG			0x00A0
+#define AC_UNKNOWN_PARTNER_MODE			0x00B0
+#define AC_CONFIRM_ON_SYNC_LEVEL_NONE		0x00C0
+#define AC_DEALLOC_BAD_TYPE			0x00D0
+#define AC_DEALLOC_LOG_LL_WRONG			0x00E0
+#define AC_P_TO_R_INVALID_TYPE			0x00F0
+#define AC_RCV_AND_WAIT_BAD_FILL		0x0100
+#define AC_RCV_IMMD_BAD_FILL			0x0110
+#define AC_RCV_AND_POST_BAD_FILL		0x0120
+#define AC_INVALID_SEMAPHONE_HANDLE		0x0130
+#define AC_BAD_RETURN_STATUS_WITH_DATA		0x0140
+#define AC_BAD_LL				0x0150
+#define AC_SEND_INVALID_TYPE			0x0160
+#define AC_INVALID_SESSION_ID			0x0170
+#define AC_INVALID_POLARITY			0x0180
+#define AC_INVALID_TYPE				0x0190
+#define AC_INVALID_LU_ALIAS			0x01A0
+#define AC_INVALID_PLU_ALIAS			0x01B0
+#define AC_INVALID_MODE_NAME			0x01C0
+#define AC_INVALID_TRANSACT_ID			0x01D0
+#define AC_SEND_DATA_CONFIRM_SYNC_LEVEL_NONE	0x01E0
+#define AC_BAD_PARTNER_LU_ALIAS			0x01F0
+#define AC_SEND_ERROR_LOG_LL_WRONG		0x0200
+#define AC_SEND_ERROR_BAD_TYPE			0x0210
+#define AC_BAD_ERROR_DIRECTION			0x0220
+#define AC_TOO_MANY_TPS				0x0230
+#define AC_BAD_TYPE				0x0240
+#define AC_UNDEFINED_TP_NAME			0x0250
+#define AC_INVALID_SET_PROT			0x0260
+#define AC_INVALID_NEW_PROT			0x0270
+#define AC_INVALID_SET_UNPROT			0x0280
+#define AC_INVALID_NEW_UNPROT			0x0290
+#define AC_INVALID_SET_USER			0x02A0
+#define AC_INVALID_DATA_TYPE			0x02B0
+#define AC_BAD_LOCAL_LU_ALIAS			0x02C0
+#define AC_BAD_REMOTE_LU_ALIAS			0x02D0
+#define AC_POST_ON_RECEIPT_BAD_FILL		0x02E0
+#define AC_STATE_CHECK				0x02F0
+#define AC_CONFIRM_BAD_STATE			0x0300
+#define AC_CONFIRM_NO_LL_BDY			0x0310
+#define AC_CONFIRMED_BAD_STATE			0x0320
+#define AC_DEALLOC_FLUSH_BAD_STATE		0x0330
+#define AC_DEALLOC_CONFIRM_BAD_STATE		0x0340
+#define AC_DEALLOC_NOT_LL_BDY			0x0350
+#define AC_FLUSH_NOT_SEND_STATE			0x0360
+#define AC_P_TO_R_NOT_LL_BDY			0x0370
+#define AC_P_TO_R_NOT_SEND_STATE		0x0380
+#define AC_RCV_AND_WAIT_BAD_STATE		0x0390
+#define AC_RCV_AND_WAIT_NOT_LL_BDY		0x03A0
+#define AC_RCV_IMMD_BAD_STATE			0x03B0
+#define AC_RCV_AND_POST_BAD_STATE		0x03C0
+#define AC_RCV_AND_POST_NOT_LL_BDY		0x03D0
+#define AC_R_T_S_BAD_STATE			0x03E0
+#define AC_SEND_DATA_NOT_SEND_STATE		0x03F0
+#define AC_SEND_DATA_NOT_LL_BDY			0x0400
+#define AC_ATTACH_MANAGER_INACTIVE		0x0410
+#define AC_ALLOCATE_NOT_PENDING			0x0420
+#define AC_INVALID_PROCESS			0x0430
+#define AC_ALLOCATION_ERROR			0x0440
+#define AC_ALLOCATION_FAILURE_NO_RETRY		0x0450
+#define AC_ALLOCATION_FAILURE_RETRY		0x0460
+#define AC_SECURITY_NOT_VALID			0x0470
+#define AC_TRANS_PGM_NOT_AVAIL_RETRY		0x0480
+#define AC_TRANS_PGM_NOT_AVAIL_NO_RETRY		0x0490
+#define AC_TP_NAME_NOT_RECOGNIZED		0x04A0
+#define AC_PIP_NOT_ALLOWED			0x04B0
+#define AC_PIP_NOT_SPECIFIED_CORRECTLY		0x04C0
+#define AC_CONVERSATION_TYPE_MISMATCH		0x04D0
+#define AC_SYNC_LEVEL_NOT_SUPPORTED		0x04E0
+#define AC_DEALLOC_ABEND			0x04F0
+#define AC_DEALLOC_ABEND_PROG			0x0500
+#define AC_DEALLOC_ABEND_SCV			0x0510
+#define AC_DEALLOC_ABEND_TIMER			0x0520
+#define AC_DEALLOC_NORMAL			0x0530
+#define AC_PROG_ERROR_NO_TRUNC			0x0540
+#define AC_PROG_ERROR_PURGING			0x0550
+#define AC_CONV_FAILURE_RETRY			0x0560
+#define AC_CONV_FAILURE_NO_RETRY		0x0570
+#define AC_SCV_ERROR_TRUNC			0x0580
+#define AC_SCV_ERROR_PURGING			0x0590
+#define AC_UNSUCCESSFUL				0x05A0
+#define AC_CONVERSATION_TYPE_MIXED		0x05B0
+#define AC_CANCELLED				0x05C0
+#define AC_SECURITY_REQUESTED_NOT_SUPPORTED	0x05D0
+#define AC_TP_BUSY				0x05E0
+#define AC_BACKED_OUT				0x05F0
+#define AC_BO_NO_RESYNC				0x0600
+#define AC_BO_RESYNC				0x0610
+#define AC_ACTIVATION_FAIL_RETRY		0x0620
+#define AC_ACTIVATION_FAIL_NO_RETRY		0x0630
+#define AC_SESSION_LIMITS_CLOSED		0x0640
+#define AC_SESSION_LIMITS_EXCEEDED		0x0650
+#define AC_VERB_IN_PROGRESS			0x0660
+#define AC_SESSION_DEACTIVATED			0x0670
+#define AC_COMM_SUBSYSTEM_ABENDED		0x0680
+#define AC_COMM_SUBSYSTEM_NOT_LOADED		0x0690
+#define AC_CONV_BUSY				0x06A0
+#define AC_INVALID_VERB				0x06B0
+
+
+/* Linux-SNA APPC call data structures. */
+struct sna_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	conv_type;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char 	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_mc_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+};
+
+struct sna_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_tp_properties {
+
+};
+
+struct sna_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_request_to_send {
+
+};
+
+struct sna_mc_request_to_send {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_mc_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_mc_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_error {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	err_type;
+	unsigned char	err_dir;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_send_error {
+        unsigned char   tp_id[8];
+        unsigned long   conv_id;
+        unsigned char   rts_rcvd;
+        unsigned char   err_type;
+        unsigned char   err_dir;
+        unsigned short  log_dlen;
+        unsigned char   *log_dptr;
+};
+
+struct sna_change_session_limit {
+
+};
+
+struct sna_init_session_limit {
+
+};
+
+struct sna_process_session_limit {
+
+};
+
+struct sna_reset_session_limit {
+
+};
+
+struct sna_mc_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_type {
+
+};
+
+struct sna_set_syncpt_options {
+
+};
+
+struct sna_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_post_on_receipt {
+
+};
+
+struct sna_mc_post_on_receipt {
+
+};
+
+struct sna_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_mc_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_receive_expedited_data {
+
+};
+
+struct sna_mc_receive_expedited_data {
+
+};
+
+struct sna_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_send_expedited_data {
+
+};
+
+struct sna_mc_send_expedited_data {
+
+};
+
+struct sna_test {
+
+};
+
+struct sna_mc_test {
+
+};
+
+struct sna_wait {
+
+};
+
+struct sna_wait_for_completion {
+
+};
+
+struct sna_backout {
+
+};
+
+struct sna_prepare_for_syncpt {
+
+};
+
+struct sna_mc_prepare_for_syncpt {
+
+};
+
+struct sna_syncpt {
+
+};
+
+struct sna_activate_session {
+
+};
+
+struct sna_deactivate_conversation_group {
+
+};
+
+struct sna_deactivate_session {
+
+};
+
+struct sna_define_local_lu {
+
+};
+
+struct sna_define_mode {
+
+};
+
+struct sna_define_remote_lu {
+
+};
+
+struct sna_define_tp {
+
+};
+
+struct sna_delete {
+
+};
+
+struct sna_display_local_lu {
+
+};
+
+struct sna_display_mode {
+
+};
+
+struct sna_display_remote_lu {
+
+};
+
+struct sna_display_tp {
+
+};
+
+struct sna_process_signoff {
+
+};
+
+struct sna_signoff {
+
+};
+
+extern void appc(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr);
+
+#ifdef __KERNEL__
+
+struct appc_ops {
+	int family;
+};
+
+#endif /* __KERNEL__ */
+#endif /* _APPC_H */
diff -ruN linux-2.4.18-clean/include/linux/attach.h linux/include/linux/attach.h
--- linux-2.4.18-clean/include/linux/attach.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/attach.h	Fri Jun  7 11:58:53 2002
@@ -0,0 +1,65 @@
+#ifndef _LINUX_ATTACH_H
+#define _LINUX_ATTACH_H
+
+struct tp_info {
+        char            tp_name[64];
+        unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+        unsigned long   flags;
+};
+
+struct tp_attach {
+	char		tp_name[64];
+	int		tp_len;
+	unsigned long	tcb_id;
+	char		netid[17];
+	char		luow_id[6];
+	char		raw_attach_hdr[100];
+};
+
+#ifdef __KERNEL__
+
+typedef enum {
+        AT_RESET = 1,
+        AT_INIT,
+        AT_WAITING,
+        AT_ATTACHED
+} attach_state;
+
+struct attach_tps {
+	struct list_head list;
+
+	attach_state	state;
+	unsigned short	flags;
+	pid_t		pid;
+	unsigned long	id;
+
+	char		tp_name[64];
+	unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+};
+
+struct attach {
+        unsigned short          flags;
+
+        struct attach_ops       *ops;		/* Calls backs for this ID */
+	struct list_head	tps;		/* All TPs using the attach */
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+
+        wait_queue_head_t       wait;
+};
+
+struct attach_ops {
+        int family;
+        int (*tp_correlate)  (pid_t pid, unsigned long tcb_id, char *tp_name);
+        int (*attach_listen) (struct attach *at, void *buf, int len);
+};
+
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+#endif /* __KERNEL__ */
+#endif /* __LINUX_ATTACH_H */
diff -ruN linux-2.4.18-clean/include/linux/brlock.h linux/include/linux/brlock.h
--- linux-2.4.18-clean/include/linux/brlock.h	Thu Nov 22 14:46:19 2001
+++ linux/include/linux/brlock.h	Fri Jun  7 08:46:24 2002
@@ -28,13 +28,15 @@
  * load-locked/store-conditional cpus (ALPHA/MIPS/PPC) and
  * compare-and-swap cpus (Sparc64).  So we control which
  * implementation to use with a __BRLOCK_USE_ATOMICS define. -DaveM
+ *
+ * Added BR_LLC_LOCK for use in net/core/ext8022.c -acme
  */
 
 /* Register bigreader lock indices here. */
 enum brlock_indices {
 	BR_GLOBALIRQ_LOCK,
 	BR_NETPROTO_LOCK,
-
+	BR_LLC_LOCK,
 	__BR_END
 };
 
diff -ruN linux-2.4.18-clean/include/linux/cpic.h linux/include/linux/cpic.h
--- linux-2.4.18-clean/include/linux/cpic.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/cpic.h	Fri Jun  7 04:57:41 2002
@@ -0,0 +1,855 @@
+/* cpic.h: CPI Communications Header.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _CPIC_H
+#define _CPIC_H
+
+#define CM_INT32 signed long int
+#define CM_ENTRY extern void
+#define CM_PTR *
+
+typedef unsigned char CONVERSATION_ID [8];
+typedef unsigned char CONTEXT_ID [32];
+typedef unsigned char SECURITY_PASSWORD [10];
+typedef unsigned char SECURITY_USER_ID [10];
+
+typedef CM_INT32 CM_AE_QUAL_OR_AP_TITLE_FORMAT;
+typedef CM_INT32 CM_ALLOCATE_CONFIRM_TYPE;
+typedef CM_INT32 CM_BEGIN_TRANSACTION;
+typedef CM_INT32 CM_BUFFER_LENGTH;
+typedef CM_INT32 CM_CALL_ID;
+typedef CM_INT32 CM_COMPLETED_OP_COUNT;
+typedef CM_INT32 CM_CONFIRMATION_URGENCY;
+typedef CM_INT32 CM_CONTEXT_ID_LENGTH;
+typedef CM_INT32 CM_CONTROL_INFORMATION_RECEIVED;
+typedef CM_INT32 CM_CONVERSATION_QUEUE;
+typedef CM_INT32 CM_CONVERSATION_RETURN_CODE;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 CM_SECURITY_PASSWORD_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_LENGTH;
+typedef CM_INT32 CM_SECURITY_USER_ID_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_STATE;
+typedef CM_INT32 CM_CONVERSATION_TYPE;
+typedef CM_INT32 CM_DATA_RECEIVED_TYPE;
+typedef CM_INT32 CM_DEALLOCATE_TYPE;
+typedef CM_INT32 CM_DIRECTORY_ENCODING;
+typedef CM_INT32 CM_DIRECTORY_SYNTAX;
+typedef CM_INT32 CM_ERROR_DIRECTION;
+typedef CM_INT32 CM_FILL;
+typedef CM_INT32 CM_MAXIMUM_BUFFER_SIZE;
+typedef CM_INT32 CM_OOID;
+typedef CM_INT32 CM_PARTNER_ID_SCOPE;
+typedef CM_INT32 CM_PARTNER_ID_TYPE;
+typedef CM_INT32 CM_PREPARE_DATA_PERMITTED_TYPE;
+typedef CM_INT32 CM_PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 CM_PROCESSING_MODE;
+typedef CM_INT32 CM_RECEIVE_TYPE;
+typedef CM_CONTROL_INFORMATION_RECEIVED CM_REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETURN_CODE;
+typedef CM_INT32 CM_RETURN_CONTROL;
+typedef CM_INT32 CM_SEND_RECEIVE_MODE;
+typedef CM_INT32 CM_SEND_TYPE;
+typedef CM_INT32 CM_STATUS_RECEIVED;
+typedef CM_INT32 CM_SYNC_LEVEL;
+typedef CM_INT32 CM_TIMEOUT;
+typedef CM_INT32 CM_TRANSACTION_CONTROL;
+typedef CM_INT32 CONVERSATION_TYPE;
+typedef CM_INT32 CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 DATA_RECEIVED;
+typedef CM_INT32 DEALLOCATE_TYPE;
+typedef CM_INT32 ERROR_DIRECTION;
+typedef CM_INT32 PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 PROCESSING_MODE;
+typedef CM_INT32 RECEIVE_TYPE;
+typedef CM_INT32 REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETCODE;
+typedef CM_INT32 RETURN_CONTROL;
+typedef CM_INT32 SEND_TYPE;
+typedef CM_INT32 STATUS_RECEIVED;
+typedef CM_INT32 SYNC_LEVEL;
+
+#define CM_DN	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 0
+#define CM_OID	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 1
+
+/* Allocate_confirm values. */
+#define CM_ALLOCATE_NO_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 0
+#define CM_ALLOCATE_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 1
+
+/* begin_transaction values. */
+#define CM_BEGIN_IMPLICIT	(CM_BEGIN_TRANSACTION) 0
+#define CM_BEGIN_EXPLICIT	(CM_BEGIN_TRANSACTION) 1
+
+/* call_ID values. */
+#define CM_CMACCI		(CM_CALL_ID) 1
+#define CM_CMACCP		(CM_CALL_ID) 2
+#define CM_CMALLC		(CM_CALL_ID) 3
+#define CM_CMCANC		(CM_CALL_ID) 4
+#define CM_CMCFM		(CM_CALL_ID) 5
+#define CM_CMCFMD		(CM_CALL_ID) 6
+#define CM_CMCNVI		(CM_CALL_ID) 7
+#define CM_CMCNVO		(CM_CALL_ID) 8
+#define CM_CMDEAL		(CM_CALL_ID) 9
+#define CM_CMDFDE		(CM_CALL_ID) 10
+#define CM_CMEACN		(CM_CALL_ID) 11
+#define CM_CMEAEQ		(CM_CALL_ID) 12
+#define CM_CMEAPT		(CM_CALL_ID) 13
+#define CM_CMECS		(CM_CALL_ID) 14
+#define CM_CMECT		(CM_CALL_ID) 15
+#define CM_CMECTX		(CM_CALL_ID) 16
+#define CM_CMEID		(CM_CALL_ID) 17
+#define CM_CMEMBS		(CM_CALL_ID) 18
+#define CM_CMEMN		(CM_CALL_ID) 19
+#define CM_CMEPID		(CM_CALL_ID) 20
+#define CM_CMEPLN		(CM_CALL_ID) 21
+#define CM_CMESI		(CM_CALL_ID) 22
+#define CM_CMESL		(CM_CALL_ID) 23
+#define CM_CMESRM		(CM_CALL_ID) 24
+#define CM_CMESUI		(CM_CALL_ID) 25
+#define CM_CMETC		(CM_CALL_ID) 26
+#define CM_CMETPN		(CM_CALL_ID) 27
+#define CM_CMFLUS		(CM_CALL_ID) 28
+#define CM_CMINCL		(CM_CALL_ID) 29
+#define CM_CMINIC		(CM_CALL_ID) 30
+#define CM_CMINIT		(CM_CALL_ID) 31
+#define CM_CMPREP		(CM_CALL_ID) 32
+#define CM_CMPTR		(CM_CALL_ID) 33
+#define CM_CMRCV		(CM_CALL_ID) 34
+#define CM_CMRCVX		(CM_CALL_ID) 35
+#define CM_CMRLTP		(CM_CALL_ID) 36
+#define CM_CMRTS		(CM_CALL_ID) 37
+#define CM_CMSAC		(CM_CALL_ID) 38
+#define CM_CMSACN		(CM_CALL_ID) 39
+#define CM_CMSAEQ		(CM_CALL_ID) 40
+#define CM_CMSAPT		(CM_CALL_ID) 41
+#define CM_CMSBT		(CM_CALL_ID) 42
+#define CM_CMSCSP		(CM_CALL_ID) 43
+#define CM_CMSCST		(CM_CALL_ID) 44
+#define CM_CMSCSU		(CM_CALL_ID) 45
+#define CM_CMSCT		(CM_CALL_ID) 46
+#define CM_CMSCU		(CM_CALL_ID) 47
+#define CM_CMSDT		(CM_CALL_ID) 48
+#define CM_CMSED		(CM_CALL_ID) 49
+#define CM_CMSEND		(CM_CALL_ID) 50
+#define CM_CMSERR		(CM_CALL_ID) 51
+#define CM_CMSF			(CM_CALL_ID) 52
+#define CM_CMSID		(CM_CALL_ID) 53
+#define CM_CMSLD		(CM_CALL_ID) 54
+#define CM_CMSLTP		(CM_CALL_ID) 55
+#define CM_CMSMN		(CM_CALL_ID) 56
+#define CM_CMSNDX		(CM_CALL_ID) 57
+#define CM_CMSPDP		(CM_CALL_ID) 58
+#define CM_CMSPID		(CM_CALL_ID) 59
+#define CM_CMSPLN		(CM_CALL_ID) 60
+#define CM_CMSPM		(CM_CALL_ID) 61
+#define CM_CMSPTR		(CM_CALL_ID) 62
+#define CM_CMSQCF		(CM_CALL_ID) 63
+#define CM_CMSQPM		(CM_CALL_ID) 64
+#define CM_CMSRC		(CM_CALL_ID) 65
+#define CM_CMSRT		(CM_CALL_ID) 66
+#define CM_CMSSL		(CM_CALL_ID) 67
+#define CM_CMSSRM		(CM_CALL_ID) 68
+#define CM_CMSST		(CM_CALL_ID) 69
+#define CM_CMSTC		(CM_CALL_ID) 70
+#define CM_CMSTPN		(CM_CALL_ID) 71
+#define CM_CMTRTS		(CM_CALL_ID) 72
+#define CM_CMWAIT		(CM_CALL_ID) 73
+#define CM_CMWCMP		(CM_CALL_ID) 74
+
+/* confirmation_urgency values. */
+#define CM_CONFIRMATION_NOT_URGENT	(CM_CONFIRMATION_URGENCY) 0
+#define CM_CONFIRMATION_URGENT		(CM_CONFIRMATION_URGENCY) 1
+
+/* control_information_received, request_to_send_received_values. */
+#define CM_NO_CONTROL_INFO_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_NOT_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_RECEIVED		(CM_CONTROL_INFORMATION_RECEIVED) 1
+#define CM_ALLOCATE_CONFIRMED		(CM_CONTROL_INFORMATION_RECEIVED) 2
+#define CM_ALLOCATE_CONFIRMED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 3
+#define CM_ALLOCATE_REJECTED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 4
+#define CM_EXPEDITED_DATA_AVAILABLE	(CM_CONTROL_INFORMATION_RECEIVED) 5
+#define CM_RTS_RCVD_AND_EXP_DATA_AVAIL	(CM_CONTROL_INFORMATION_RECEIVED) 6
+
+/* conversation_queue values. */
+#define CM_INITIALIZATION_QUEUE		(CM_CONVERSATION_QUEUE) 0
+#define CM_SEND_QUEUE			(CM_CONVERSATION_QUEUE) 1
+#define CM_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 2
+#define CM_SEND_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 3
+#define CM_EXPEDITED_SEND_QUEUE		(CM_CONVERSATION_QUEUE) 4
+#define CM_EXPEDITED_RECEIVE_QUEUE	(CM_CONVERSATION_QUEUE) 5
+
+/* conversation_state values. */
+#define CM_INITIALIZE_STATE		(CM_CONVERSATION_STATE) 2
+#define CM_SEND_STATE			(CM_CONVERSATION_STATE) 3
+#define CM_RECEIVE_STATE		(CM_CONVERSATION_STATE) 4
+#define CM_SEND_PENDING_STATE		(CM_CONVERSATION_STATE) 5
+#define CM_CONFIRM_STATE		(CM_CONVERSATION_STATE) 6
+#define CM_CONFIRM_SEND_STATE		(CM_CONVERSATION_STATE) 7
+#define CM_CONFIRM_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 8
+#define CM_DEFER_RECEIVE_STATE		(CM_CONVERSATION_STATE) 9
+#define CM_DEFER_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 10
+#define CM_SYNC_POINT_STATE		(CM_CONVERSATION_STATE) 11
+#define CM_SYNC_POINT_SEND_STATE	(CM_CONVERSATION_STATE) 12
+#define CM_SYNC_POINT_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 13
+#define CM_INITIALIZE_INCOMING_STATE	(CM_CONVERSATION_STATE) 14
+#define CM_SEND_ONLY_STATE		(CM_CONVERSATION_STATE) 15
+#define CM_RECEIVE_ONLY_STATE		(CM_CONVERSATION_STATE) 16
+#define CM_SEND_RECEIVE_STATE		(CM_CONVERSATION_STATE) 17
+#define CM_PREPARED_STATE		(CM_CONVERSATION_STATE) 18
+
+/* conversation_type value. */
+#define CM_BASIC_CONVERSATION		(CM_CONVERSATION_TYPE) 0
+#define CM_MAPPED_CONVERSATION		(CM_CONVERSATION_TYPE) 1
+
+/* data_received values. */
+#define CM_NO_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 0
+#define CM_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 1
+#define CM_COMPLETE_DATA_RECEIVED	(CM_DATA_RECEIVED_TYPE) 2
+#define CM_INCOMPLETE_DATA_RECEVIED	(CM_DATA_RECEIVED_TYPE) 3
+
+/* deallocate_type values. */
+#define CM_DEALLOCATE_SYNC_LEVEL	(CM_DEALLOCATE_TYPE) 0
+#define CM_DEALLOCATE_FLUSH		(CM_DEALLOCATE_TYPE) 1
+#define CM_DEALLOCATE_CONFIRM		(CM_DEALLOCATE_TYPE) 2
+#define CM_DEALLOCATE_ABEND		(CM_DEALLOCATE_TYPE) 3
+
+/* directory_encoding values. */
+#define CM_DEFAULT_ENCODING		(CM_DIRECTORY_ENCODING) 0
+#define CM_UNICODE_ENCODING		(CM_DIRECTORY_ENCODING) 1
+
+/* directory_syntax values. */
+#define CM_DEFAULT_SYNTAX		(CM_DIRECTORY_SYNTAX) 0
+#define CM_DCE_SYNTAX			(CM_DIRECTORY_SYNTAX) 1
+#define CM_XDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 2
+#define CM_NDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 3
+
+/* error_direction values. */
+#define CM_RECEIVE_ERROR		(CM_ERROR_DIRECTION) 0
+#define CM_SEND_ERROR			(CM_ERROR_DIRECTION) 1
+
+/* fill values. */
+#define CM_FILL_LL			(CM_FILL) 0
+#define CM_FILL_BUFFER			(CM_FILL) 1
+
+/* partner_ID_scope values. */
+#define CM_EXPLICIT			(CM_PARTNER_ID_SCOPE) 0
+#define CM_REFERENCE			(CM_PARTNER_ID_SCOPE) 1
+
+/* partner_ID_type values. */
+#define CM_DISTINGUISHED_NAME		(CM_PARTNER_ID_TYPE) 0
+#define CM_LOCAL_DISTINGUISHED_NAME	(CM_PARTNER_ID_TYPE) 1
+#define CM_PROGRAM_FUNCTION_ID		(CM_PARTNER_ID_TYPE) 2
+#define CM_OSI_TPSU_TITLE_OID		(CM_PARTNER_ID_TYPE) 3
+#define CM_PROGRAM_BINDING		(CM_PARTNER_ID_TYPE) 4
+
+/* prepare_data_permitted values. */
+#define CM_PREPARE_DATA_NOT_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 0
+#define CM_PREPARE_DATA_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 1
+
+/* prepare_to_receive_type values. */
+#define CM_PREP_TO_RECEIVE_SYNC_LEVEL	(CM_PREPARE_TO_RECEIVE_TYPE) 0
+#define CM_PREP_TO_RECEIVE_FLUSH	(CM_PREPARE_TO_RECEIVE_TYPE) 1
+#define CM_PREP_TO_RECEIVE_CONFIRM	(CM_PREPARE_TO_RECEIVE_TYPE) 2
+
+/* processing_mode values. */
+#define CM_BLOCKING			(CM_PROCESSING_MODE) 0
+#define CM_NON_BLOCKING			(CM_PROCESSING_MODE) 1
+
+/* receive_type values. */
+#define CM_RECEIVE_AND_WAIT		(CM_RECEIVE_TYPE) 0
+#define CM_RECEIVE_IMMEDIATE		(CM_RECEIVE_TYPE) 1
+
+/* return_code values. */
+#define CM_OK				(CM_RETURN_CODE) 0
+#define CM_ALLOCATE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 1
+#define CM_ALLOCATE_FAILURE_RETRY	(CM_RETURN_CODE) 2
+#define CM_CONVERSATION_TYPE_MISMATCH	(CM_RETURN_CODE) 3
+#define CM_PIP_NOT_SPECIFIED_CORRECTLY	(CM_RETURN_CODE) 5
+#define CM_SECURITY_NOT_VALID		(CM_RETURN_CODE) 6
+#define CM_SYNC_LVL_NOT_SUPPORTED_LU	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_SYS	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_PGM	(CM_RETURN_CODE) 8
+#define CM_TPN_NOT_RECOGNIZED		(CM_RETURN_CODE) 9
+#define CM_TP_NOT_AVAILABLE_NO_RETRY	(CM_RETURN_CODE) 10
+#define CM_TP_NOT_AVAILABLE_RETRY	(CM_RETURN_CODE) 11
+#define CM_DEALLOCATED_ABEND		(CM_RETURN_CODE) 17
+#define CM_DEALLOCATED_NORMAL		(CM_RETURN_CODE) 18
+#define CM_PARAMETER_ERROR		(CM_RETURN_CODE) 19
+#define CM_PRODUCT_SPECIFIC_ERROR	(CM_RETURN_CODE) 20
+#define CM_PROGRAM_ERROR_NO_TRUNC	(CM_RETURN_CODE) 21
+#define CM_PROGRAM_ERROR_PURGING	(CM_RETURN_CODE) 22
+#define CM_PROGRAM_ERROR_TRUNC		(CM_RETURN_CODE) 23
+#define CM_PROGRAM_PARAMETER_CHECK	(CM_RETURN_CODE) 24
+#define CM_PROGRAM_STATE_CHECK		(CM_RETURN_CODE) 25
+#define CM_RESOURCE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 26
+#define CM_RESOURCE_FAILURE_RETRY	(CM_RETURN_CODE) 27
+#define CM_UNSUCCESSFUL			(CM_RETURN_CODE) 28
+#define CM_DEALLOCATED_ABEND_SVC	(CM_RETURN_CODE) 30
+#define CM_DEALLOCATED_ABEND_TIMER	(CM_RETURN_CODE) 31
+#define CM_SVC_ERROR_NO_TRUNC		(CM_RETURN_CODE) 32
+#define CM_SVC_ERROR_PURGING		(CM_RETURN_CODE) 33
+#define CM_SVC_ERROR_TRUNC		(CM_RETURN_CODE) 34
+#define CM_OPERATION_INCOMPLETE		(CM_RETURN_CODE) 35
+#define CM_SYSTEM_EVENT			(CM_RETURN_CODE) 36
+#define CM_OPERATION_NOT_ACCEPTED	(CM_RETURN_CODE) 37
+#define CM_CONVERSATION_ENDING		(CM_RETURN_CODE) 38
+#define CM_SEND_RCV_MODE_NOT_SUPPORTED	(CM_RETURN_CODE) 39
+#define CM_BUFFER_TOO_SMALL		(CM_RETURN_CODE) 40
+#define CM_EXP_DATA_NOT_SUPPORTED	(CM_RETURN_CODE) 41
+#define CM_DEALLOC_CONFIRM_REJECT	(CM_RETURN_CODE) 42
+#define CM_ALLOCATION_ERROR		(CM_RETURN_CODE) 43
+#define CM_RETRY_LIMIT_EXCEEDED		(CM_RETURN_CODE) 44
+#define CM_NO_SECONDARY_INFORMATION	(CM_RETURN_CODE) 45
+#define CM_SECURITY_NOT_SUPPORTED	(CM_RETURN_CODE) 46
+#define CM_SECURITY_MUTUAL_FAILED	(CM_RETURN_CODE) 47
+#define CM_CALL_NOT_SUPPORTED		(CM_RETURN_CODE) 48
+#define CM_PARM_VALUE_NOT_SUPPORTED	(CM_RETURN_CODE) 49
+#define CM_TAKE_BACKOUT			(CM_RETURN_CODE) 100
+#define CM_DEALLOCATED_ABEND_BO		(CM_RETURN_CODE) 130
+#define CM_DEALLOCATED_ABEND_SVC_BO	(CM_RETURN_CODE) 131
+#define CM_DEALLOCATED_ABEND_TIMER_BO	(CM_RETURN_CODE) 132
+#define CM_RESOURCE_FAIL_NO_RETRY_BO	(CM_RETURN_CODE) 133
+#define CM_RESOURCE_FAILURE_RETRY_BO	(CM_RETURN_CODE) 134
+#define CM_DEALLOCATED_NORMAL_BO	(CM_RETURN_CODE) 135
+#define CM_CONV_DEALLOC_AFTER_SYNCPT	(CM_RETURN_CODE) 136
+#define CM_INCLUDE_PARTNER_REJECT_BO	(CM_RETURN_CODE) 137
+
+/* return_control values. */
+#define CM_WHEN_SESSION_ALLOCATED	(CM_RETURN_CONTROL) 0
+#define CM_IMMEDIATE			(CM_RETURN_CONTROL) 1
+
+/* send_receive_mode values. */
+#define CM_HALF_DUPLEX			(CM_SEND_RECEIVE_MODE) 0
+#define CM_FULL_DUPLEX			(CM_SEND_RECEIVE_MODE) 1
+
+/* send_type values. */
+#define CM_BUFFER_DATA			(CM_SEND_TYPE) 0
+#define CM_SEND_AND_FLUSH		(CM_SEND_TYPE) 1
+#define CM_SEND_AND_CONFIRM		(CM_SEND_TYPE) 2
+#define CM_SEND_AND_PREP_TO_RECEIVE	(CM_SEND_TYPE) 3
+#define CM_SEND_AND_DEALLOCATE		(CM_SEND_TYPE) 4
+
+/* status_received values. */
+#define CM_NO_STATUS_RECEIVED		(CM_STATUS_RECEIVED) 0
+#define CM_SEND_RECEIVED		(CM_STATUS_RECEIVED) 1
+#define CM_CONFIRM_RECEIVED		(CM_STATUS_RECEIVED) 2
+#define CM_CONFIRM_SEND_RECEIVED	(CM_STATUS_RECEIVED) 3
+#define CM_CONFIRM_DEALLOC_RECEIVED	(CM_STATUS_RECEIVED) 4
+#define CM_TAKE_COMMIT			(CM_STATUS_RECEIVED) 5
+#define CM_TAKE_COMMIT_SEND		(CM_STATUS_RECEIVED) 6
+#define CM_TAKE_COMMIT_DEALLOCATE	(CM_STATUS_RECEIVED) 7
+#define CM_TAKE_COMMIT_DATA_OK		(CM_STATUS_RECEIVED) 8
+#define CM_TAKE_COMMIT_SEND_DATA_OK	(CM_STATUS_RECEIVED) 9
+#define CM_TAKE_COMMIT_DEALLOC_DATA_OK	(CM_STATUS_RECEIVED) 10
+#define CM_PREPARE_OK			(CM_STATUS_RECEIVED) 11
+#define CM_JOIN_TRANSACTION		(CM_STATUS_RECEIVED) 12
+
+/* sync_level values. */
+#define CM_NONE				(CM_SYNC_LEVEL) 0
+#define CM_CONFIRM			(CM_SYNC_LEVEL) 1
+#define CM_SYNC_POINT			(CM_SYNC_LEVEL) 2
+#define CM_SYNC_POINT_NO_CONFIRM	(CM_SYNC_LEVEL) 3
+
+/* conversation_security_type values. */
+#define CM_SECURITY_NONE		(CM_CONVERSATION_SECURITY_TYPE) 0
+#define CM_SECURITY_SAME		(CM_CONVERSATION_SECURITY_TYPE) 1
+#define CM_SECURITY_PROGRAM		(CM_CONVERSATION_SECURITY_TYPE) 2
+#define CM_SECURITY_DISTRIBUTED		(CM_CONVERSATION_SECURITY_TYPE) 3
+#define CM_SECURITY_MUTUAL		(CM_CONVERSATION_SECURITY_TYPE) 4
+#define CM_SECURITY_PROGRAM_STRONG	(CM_CONVERSATION_SECURITY_TYPE) 5
+
+/* transaction_control values. */
+#define CM_CHAINED_TRANSACTIONS		(CM_TRANSACTION_CONTROL) 0
+#define CM_UNCHAINED_TRANSACTIONS	(CM_TRANSACTION_CONTROL) 1
+
+/* maximum sizes of strings and buffers. */
+#define CM_CID_SIZE	(8)	/* converstation ID. */
+#define CM_CTX_SIZE	(32)	/* context ID. */
+#define CM_LD_SIZE	(512)	/* log data. */
+#define CM_MN_SIZE	(8)	/* mode name. */
+#define CM_PLN_SIZE	(17)	/* partner LU name. */
+#define CM_PW_SIZE	(10)	/* password. */
+#define CM_SDN_SIZE	(8)	/* synbolic destination name. */
+#define CM_TPN_SIZE	(64)	/* TP name. */
+#define CM_UID_SIZE	(10)	/* userid ID. */
+
+CM_ENTRY cmacci(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmaccp(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmallc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcanc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfm(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfmd(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvo(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdeal(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdfde(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmecs(unsigned char CM_PTR,
+        CM_CONVERSATION_STATE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmect(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmectx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmembs(CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmemn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesui(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmflus(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmincl(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminic(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminit(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmprep(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmptr(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcv(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_STATUS_RECEIVED CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcvx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrts(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsac(unsigned char CM_PTR,
+        CM_ALLOCATE_CONFIRM_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsbt(unsigned char CM_PTR,
+        CM_BEGIN_TRANSACTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsp(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscst(unsigned char CM_PTR,
+        CM_CONVERSATION_SECURITY_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsu(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsct(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscu(unsigned char CM_PTR,
+        CM_CONFIRMATION_URGENCY CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsdt(unsigned char CM_PTR,
+        CM_DEALLOCATE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsed(unsigned char CM_PTR,
+        CM_ERROR_DIRECTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsend(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmserr(unsigned char CM_PTR,
+	CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsf(unsigned char CM_PTR,
+        CM_FILL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsld(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsmn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsndx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspdp(unsigned char CM_PTR,
+        CM_PREPARE_DATA_PERMITTED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspm(unsigned char CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsptr(unsigned char CM_PTR,
+        CM_PREPARE_TO_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqcf(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqpm(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrc(unsigned char CM_PTR,
+        CM_RETURN_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrt(unsigned char CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsst(unsigned char CM_PTR,
+        CM_SEND_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmtrts(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwait(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwcmp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+
+/* Macros to use long descriptive names instead of crusty CPI-C names. */
+#define Accept_Conversation(v1,v2)			cmaccp(v1,v2)
+#define Accept_Incoming(v1,v2)				cmacci(v1,v2)
+#define Allocate(v1,v2)					cmallc(v1,v2)
+#define Cancel_Conversation(v1,v2)			cmcanc(v1,v2)
+#define Confirm(v1,v2,v3)				cmcfm(v1,v2,v3)
+#define Confirmed(v1,v2)				cmcfmd(v1,v2)
+#define Convert_Incoming(v1,v2,v3)			cmcnvi(v1,v2,v3)
+#define Convert_Outgoing(v1,v2,v3)			cmcnvo(v1,v2,v3)
+#define Deallocate(v1,v2)				cmdeal(v1,v2)
+#define Deferred_Deallocate(v1,v2)			cmdfde(v1,v2)
+#define Extract_AE_Qualifier(v1,v2,v3,v4,v5)		cmeaeq(v1,v2,v3,v4,v5)
+#define Extract_AP_Title(v1,v2,v3,v4,v5)		cmeapt(v1,v2,v3,v4,v5)
+#define Extract_Application_Context_Name(v1,v2,v3,v4)	cmeacn(v1,v2,v3,v4)
+#define Extract_Conversation_Context(v1,v2,v3,v4)	cmectx(v1,v2,v3,v4)
+#define Extract_Conversation_State(v1,v2,v3)		cmecs(v1,v2,v3)
+#define Extract_Conversation_Type(v1,v2,v3)		cmect(v1,v2,v3)
+#define Extract_Initialization_Data(v1,v2,v3,v4,v5)	cmeid(v1,v2,v3,v4,v5)
+#define Extract_Maximum_Buffer_Size(v1,v2)		cmembs(v1,v2)
+#define Extract_Mode_Name(v1,v2,v3,v4,v5)		cmemn(v1,v2,v3,v4,v5)
+#define Extract_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8,v9) \
+	cmepid(v1,v2,v3,v4,v5,v6,v7,v8,v9)
+#define Extract_Partner_LU_Name(v1,v2,v3,v4)		cmpln(v1,v2,v3,v4)
+#define Extract_Secondary_Information(v1,v2,v3,v4,v5,v6,v7) \
+	cmesi(v1,v2,v3,v4,v5,v6,v7)
+#define Extract_Security_User_ID(v1,v2,v3,v4)		cmesui(v1,v2,v3,v4)
+#define Extract_Send_Receive_Mode(v1,v2,v3)		cmesrm(v1,v2,v3)
+#define Extract_Sync_Level(v1,v2,v3)			cmesl(v1,v2,v3)
+#define Extract_Transaction_Control(v1,v2,v3)		cmetc(v1,v2,v3)
+#define Extract_TP_Name(v1,v2,v3,v4)			cmetpn(v1,v2,v3,v4)
+#define Flush(v1,v2)					cmflus(v1,v2)
+#define Include_Partner_In_Transaction(v1,v2)		cmincl(v1,v2)
+#define Initialize_Conversation(v1,v2,v3)		cminit(v1,v2,v3)
+#define Initialize_For_Incomint(v1,v2)			cminic(v1,v2)
+#define Prepare(v1,v2)					cmprep(v1,v2)
+#define Prepare_To_Receive(v1,v2)			cmptr(v1,v2)
+#define Receive(v1,v2,v3,v4,v5,v6,v7,v8)		\
+	cmrcv(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Receive_Expedited_Data(v1,v2,v3,v4,v5,v6,v7)	\
+	cmrcvx(v1,v2,v3,v4,v5,v6,v7)
+#define Release_Local_TP_Name(v1,v2,v3)			cmrltp(v1,v2,v3)
+#define Request_To_Send(v1,v2)				cmrts(v1,v2)
+#define Send_Data(v1,v2,v3,v4,v5)			cmsend(v1,v2,v3,v4,v5)
+#define Send_Error(v1,v2,v3)				cmserr(v1,v2,v3)
+#define Send_Expedited_Data(v1,v2,v3,v4,v5)		cmsndx(v1,v2,v3,v4,v5)
+#define Set_AE_Qualifier(v1,v2,v3,v4,v5)		cmsaeq(v1,v2,v3,v4,v5)
+#define Set_Allocate_Confirm(v1,v2,v3)			cmsac(v1,v2,v3)
+#define Set_AP_Title(v1,v2,v3,v4,v5)			cmsapt(v1,v2,v3,v4,v5)
+#define Set_Application_Context_Name(v1,v2,v3,v4)	cmsacn(v1,v2,v3,v4)
+#define Set_Begin_Transaction(v1,v2,v3)			cmsbt(v1,v2,v3)
+#define Set_Confirmation_Urgency(v1,v2,v3)		cmscu(v1,v2,v3)
+#define Set_Conversation_Security_Password(v1,v2,v3,v4)	cmscsp(v1,v2,v3,v4)
+#define Set_Conversation_Security_Type(v1,v2,v3)	cmscst(v1,v2,v3)
+#define Set_Conversation_Security_User_ID(v1,v2,v3,v4)	cmscsu(v1,v2,v3,v4)
+#define Set_Conversation_Type(v1,v2,v3)			cmsct(v1,v2,v3)
+#define Set_Deallocate_Type(v1,v2,v3)			cmsdt(v1,v2,v3)
+#define Set_Error_Direction(v1,v2,v3)			cmsed(v1,v2,v3)
+#define Set_Fill(v1,v2,v3)				cmsf(v1,v2,v3)
+#define Set_Initialization_Data(v1,v2,v3,v4)		cmsid(v1,v2,v3,v4)
+#define Set_Log_Data(v1,v2,v3,v4)			cmsld(v1,v2,v3,v4)
+#define Set_Mode_Name(v1,v2,v3,v4)			cmsmn(v1,v2,v3,v4)
+#define Set_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8)	\
+	cmspid(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Set_Partner_LU_Name(v1,v2,v3,v4)		cmspln(v1,v2,v3,v4)
+#define Set_Prepare_Data_Permitted(v1,v2,v3)		cmspdp(v1,v2,v3)
+#define Set_Prepare_To_Receive_Type(v1,v2,v3)		cmsptr(v1,v2,v3)
+#define Set_Processing_Mode(v1,v2,v3)			cmspm(v1,v2,v3)
+#define Set_Queue_Callback_Function(v1,v2,v3,v4,v5,v6)	\
+	cmsqcf(v1,v2,v3,v4,v5,v6)
+#define Set_Queue_Processing_Mode(v1,v2,v3,v4,v5,v6)	\
+	cmsqpm(v1,v2,v3,v4,v5,v6)
+#define Set_Receive_Type(v1,v2,v3)			cmsrt(v1,v2,v3)
+#define Set_Return_Control(v1,v2,v3)			cmsrc(v1,v2,v3)
+#define Set_Send_Type(v1,v2,v3)				cmsst(v1,v2,v3)
+#define Set_Sync_Level(v1,v2,v3)			cmssl(v1,v2,v3)
+#define Set_TP_Name(v1,v2,v3,v4)			cmstpn(v1,v2,v3,v4)
+#define Set_Transaction_Control(v1,v2,v3)		cmstc(v1,v2,v3)
+#define Specify_Local_TP_Name(v1,v2,v3)			cmsltp(v1,v2,v3)
+#define Test_Request_To_Send_Received(v1,v2,v3)		cmtrts(v1,v2,v3)
+#define Wait_For_Completion(v1,v2,v3,v4,v5,v6,v7)	\
+	cmwcmp(v1,v2,v3,v4,v5,v6,v7)
+#define Wait_For_Conversation(v1,v2,v3)			cmwait(v1,v2,v3)
+
+#define CPIC_DEFINE_SIDE                0x101D
+#define CPIC_DELETE_SIDE                0x1035
+
+struct cpic_define_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+
+        unsigned char           sym_dest_name[9];
+        unsigned char           mode_name[9];
+        unsigned char           tp_name[64];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[10];
+        unsigned char           password[10];
+};
+
+struct cpic_delete_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+        unsigned char           sym_dest_name[9];
+};
+
+struct cpicsreq {
+	struct cpicsreq		*next;
+	struct cpicsreq		*prev;
+
+	char			netid[18];
+	char			netid_plu[18];
+        char            	sym_dest_name[9];
+        char            	mode_name[9];
+        char            	tp_name[65];
+        unsigned char   	service_tp;
+        unsigned char   	security_level;
+        char            	username[11];
+        char            	password[11];
+        unsigned short  	flags;
+        unsigned long   	proc_id;
+};
+
+struct cpicsconf {
+        int     cpics_len;
+        char    cpics_net[9];
+        char    cpics_name[9];
+        char    cpics_plunet[9];
+        char    cpics_pluname[9];
+        char    cpics_sym_dest_name[9];
+
+        union {
+                char            *cpicsc_buf;
+                struct cpicsreq   *cpicsc_req;
+        } cpicsc_cpicscu;
+};
+
+struct sna_qcpics {
+        struct sna_qcpics *next;
+        struct cpicsreq   data;
+};
+
+#define cpicsc_buf cpicsc_cpicscu.cpicsc_buf         /* buffer address       */
+#define cpicsc_req cpicsc_cpicscu.cpicsc_req         /* array of structures  */
+
+/* Input/Output CPI-C call structure. */
+typedef struct {
+        unsigned long   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
+} cpic_args;
+
+#define cargo1(a, v1)                   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1;
+
+#define cargo2(a, v1, v2)               \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2;
+
+#define cargo3(a, v1, v2, v3)           \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3;
+
+#define cargo4(a, v1, v2, v3, v4)       \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4;
+
+#define cargo5(a, v1, v2, v3, v4, v5)   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5;
+
+#define cargo6(a, v1, v2, v3, v4, v5, v6) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6;
+
+#define cargo7(a, v1, v2, v3, v4, v5, v6, v7) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6; \
+        a->a7 = (unsigned long *)v7;
+
+#endif	/* _CPIC_H */
diff -ruN linux-2.4.18-clean/include/linux/dextab.h linux/include/linux/dextab.h
--- linux-2.4.18-clean/include/linux/dextab.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/dextab.h	Fri Jun  7 08:47:10 2002
@@ -0,0 +1,58 @@
+#ifndef __LINUX_DEXTAB_H
+#define __LINUX_DEXTAB_H
+/*
+ * dextab.h - Contains definition of dynamically expandable tables 
+ *
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <asm/byteorder.h>
+
+/* Dynamically expandable table structure */
+struct dex_table {
+	void **		addr;
+	__u16		size;
+	__u16		reserved;
+	__u16		max_size;
+	__u16		count;
+	spinlock_t	lock;
+};
+typedef struct dex_table dextab_t;
+
+#define DEXTAB_NOFREE_ENTRY	0
+#define DEXTAB_FREE_ENTRY	1
+
+#define dextab_add_entry(tbl, entry_size) \
+	dextab_add_insert_entry(tbl, entry_size, NULL)
+#define dextab_insert_entry(tbl, entry)	dextab_add_insert_entry(tbl, 0, entry)
+#define dextab_remove_index(tbl, entry_index) \
+	dextab_remove_delete_index(tbl, entry_index, DEXTAB_FREE_ENTRY)
+#define dextab_delete_index(tbl, entry_index) \
+	dextab_remove_delete_index(tbl, entry_index, DEXTAB_NOFREE_ENTRY)
+#define __dextab_delete_index(tbl, entry_index) \
+	__dextab_remove_delete_index(tbl, entry_index, DEXTAB_NOFREE_ENTRY)
+#define dextab_remove_entry(tbl, entry) \
+	dextab_remove_delete_index(tbl, dextab_entry_index(tbl, entry), \
+				   DEXTAB_FREE_ENTRY)
+#define dextab_delete_entry(tbl, entry) \
+	dextab_remove_delete_index(tbl, dextab_entry_index(tbl, entry), \
+				   DEXTAB_NOFREE_ENTRY)
+/* Dynamically expandable table interface */
+extern void dextab_init(dextab_t *tbl, int reserved, int max_size);
+extern int dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry);
+extern void __dextab_remove_delete_index(dextab_t *tbl, int entry_index,
+				         int flag);
+extern void dextab_remove_delete_index(dextab_t *tbl, int entry_index,
+				       int flag);
+extern int dextab_entry_index(dextab_t *tbl, void *entry);
+extern inline int __dextab_count_entries(dextab_t *tbl);
+extern inline int dextab_count_entries(dextab_t *tbl);
+extern void dextab_destruct(dextab_t *tbl);
+#endif __LINUX_DEXTAB_H
diff -ruN linux-2.4.18-clean/include/linux/fs.h linux/include/linux/fs.h
--- linux-2.4.18-clean/include/linux/fs.h	Mon Feb 25 14:38:13 2002
+++ linux/include/linux/fs.h	Fri Jun  7 12:46:10 2002
@@ -27,6 +27,9 @@
 
 struct poll_table_struct;
 
+#include <linux/cpic.h>
+#include <net/cpic.h>
+#include <linux/attach.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -473,6 +476,8 @@
 
 	unsigned int		i_flags;
 	unsigned char		i_sock;
+	unsigned char		i_cpic;
+	unsigned char		i_attach;
 
 	atomic_t		i_writecount;
 	unsigned int		i_attr_flags;
@@ -506,6 +511,8 @@
 		struct socket			socket_i;
 		struct usbdev_inode_info        usbdev_i;
 		struct jffs2_inode_info		jffs2_i;
+		struct cpic			cpic_i;
+		struct attach			attach_i;
 		void				*generic_ip;
 	} u;
 };
diff -ruN linux-2.4.18-clean/include/linux/if_arp.h linux/include/linux/if_arp.h
--- linux-2.4.18-clean/include/linux/if_arp.h	Mon Feb 25 14:38:13 2002
+++ linux/include/linux/if_arp.h	Fri Jun  7 12:49:59 2002
@@ -51,9 +51,11 @@
 #define ARPHRD_ROSE	270
 #define ARPHRD_X25	271		/* CCITT X.25			*/
 #define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CHANNEL	273		/* ESCON / Bus-Tag channel	*/
 #define ARPHRD_PPP	512
 #define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
 #define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_SDLC	514		/* SDLC				*/
 #define ARPHRD_LAPB	516		/* LAPB				*/
 #define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
 #define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
diff -ruN linux-2.4.18-clean/include/linux/if_ether.h linux/include/linux/if_ether.h
--- linux-2.4.18-clean/include/linux/if_ether.h	Tue Oct 30 18:08:12 2001
+++ linux/include/linux/if_ether.h	Fri Jun  7 04:57:41 2002
@@ -55,6 +55,7 @@
 #define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
 #define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
 #define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_SNA	0x80D5		/* SNA				*/
 #define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
 #define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
 #define ETH_P_IPX	0x8137		/* IPX over DIX			*/
diff -ruN linux-2.4.18-clean/include/linux/llc.h linux/include/linux/llc.h
--- linux-2.4.18-clean/include/linux/llc.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/llc.h	Fri Jun  7 04:57:41 2002
@@ -0,0 +1,96 @@
+#ifndef __LINUX_LLC_H
+#define __LINUX_LLC_H
+/*
+ * IEEE 802.2 User Interface SAPs for Linux, data structures and indicators.
+ *
+ * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#define __LLC_SOCK_SIZE__ 28	/* sizeof(sockaddr_llc), word align. */
+struct sockaddr_llc {
+	sa_family_t     sllc_family;	/* AF_LLC */
+	sa_family_t	sllc_arphrd;	/* ARPHRD_ETHER */
+	unsigned char   sllc_test;
+	unsigned char   sllc_xid;
+	unsigned char	sllc_ua;	/* UA data, only for SOCK_STREAM. */
+	unsigned char   sllc_dsap;
+	unsigned char   sllc_ssap;
+	unsigned char   sllc_dmac[IFHWADDRLEN];
+	unsigned char   sllc_smac[IFHWADDRLEN];
+	unsigned char   sllc_mmac[IFHWADDRLEN];
+	unsigned char   __pad[__LLC_SOCK_SIZE__ - sizeof(sa_family_t) * 2 -
+			      sizeof(unsigned char) * 5 - IFHWADDRLEN * 3];
+};
+
+/* sockopt definitions. */
+enum llc_sockopts {
+	LLC_OPT_UNKNOWN = 0,
+	LLC_OPT_RETRY,		/* max retrans attempts. */
+	LLC_OPT_SIZE,		/* max PDU size (octets). */
+	LLC_OPT_ACK_TMR_EXP,	/* ack expire time (secs). */
+	LLC_OPT_P_TMR_EXP,	/* pf cycle expire time (secs). */
+	LLC_OPT_REJ_TMR_EXP,	/* rej sent expire time (secs). */
+	LLC_OPT_BUSY_TMR_EXP,	/* busy state expire time (secs). */
+	LLC_OPT_TX_WIN,		/* tx window size. */
+	LLC_OPT_RX_WIN,		/* rx window size. */
+	LLC_OPT_MAX
+};
+
+#define LLC_OPT_MAX_RETRY	 100
+#define LLC_OPT_MAX_SIZE	4196
+#define LLC_OPT_MAX_WIN		 127
+#define LLC_OPT_MAX_ACK_TMR_EXP	  60
+#define LLC_OPT_MAX_P_TMR_EXP	  60
+#define LLC_OPT_MAX_REJ_TMR_EXP	  60
+#define LLC_OPT_MAX_BUSY_TMR_EXP  60
+
+/* LLC SAP types. */
+#define LLC_SAP_NULL	0x00		/* NULL SAP. 			*/
+#define LLC_SAP_LLC	0x02		/* LLC Sublayer Managment. 	*/
+#define LLC_SAP_SNA	0x04		/* SNA Path Control. 		*/
+#define LLC_SAP_PNM	0x0E		/* Proway Network Managment.	*/	
+#define LLC_SAP_IP	0x06		/* TCP/IP. 			*/
+#define LLC_SAP_BSPAN	0x42		/* Bridge Spanning Tree Proto	*/
+#define LLC_SAP_MMS	0x4E		/* Manufacturing Message Srv.	*/
+#define LLC_SAP_8208	0x7E		/* ISO 8208			*/
+#define LLC_SAP_3COM	0x80		/* 3COM. 			*/
+#define LLC_SAP_PRO	0x8E		/* Proway Active Station List	*/
+#define LLC_SAP_SNAP	0xAA		/* SNAP. 			*/
+#define LLC_SAP_BANYAN	0xBC		/* Banyan. 			*/
+#define LLC_SAP_IPX	0xE0		/* IPX/SPX. 			*/
+#define LLC_SAP_NETBEUI	0xF0		/* NetBEUI. 			*/
+#define LLC_SAP_LANMGR	0xF4		/* LanManager. 			*/
+#define LLC_SAP_IMPL	0xF8		/* IMPL				*/
+#define LLC_SAP_DISC	0xFC		/* Discovery			*/
+#define LLC_SAP_OSI	0xFE		/* OSI Network Layers. 		*/
+#define LLC_SAP_LAR	0xDC		/* LAN Address Resolution 	*/
+#define LLC_SAP_RM	0xD4		/* Resource Management 		*/
+#define LLC_SAP_GLOBAL	0xFF		/* Global SAP. 			*/
+
+#ifdef __KERNEL__
+#define LLC_SAP_DYN_START	0xC0
+#define LLC_SAP_DYN_STOP	0xDE
+#define LLC_SAP_DYN_TRIES	4
+
+struct sock;
+
+struct llc_ui_opt {
+	u16		     link;	/* network layer link number */
+	struct llc_sap	    *sap;	/* pointer to parent SAP */
+	struct sock	    *core_sk;
+	struct net_device   *dev;	/* device to send to remote */
+	struct sockaddr_llc  addr;	/* address sock is bound to */
+};
+
+#define LLC_UI_SK(sk) (&sk->protinfo.af_llc)
+
+extern int llc_ui_init(void);
+extern void llc_ui_exit(void);
+#endif /* __KERNEL__ */
+#endif /* __LINUX_LLC_H */
diff -ruN linux-2.4.18-clean/include/linux/netbeui.h linux/include/linux/netbeui.h
--- linux-2.4.18-clean/include/linux/netbeui.h	Thu Dec 12 09:54:20 1996
+++ linux/include/linux/netbeui.h	Fri Jun  7 12:46:10 2002
@@ -1,16 +1,587 @@
 #ifndef _LINUX_NETBEUI_H
 #define _LINUX_NETBEUI_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <linux/if_tr.h>
+#include <linux/if_ether.h>
+#include <linux/dextab.h>
+#include <linux/af_netb.h>
+/* NetBIOS frame commands - listed by functionality */
+#define NETBEUI_ADD_GROUP_NAME_QUERY	0x00
+#define NETBEUI_ADD_NAME_QUERY		0x01
+#define NETBEUI_ADD_NAME_RESPONSE	0x0D
+#define NETBEUI_NAME_IN_CONFLICT	0x02
 
-#include <linux/if.h>
+#define NETBEUI_NAME_QUERY		0x0A
+#define NETBEUI_NAME_RECOGNIZED		0x0E
+#define NETBEUI_SESSION_ALIVE		0x1F
+#define NETBEUI_SESSION_CONFIRM		0x17
+#define NETBEUI_SESSION_END		0x18
+#define NETBEUI_SESSION_INITIALIZE	0x19
 
-#define NB_NAME_LEN	20	/* Set this properly from the full docs when
-				   I get them */
-				   
-struct sockaddr_netbeui
-{
-	sa_family	snb_family;
-	char		snb_name[NB_NAME_LEN];
-	char		snb_devhint[IFNAMSIZ];
+#define NETBEUI_DATA_ACK		0x14
+#define NETBEUI_DATA_FIRST_MIDDLE	0x15
+#define NETBEUI_DATAGRAM		0x08
+#define NETBEUI_DATAGRAM_BROADCAST	0x09
+#define NETBEUI_DATA_ONLY_LAST		0x16
+#define NETBEUI_NO_RECEIVE		0x1A
+#define NETBEUI_RECEIVE_CONTINUE	0x1C
+#define NETBEUI_RECEIVE_OUTSTANDING	0x1B
+
+#define NETBEUI_STATUS_QUERY		0x03
+#define NETBEUI_STATUS_RESPONSE		0x0F
+#define NETBEUI_TERMINATE_TRACE		0x07
+#define NETBEUI_TERMINATE_TRACE2	0x13
+
+#define NETBEUI_MAX_COMMAND_CODE	0x1F
+#define NETBEUI_MIN_COMMAND_LEN		0x0B
+
+extern u8 nb_cmd_hdr_len[];
+
+/* NetBIOS name service constants */
+typedef enum { 
+	NETBEUI_NAME_INITIAL = 0, 
+	NETBEUI_NAME_ADDWAIT, 
+	NETBEUI_NAME_COLLIDED,
+	NETBEUI_NAME_ACQUIRED 
+} name_state_t;
+
+typedef enum {
+	NETBEUI_NAME_ADD_NAME = 0,
+	NETBEUI_NAME_RETRY_TIMEOUT,
+	NETBEUI_NAME_RESPONSE_TIMEOUT,
+	NETBEUI_NAME_ADD_NAME_RESPONSE1,
+	NETBEUI_NAME_ADD_NAME_RESPONSE2,
+	NETBEUI_NAME_ADD_NAME_QUERY,
+	NETBEUI_NAME_NAME_CONFLICT,
+	NETBEUI_NAME_REMOVE_NAME
+} name_event_t;
+
+/* NetBIOS query service constants */
+#define NETBEUI_QUERY_MAX_CACHE_ENTRIES 50
+#define NETBEUI_QUERY_CACHE_LIVING_TIME (5 * 60 * HZ)
+
+typedef enum { 
+	NETBEUI_QUERY_INITIAL = 0, 
+	NETBEUI_QUERY_QRYWAIT,
+	NETBEUI_QUERY_FINDWAIT,
+	NETBEUI_QUERY_RECOGNIZED
+} query_state_t;
+
+typedef enum {
+	NETBEUI_QUERY_NAME_QUERY = 0,
+	NETBEUI_QUERY_NAME_FIND,
+	NETBEUI_QUERY_RETRY_TIMEOUT,
+	NETBEUI_QUERY_RESPONSE_TIMEOUT,
+	NETBEUI_QUERY_NAME_RECOGNIZED,
+	NETBEUI_QUERY_END_QUERY
+} query_event_t;
+
+#define NETBEUI_CALL_TT(data2)		((data2 & 0xFF00) >> 8)
+#define NETBEUI_CALL_SS(data2)  	(data2 & 0x00FF)
+#define NETBEUI_CALL_DATA2(tt,ss)	(((tt << 8) & 0xFF00) | (ss & 0x00FF))
+
+/* NetBIOS session service constants */ 
+typedef enum { 
+	NETBEUI_SESS_INITIAL = 0, 
+	NETBEUI_SESS_CALLWAIT,
+	NETBEUI_SESS_CONFWAIT,
+	NETBEUI_SESS_LISTENWAIT,
+	NETBEUI_SESS_INITWAIT,
+	NETBEUI_SESS_CONNECTED,
+	NETBEUI_SESS_DISCWAIT,
+	NETBEUI_SESS_CONTWAIT,
+	NETBEUI_SESS_STANDWAIT,
+	NETBEUI_SESS_ACKWAIT,
+	NETBEUI_SESS_RSRCWAIT,
+	NETBEUI_SESS_NORMAL
+} session_state_t;
+
+typedef enum {
+	NETBEUI_SESS_CALL = 0,
+	NETBEUI_SESS_LISTEN,
+	NETBEUI_SESS_CONFIRM,
+	NETBEUI_SESS_REJECT,
+	NETBEUI_SESS_CONNECT,
+	NETBEUI_SESS_TIMEOUT,
+	NETBEUI_SESS_ABORT,
+	NETBEUI_SESS_HANGUP,
+	NETBEUI_SESS_END,
+	NETBEUI_SESS_FIRST_MIDDLE_CONT,
+	NETBEUI_SESS_FIRST_MIDDLE,
+	NETBEUI_SESS_CONTINUE,
+	NETBEUI_SESS_NONBLOCK,
+	NETBEUI_SESS_PAUSE,
+	NETBEUI_SESS_PAUSE2, 
+	NETBEUI_SESS_RESTART,
+	NETBEUI_SESS_ONLY_LAST_ACK,
+	NETBEUI_SESS_ONLY_LAST,
+	NETBEUI_SESS_DATA_ACKED,
+	NETBEUI_SESS_RESOURCE,
+	NETBEUI_SESS_CONN_RETRY,
+	NETBEUI_SESS_NORM_RETRY,
+	NETBEUI_SESS_ABORT_SEND,
+} session_event_t;
+
+typedef enum {
+	NETBEUI_RECV_NORMAL= 0,
+	NETBEUI_RECV_NO_RECEIVE,
+	NETBEUI_RECV_RECEIVE_OUTSTANDING
+} input_state_t;
+
+#define NETBEUI_VERSION_1xx	0
+#define NETBEUI_VERSION_2xx	1
+
+#define NETBEUI_NACK_NONE	0
+#define NETBEUI_NACK_ABLE	1
+
+#define NETBEUI_ORIGIN_CONNECTED 1
+#define NETBEUI_ORIGIN_NORMAL    2
+
+#define NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr)	(hdr->data1 & 0x80)
+#define NETBIOS_VERSION(hdr)			(hdr->data1 & 0x01)
+#define NETBEUI_TR_FRAME_LF(hdr)		(((hdr->data1) & 0x0E) >> 1)
+
+#define NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr) (hdr->data1 & 0x01)
+#define NETBEUI_NACK_INDICATOR(hdr)		(hdr->data1 & 0x02)
+#define NETBEUI_ACK_WITH_DATA_ALLOWED(hdr)  	(hdr->data1 & 0x04)
+#define NETBEUI_ACK_WITH_DATA_INCLUDED(hdr)	(hdr->data1 & 0x08)
+
+#define NETBEUI_REQUEST_RECEIVE_CONTINUE(hdr)	(hdr->data1 |= 0x01)
+#define NETBEUI_INDICATE_NACK(hdr)		(hdr->data1 |= 0x02)
+#define NETBEUI_ALLOW_ACK_WITH_DATA(hdr)	(hdr->data1 |= 0x04)
+#define NETBEUI_INCLUDE_ACK_WITH_DATA(hdr)	(hdr->data1 |= 0x08)
+
+#define NETBEUI_RESYNCH_INDICATOR(hdr)		(hdr->data2)
+
+#define NETBEUI_ACK_FLAG			0x80000000
+
+/* NetBIOS link manager constants */
+typedef enum {
+	NETBEUI_LINK_INITIAL = 0,
+	NETBEUI_LINK_CONNWAIT,
+	NETBEUI_LINK_UP
+} link_state_t;
+
+typedef enum {
+	NETBEUI_LINK_CONN_INDICATE = 0,
+	NETBEUI_LINK_CONN_REQUEST,
+	NETBEUI_LINK_DUMMY_CONN,
+	NETBEUI_LINK_CONN_CONFIRM,
+	NETBEUI_LINK_CONN_REJECT,
+	NETBEUI_LINK_RESET_INDICATE,
+	NETBEUI_LINK_SESSION_ALIVE,
+	NETBEUI_LINK_DISC_REQUEST,
+	NETBEUI_LINK_DISC_INDICATE
+} link_event_t;
+
+/* NetBIOS constants */
+#define MIN(a,b) (((a) < (b)) ? (a) : (b))
+#define MAX(a,b) (((a) > (b)) ? (a) : (b))
+
+#define NB_SK(sk) (&sk->tp_pinfo.af_netbeui)
+
+#define MAC_ADDR_LEN	6
+
+#define NETBIOS_FUNC_ADDR_4ETH	"\x03\x00\x00\x00\x00\x01"
+#define NETBIOS_FUNC_ADDR_4TR	"\xC0\x00\x00\x00\x00\x80"
+
+#define NETBEUI_DELIMITER	0xEFFF
+
+#define NETBEUI_LLC_I_HEADLEN	4	/* 4 bytes for LLC header of I_frames */
+#define NETBEUI_ILEN		0x0E	/* NetBEUI I_frame header length */
+
+#define NETBEUI_LLC_UI_HEADLEN	3       /* 3 bytes for LLC header of UI_frames */
+#define NETBEUI_UILEN	0x2C    /* NetBEUI UI_frame header length */
+
+#define NETBEUI_MAC_B_HEADLEN MAX(sizeof(struct ethhdr), sizeof(struct trh_hdr))
+
+/* NetBIOS status service constants */
+typedef enum { 
+	NBS_STAT_INITIAL = 0, 
+	NBS_STAT_RESPWAIT
+} status_state_t;
+
+typedef enum {
+	NBE_STAT_STATUS_QUERY = 0,
+	NBE_STAT_RETRY_TIMEOUT,
+	NBE_STAT_RESPONSE_TIMEOUT,
+	NBE_STAT_STATUS_RESPONSE,
+	NBE_STAT_INCOMP_RESPONSE
+} status_event_t;
+
+typedef enum {
+	NO_RESPONSE = 0,
+	INCOMPLETE_RESPONSE,
+	USER_BUFFER_OVERFLOW,
+	COMPLETED_RESPONSE
+} status_rc_t;
+
+struct nb_adapters {
+	struct net_device *dev[NETBEUI_MAX_ADAPTERS];
+	int count;
+	int autobind;
+	rwlock_t lock;
+};
+
+/* NetBIOS name data structure */
+struct nb_name {
+	struct nb_name *	next;
+	atomic_t		refcnt;
+	name_state_t volatile  	state;		
+	s32 volatile		status;
+	__u8     		name[NETBEUI_NAME_LEN];	
+	__u8			reserved;
+	__u8			conflicted;
+	name_type_t		type;		
+	__u8			name_number;
+	__u32			identifier;
+	wait_queue_head_t       waitq;
+	struct timer_list 	timer;
+	struct sk_buff *	skb;
+	__u16 			resp_correlator;
+	__u16			xmit_correlator;
+	__u8 			retries;	
+	__u8 			responses;
+	__u8			remote_mac[6];
+	struct net_device      *dev;
+};
+typedef struct nb_name name_t;
+
+/* NetBIOS Query Data Structure */ 
+struct nb_query {
+	struct nb_query	       *next;
+	query_state_t volatile	state;		
+	s32 volatile 		status;
+	name_t *		calling_name;
+	__u8     		called_name[NETBEUI_NAME_LEN];	
+	__u8			reserved;
+	__u8			lsn;
+	__u16 			resp_correlator;
+	char		       *mac_buff;
+	struct net_device     **dev_buff;
+	__u8			buff_len;
+	__u8			buff_ofs;
+	__u8			rsn;
+	__u8			remote_mac[6];
+	struct net_device      *dev;
+	__u16			xmit_correlator;
+	__u8			tr_lfb; /* for Token-Ring support */
+	struct timer_list 	timer;
+	struct sk_buff	       *skb;
+	__u8 			retries;	
+	__u8 			responses;
+	wait_queue_head_t       waitq;
+};
+typedef struct nb_query query_t;
+
+struct nb_session;
+typedef struct nb_session session_t;
+
+typedef void (*abort_owner_cbt)(struct sock *sk, session_t *session);
+typedef void (*session_ready_cbt)(struct sock *sk, session_t *session);
+
+/* NetBIOS Session Data Structure */
+struct nb_session {
+	struct nb_session *	next;
+	struct nb_session *	prev;
+	session_state_t volatile state;		
+	s32 volatile		status;
+	atomic_t		refcnt;
+	int			link;
+	struct sock *		owner;
+	name_t *		local_name;
+	name_type_t		remote_name_type;		
+	__u8 			remote_name[NETBEUI_NAME_LEN];
+	__u8			reserved;
+	__u8			lsn;
+	__u8			rsn;
+	__u8			version;
+	__u8			nack_indicator;
+	__u8			tr_frame_lf;
+	__u16			mtu;
+	__u16			llcmac_ihl;
+	__u8			urgent_ack;
+	__u8			users;
+	__u8			zapped;
+	struct sk_buff_head 	back_log;
+	abort_owner_cbt		abort_owner_callback;
+	session_ready_cbt	session_ready_callback;
+	wait_queue_head_t       waitq;
+	struct timer_list 	timer;
+	struct sk_buff *	skb;
+	struct net_device * 	dev;
+	__u8			remote_mac[6];
+	__u16			xmit_correlator;
+	__u16			resp_correlator;
+	__u8			o_nonblock;
+	__u8			o_noack;
+	__u8			o_aborted;
+	__u8			o_no_receive;
+	__u8			o_receive_continue;
+	__u8			o_receive_outstanding;
+	__u8			o_rsrc_origin;
+	__u8 *			o_buff;
+	__u16			o_buffsize;
+	__u16			o_size;
+	__u16			o_txed;
+	__u16			o_acked;
+	__u16			r_acked;
+	__u32			o_total;
+	__u32			o_ack_correlator;
+	__u16			i_rcvbuf;
+	__u16			i_aborted;
+	input_state_t		i_state;
+	struct sk_buff_head 	i_skbq;
+	__u16			i_notacked;
+	__u16			i_size;
+	__u32			i_total;
+};
+
+/* NetBIOS-LLC link data structure */
+struct nb_link {
+	link_state_t volatile 	state;		
+	s32	volatile 	status;
+	void 		       *llc_handle;	
+	__u32			link;
+	atomic_t		refcnt;
+	__u8			remote_mac[6];	
+	struct net_device      *dev;	
+	struct sk_buff_head	skbq;
+	__u8			llc_busy;
+	__u32			iactivity;
+	__u8			keep_alive;
+	struct timer_list	timer;
+	dextab_t		session_table;	
+	wait_queue_head_t       waitq;
+};
+typedef struct nb_link link_t;
+
+/* NetBIOS dataGram data structure */
+struct name_dgrms {
+	char			 name[NETBEUI_NAME_LEN];
+	struct sk_buff_head	 frameq;
+	struct sk_buff		*curr_skb;
+	volatile unsigned char	 connected;
+	char			*conn_name;
+	wait_queue_head_t	*waitq;
+	struct name_dgrms	**list;
+	struct name_dgrms	*next;
+	struct name_dgrms	*prev;
+};
+typedef struct name_dgrms name_dgrms_t;
+
+/* NetBIOS socket supplement structures, present in struct sock's tp_pinfo */
+struct netbeui_opt {
+	name_t *name;
+	union {
+		struct {
+			session_t *session;
+			session_t *backlog;
+			volatile struct timeval	sto;
+			volatile struct timeval	rto;
+		} st;
+		struct {
+			struct sockaddr_netbeui	conn_name;
+			name_dgrms_t *namep;
+		} dg;
+	} u;
+};
+
+/* NetBIOS status data structure */ 
+struct nb_status {
+	struct nb_status 	*next;
+	__u8     		*called_name;
+	char			*user_sbuff;
+	int			sbuff_len;
+	status_rc_t		resp_status;
+	volatile status_state_t	state;
+	__u8 			retries;	
+	int			len_rx_info;
+	__u8			no_rx_names;
+	__u8			overflowed;
+	__u16 			resp_correlator;
+	__u8			unicast;
+	__u8			remote_mac[MAC_ADDR_LEN];
+	struct sk_buff		*tx_skb;
+	struct sk_buff		*rx_skb;
+	volatile unsigned char	locked;
+	struct timer_list 	timer;
+	wait_queue_head_t       waitq;
+};
+typedef struct nb_status status_t;
+
+/* NetBIOS datagram packet header */
+struct nb_dgram {
+	__u16	length;
+	__u16	delimiter;
+	__u8	command;
+	__u8	data1;
+	__u16	data2;
+	__u16	xmit_correlator;
+	__u16	resp_correlator;
+	__u8	dest_name[NETBEUI_NAME_LEN];
+	__u8	source_name[NETBEUI_NAME_LEN];
+};
+typedef struct nb_dgram dgram_t;
+
+/* NetBIOS session packet header */ 
+struct nb_packet {
+	__u16	length;
+	__u16	delimiter;
+	__u8	command;
+	__u8	data1;
+	__u16	data2;
+	__u16	xmit_correlator;
+	__u16	resp_correlator;
+	__u8	dest_num;
+	__u8	source_num;
 };
+typedef	struct nb_packet packet_t;
+
+/* NetBIOS Configuration Definitions */
+typedef struct netbeui_config config_t;
+
+extern config_t netbios_config;
+extern struct nb_adapters netbeui_adapters;
+
+#define NETBEUI_INACTIVITY_TIMEOUT (netbios_config.inactivity_timeout * HZ)
+#define NETBEUI_TRANSMIT_TIMEOUT   (netbios_config.transmit_timeout * (HZ / 2))
+#define NETBEUI_TRANSMIT_COUNT     (netbios_config.transmit_count)
+#define NETBEUI_RESOURCE_TIMEOUT   (netbios_config.resource_timeout * (HZ / 10))
+#define NETBEUI_DATA_ACK_TIMEOUT   (netbios_config.data_ack_timeout * (HZ / 10))
+
+/* Common functions interface */ 
+extern inline char *netbeui_funcaddr(struct net_device *dev);
+extern unsigned char nbcm_apt_dev(struct net_device *dev);
+extern inline int MAC_HEADLEN(struct net_device *dev);
+extern inline int LLCMAC_I_HEADLEN(struct net_device *dev);
+extern inline int LLCMAC_UI_HEADLEN(int mac_hlen);
+extern inline int LLCMAC_UIB_HEADLEN(void);
+extern inline int CALC_DG_SKBLEN(int mac_hlen, int user_datalen);
+
+/* LLC supplement interface */
+extern int nbll_attach_session(session_t *session, struct net_device *dev,
+			       unsigned char *remote_mac);
+extern int nbll_link_session(int link);
+extern int nbll_isend(int link, struct sk_buff *skb);
+extern int nbll_uisend(unsigned char *remote_maccaddr, struct sk_buff *skb);
+extern void nbll_detach_session(int link, unsigned char session_no);
+extern int nbll_drop_link(int link);
+extern dextab_t *nbll_get_link_table(void);
+extern link_t *nbll_get_link(int link);
+extern inline void nbll_link_put(link_t *nb_link);
+extern void nbll_test(void);
+ 
+/* Name service interface */
+extern unsigned char *netbeui_dev_name_number_1(struct net_device *dev);
+extern int nbns_validate_name(char *name);
+extern void nbns_init_name_number_1(struct net_device *adapters[]);
+extern name_t *nbns_name_number_1(void);
+extern int nbns_add_name(char *name, name_type_t type, name_t **out_name);
+extern name_t *nbns_find_name(char *name);
+extern inline void nbns_name_hold(name_t *nb_name);
+extern inline void nbns_name_put(name_t *nb_name);
+extern void nbns_del_name(name_t *name);
+extern void nbns_del_identifier(unsigned long id);
+extern void nbns_get_add_name_query(struct sk_buff *skb,
+				    unsigned char *remote_mac, int type);
+extern void nbns_get_add_name_response(struct sk_buff *skb,
+				       unsigned char *remote_mac);
+extern void nbns_get_name_conflict(struct sk_buff *skb);
+extern dextab_t *nbns_get_name_table(void);
+extern name_t *nbns_get_name_list(void);
+extern int nbns_count_names(void);
+extern void nbns_test(void);
+
+/* Query service interface */
+extern void nbqs_get_name_recognized(struct sk_buff *skb,
+				     unsigned char *remote_mac);
+extern int nbqs_query_name(char *called_name, name_t *calling_name, 
+                           unsigned char lsn, unsigned char *rsn, 
+                           unsigned char *lfb, unsigned short *xmit_correlator);
+extern int nbqs_find_name(char *called_name, char *mac_buff, 
+			  struct net_device **dev_buff, int buff_len);
+extern void nbqs_add_rnc(char *name, struct net_device *dev,
+			 unsigned char *mac);
+extern void nbqs_delete_rnc(char *name);
+extern void nbqs_test(void);
+
+/* Session service interface */
+extern void nbss_get_name_query(struct sk_buff *skb, unsigned char *remote_mac);
+extern void nbss_deliver_frame(session_t *session, struct sk_buff *skb);
+extern int nbss_call(name_t *calling_name, char *called_name,
+		     struct sock *owner, abort_owner_cbt itf_abort_owner, 
+           	     session_t **session_ptr);
+extern int nbss_listen(name_t *name, int backlog, struct sock *owner,
+           	       abort_owner_cbt itf_abort_owner, 
+           	       session_ready_cbt itf_session_ready);
+extern int nbss_listen_bh(name_t *nb_name, int backlog, struct sock *owner,
+			  abort_owner_cbt itf_abort_owner,
+			  session_ready_cbt itf_session_ready);
+extern void __nbss_end_listen(name_t *name);
+extern int nbss_send(session_t *session, unsigned char *buf,
+		     unsigned short size, unsigned char nonblock,
+		     unsigned char noack);
+extern int nbss_send_zero(session_t *session, char *buff);
+extern void nbss_abort_send(session_t *session);
+extern int nbss_send_ready(session_t *session);
+extern int nbss_receive(session_t *session, unsigned char *buf,
+  			unsigned short size, unsigned char nonblock);
+extern void nbss_abort_receive(session_t *session);
+extern int nbss_receive_ready(session_t *session);
+extern int nbss_trim_data(session_t *session);
+extern void nbss_hangup(session_t *session);
+extern void nbss_abort_session(session_t *session);
+extern int nbss_drop_session(int link, int session_no);
+extern dextab_t *nbss_get_session_table(int link);
+extern void nbss_test(char *service_name);
+
+/* DataGram service interface */
+extern void nbdg_set_dgbc_mtu(void);
+extern int nbdg_remove_unwanted_dgf(name_dgrms_t *namep, int len);
+extern void nbdg_register_peername(name_dgrms_t *namep, char *remote_name);
+extern void nbdg_deregister_peername(name_dgrms_t *namep);
+extern int nbdg_add_name(char *local_name, wait_queue_head_t *wq,
+			 name_dgrms_t **namep);
+extern void nbdg_del_name(name_dgrms_t *namep);
+extern int nbdg_receive_ready(name_dgrms_t *namep);
+extern int nbdg_send(struct sock *sk, char *local_name, char *dest_name,
+		     name_type_t dest_type, struct iovec *iov, int len,
+		     int noblock);
+extern int nbdg_receive(name_dgrms_t *namep, char *source_name, char *dest_name,
+			char *buff, int bufflen, int nonblock);
+extern void nbdg_get_datagram(struct sk_buff *skb);
+extern void nbdg_get_datagram_broadcast(struct sk_buff *skb);
+
+/* Socket Supplement Interface */
+extern int nbso_init(void);
+extern int nbso_exit(void);
+
+/* Status service interface */
+void nbst_init_status(void);
+int nbst_obtain_status(char *called_name, char *status_buff, int *buff_len);
+void nbst_get_status_query(struct sk_buff *skb, unsigned char *remote_mac);
+void nbst_get_status_response(struct sk_buff *skb, unsigned char *remote_mac);
+
+/* PROC entry interface */
+extern int netbeui_proc_init(void);
+extern void netbeui_proc_clean(void);
 
-#endif
+/* Configuration system interface */ 
+extern int nbcs_setsockopt(struct socket *sock, int optname, void *optval,
+			   int optlen);
+extern int nbcs_getsockopt(struct socket *sock, int optname, void *optval,
+			   int *optlen);
+extern int nbcs_ioctl(unsigned int cmd, void *arg);
+#endif /* _LINUX_NETBEUI_H */
diff -ruN linux-2.4.18-clean/include/linux/skbuff.h linux/include/linux/skbuff.h
--- linux-2.4.18-clean/include/linux/skbuff.h	Thu Nov 22 14:46:26 2001
+++ linux/include/linux/skbuff.h	Fri Jun  7 12:46:10 2002
@@ -136,9 +136,24 @@
 	struct timeval	stamp;			/* Time we arrived				*/
 	struct net_device	*dev;		/* Device we arrived on/are leaving by		*/
 
+	/* Function management header */
+	union
+	{
+		struct fmhdr    *fm;
+		unsigned char   *raw;
+	} f;
+
+	/* Session layer header */
+	union
+	{
+		struct snaruhdr *ru;
+		unsigned char   *raw;
+	} s;
+
 	/* Transport layer header */
 	union
 	{
+		struct snarhdr  *rh;
 		struct tcphdr	*th;
 		struct udphdr	*uh;
 		struct icmphdr	*icmph;
@@ -151,8 +166,10 @@
 	/* Network layer header */
 	union
 	{
+		struct snathdr  *fidh;
 		struct iphdr	*iph;
 		struct ipv6hdr	*ipv6h;
+		struct larhdr   *larh;
 		struct arphdr	*arph;
 		struct ipxhdr	*ipxh;
 		unsigned char	*raw;
diff -ruN linux-2.4.18-clean/include/linux/sna.h linux/include/linux/sna.h
--- linux-2.4.18-clean/include/linux/sna.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/sna.h	Sat Jun  8 15:25:34 2002
@@ -0,0 +1,1163 @@
+/* sna.h: Linux-SNA Network Operator Facility Headers.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#define SNA_NETWORK_NAME_LEN    9
+#define SNA_RESOURCE_NAME_LEN   9
+#define SNA_FQCP_NAME_LEN	18
+#define SNA_PORT_ADDR_LEN       12
+
+struct sna_netid {
+        unsigned char net[SNA_NETWORK_NAME_LEN];
+        unsigned char name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_nodeid {
+	unsigned long	block_id:12,
+			pu_id:20;
+};
+
+#define SNA_DOWN        0x1
+#define SNA_UP          0x2             /* Registed w/ the system */
+#define SNA_RUNNING     0x4             /* In a Running state */
+#define SNA_STOPPED     0x8             /* In a Stopped state */
+
+#define SNA_PORT_ROLE_PRI       0x1
+#define SNA_PORT_ROLE_SEC       0x2
+#define SNA_PORT_ROLE_NEG       0x4
+
+#ifdef __KERNEL__
+
+extern char sna_version[];
+extern char sna_maintainer[];
+extern __u32 sna_debug_level;
+
+extern void sna_mod_inc_use_count(void);
+extern void sna_mod_dec_use_count(void);
+
+extern int hexdump(unsigned char *pkt_data, int pkt_len);
+extern int sna_utok(void *uaddr, int ulen, void *kaddr);
+extern int sna_ktou(void *kaddr, int klen, void *uaddr);
+
+#define SNA_DEBUG 10
+#ifndef SNA_DEBUG
+#define sna_debug(level, format, arg...)
+#else
+#define sna_debug(level, format, arg...) \
+        if(SNA_DEBUG >= level)  \
+                printk(KERN_EMERG __FILE__ ":" __FUNCTION__ ": " format, ## arg)
+#endif  /* SNA_DEBUG */
+
+#define new(ptr, flag)	do { 				\
+	(ptr) = kmalloc(sizeof(*(ptr)), flag);		\
+	if (ptr) 					\
+		memset(ptr, 0, sizeof(*(ptr))); 	\
+} while (0)
+
+#define new_s(ptr, size, flag)	do {			\
+	(ptr) = kmalloc(size, flag);			\
+	if (ptr)					\
+		memset(ptr, 0, size);			\
+} while (0)
+		
+/* Linux-SNA Layer Identifiers */
+#define SNA_SM          0x01    /* Session Manager */
+#define SNA_HS          0x02    /* Half Session Router */
+#define SNA_INIT        0x03    /* SNA Initiator */
+#define SNA_PS          0x04    /* Presentation Services */
+#define SNA_RM          0x05    /* Resource Manager */
+#define SNA_ASM         0x06    /* Address Space Manager */
+#define SNA_SS          0x07    /* Session Services */
+
+/* Linux-SNA MU header types */
+#define SNA_MU_BIND_RQ_SEND             0x01
+#define SNA_MU_BIND_RSP_SEND            0x02
+#define SNA_MU_UNBIND_RQ_SEND           0x03
+#define SNA_MU_UNBIND_RQ_RCV            0x04
+#define SNA_MU_UNBIND_RSP_SEND          0x05
+#define SNA_MU_BIND_RQ_RCV              0x06
+#define SNA_MU_BIND_RSP_RCV             0x07
+#define SNA_MU_HS_TO_RM                 0x08
+#define SNA_MU_RM_TO_PS                 0x09
+#define SNA_MU_HS_TO_PS                 0x0A
+#define SNA_MU_PS_TO_HS                 0x0B
+#define SNA_MU_HS_TO_PC                 0x0C
+
+/* Linux-SNA Deactivate session identifiers */
+#define SNA_DEACT_PENDING               0x01
+#define SNA_DEACT_ACTIVE                0x02
+
+/* Linux-SNA Session Identifiers */
+#define SNA_SESSION_NONE                0x00    /* No Session Speaker */
+#define SNA_SESSION_FIRST_SPEAKER       0x01    /* First Speaker Session */
+#define SNA_SESSION_BIDDER              0x02    /* Bidder Session */
+#define SNA_SESSION_EITHER              0x03    /* First or Bidder Session */
+
+/* Linux-SNA Sync level indicators */
+#define SNA_SYNC_NONE                   0x01
+#define SNA_SYNC_CONFIRM                0x02
+#define SNA_SYNC_SYNCPT                 0x03
+#define SNA_SYNC_BACKOUT                0x04
+
+/* Linux-SNA HS type indicators */
+#define SNA_HS_PRI                      0x01
+#define SNA_HS_SEC                      0x02
+
+/* Linux-SNA Security indicators */
+#define SNA_SECURITY_NONE               0x01
+#define SNA_SECURITY_SAME               0x02
+#define SNA_SECURITY_PGM                0x03
+
+/* Linux-SNA sna_send_deactivate_pending() indicators */
+#define SNA_PENDING                     0x01
+#define SNA_ACTIVE                      0x02
+#define SNA_ABNORMAL                    0x03
+#define SNA_ABNORMAL_RETRY              0x04
+#define SNA_ABNORMAL_NO_RETRY           0x05
+#define SNA_CLEANUP                     0x06
+#define SNA_NORMAL                      0x07
+
+/* Linux-SNA Structure Identifiers */
+#define SNA_REC_BID                     0x001
+#define SNA_REC_BID_RSP                 0x002
+#define SNA_REC_MU                      0x003
+#define SNA_REC_MU_FMH5                 0x004
+#define SNA_REC_MU_FMH12                0x005
+#define SNA_REC_FREE_SESSION            0x006
+#define SNA_REC_RTR_RQ                  0x007
+#define SNA_REC_RTR_RSP                 0x008
+#define SNA_REC_BIS_REPLY               0x009
+#define SNA_REC_ALLOCATE_RCB            0x00A
+#define SNA_REC_GET_SESSION             0x00B
+#define SNA_REC_DEALLOCATE_RCB          0x00C
+#define SNA_REC_TERMINATE_PS            0x00D
+#define SNA_REC_CHANGE_SESSIONS         0x00E
+#define SNA_REC_RM_ACTIVATE_SESSION     0x00F
+#define SNA_REC_RM_DEACTIVATE_SESSION   0x010
+#define SNA_REC_DEACTIVATE_CONV_GROUP   0x011
+#define SNA_REC_UNBIND_PROTOCOL_ERROR   0x012
+#define SNA_REC_ABEND_NOTIFICATION      0x013
+#define SNA_REC_ACTIVATE_SESSION_RSP    0x014
+#define SNA_REC_SESSION_ACTIVATED       0x015
+#define SNA_REC_SESSION_DEACTIVATED     0x016
+#define SNA_REC_BIS_RQ                  0x017
+#define SNA_REC_ACTIVATE_SESSION        0x018
+#define SNA_REC_DEACTIVATE_SESSION      0x019
+#define SNA_REC_INIT_HS_RSP             0x01B
+#define SNA_REC_ABORT_HS                0x01C
+#define SNA_REC_INIT_SIGNAL_NEG_RSP     0x01D
+#define SNA_REC_CINIT_SIGNAL            0x01E
+#define SNA_REC_SESSION_ROUTE_INOP      0x01F
+#define SNA_REC_LFSID_IN_USE            0x020
+#define SNA_REC_BRACKET_FREED           0x021
+#define SNA_REC_BID_WITHOUT_ATTACH      0x022
+#define SNA_REC_HS_PS_CONNECTED         0x023
+#define SNA_REC_RM_HS_CONNECTED         0x024
+#define SNA_REC_SECURITY_REPLY_2        0x025
+#define SNA_REC_YIELD_SESSION           0x026
+#define SNA_REC_INIT_HS                 0x027
+#define SNA_REC_RCB_ALLOCATED           0x028
+#define SNA_REC_SESSION_ALLOCATED       0x029
+#define SNA_REC_RM_SESSION_ALLOCATED    0x02A
+#define SNA_REC_CONV_FAIL               0x02B
+#define SNA_REC_RM_SESSION_ACTIVATED    0x02C
+#define SNA_REC_START_TP                0x02D
+#define SNA_REC_FREE_LFSID              0x02E
+#define SNA_REC_PC_HS_DISCONNECT        0x02F
+#define SNA_REC_ASSIGN_LFSID            0x030
+#define SNA_REC_LFSID_IN_USE_RSP        0x031
+#define SNA_REC_INIT_SIGNAL             0x032
+#define SNA_REC_SESSEND_SIGNAL          0x033
+#define SNA_REC_SESSST_SIGNAL           0x034
+#define SNA_REC_ASSIGN_PCID             0x035
+#define SNA_REC_RCB_DEALLOCATED         0x036
+#define SNA_REC_SEND_RTR                0x037
+#define SNA_REC_RM_TIMER_POP            0x038
+
+#endif 	/* __KERNEL__ */
+
+		
+#define SIOCGNODE	0x1000
+#define SIOCGDLC	0x1001
+#define SIOCGPORT	0x1002
+#define SIOCGLS		0x1003
+#define SIOCGMODE	0x1004
+#define SIOCGLU		0x1005
+#define SIOCGPLU	0x1006
+#define SIOCGCPICS	0x1007
+#define SIOCGPS		0x1008
+#define SIOCGCOS	0x1009
+
+struct cosreq {
+	struct cosreq		*next;
+	struct cosreq		*prev;
+
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+};
+
+struct cosconf {
+        int     cos_len;
+        char    cos_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *cosc_buf;
+                struct cosreq   *cosc_req;
+        } cosc_coscu;
+};
+
+struct sna_qcos {
+        struct sna_qcos *next;
+        struct cosreq   data;
+};
+
+#define cosc_buf cosc_coscu.cosc_buf              /* buffer address       */
+#define cosc_req cosc_coscu.cosc_req              /* array of structures  */
+
+struct plureq {
+	struct plureq		*next;
+	struct plureq		*prev;
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	struct sna_netid	fqcp_name;
+	unsigned char		parallel_ss;
+        unsigned char   	cnv_security;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct pluconf {
+	int	plu_len;
+	char	plu_net[SNA_NETWORK_NAME_LEN];
+	char	plu_name[SNA_RESOURCE_NAME_LEN];
+	char	plu_plunet[SNA_NETWORK_NAME_LEN];
+	char	plu_pluname[SNA_RESOURCE_NAME_LEN];
+	char	plu_fqcpnet[SNA_NETWORK_NAME_LEN];
+	char	plu_fqcpname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *pluc_buf;
+                struct plureq	*pluc_req;
+        } pluc_plucu;
+};
+
+struct sna_qplu {
+        struct sna_qplu *next;
+        struct plureq   data;
+};
+
+#define pluc_buf pluc_plucu.pluc_buf              /* buffer address       */
+#define pluc_req pluc_plucu.pluc_req              /* array of structures  */
+
+struct lureq {
+	struct lureq		*next;
+	struct lureq		*prev;
+
+	struct sna_netid	netid;
+	char			name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		sync_point;
+	unsigned long		lu_sess_limit;
+	unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct luconf {
+	int             lu_len;
+        char            lu_net[SNA_NETWORK_NAME_LEN];
+        char            lu_name[SNA_RESOURCE_NAME_LEN];
+	char		lu_luname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *luc_buf;
+                struct lureq      *luc_req;
+        } luc_lucu;
+};
+
+struct sna_qlu {
+        struct sna_qlu *next;
+        struct lureq   data;
+};
+
+#define luc_buf luc_lucu.luc_buf              /* buffer address       */
+#define luc_req luc_lucu.luc_req              /* array of structures  */
+
+/* mode information request record. */
+struct modereq {
+	struct modereq		*next;
+	struct modereq		*prev;
+
+	char			mode_name[SNA_RESOURCE_NAME_LEN];
+	char			cos_name[SNA_RESOURCE_NAME_LEN];
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	unsigned long		tx_pacing;
+        unsigned long   	rx_pacing;
+        unsigned long   	max_tx_ru;
+        unsigned long   	max_rx_ru;
+        unsigned long   	crypto;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+
+	unsigned short  	auto_activation;
+        unsigned long   	max_sessions;
+        unsigned long   	min_conlosers;
+        unsigned long   	min_conwinners;
+
+        unsigned long   	act_sessions;
+        unsigned long   	act_conwinners;
+        unsigned long   	act_conlosers;
+
+        unsigned long   	pend_sessions;
+        unsigned long   	pend_conwinners;
+        unsigned long   	pend_conlosers;
+};
+
+struct modeconf {
+	int             mode_len;
+        char            mode_net[SNA_NETWORK_NAME_LEN];
+        char            mode_name[SNA_RESOURCE_NAME_LEN];
+	char		mode_modename[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *modec_buf;
+                struct modereq      *modec_req;
+        } modec_modecu;
+};
+
+struct sna_qmode {
+        struct sna_qmode *next;
+        struct modereq   data;
+};
+
+#define modec_buf modec_modecu.modec_buf              /* buffer address       */
+#define modec_req modec_modecu.modec_req              /* array of structures  */
+
+struct lsreq {
+	struct lsreq		*next;
+	struct lsreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+        char            	lsname[SNA_RESOURCE_NAME_LEN];
+	char			dname[SNA_FQCP_NAME_LEN];
+	char			daddr[12];
+	unsigned char		sport;
+	unsigned long		proc_id;
+	unsigned short		flags;
+	unsigned long		auto_act;
+	unsigned long		auto_deact;
+	unsigned long		byteswap;
+};
+
+struct lsconf {
+        int             ls_len;
+        char            ls_net[SNA_NETWORK_NAME_LEN];
+        char            ls_name[SNA_RESOURCE_NAME_LEN];
+        char            ls_devname[SNA_RESOURCE_NAME_LEN];
+        char            ls_portname[SNA_RESOURCE_NAME_LEN];
+	char		ls_lsname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *lsc_buf;
+                struct lsreq      *lsc_req;
+        } lsc_lscu;
+};
+
+struct sna_qls {
+        struct sna_qls *next;
+        struct lsreq   data;
+};
+
+#define lsc_buf lsc_lscu.lsc_buf              /* buffer address       */
+#define lsc_req lsc_lscu.lsc_req              /* array of structures  */
+
+struct portreq {
+	struct portreq		*next;
+	struct portreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+
+	char			saddr[12];
+	unsigned long		ls_qlen;
+	unsigned long		proc_id;
+	unsigned long		role;
+	unsigned long		btu;
+	unsigned long		mia;
+	unsigned long		moa;
+
+	unsigned short		flags;
+
+	struct lsreq		*ls;
+};
+
+struct portconf {
+        int             port_len;
+        char            port_net[SNA_NETWORK_NAME_LEN];
+        char            port_name[SNA_RESOURCE_NAME_LEN];
+        char            port_devname[SNA_RESOURCE_NAME_LEN];
+	char		port_portname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *portc_buf;
+                struct portreq    *portc_req;
+        } portc_portcu;
+};
+
+struct sna_qport {
+        struct sna_qport *next;
+        struct portreq   data;
+};
+
+#define portc_buf portc_portcu.portc_buf              /* buffer address       */
+#define portc_req portc_portcu.portc_req              /* array of structures  */
+
+struct dlcreq {
+	struct dlcreq		*next;
+	struct dlcreq		*prev;
+
+	struct sna_netid	netid;
+	char			devname[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		port_qlen;
+	unsigned long		proc_id;
+	unsigned short		flags;	
+
+	struct portreq		*port;
+};
+
+struct dlconf {
+        int             dlc_len;
+        char            dlc_net[SNA_NETWORK_NAME_LEN];
+        char            dlc_name[SNA_RESOURCE_NAME_LEN];
+	char		dlc_devname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *dlc_buf;
+                struct dlcreq    *dlc_req;
+        } dlc_dlcu;
+};
+
+struct sna_qdlc {
+        struct sna_qdlc *next;
+        struct dlcreq   data;
+};
+
+#define dlc_buf dlc_dlcu.dlc_buf              /* buffer address       */
+#define dlc_req dlc_dlcu.dlc_req              /* array of structures  */
+
+struct snareq {
+	char		net[SNA_NETWORK_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short   bind_seg;      /* Is Bind segmenting supported. */
+        unsigned long    max_lus;	/* Max LU sessions */
+	unsigned short	node_status;
+};
+
+struct snaconf {
+        int             snac_len;
+	char		snac_net[SNA_NETWORK_NAME_LEN];
+	char		snac_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *snac_buf;
+                struct snareq    *snac_req;
+        } snac_snacu;
+};
+
+struct sna_qsna {
+        struct sna_qsna *next;
+        struct snareq   data;
+};
+
+#define snac_buf snac_snacu.snac_buf              /* buffer address       */
+#define snac_req snac_snacu.snac_req              /* array of structures  */
+
+struct sna_all_info {
+	struct sna_all_info *next;		/* Next node */
+
+	/* Std. Node info. */
+	char		net[SNA_RESOURCE_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;      	/* Is Bind segmenting supported. */
+        unsigned long   max_lus;       	/* Max LU sessions */
+	unsigned short	node_status;	
+
+	struct modereq		*mode;
+	struct plureq		*plu;
+	struct lureq		*lu;
+	struct dlcreq		*dl;
+	struct cpicsreq		*cpics;
+	struct cosreq		*cos;
+};
+
+#define SNA_NODE_NAME_LEN	8
+
+#ifdef __KERNEL__
+struct sna_nof_pinfo {
+	struct list_head list;
+
+	struct sna_netid 	netid;
+	struct sna_nodeid	nodeid;
+	unsigned short	status;
+	unsigned char	type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;       /* Is Bind segmenting supported. */
+        unsigned long   max_lus;        /* Max number of LU sessions,
+                                         * 0 = Unlimited.
+                                         */
+
+	/* Data below not currently used. */
+        unsigned long   netid_registered;
+        unsigned long   ls_supp_type;
+        unsigned long   resource_registration;
+        unsigned long   segment_generation_lvl;
+        unsigned long   mode_to_cos_mapping;
+        unsigned long   ms_node_type;
+        unsigned long   mj_vector_file;
+        unsigned long   ms_log_file;
+        unsigned long   peer_resource_registration;
+        unsigned long   network_node_type;
+        unsigned long   directory_type_supp;
+        unsigned long   rs_tree_update_type;
+        unsigned long   tdm_node_name;
+        unsigned long   cosdm_node_name;
+        unsigned long   max_rs_cache_trees;
+        unsigned long   max_oos_tdm_updates;
+        unsigned long   resource_service_search;
+        unsigned long   general_odai_usage_supp;
+};
+#endif	/* __KERNEL__ */
+
+#define SNA_NOF_NODE_SHUTDOWN_RQ		0xFFFF
+
+#define SNA_CP_CREATE_PARMS_RQ			0x0100
+struct sna_cp_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_cp;
+	unsigned long	*netid;
+	unsigned long	bind_reassembly;
+	unsigned long	adaptive_bind_pacing;
+	unsigned long	sense;
+};
+
+#define SNA_TRS_CREATE_PARMS_RQ			0x0102
+struct sna_trs_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	node_type;
+	unsigned long	*cp_name;
+	unsigned long	netid;
+	unsigned long	rs_tree_caching;
+	unsigned long	incr_rs_tree_updates;
+	unsigned long	max_rs_trees;
+	unsigned long	max_tdm_nodes;
+	unsigned long	max_oos_tdus;
+	unsigned long	cosdm_file_name;
+	unsigned long	tdm_file_name;
+	unsigned long	gateway;
+	unsigned long	central_directory_server;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NAME		0x9998
+struct sna_query_connection_name {
+	char 		connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned 	long sense;
+};
+
+#define SNA_ACTIVATE_CONTROL_SESSIONS	0x1000
+struct sna_activate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*remote_cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_CHANGE_SESSION_LIMIT		0x1002
+struct sna_change_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	new_limit_conwinner;
+	unsigned long	new_limit_conloser;
+	unsigned long	deactivating_lu;
+	unsigned long   sense;
+};
+
+#define SNA_DEACTIVATE_CONTROL_SESSIONS	0x1004
+struct sna_deactivate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_ADJACENT_NODE		0x1006
+struct sna_define_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long	cp_capabilities;
+	unsigned long	node_type;
+	unsigned long	auth_lvl_adj_node;
+	unsigned long	*netid_lu_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_CLASS_OF_SERVICE		0x1008
+struct sna_define_cos {
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+
+	/* Tg Characteristics */
+	unsigned short	tg_rsn;
+	unsigned short  min_cost_per_connect;
+        unsigned short  max_cost_per_connect;
+        unsigned short  min_cost_per_byte;
+        unsigned short  max_cost_per_byte;
+        unsigned short  min_security;
+        unsigned short  max_security;
+        unsigned short  min_propagation_delay;
+        unsigned short  max_propagation_delay;
+        unsigned short  min_effective_capacity;
+        unsigned short  max_effective_capacity;
+        unsigned short  min_user1;
+        unsigned short  max_user1;
+        unsigned short  min_user2;
+        unsigned short  max_user2;
+        unsigned short  min_user3;
+        unsigned short  max_user3;
+
+	/* Node Characteristics */
+	unsigned short  node_rsn;
+        unsigned short  min_route_resistance;
+	unsigned short	max_route_resistance;
+        unsigned short  min_node_congested;
+	unsigned short	max_node_congested;
+};
+
+#define SNA_DEFINE_CONNECTION_NETWORK	0x100A
+struct sna_define_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid;
+	unsigned long	tg_characteristics;
+	unsigned long	port_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_DIRECTORY_ENTRY		0x100C
+struct sna_define_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource;
+	unsigned long	entry_class;
+	unsigned long	directory_entry_scope;
+	unsigned long	registration_requirements;
+	unsigned long   sense;
+};
+
+#define SNA_LS_MODE_ABM				0x1
+#define SNA_LS_MODE_NRM				0x2
+
+#define SNA_DEFINE_ISR_TUNING		0x1010
+struct sna_define_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*secondary_lu_name;
+	unsigned long	*mode_name;
+	unsigned long	slu_mode_entry;
+	unsigned long	pri_rws;
+	unsigned long	sec_rws;
+	unsigned long	max_pri_rws;
+	unsigned long	max_sec_rws;
+	unsigned long	nonreserved_perm_buf_pool_size;
+	unsigned long	max_pri_ru_size;
+	unsigned long	max_sec_ru_size;
+	unsigned long	adaptive_session_lvl_pacing;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_LINK_STATION		0x1012
+struct sna_define_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+        char    saddr[SNA_PORT_ADDR_LEN];       /* 0x04 */
+
+	struct sna_netid plu_name;
+	char	dname[7];			/* Dest. MAC addr */
+	char	daddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+
+	int byteswap;
+	int retry_on_fail;
+        int retry_times;
+        int autoact;
+        int autodeact;
+        int tg_number;
+        int cost_per_byte;
+        int cost_per_connect_time;
+        int effective_capacity;
+        int propagation_delay;
+        int security;
+        int user1;
+        int user2;
+        int user3;
+};
+
+#define SNA_DEFINE_LOCAL_LU			0x1014
+struct sna_define_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char	sync_point;
+	unsigned long	lu_sess_limit;
+
+	/* Data below not used */
+	unsigned long	reg_requirments;
+	unsigned long	bind_range_process;
+	unsigned long	queueing_capability;
+	unsigned long	map_lu_names_list;
+};
+
+#define SNA_DEFINE_MODE			0x1016
+struct sna_define_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		tx_pacing;
+	unsigned long		rx_pacing;
+	unsigned long		max_tx_ru;
+	unsigned long		max_rx_ru;
+	unsigned char		crypto;
+	unsigned long		min_conwinners;
+	unsigned long		min_conlosers;
+	unsigned long		max_sessions;
+	unsigned char		auto_activation;
+};
+
+#define SNA_DEFINE_NODE_CHARS		0x1018
+struct sna_define_node_chars {
+	struct sna_netid	cp_name;
+	unsigned char		route_resistance;
+	unsigned char		quiescing;
+};
+
+#define SNA_DEFINE_PARTNER_LU		0x101A
+struct sna_define_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+	struct sna_netid netid_fqcp;
+	unsigned char 	parallel_ss;
+	unsigned char 	cnv_security;
+
+	/* Data below not used. */
+	unsigned long	init_lu_type;
+	unsigned long	multi_sessions;
+	unsigned long	cnos_lvl_exchg;
+	unsigned long	password;
+	unsigned long	lu_access_security;
+};
+
+#define SNA_DEFINE_PORT			0x101C
+struct sna_define_port {
+	struct sna_netid netid;
+	char	name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x4 */
+	unsigned long	role;		/* PRI */
+	unsigned long	btu;		/* Max Rx/Tx BTU size. */
+	unsigned long	mia;		/* Max inbound activations */
+	unsigned long	moa;		/* Max outbound activations */
+	
+	unsigned long	link_station_txrx;
+	unsigned long	max_nonack_xid;
+};
+
+#define SNA_DEFINE_TP			0x101E
+struct sna_define_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	init_tp_status;
+	unsigned long	conv_types_allowed;
+	unsigned long	sync_lvl_supp;
+	unsigned long	pip_lvl;
+	unsigned long	num_pip_parms;
+	unsigned long	data_map_supp;
+	unsigned long	fm_hdr_supp;
+	unsigned long	max_concurrent_tp_instances;
+	unsigned long	*issue_verb_list;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ADJACENT_NODE		0x1020
+struct sna_delete_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_CLASS_OF_SERVICE		0x1022
+struct sna_delete_cos {
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_CONNECTION_NETWORK	0x1024
+struct sna_delete_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_net;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_DIRECTORY_ENTRY		0x1026
+struct sna_delete_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource_name;
+	unsigned long	parent_resource_type;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ISR_TUNING		0x102A
+struct sna_delete_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	mode_name;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_LINK_STATION		0x102C
+struct sna_delete_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN]; 
+	char	dname[17];
+	char	daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_DELETE_LOCAL_LU			0x102E
+struct sna_delete_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_MODE			0x1030
+struct sna_delete_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_PARTNER_LU		0x1032
+struct sna_delete_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+};
+
+#define SNA_DELETE_PORT			0x1034
+struct sna_delete_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_DELETE_TP			0x1036
+struct sna_delete_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long   sense;
+};
+
+#define SNA_INITIALIZE_SESSION_LIMIT		0x1038
+struct sna_initialize_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	max_session_limit;
+	unsigned long	max_session_limit_conwinner;
+	unsigned long	max_session_limit_conloser;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CLASS_OF_SERVICE		0x103A
+struct sna_query_class_of_service {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cos_name;
+
+	unsigned long	tx_priority;
+	unsigned long	*mode_name_list;
+	unsigned long	*node_weights;
+	unsigned long	*tg_weights;
+	unsigned long	default_cos;
+	unsigned long	default_blank_cos;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NETWORK		0x103C
+struct sna_query_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_network;
+
+	unsigned long	*network_control_block;
+	unsigned long	*tg_status_list;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_DLC			0x103E
+struct sna_query_dlc {
+	struct sna_netid netid;
+
+	char 		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+	unsigned long	fsm_dlc_state;
+
+	char		port_list[90];	/* Room for 10 ports to be listed. */
+};
+
+#define SNA_QUERY_ISR_TUNING			0x1040
+struct sna_query_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	*mode_name;
+
+	unsigned long	*slu_mode_entry;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_LINK_STATION		0x1042
+struct sna_query_link_station {
+	struct sna_netid *netid;
+
+	char		ls_name[SNA_RESOURCE_NAME_LEN];
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long	adj_node_type;
+	unsigned long	fsm_ls_state;
+
+	unsigned long	ls_entered_act_state;
+	unsigned long	node_act;
+	unsigned long	ls_activation;
+
+	char		dest_addr[6];
+
+	unsigned long	tx_win_size;
+	unsigned long	rx_win_size;
+
+	unsigned long	fsm_xid_state;
+	unsigned long	fsm_nonact_xid_state;
+	unsigned long	fsm_ls_role_state;
+};
+
+#define SNA_QUERY_PORT			0x1044
+struct sna_query_port {
+	struct sna_netid *netid;
+
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_system_id;
+	char		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_type;
+	unsigned long   max_rx_btu_size;
+        unsigned long   max_tx_btu_size;
+
+        unsigned long   max_adjacent_link_stations;
+        unsigned long   real_adjacent_link_stations;
+
+        unsigned long   max_inbound_activation;
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   max_outbound_activation;
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+	unsigned long   port_role;
+	unsigned long   link_station_txrx;
+	unsigned long   max_nonack_xid;
+	unsigned long	port_address;
+	unsigned long	fsm_port_state;
+};
+
+#define SNA_QUERY_STATISTICS			0x1046
+struct sna_query_stats {
+	struct sna_netid *netid;
+
+	unsigned long	*adj_link_station_name;
+	unsigned long	*sysid_dlc;
+	unsigned long	*sysid_port;
+	unsigned long	*sysid_adj_ls;
+	unsigned long	*stats;
+};
+
+#define SNA_RESET_SESSION_LIMIT		0x1048
+struct sna_reset_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	rsp_lu;
+	unsigned long	lu_session_availability;
+	unsigned long	plu_session_availability;
+	unsigned long	cnos_error_handling;
+	unsigned long   sense;
+};
+
+#define SNA_START_NODE			0x104A
+struct sna_start_node {
+	struct sna_netid 	netid;	/* Local NetID.Node. */
+	struct sna_nodeid	nodeid;	/* Local Block and PU ID. */
+	unsigned char	type;		/* Node type. */
+	unsigned short	lu_seg;		/* Is LU segmenting supported. */
+	unsigned short	bind_seg;	/* Is Bind segmenting supported. */
+	unsigned long	max_lus;	/* Max number of LU sessions,
+					 * 0 = Unlimited.
+					 */
+
+	/* Data below not used at the moment */
+	unsigned long	netid_registered;
+	unsigned long	ls_supp_type;
+	unsigned long	resource_registration;
+	unsigned long	segment_generation_lvl;
+	unsigned long	mode_to_cos_mapping;
+	unsigned long	ms_node_type;
+	unsigned long	*mj_vector_file;
+	unsigned long	*ms_log_file;
+	unsigned long	peer_resource_registration;
+	unsigned long	network_node_type;
+	unsigned long	directory_type_supp;
+	unsigned long	rs_tree_update_type;
+	unsigned long	*tdm_node_name;
+	unsigned long	*cosdm_node_name;
+	unsigned long	max_rs_cache_trees;
+	unsigned long	max_oos_tdm_updates;
+	unsigned long	*resource_service_search;
+	unsigned long	general_odai_usage_supp;
+};
+
+#define SNA_DELETE_NODE			0x104B
+struct sna_delete_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_START_DLC			0x104C
+struct sna_start_dlc {
+	char node_name[SNA_NODE_NAME_LEN];
+	unsigned long	*dlc_name;
+        unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+        unsigned long   data;
+	unsigned long   sense;
+};
+
+#define SNA_START_LINK_STATION		0x104E
+struct sna_start_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_START_PORT			0x1050
+struct sna_start_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_START_TP				0x1052
+struct sna_start_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	*pip;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_DLC				0x1054
+struct sna_stop_dlc {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*dlc_name;
+	unsigned long	deact_type;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_NODE				0x1055
+struct sna_stop_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_STOP_LINK_STATION		0x1056
+struct sna_stop_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+
+	unsigned long	deact_type;
+};
+
+#define SNA_STOP_PORT			0x1058
+struct sna_stop_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+	unsigned long	deact_type;
+};
+
+/* SNA node types. */
+#define SNA_LEN_END_NODE	0x1
+#define SNA_APPN_END_NODE	0x2
+#define SNA_APPN_NET_NODE	0x4
+
+/* SNA Network qualified name is registered or not. */
+#define SNA_NOF_NO_NETID_REG		0x0
+#define SNA_NOF_NETID_REG		0x1
+
+/* SNA resource registration indicatiors. */
+#define SNA_NOF_RESOURCE_REG_NONE	0x0
+#define SNA_NOF_RESOURCE_REG_RESOURCES	0x1
+
+/* MS node type. */
+#define SNA_NOF_MS_ENTRY_POINT		0x0
+#define SNA_NOF_MS_FOCAL_POINT		0x1
+
+#ifdef __KERNEL__
+
+#include <net/sna_formats.h>
+#include <net/sna_cbs.h>
+#include <net/sna_externs.h>
+#include <net/sna_errors.h>
+
+#endif  /* __KERNEL__ */
diff -ruN linux-2.4.18-clean/include/linux/socket.h linux/include/linux/socket.h
--- linux-2.4.18-clean/include/linux/socket.h	Fri Dec 21 12:42:04 2001
+++ linux/include/linux/socket.h	Fri Jun  7 08:46:12 2002
@@ -242,6 +242,10 @@
 #define SOL_NETBEUI	267
 #define SOL_LLC		268
 
+#define SOL_SNA_NOF     278     /* SNA Network Operator Facility */
+#define SOL_SNA_CPIC    279     /* CPI-C v2.1 */
+#define SOL_SNA_PS     	281     /* Presentation Services */
+
 /* IPX options */
 #define IPX_TYPE	1
 
diff -ruN linux-2.4.18-clean/include/linux/sysctl.h linux/include/linux/sysctl.h
--- linux-2.4.18-clean/include/linux/sysctl.h	Mon Nov 26 08:29:17 2001
+++ linux/include/linux/sysctl.h	Fri Jun  7 08:46:14 2002
@@ -164,7 +164,8 @@
 	NET_TR=14,
 	NET_DECNET=15,
 	NET_ECONET=16,
-	NET_KHTTPD=17
+	NET_KHTTPD=17,
+	NET_SNA=18
 };
 
 /* /proc/sys/kernel/random */
@@ -210,6 +211,26 @@
 /* /proc/sys/net/ethernet */
 
 /* /proc/sys/net/802 */
+
+/* /proc/sys/net/sna */
+enum {
+        NET_SNA_MAX_LINK_STATIONS=1,
+        NET_SNA_MAX_LU=2,
+        NET_SNA_MAX_MODE=3,
+        NET_SNA_XID_RETRY=4,
+        NET_SNA_MIA=5,
+        NET_SNA_MOA=6,
+        NET_SNA_MAX_RETRY=7,
+        NET_SNA_MAX_BTU=8,
+        NET_SNA_MAX_TX_RU=9,
+        NET_SNA_MAX_RX_RU=10,
+        NET_SNA_MAX_AUTO_ACT=11,
+        NET_SNA_DEBUG=12,
+        NET_SNA_XID_IDLE_LIMIT=13,
+        NET_SNA_XID_RETRY_INTERVAL=14,
+        NET_SNA_CO_MAX_RETRIES=15,
+       	NET_SNA_MAX_LS_CNT=16
+};
 
 /* /proc/sys/net/unix */
 
diff -ruN linux-2.4.18-clean/include/linux/trdevice.h linux/include/linux/trdevice.h
--- linux-2.4.18-clean/include/linux/trdevice.h	Sun Mar 25 21:24:31 2001
+++ linux/include/linux/trdevice.h	Fri Jun  7 04:57:42 2002
@@ -31,6 +31,9 @@
 extern int		tr_header(struct sk_buff *skb, struct net_device *dev,
 				   unsigned short type, void *daddr,
 				   void *saddr, unsigned len);
+extern void		tr_source_route(struct sk_buff *skb,
+					struct trh_hdr *trh,
+					struct net_device *dev);
 extern int		tr_rebuild_header(struct sk_buff *skb);
 extern unsigned short	tr_type_trans(struct sk_buff *skb, struct net_device *dev);
 extern struct net_device *init_trdev(struct net_device *dev, int sizeof_priv);
diff -ruN linux-2.4.18-clean/include/net/cpic.h linux/include/net/cpic.h
--- linux-2.4.18-clean/include/net/cpic.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/cpic.h	Fri Jun  7 11:48:59 2002
@@ -0,0 +1,183 @@
+#ifndef _NET_CPIC_H
+#define _NET_CPIC_H
+
+#ifdef __KERNEL__
+
+typedef enum {
+	CM_RESET = 1,
+	CM_INIT,
+	CM_SEND,
+	CM_RCV,
+	CM_SEND_PEND,
+//	CM_CONFIRM,
+	CM_CONFIRM_SEND,
+	CM_CONFIRM_DEALLOC,
+	CM_INIT_INCOMING,
+	CM_SEND_RCV,
+	CM_SEND_ONLY,
+	CM_RCV_ONLY,
+	CM_DEFER_RCV,
+	CM_DEFER_DEALLOC,
+	CM_PREPARED,
+//	CM_SYNC_POINT,
+	CM_SYNC_POINT_SEND,
+	CM_SYNC_POINT_DEALLOC
+} cpic_state;
+
+#define NETWORK_NAME_LEN    9
+#define RESOURCE_NAME_LEN   9
+struct netid {
+        unsigned char net[NETWORK_NAME_LEN];
+        unsigned char name[RESOURCE_NAME_LEN];
+};
+
+struct cpic_side_info {
+	struct list_head list;
+
+        unsigned long           proc_id;
+
+	struct netid		netid;
+	struct netid		netid_plu;
+
+        unsigned char           sym_dest_name[RESOURCE_NAME_LEN];
+        unsigned char           mode_name[RESOURCE_NAME_LEN];
+        unsigned char           tp_name[65];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[11];
+        unsigned char           password[11];
+};
+
+struct cpic {
+        cpic_state              state;
+        unsigned short          flags;
+
+        struct cpic_ops         *ops;
+        struct cpic_side_info   *side;
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+        pid_t                   pid;
+
+	union {
+        	struct sna_tcb         *sna;
+	} vi;
+
+        wait_queue_head_t       wait;
+};
+
+/* Should be:
+ *
+ *	struct cpic_ops {
+ *		int family;
+ *		*release
+ *		*create
+ *		*extract
+ *		*set
+ *		*rcv
+ *		*rcvx
+ *		*send
+ *		*sendx
+ *	};
+ */
+
+struct cpic_ops {
+        int     family;
+
+	struct sna_tcb *(*find_tcb_by_pid) (pid_t pid);
+        int     (*release)      (struct cpic *cpic);
+        int     (*create)       (struct cpic *cpic, int s);
+
+        __u32 (*cmsaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+/* 5 */ __u32 (*cmsac)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+        __u32 (*cmsbt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsp)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*10*/  __u32 (*cmscst)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsu)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsct)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscu)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsdt)          (struct cpic *cpic, __u32 *a1);
+/*15*/  __u32 (*cmsed)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsend)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+        __u32 (*cmserr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsf)           (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsid)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*20*/  __u32 (*cmsld)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsmn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsndx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+        __u32 (*cmspdp)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmspid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+/*25*/  __u32 (*cmspln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmspm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsptr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsqcf)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4);
+        __u32 (*cmsqpm)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4);
+/*30*/  __u32 (*cmsrc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsrt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssrm)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsst)          (struct cpic *cpic, __u32 *a1);
+/*35*/  __u32 (*cmstc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmstpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+        __u32 (*cmeapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3);
+        __u32 (*cmeacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*40*/  __u32 (*cmecs)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmect)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmectx)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeid)  	(struct cpic *cpic, __u32 *a1, __u32 *a2, __u32 *a3);
+        __u32 (*cmemn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*45*/  __u32 (*cmepid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4, __u32 *a5, 
+					__u32 *a6, __u32 *a7);
+        __u32 (*cmepln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmesi)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4);
+        __u32 (*cmesl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmesrm)         (struct cpic *cpic, __u32 *a1);
+/*50*/  __u32 (*cmesui)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmetc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmetpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmallc)         (struct cpic *cpic);
+        __u32 (*cmcanc)         (struct cpic *cpic);
+/*55*/  __u32 (*cmcfmd)         (struct cpic *cpic);
+        __u32 (*cmcfm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmdeal)         (struct cpic *cpic);
+        __u32 (*cmrcv)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+        __u32 (*cmdfde)         (struct cpic *cpic);
+/*60*/  __u32 (*cmacci)         (struct cpic *cpic);
+        __u32 (*cmwait)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsltp)         (__u32 *a1, __u32 *a2);
+        __u32 (*cmflus)         (struct cpic *cpic);
+        __u32 (*cmincl)         (struct cpic *cpic);
+/*65*/  __u32 (*cmprep)         (struct cpic *cpic);
+        __u32 (*cmptr)          (struct cpic *cpic);
+        __u32 (*cmrcvx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+			                __u32 *a3, __u32 *a4, __u32 *a5);
+        __u32 (*cmrts)          (struct cpic *cpic);
+        __u32 (*cmtrts)         (struct cpic *cpic, __u32 *a1);
+/*70*/  __u32 (*cminic)         (struct cpic *cpic);
+};
+
+extern int cpic_query_side_info(char *arg);
+extern int cpic_register_side_info(struct cpic_define_side_info *side);
+extern int cpic_unregister_side_info(struct cpic_delete_side_info *side);
+extern int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int cpic_register(struct cpic_ops *ops);
+extern int cpic_unregister(int family);
+
+#endif  /* __KERNEL__ */
+#endif /* _NET_CPIC_H */
diff -ruN linux-2.4.18-clean/include/net/datalink.h linux/include/net/datalink.h
--- linux-2.4.18-clean/include/net/datalink.h	Wed Aug 18 14:38:47 1999
+++ linux/include/net/datalink.h	Fri Jun  7 04:57:42 2002
@@ -2,15 +2,24 @@
 #define _NET_INET_DATALINK_H_
 
 struct datalink_proto {
-	unsigned short	type_len;
-	unsigned char	type[8];
-	const char	*string_name;
-	unsigned short	header_length;
-	int	(*rcvfunc)(struct sk_buff *, struct net_device *, 
-				struct packet_type *);
-	void	(*datalink_header)(struct datalink_proto *, struct sk_buff *,
-					unsigned char *);
-	struct datalink_proto	*next;
+        unsigned short  type_len;
+        unsigned char   type[8];
+        const char      *string_name;
+
+        union {
+                struct llc_pinfo *llc;
+        } ll_pinfo;
+
+	struct llc_sc_info *llc_sc;
+	struct sock *sock;
+
+        unsigned short  header_length;
+
+        int     (*rcvfunc)(struct sk_buff *, struct net_device *,
+                                struct packet_type *);
+        void    (*datalink_header)(struct datalink_proto *, struct sk_buff *,
+                                        unsigned char *);
+        struct datalink_proto   *next;
 };
 
 #endif
diff -ruN linux-2.4.18-clean/include/net/llc_actn.h linux/include/net/llc_actn.h
--- linux-2.4.18-clean/include/net/llc_actn.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_actn.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,48 @@
+#ifndef LLC_ACTN_H
+#define LLC_ACTN_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Station component state transition actions */
+#define LLC_STATION_AC_START_ACK_TMR		1
+#define LLC_STATION_AC_SET_RETRY_CNT_0		2
+#define LLC_STATION_AC_INCREMENT_RETRY_CNT_BY_1	3
+#define LLC_STATION_AC_SET_XID_R_CNT_0		4
+#define LLC_STATION_AC_INCREMENT_XID_R_CNT_BY_1	5
+#define LLC_STATION_AC_SEND_NULL_DSAP_XID_C	6
+#define LLC_STATION_AC_SEND_XID_R		7
+#define LLC_STATION_AC_SEND_TEST_R		8
+#define LLC_STATION_AC_REPORT_STATUS		9
+
+/* All station state event action functions look like this */
+typedef int (*llc_station_action_t)(struct llc_station *station,
+				    struct llc_station_state_ev *ev);
+extern int llc_station_ac_start_ack_timer(struct llc_station *station,
+					  struct llc_station_state_ev *ev);
+extern int llc_station_ac_set_retry_cnt_0(struct llc_station *station,
+					  struct llc_station_state_ev *ev);
+extern int llc_station_ac_inc_retry_cnt_by_1(struct llc_station *station,
+					     struct llc_station_state_ev *ev);
+extern int llc_station_ac_set_xid_r_cnt_0(struct llc_station *station,
+					  struct llc_station_state_ev *ev);
+extern int llc_station_ac_inc_xid_r_cnt_by_1(struct llc_station *station,
+					     struct llc_station_state_ev *ev);
+extern int llc_station_ac_send_null_dsap_xid_c(struct llc_station *station,
+					   struct llc_station_state_ev *ev);
+extern int llc_station_ac_send_xid_r(struct llc_station *station,
+				 struct llc_station_state_ev *ev);
+extern int llc_station_ac_send_test_r(struct llc_station *station,
+                                  struct llc_station_state_ev *ev);
+extern int llc_station_ac_report_status(struct llc_station *station,
+				    struct llc_station_state_ev *ev);
+extern int llc_station_ac_report_status(struct llc_station *station,
+                                   struct llc_station_state_ev *ev);
+#endif /* LLC_ACTN_H */
diff -ruN linux-2.4.18-clean/include/net/llc_c_ac.h linux/include/net/llc_c_ac.h
--- linux-2.4.18-clean/include/net/llc_c_ac.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_c_ac.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,254 @@
+#ifndef LLC_C_AC_H
+#define LLC_C_AC_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Connection component state transition actions */
+/* 
+ * Connection state transition actions
+ * (Fb = F bit; Pb = P bit; Xb = X bit)
+ */
+#define LLC_CONN_AC_CLEAR_REMOTE_BUSY			 1
+#define LLC_CONN_AC_CONN_IND				 2
+#define LLC_CONN_AC_CONN_CONFIRM			 3
+#define LLC_CONN_AC_DATA_IND				 4
+#define LLC_CONN_AC_DISC_IND				 5
+#define LLC_CONN_AC_RESET_IND				 6
+#define LLC_CONN_AC_RESET_CONFIRM			 7
+#define LLC_CONN_AC_REPORT_STATUS			 8
+#define LLC_CONN_AC_CLEAR_REMOTE_BUSY_IF_Fb_EQ_1	 9
+#define LLC_CONN_AC_STOP_REJ_TMR_IF_DATA_FLAG_EQ_2	10
+#define LLC_CONN_AC_SEND_DISC_CMD_Pb_SET_X		11
+#define LLC_CONN_AC_SEND_DM_RSP_Fb_SET_Pb		12
+#define LLC_CONN_AC_SEND_DM_RSP_Fb_SET_1		13
+#define LLC_CONN_AC_SEND_DM_RSP_Fb_SET_F_FLAG		14
+#define LLC_CONN_AC_SEND_FRMR_RSP_Fb_SET_X		15
+#define LLC_CONN_AC_RESEND_FRMR_RSP_Fb_SET_0		16
+#define LLC_CONN_AC_RESEND_FRMR_RSP_Fb_SET_Pb		17
+#define LLC_CONN_AC_SEND_I_CMD_Pb_SET_1			18
+#define LLC_CONN_AC_RESEND_I_CMD_Pb_SET_1		19
+#define LLC_CONN_AC_RESEND_I_CMD_Pb_SET_1_OR_SEND_RR	20
+#define LLC_CONN_AC_SEND_I_XXX_Xb_SET_0			21
+#define LLC_CONN_AC_RESEND_I_XXX_Xb_SET_0		22
+#define LLC_CONN_AC_RESEND_I_XXX_Xb_SET_0_OR_SEND_RR	23
+#define LLC_CONN_AC_RESEND_I_RSP_Fb_SET_1		24
+#define LLC_CONN_AC_SEND_REJ_CMD_Pb_SET_1		25
+#define LLC_CONN_AC_SEND_REJ_RSP_Fb_SET_1		26
+#define LLC_CONN_AC_SEND_REJ_XXX_Xb_SET_0		27
+#define LLC_CONN_AC_SEND_RNR_CMD_Pb_SET_1		28
+#define LLC_CONN_AC_SEND_RNR_RSP_Fb_SET_1		29
+#define LLC_CONN_AC_SEND_RNR_XXX_Xb_SET_0		30
+#define LLC_CONN_AC_SET_REMOTE_BUSY			31
+#define LLC_CONN_AC_OPTIONAL_SEND_RNR_XXX_Xb_SET_0	32
+#define LLC_CONN_AC_SEND_RR_CMD_Pb_SET_1		33
+#define LLC_CONN_AC_SEND_ACK_CMD_Pb_SET_1		34
+#define LLC_CONN_AC_SEND_RR_RSP_Fb_SET_1		35
+#define LLC_CONN_AC_SEND_ACK_RSP_Fb_SET_1		36
+#define LLC_CONN_AC_SEND_RR_XXX_Xb_SET_0		37
+#define LLC_CONN_AC_SEND_ACK_XXX_Xb_SET_0		38
+#define LLC_CONN_AC_SEND_SABME_CMD_Pb_SET_X		39
+#define LLC_CONN_AC_SEND_UA_RSP_Fb_SET_Pb		40
+#define LLC_CONN_AC_SEND_UA_RSP_Fb_SET_F_FLAG		41
+#define LLC_CONN_AC_S_FLAG_SET_0			42
+#define LLC_CONN_AC_S_FLAG_SET_1			43
+#define LLC_CONN_AC_START_P_TMR				44
+#define LLC_CONN_AC_START_ACK_TMR			45
+#define LLC_CONN_AC_START_REJ_TMR			46
+#define LLC_CONN_AC_START_ACK_TMR_IF_NOT_RUNNING	47
+#define LLC_CONN_AC_STOP_ACK_TMR			48
+#define LLC_CONN_AC_STOP_P_TMR				49
+#define LLC_CONN_AC_STOP_REJ_TMR			50
+#define LLC_CONN_AC_STOP_ALL_TMRS			51
+#define LLC_CONN_AC_STOP_OTHER_TMRS			52
+#define LLC_CONN_AC_UPDATE_Nr_RECEIVED			53
+#define LLC_CONN_AC_UPDATE_P_FLAG			54
+#define LLC_CONN_AC_DATA_FLAG_SET_2			55
+#define LLC_CONN_AC_DATA_FLAG_SET_0			56
+#define LLC_CONN_AC_DATA_FLAG_SET_1			57
+#define LLC_CONN_AC_DATA_FLAG_SET_1_IF_DATA_FLAG_EQ_0	58
+#define LLC_CONN_AC_P_FLAG_SET_0			59
+#define LLC_CONN_AC_P_FLAG_SET_P			60
+#define LLC_CONN_AC_REMOTE_BUSY_SET_0			61
+#define LLC_CONN_AC_RETRY_CNT_SET_0			62
+#define LLC_CONN_AC_RETRY_CNT_INCREMENT_BY_1		63
+#define LLC_CONN_AC_Vr_SET_0				64
+#define LLC_CONN_AC_Vr_INCREMENT_BY_1			65
+#define LLC_CONN_AC_Vs_SET_0				66
+#define LLC_CONN_AC_Vs_SET_Nr				67
+#define LLC_CONN_AC_F_FLAG_SET_P			68
+#define LLC_CONN_AC_STOP_SENDACK_TMR			70
+#define LLC_CONN_AC_START_SENDACK_TMR_IF_NOT_RUNNING	71
+
+typedef int (*llc_conn_action_t)(struct sock *sk, struct llc_conn_state_ev *ev);
+
+extern int llc_conn_ac_clear_remote_busy(struct sock *sk,
+					 struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_conn_ind(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_conn_confirm(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_data_ind(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_disc_ind(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_rst_ind(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_rst_confirm(struct sock* sk,
+				     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_report_status(struct sock* sk,
+				     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_clear_remote_busy_if_f_eq_1(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_disc_cmd_p_set_x(struct sock* sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_dm_rsp_f_set_p(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_dm_rsp_f_set_1(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_dm_rsp_f_set_f_flag(struct sock* sk,
+						struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_frmr_rsp_f_set_x(struct sock* sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_frmr_rsp_f_set_0(struct sock* sk,
+					       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_frmr_rsp_f_set_p(struct sock* sk,
+					       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_cmd_p_set_1(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_cmd_p_set_0(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_i_cmd_p_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_i_cmd_p_set_1_or_send_rr(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_xxx_x_set_0(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_i_xxx_x_set_0(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_i_xxx_x_set_0_or_send_rr(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_resend_i_rsp_f_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rej_cmd_p_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rej_rsp_f_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rej_xxx_x_set_0(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rnr_cmd_p_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rnr_rsp_f_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rnr_xxx_x_set_0(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_remote_busy(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_opt_send_rnr_xxx_x_set_0(struct sock* sk,
+						struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rr_cmd_p_set_1(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_ack_cmd_p_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rr_rsp_f_set_1(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_ack_rsp_f_set_1(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rr_xxx_x_set_0(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_ack_xxx_x_set_0(struct sock* sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_sabme_cmd_p_set_x(struct sock* sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_ua_rsp_f_set_f_flag(struct sock* sk,
+						struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_ua_rsp_f_set_p(struct sock* sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_s_flag_0(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_s_flag_1(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_start_p_timer(struct sock* sk,
+				     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_start_ack_timer(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_start_rej_timer(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_start_ack_tmr_if_not_running(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_ack_timer(struct sock* sk,
+				      struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_p_timer(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_rej_timer(struct sock* sk,
+				      struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_all_timers(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_stop_other_timers(struct sock* sk,
+					 struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_upd_nr_received(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_inc_tx_win_size(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_dec_tx_win_size(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_upd_p_flag(struct sock* sk,
+				     struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_data_flag_2(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_data_flag_0(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_data_flag_1(struct sock* sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_data_flag_1_if_data_flag_eq_0(struct sock* sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_p_flag_0(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_p_flag_1(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_remote_busy_0(struct sock* sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_retry_cnt_0(struct sock* sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_cause_flag_0(struct sock* sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_cause_flag_1(struct sock* sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_inc_retry_cnt_by_1(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_vr_0(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_inc_vr_by_1(struct sock* sk,
+				   struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_vs_0(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_vs_nr(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_rst_vs(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_upd_vs(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_set_f_flag_p(struct sock* sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_disc(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_reset(struct sock* sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_disc_confirm(struct sock* sk, struct llc_conn_state_ev *ev);
+extern u8 llc_circular_between(u8 a, u8 b, u8 c);
+extern int llc_conn_ac_send_ack_if_needed(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_inc_npta_value(struct sock* sk,
+				      struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_adjust_npta_by_rr(struct sock* sk,
+					 struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_adjust_npta_by_rnr(struct sock* sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_rst_sendack_flag(struct sock* sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_rr_rsp_f_set_ackpf(struct sock* sk,
+					       struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_rsp_f_set_ackpf(struct sock* sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_rsp_as_ack(struct sock* sk,
+					 struct llc_conn_state_ev *ev);
+extern int llc_conn_ac_send_i_as_ack(struct sock* sk,
+				     struct llc_conn_state_ev *ev);
+#endif /* LLC_C_AC_H */
diff -ruN linux-2.4.18-clean/include/net/llc_c_ev.h linux/include/net/llc_c_ev.h
--- linux-2.4.18-clean/include/net/llc_c_ev.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_c_ev.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,323 @@
+#ifndef LLC_C_EV_H
+#define LLC_C_EV_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Connection component state transition event qualifiers */
+/* Types of events (possible values in 'ev->type') */
+#define LLC_CONN_EV_TYPE_SIMPLE		 1
+#define LLC_CONN_EV_TYPE_CONDITION	 2
+#define LLC_CONN_EV_TYPE_PRIM		 3
+#define LLC_CONN_EV_TYPE_PDU		 4           /* command/response PDU */
+#define LLC_CONN_EV_TYPE_ACK_TMR	 5
+#define LLC_CONN_EV_TYPE_P_TMR		 6
+#define LLC_CONN_EV_TYPE_REJ_TMR	 7
+#define LLC_CONN_EV_TYPE_BUSY_TMR	 8
+#define LLC_CONN_EV_TYPE_RPT_STATUS	 9
+#define LLC_CONN_EV_TYPE_SENDACK_TMR	10
+
+#define NBR_CONN_EV		   5
+/* Connection events which cause state transitions when fully qualified */
+
+#define LLC_CONN_EV_CONN_REQ				 1
+#define LLC_CONN_EV_CONN_RESP				 2
+#define LLC_CONN_EV_DATA_REQ				 3
+#define LLC_CONN_EV_DISC_REQ				 4
+#define LLC_CONN_EV_RESET_REQ				 5
+#define LLC_CONN_EV_RESET_RESP				 6
+#define LLC_CONN_EV_LOCAL_BUSY_DETECTED			 7
+#define LLC_CONN_EV_LOCAL_BUSY_CLEARED			 8
+#define LLC_CONN_EV_RX_BAD_PDU				 9
+#define LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X		10
+#define LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X		11
+#define LLC_CONN_EV_RX_FRMR_RSP_Fbit_SET_X		12
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_X			13
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_X_UNEXPD_Ns	14
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_X_INVAL_Ns	15
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_X			16
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_X_UNEXPD_Ns	17
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_X_INVAL_Ns	18
+#define LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_X		19
+#define LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_X		20
+#define LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_X		21
+#define LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_X		22
+#define LLC_CONN_EV_RX_RR_CMD_Pbit_SET_X		23
+#define LLC_CONN_EV_RX_RR_RSP_Fbit_SET_X		24
+#define LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X		25
+#define LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X		26
+#define LLC_CONN_EV_RX_XXX_CMD_Pbit_SET_X		27
+#define LLC_CONN_EV_RX_XXX_RSP_Fbit_SET_X		28
+#define LLC_CONN_EV_RX_XXX_YYY				29
+#define LLC_CONN_EV_RX_ZZZ_CMD_Pbit_SET_X_INVAL_Nr	30
+#define LLC_CONN_EV_RX_ZZZ_RSP_Fbit_SET_X_INVAL_Nr	31
+#define LLC_CONN_EV_P_TMR_EXP				32
+#define LLC_CONN_EV_ACK_TMR_EXP				33
+#define LLC_CONN_EV_REJ_TMR_EXP				34
+#define LLC_CONN_EV_BUSY_TMR_EXP			35
+#define LLC_CONN_EV_RX_XXX_CMD_Pbit_SET_1		36
+#define LLC_CONN_EV_RX_XXX_CMD_Pbit_SET_0		37
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns	38
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns	39
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns	40
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns	41
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_0			42
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_0			43
+#define LLC_CONN_EV_RX_I_CMD_Pbit_SET_1			44
+#define LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0		45
+#define LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0		46
+#define LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1		47
+#define LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1		48
+#define LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0		49
+#define LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0		50
+#define LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1		51
+#define LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1		52
+#define LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0		53
+#define LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0		54
+#define LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1		55
+#define LLC_CONN_EV_RX_I_RSP_Fbit_SET_1			56
+#define LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_1		57
+#define LLC_CONN_EV_RX_XXX_RSP_Fbit_SET_1		58
+#define LLC_CONN_EV_TX_BUFF_FULL			59
+
+#define LLC_CONN_EV_INIT_P_F_CYCLE                     100
+/*
+ * Connection event qualifiers; for some events a certain combination of
+ * these qualifiers must be TRUE before event recognized valid for state;
+ * these constants act as indexes into the Event Qualifier function
+ * table
+ */
+#define LLC_CONN_EV_QFY_DATA_FLAG_EQ_1		 1
+#define LLC_CONN_EV_QFY_DATA_FLAG_EQ_0		 2
+#define LLC_CONN_EV_QFY_DATA_FLAG_EQ_2		 3
+#define LLC_CONN_EV_QFY_P_FLAG_EQ_1		 4
+#define LLC_CONN_EV_QFY_P_FLAG_EQ_0		 5
+#define LLC_CONN_EV_QFY_P_FLAG_EQ_Fbit		 6
+#define LLC_CONN_EV_QFY_REMOTE_BUSY_EQ_0	 7
+#define LLC_CONN_EV_QFY_RETRY_CNT_LT_N2		 8
+#define LLC_CONN_EV_QFY_RETRY_CNT_GTE_N2	 9
+#define LLC_CONN_EV_QFY_S_FLAG_EQ_1		10
+#define LLC_CONN_EV_QFY_S_FLAG_EQ_0		11
+#define LLC_CONN_EV_QFY_INIT_P_F_CYCLE		12
+
+/* Event data interface; what is sent in an event package */
+/* Event LLC_CONN_EV_TYPE_SIMPLE interface */
+struct llc_conn_ev_simple_if {
+	u8 ev;
+};
+
+/* Event LLC_CONN_EV_TYPE_PRIM interface */
+struct llc_conn_ev_prim_if {
+	u8			  prim;  /* connect, disconnect, reset, ... */
+	u8			  type;  /* request, indicate, response, conf */
+	struct llc_prim_if_block *data;
+};
+
+/* Event LLC_CONN_EV_TYPE_PDU interface */
+struct llc_conn_ev_pdu_if {
+	u8		ev;
+	u8		reason;
+	struct sk_buff *skb;
+};
+
+/* Event interface for timer-generated events */
+struct llc_conn_ev_tmr_if {
+	struct sock *sk;
+	u32          component_handle;
+	void	    *timer_specific;
+};
+
+struct llc_conn_ev_rpt_sts_if {
+	u8 status;
+};
+
+union llc_conn_ev_if {
+	struct llc_conn_ev_simple_if  a;	/* 'a' for simple, easy ... */
+	struct llc_conn_ev_prim_if    prim;
+	struct llc_conn_ev_pdu_if     pdu;
+	struct llc_conn_ev_tmr_if     tmr;
+	struct llc_conn_ev_rpt_sts_if rsts;	/* report status */
+};
+
+struct llc_conn_state_ev {
+	u8			  type;
+	u8			  status;
+	u8			  flag;
+	struct llc_prim_if_block *ind_prim;
+	struct llc_prim_if_block *cfm_prim;
+	union llc_conn_ev_if	  data;
+};
+
+typedef int (*llc_conn_ev_t)(struct sock *sk, struct llc_conn_state_ev *ev);
+typedef int (*llc_conn_ev_qfyr_t)(struct sock *sk,
+				  struct llc_conn_state_ev *ev);
+
+extern int llc_conn_ev_conn_req(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_conn_resp(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_data_req(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_disc_req(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rst_req(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rst_resp(struct sock *sk, struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_local_busy_detected(struct sock *sk,
+				       struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_local_busy_cleared(struct sock *sk,
+					  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_bad_pdu(struct sock *sk,
+				  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_disc_cmd_pbit_set_x(struct sock *sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_dm_rsp_fbit_set_x(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_frmr_rsp_fbit_set_x(struct sock *sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_cmd_pbit_set_x_inval_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_x(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_x_inval_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rej_rsp_fbit_set_x(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_sabme_cmd_pbit_set_x(struct sock *sk,
+					       struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_ua_rsp_fbit_set_x(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_xxx_cmd_pbit_set_x(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_xxx_rsp_fbit_set_x(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_xxx_yyy(struct sock *sk,
+				  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_p_tmr_exp(struct sock *sk,
+				   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_ack_tmr_exp(struct sock *sk,
+				   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rej_tmr_exp(struct sock *sk,
+				   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_busy_tmr_exp(struct sock *sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_any_tmr_exp(struct sock *sk,
+				   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_sendack_tmr_exp(struct sock *sk,
+				       struct llc_conn_state_ev *ev);
+/* NOT_USED functions and their variations */
+extern int llc_conn_ev_rx_xxx_cmd_pbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_xxx_cmd_pbit_set_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_xxx_rsp_fbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_cmd_pbit_set_0(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_cmd_pbit_set_1(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_0(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_i_rsp_fbit_set_1(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rr_cmd_pbit_set_0(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rr_cmd_pbit_set_1(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rr_rsp_fbit_set_0(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rr_rsp_fbit_set_1(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rnr_cmd_pbit_set_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rnr_cmd_pbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rnr_rsp_fbit_set_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rnr_rsp_fbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rej_cmd_pbit_set_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rej_cmd_pbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rej_rsp_fbit_set_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_rej_rsp_fbit_set_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_rx_any_frame(struct sock *sk,
+				    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_tx_buffer_full(struct sock *sk,
+				      struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_init_p_f_cycle(struct sock *sk,
+				      struct llc_conn_state_ev *ev);
+
+/* Available connection action qualifiers */
+extern int llc_conn_ev_qlfy_data_flag_eq_1(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_data_flag_eq_0(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_data_flag_eq_2(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_p_flag_eq_1(struct sock *sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_last_frame_eq_1(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_last_frame_eq_0(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_p_flag_eq_0(struct sock *sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_p_flag_eq_f(struct sock *sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_remote_busy_eq_0(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_remote_busy_eq_1(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_retry_cnt_lt_n2(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_retry_cnt_gte_n2(struct sock *sk,
+					     struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_s_flag_eq_1(struct sock *sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_s_flag_eq_0(struct sock *sk,
+					struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_cause_flag_eq_1(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_cause_flag_eq_0(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_init_p_f_cycle(struct sock *sk,
+					   struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_conn(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_disc(struct sock *sk,
+					    struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_failed(struct sock *sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_impossible(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_remote_busy(struct sock *sk,
+						  struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_received(struct sock *sk,
+						struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_refuse(struct sock *sk,
+					      struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_conflict(struct sock *sk,
+						struct llc_conn_state_ev *ev);
+extern int llc_conn_ev_qlfy_set_status_rst_done(struct sock *sk,
+						struct llc_conn_state_ev *ev);
+#endif /* LLC_C_EV_H */
diff -ruN linux-2.4.18-clean/include/net/llc_c_st.h linux/include/net/llc_c_st.h
--- linux-2.4.18-clean/include/net/llc_c_st.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_c_st.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,48 @@
+#ifndef LLC_C_ST_H
+#define LLC_C_ST_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Connection component state management */
+/* connection states */
+#define LLC_CONN_OUT_OF_SVC            0       /* prior to allocation */
+
+#define LLC_CONN_STATE_ADM             1       /* disconnected, initial state */
+#define LLC_CONN_STATE_SETUP           2       /* disconnected state */
+#define LLC_CONN_STATE_NORMAL          3       /* connected state */
+#define LLC_CONN_STATE_BUSY            4       /* connected state */
+#define LLC_CONN_STATE_REJECT          5       /* connected state */
+#define LLC_CONN_STATE_AWAIT           6       /* connected state */
+#define LLC_CONN_STATE_AWAIT_BUSY      7       /* connected state */
+#define LLC_CONN_STATE_AWAIT_REJECT    8       /* connected state */
+#define LLC_CONN_STATE_D_CONN          9       /* disconnected state */
+#define LLC_CONN_STATE_RESET           10      /* disconnected state */
+#define LLC_CONN_STATE_ERROR           11      /* disconnected state */
+#define LLC_CONN_STATE_TEMP            12      /* disconnected state */
+
+#define NBR_CONN_STATES            12      /* size of state table */
+#define NO_STATE_CHANGE            100      
+
+/* Connection state table structure */
+struct llc_conn_state_trans {
+   llc_conn_ev_t       ev;
+   u8                  next_state;
+   llc_conn_ev_qfyr_t *ev_qualifiers;
+   llc_conn_action_t  *ev_actions;
+};
+
+struct llc_conn_state {
+   u8 current_state;
+   struct llc_conn_state_trans **transitions;
+};
+
+extern struct llc_conn_state llc_conn_state_table[];
+#endif /* LLC_C_ST_H */
diff -ruN linux-2.4.18-clean/include/net/llc_conn.h linux/include/net/llc_conn.h
--- linux-2.4.18-clean/include/net/llc_conn.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_conn.h	Sat Jun  8 08:00:35 2002
@@ -0,0 +1,157 @@
+#ifndef LLC_CONN_H
+#define LLC_CONN_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/timer.h>
+#include <net/llc_if.h>
+
+#define DEBUG_LLC_CONN_ALLOC
+
+struct llc_timer {
+	struct timer_list timer;
+	u8                running;	/* timer is running or no */
+	u16               expire;	/* timer expire time */
+};
+
+struct llc_opt {
+	struct list_head    node;		/* entry in sap->sk_list.list */
+	u8		    state;		/* state of connection */
+	struct llc_sap	   *sap;		/* pointer to parent SAP */
+	struct llc_addr	    laddr;		/* lsap/mac pair */
+	struct llc_addr	    daddr;		/* dsap/mac pair */
+	struct net_device  *dev;		/* device to send to remote */
+	u8                  retry_count;	/* number of retries */
+	u8		    ack_must_be_send;
+	u8		    first_pdu_Ns;
+	u8		    npta;   
+	struct llc_timer    ack_timer;
+	struct llc_timer    pf_cycle_timer;     
+	struct llc_timer    rej_sent_timer;
+	struct llc_timer    busy_state_timer;	/* ind busy clr at remote LLC */
+	u8                  vS;			/* seq# next in-seq I-PDU tx'd*/
+	u8		    vR;			/* seq# next in-seq I-PDU rx'd*/
+	u32		    n2;			/* max nbr re-tx's for timeout*/
+	u32		    n1;			/* max nbr octets in I PDU */
+	u8		    k;			/* tx window size; max = 127 */
+	u8		    rw;			/* rx window size; max = 127 */
+	u8		    p_flag;		/* state flags */
+	u8		    f_flag;
+	u8		    s_flag;
+	u8		    data_flag;
+	u8		    remote_busy_flag;
+	u8		    cause_flag;
+	struct sk_buff_head pdu_unack_q;	/* PUDs sent/waiting ack */
+	u16		    link;		/* network layer link number */
+	u8		    X;			/* a temporary variable */
+	u8		    ack_pf;		/* this flag indicates what is
+						   the P-bit of acknowledge */
+	u8		    failed_data_req; /* recognize that already exist a
+					        failed data_conn_req
+					        (tx_buffer_full or unacceptable
+					        state */
+	u8		    dec_step;
+	u8		    inc_cntr;
+	u8		    dec_cntr;
+	u8		    connect_step;
+	u8		    last_nr;	   /* NR of last pdu recieved */
+	u32		    rx_pdu_hdr;	   /* used for saving header of last pdu
+					      received and caused sending FRMR.
+					      Used for resending FRMR */
+#ifdef DEBUG_LLC_CONN_ALLOC
+	char *f_alloc,	/* function that allocated this connection */
+	     *f_free;	/* function that freed this connection */
+	int l_alloc,	/* line that allocated this connection */
+	    l_free;	/* line that freed this connection */
+#endif
+};
+
+#define LLC_SK(sk) (&sk->protinfo.core_llc)
+
+#define sock_list_entry(ptr,type,entry) ((struct sock *)(((char *) \
+					 list_entry(ptr, type, entry)) - \
+					 offsetof(struct sock, protinfo)))
+
+struct llc_conn_state_ev;
+
+extern struct sock *__llc_sock_alloc(void);
+extern void __llc_sock_free(struct sock *sk, u8 free);
+
+#ifdef DEBUG_LLC_CONN_ALLOC
+#define dump_stack() printk(KERN_INFO "call trace: %p, %p, %p\n",	\
+				__builtin_return_address(0),		\
+				__builtin_return_address(1),		\
+				__builtin_return_address(2));
+#define llc_sock_alloc()	({					\
+	struct sock *__sk = __llc_sock_alloc();				\
+	if (__sk) {							\
+		LLC_SK(__sk)->f_alloc = __FUNCTION__;			\
+		LLC_SK(__sk)->l_alloc = __LINE__;			\
+	}								\
+	__sk;})
+#define __llc_sock_assert(__sk)						\
+	if (LLC_SK(__sk)->f_free) {					\
+		printk(KERN_ERR						\
+		       "%p conn (alloc'd @ %s(%d)) "			\
+		       "already freed @ %s(%d) "			\
+		       "being used again @ %s(%d)\n",			\
+		       LLC_SK(__sk),					\
+		       LLC_SK(__sk)->f_alloc, LLC_SK(__sk)->l_alloc,	\
+		       LLC_SK(__sk)->f_free, LLC_SK(__sk)->l_free,	\
+		       __FUNCTION__, __LINE__);				\
+		dump_stack();
+#define llc_sock_free(__sk)						\
+{									\
+	__llc_sock_assert(__sk)						\
+	} else {							\
+		__llc_sock_free(__sk, 0);				\
+		LLC_SK(__sk)->f_free = __FUNCTION__;			\
+		LLC_SK(__sk)->l_free = __LINE__;			\
+	}								\
+}
+#define llc_sock_assert(__sk)						\
+{									\
+	__llc_sock_assert(__sk);					\
+	return; }							\
+}
+#define llc_sock_assert_ret(__sk, __ret)				\
+{									\
+	__llc_sock_assert(__sk);					\
+	return __ret; }							\
+}
+#else /* DEBUG_LLC_CONN_ALLOC */
+#define llc_sock_alloc() __llc_sock_alloc()
+#define llc_sock_free(__sk) __llc_sock_free(__sk, 1)
+#define llc_sock_assert(__sk)
+#define llc_sock_assert_ret(__sk)
+#endif /* DEBUG_LLC_CONN_ALLOC */
+
+extern void llc_sock_reset(struct sock *sk);
+extern void llc_sock_init(struct sock *sk);
+
+/* Access to a connection */
+extern struct llc_conn_state_ev *llc_conn_alloc_ev(struct sock *sk);
+extern int llc_conn_send_ev(struct sock *sk, struct llc_conn_state_ev *ev);
+extern void llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb);
+extern void llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb,
+			     struct llc_conn_state_ev *ev);
+extern void llc_conn_free_ev(struct llc_conn_state_ev *ev);
+extern void llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr,
+					 u8 first_p_bit);
+extern void llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr,
+					 u8 first_f_bit);
+extern int llc_conn_remove_acked_pdus(struct sock *conn, u8 nr,
+				      u16 *how_many_unacked);
+extern struct sock *llc_find_conn(struct llc_sap *sap,
+				  struct llc_addr *remote_addr,
+				  struct llc_addr *local_addr);
+extern u8 llc_data_accept_state(u8 state); 
+extern void llc_build_offset_table(void);
+#endif /* LLC_CONN_H */
diff -ruN linux-2.4.18-clean/include/net/llc_evnt.h linux/include/net/llc_evnt.h
--- linux-2.4.18-clean/include/net/llc_evnt.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_evnt.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,93 @@
+#ifndef LLC_EVNT_H
+#define LLC_EVNT_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Station component state transition events */
+/* Types of events (possible values in 'ev->type') */
+#define LLC_STATION_EV_TYPE_SIMPLE	1
+#define LLC_STATION_EV_TYPE_CONDITION	2
+#define LLC_STATION_EV_TYPE_PRIM	3
+#define LLC_STATION_EV_TYPE_PDU		4       /* command/response PDU */
+#define LLC_STATION_EV_TYPE_ACK_TMR	5
+#define LLC_STATION_EV_TYPE_RPT_STATUS	6
+
+/* Events */
+#define LLC_STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK		1
+#define LLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK		2
+#define LLC_STATION_EV_ACK_TMR_EXP_LT_RETRY_CNT_MAX_RETRY	3
+#define LLC_STATION_EV_ACK_TMR_EXP_EQ_RETRY_CNT_MAX_RETRY	4
+#define LLC_STATION_EV_RX_NULL_DSAP_XID_C			5
+#define LLC_STATION_EV_RX_NULL_DSAP_0_XID_R_XID_R_CNT_EQ	6
+#define LLC_STATION_EV_RX_NULL_DSAP_1_XID_R_XID_R_CNT_EQ	7
+#define LLC_STATION_EV_RX_NULL_DSAP_TEST_C			8
+#define LLC_STATION_EV_DISABLE_REQ				9
+
+/* Interfaces for various types of supported events */
+struct llc_stat_ev_simple_if {
+	u8 ev;
+};
+
+struct llc_stat_ev_prim_if {
+	u8 prim; /* connect, disconnect, reset, ... */
+	u8 type; /* request, indicate, response, confirm */
+};
+
+struct llc_stat_ev_pdu_if {
+	u8 reason;
+	struct sk_buff *skb;
+};
+
+struct llc_stat_ev_tmr_if {
+	void *timer_specific;
+};
+
+struct llc_stat_ev_rpt_sts_if {
+	u8 status;
+};
+
+union llc_stat_ev_if {
+	struct llc_stat_ev_simple_if  a;	/* 'a' for simple, easy ... */
+	struct llc_stat_ev_prim_if    prim;
+	struct llc_stat_ev_pdu_if     pdu;
+	struct llc_stat_ev_tmr_if   tmr;
+	struct llc_stat_ev_rpt_sts_if rsts;	/* report status */
+};
+
+struct llc_station_state_ev {
+	u8			type;
+	union llc_stat_ev_if data;
+	struct list_head	node; /* node in station->ev_q.list */
+};
+
+typedef int (*llc_station_ev_t)(struct llc_station *station,
+				struct llc_station_state_ev *ev);
+
+extern int llc_stat_ev_enable_with_dup_addr_check(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_enable_without_dup_addr_check(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_ack_tmr_exp_lt_retry_cnt_max_retry(struct llc_station *
+									station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_ack_tmr_exp_eq_retry_cnt_max_retry(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_rx_null_dsap_xid_c(struct llc_station *station,
+					  struct llc_station_state_ev *ev);
+extern int llc_stat_ev_rx_null_dsap_0_xid_r_xid_r_cnt_eq(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_rx_null_dsap_1_xid_r_xid_r_cnt_eq(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+extern int llc_stat_ev_rx_null_dsap_test_c(struct llc_station *station,
+					   struct llc_station_state_ev *ev);
+extern int llc_stat_ev_disable_req(struct llc_station *station,
+				       struct llc_station_state_ev *ev);
+#endif /* LLC_EVNT_H */
diff -ruN linux-2.4.18-clean/include/net/llc_if.h linux/include/net/llc_if.h
--- linux-2.4.18-clean/include/net/llc_if.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_if.h	Sat Jun  8 07:58:40 2002
@@ -0,0 +1,153 @@
+#ifndef LLC_IF_H
+#define LLC_IF_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Defines LLC interface to network layer */
+/* Available primitives */
+#define LLC_DATAUNIT_PRIM	0
+#define LLC_CONN_PRIM		1
+#define LLC_DATA_PRIM           2
+#define LLC_DISC_PRIM		3
+#define LLC_RESET_PRIM          4
+#define LLC_FLOWCONTROL_PRIM    5
+#define LLC_DISABLE_PRIM        6
+#define LLC_XID_PRIM            7
+#define LLC_TEST_PRIM           8
+#define LLC_SAP_ACTIVATION      9
+#define LLC_SAP_DEACTIVATION   10
+
+#define LLC_NBR_PRIMITIVES     11
+
+#define LLC_IND		1
+#define LLC_CONFIRM	2
+ 
+/* Primitive type */
+#define LLC_PRIM_TYPE_REQ	1
+#define LLC_PRIM_TYPE_IND	2
+#define LLC_PRIM_TYPE_RESP	3
+#define LLC_PRIM_TYPE_CONFIRM	4
+
+/* Reset reasons, remote entity or local LLC */
+#define LLC_RESET_REASON_REMOTE        1
+#define LLC_RESET_REASON_LOCAL         2
+
+/* Disconnect reasons */
+#define LLC_DISC_REASON_RX_DM_RSP_PDU	0
+#define LLC_DISC_REASON_RX_DISC_CMD_PDU	1
+#define LLC_DISC_REASON_ACK_TMR_EXP	2
+ 
+/* Confirm reasons */
+#define LLC_STATUS_CONN		0 /* connect confirm & reset confirm */
+#define LLC_STATUS_DISC		1 /* connect confirm & reset confirm */
+#define LLC_STATUS_FAILED	2 /* connect confirm & reset confirm */	
+#define LLC_STATUS_IMPOSSIBLE	3 /* connect confirm */
+#define LLC_STATUS_RECEIVED	4 /* data conn */
+#define LLC_STATUS_REMOTE_BUSY	5 /* data conn */
+#define LLC_STATUS_REFUSE	6 /* data conn */
+#define LLC_STATUS_CONFLICT	7 /* disconnect conn */
+#define LLC_STATUS_RESET_DONE	8 /*  */
+
+/* Structures and types */
+/* SAP/MAC Address pair */
+struct llc_addr {
+	u8 lsap;
+	u8 mac[6];
+};
+
+/* Primitive-specific data */
+struct llc_prim_conn {
+	struct llc_addr	   saddr;	/* used by request only */
+	struct llc_addr	   daddr;	/* used by request only */
+	u8		   status;	/* reason for failure */	
+	u8		   pri;		/* service_class */
+	struct net_device *dev;
+	struct sock	  *sk;		/* returned from REQUEST */
+	u16		   link;
+	struct sk_buff	  *skb;		/* received SABME  */
+};
+
+struct llc_prim_disc {
+	struct sock *sk;
+	u16	     link;
+	u8	     reason;		/* not used by request */
+};
+
+struct llc_prim_reset {
+	struct sock *sk;
+	u16	     link;
+	u8	     reason;		/* used only by indicate */
+};
+
+struct llc_prim_flow_ctrl {
+	struct sock *sk;
+	u16	     link;
+	u32	     amount;
+};
+
+struct llc_prim_data {
+	struct sock    *sk;
+	u16		link;
+	u8		pri;
+	struct sk_buff *skb;	/* pointer to frame */
+	u8	 	status;	/* reason */
+};
+
+ /* Sending data in conection-less mode */
+struct llc_prim_unit_data {
+	struct llc_addr	saddr;
+	struct llc_addr	daddr;
+	u8		pri;
+	struct sk_buff *skb;	/* pointer to frame */
+	u8		lfb;	/* largest frame bit (TR) */
+};
+
+struct llc_prim_xid {
+	struct llc_addr saddr;
+	struct llc_addr daddr;
+	u8		pri;
+	struct sk_buff *skb;
+};
+
+struct llc_prim_test {
+	struct llc_addr	saddr;
+	struct llc_addr	daddr;
+	u8		pri;
+	struct sk_buff *skb;           /* pointer to frame */
+};
+                       
+union llc_u_prim_data {
+	struct llc_prim_conn	  conn;
+	struct llc_prim_disc	  disc;
+	struct llc_prim_reset	  res;
+	struct llc_prim_flow_ctrl fc;
+	struct llc_prim_data	  data;           /* data */
+	struct llc_prim_unit_data udata;          /* unit data */
+	struct llc_prim_xid	  xid;
+	struct llc_prim_test	  test;
+};
+
+struct llc_sap;
+
+/* Information block passed with all called primitives */
+struct llc_prim_if_block {
+	struct llc_sap	      *sap;
+	u8		       prim;
+	u8		       type;
+	union llc_u_prim_data *data;
+};
+typedef int (*llc_prim_call_t)(struct llc_prim_if_block *prim_if);
+
+extern struct llc_sap *llc_sap_open(llc_prim_call_t network_indicate,
+				    llc_prim_call_t network_confirm,
+				    u8 local_sap);
+extern void llc_sap_close(struct llc_sap *sap);
+#endif /* LLC_IF_H */
diff -ruN linux-2.4.18-clean/include/net/llc_mac.h linux/include/net/llc_mac.h
--- linux-2.4.18-clean/include/net/llc_mac.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_mac.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,40 @@
+#ifndef LLC_MAC_H
+#define LLC_MAC_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#define MAC_ADDR_LEN 6
+
+/* 802.3/Ethernet MAC structure */
+typedef struct {
+	u8  da[MAC_ADDR_LEN];	/* destination address */
+	u8  sa[MAC_ADDR_LEN];	/* source address */
+	u16 lpdu_len;		/* length of "information" */
+} ieee_802_3_mac_hdr_t;
+
+/* Token-ring MAC structure */
+typedef struct {
+	u8  ac;			/* access control */
+	u8  fc;			/* frame control */
+	u8  da[MAC_ADDR_LEN];	/* destination address */
+	u8  sa[MAC_ADDR_LEN];	/* source address */
+	u16 rcf;		/* route control field */
+	u16 rseg[8];		/* routing registers */
+} token_ring_mac_hdr_t;
+
+/* Defines MAC-layer interface to LLC layer */
+extern u16 mac_send_pdu(struct sk_buff *skb);
+extern int mac_indicate(struct sk_buff *skb, struct net_device *dev,
+			struct packet_type *pt);
+extern int llc_pdu_router(struct llc_sap *sap, struct sock *sk,
+			  struct sk_buff *skb, u8 type);
+extern u16 lan_hdrs_init(struct sk_buff *skb, u8 *sa, u8 *da);
+#endif /* LLC_MAC_H */
diff -ruN linux-2.4.18-clean/include/net/llc_main.h linux/include/net/llc_main.h
--- linux-2.4.18-clean/include/net/llc_main.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_main.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,69 @@
+#ifndef LLC_MAIN_H
+#define LLC_MAIN_H
+/*
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#define LLC_EVENT		 1
+#define LLC_PACKET		 2
+#define LLC_TYPE_1		 1
+#define LLC_TYPE_2		 2
+#define LLC_P_TIME		 2
+#define LLC_ACK_TIME		 3
+#define LLC_REJ_TIME		 3
+#define LLC_BUSY_TIME		 3
+#define LLC_SENDACK_TIME	50
+#define LLC_DEST_INVALID	 0	/* Invalid LLC PDU type */
+#define LLC_DEST_SAP		 1	/* Type 1 goes here */
+#define LLC_DEST_CONN		 2	/* Type 2 goes here */
+
+/* LLC Layer global default parameters */
+
+#define LLC_GLOBAL_DEFAULT_MAX_NBR_SAPS            4
+#define LLC_GLOBAL_DEFAULT_MAX_NBR_CONNS           64
+
+extern struct llc_prim_if_block llc_ind_prim, llc_cfm_prim;
+
+/* LLC station component (SAP and connection resource manager) */
+/* Station component; one per adapter */
+struct llc_station {
+	u8     state;			/* state of station */
+	u8     xid_r_count;		/* XID response PDU counter */
+	struct timer_list ack_timer;
+	u8     ack_tmr_running;	/* 1 or 0 */
+	u8     retry_count;
+	u8     maximum_retry;
+	u8     mac_sa[6];		/* MAC source address */
+	struct {
+		spinlock_t	 lock;
+		struct list_head list;
+	} sap_list;			/* list of related SAPs */
+	struct {
+		spinlock_t	 lock;
+		struct list_head list;
+	} ev_q;				/* events entering state mach. */
+	struct sk_buff_head mac_pdu_q;	/* PDUs ready to send to MAC */
+};
+struct llc_station_state_ev;
+
+extern struct llc_sap *llc_sap_alloc(void);
+extern void llc_sap_save(struct llc_sap *sap);
+extern void llc_free_sap(struct llc_sap *sap);
+extern struct llc_sap *llc_sap_find(u8 lsap);
+extern u16 llc_check_init(void);
+extern struct llc_station *llc_station_get(void);
+extern struct llc_station_state_ev *
+			     llc_station_alloc_ev(struct llc_station *station);
+extern void llc_station_send_ev(struct llc_station *station,
+				struct llc_station_state_ev *ev);
+extern void llc_station_send_pdu(struct llc_station *station,
+				 struct sk_buff *skb);
+extern struct sk_buff *llc_alloc_frame(void);
+#endif /* LLC_MAIN_H */
diff -ruN linux-2.4.18-clean/include/net/llc_pdu.h linux/include/net/llc_pdu.h
--- linux-2.4.18-clean/include/net/llc_pdu.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_pdu.h	Sat Jun  8 01:55:24 2002
@@ -0,0 +1,258 @@
+#ifndef LLC_PDU_H
+#define LLC_PDU_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* LLC PDU structure */
+/* Lengths of frame formats */
+#define LLC_PDU_LEN_I          4       /* header and 2 control bytes */
+#define LLC_PDU_LEN_S          4
+#define LLC_PDU_LEN_U          3       /* header and 1 control byte */
+/* Known SAP addresses */
+#define GLOBAL_SAP             0xFF
+#define NULL_SAP               0x00        /* not network-layer visible */
+#define LLC_MGMT_INDIV         0x02        /* station LLC mgmt indiv addr */
+#define LLC_MGMT_GRP           0x03        /* station LLC mgmt group addr */
+#define RDE_SAP                0xA6        /* route ... */
+
+/* SAP field bit masks */
+#define ISO_RESERVED_SAP	0x02
+#define SAP_GROUP_DSAP		0x01
+#define SAP_RESP_SSAP		0x01
+
+/* Group/individual DSAP indicator is DSAP field */
+#define LLC_PDU_GROUP_DSAP_MASK    0x01
+#define LLC_PDU_IS_GROUP_DSAP(pdu)      \
+           ((pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+#define LLC_PDU_IS_INDIV_DSAP(pdu)      \
+           (!(pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+
+/* Command/response PDU indicator in SSAP field */
+#define LLC_PDU_CMD_RSP_MASK   0x01
+#define LLC_PDU_CMD            0
+#define LLC_PDU_RSP            1
+#define LLC_PDU_IS_CMD(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 1 : 0)
+#define LLC_PDU_IS_RSP(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 0 : 1)
+
+/* Get PDU type from 2 lowest-order bits of control field first byte */
+#define LLC_PDU_TYPE_I_MASK    0x01        /* 16-bit control field */
+#define LLC_PDU_TYPE_S_MASK    0x03
+#define LLC_PDU_TYPE_U_MASK    0x03        /* 8-bit control field */
+#define LLC_PDU_TYPE_MASK      0x03
+
+#define LLC_PDU_TYPE_I         0           /* first bit */
+#define LLC_PDU_TYPE_S         1           /* first two bits */
+#define LLC_PDU_TYPE_U         3           /* first two bits */
+#define LLC_PDU_TYPE_XID       4	   /* special type for xid pdu_init. */
+	
+#define LLC_PDU_TYPE_IS_I(pdu) \
+           ((!(pdu->ctrl_1 & LLC_PDU_TYPE_I_MASK)) ? 0 : 1)
+
+#define LLC_PDU_TYPE_IS_U(pdu) \
+           (((pdu->ctrl_1 & LLC_PDU_TYPE_U_MASK) == LLC_PDU_TYPE_U) ? 0 : 1)
+
+#define LLC_PDU_TYPE_IS_S(pdu) \
+           (((pdu->ctrl_1 & LLC_PDU_TYPE_S_MASK) == LLC_PDU_TYPE_S) ? 0 : 1)
+
+/* U-format PDU control field masks */
+#define LLC_U_PF_BIT_MASK      0x10        /* P/F bit mask */
+#define LLC_U_PF_IS_1(pdu)     ((pdu->ctrl_1 & LLC_U_PF_BIT_MASK) ? 0 : 1)
+#define LLC_U_PF_IS_0(pdu)     ((!(pdu->ctrl_1 & LLC_U_PF_BIT_MASK)) ? 0 : 1)
+
+#define LLC_U_PDU_CMD_MASK     0xEC        /* cmd/rsp mask */
+#define LLC_U_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+#define LLC_U_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+
+#define LLC_1_PDU_CMD_UI       0x00        /* Type 1 cmds/rsps */
+#define LLC_1_PDU_CMD_XID      0xAC
+#define LLC_1_PDU_CMD_TEST     0xE0
+
+#define LLC_2_PDU_CMD_SABME    0x6C        /* Type 2 cmds/rsps */
+#define LLC_2_PDU_CMD_DISC     0x40
+#define LLC_2_PDU_RSP_UA       0x60
+#define LLC_2_PDU_RSP_DM       0x0C
+#define LLC_2_PDU_RSP_FRMR     0x84
+
+/* Type 1 operations */
+
+/* XID information field bit masks */
+
+/* LLC format identifier (byte 1) */
+#define XID_FMT_ID             0x81        /* first byte must be this */
+
+/* LLC types/classes identifier (byte 2) */
+#define XID_CLASS_ZEROS_MASK   0xE0        /* these must be zeros */
+#define XID_CLASS_MASK         0x1F        /* AND with byte to get below */
+
+#define XID_NULL_CLASS_1       0x01        /* if NULL LSAP...use these */
+#define XID_NULL_CLASS_2       0x03
+#define XID_NULL_CLASS_3       0x05
+#define XID_NULL_CLASS_4       0x07
+
+#define XID_NNULL_TYPE_1       0x01        /* if non-NULL LSAP...use these */
+#define XID_NNULL_TYPE_2       0x02
+#define XID_NNULL_TYPE_3       0x04
+#define XID_NNULL_TYPE_1_2     0x03
+#define XID_NNULL_TYPE_1_3     0x05
+#define XID_NNULL_TYPE_2_3     0x06
+#define XID_NNULL_ALL          0x07
+
+/* Sender Receive Window (byte 3) */
+#define XID_RW_MASK            0xFE        /* AND with value to get below */
+
+#define XID_MIN_RW             0x02        /* lowest-order bit always zero */
+
+/* Type 2 operations */
+
+#define LLC_2_SEQ_NBR_MODULO   ((u8) 128)
+
+/* I-PDU masks ('ctrl' is I-PDU control word) */
+#define LLC_I_GET_NS(pdu)     (u8)((pdu->ctrl_1 & 0xFE) >> 1)
+#define LLC_I_GET_NR(pdu)     (u8)((pdu->ctrl_2 & 0xFE) >> 1)
+
+#define LLC_I_PF_BIT_MASK      0x01
+
+#define LLC_I_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_I_PF_BIT_MASK)) ? 0 : 1)
+#define LLC_I_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_I_PF_BIT_MASK) ? 0 : 1)
+
+/* S-PDU supervisory commands and responses */
+
+#define LLC_S_PDU_CMD_MASK     0x0C
+#define LLC_S_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+#define LLC_S_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+
+#define LLC_2_PDU_CMD_RR       0x00        /* rx ready cmd */
+#define LLC_2_PDU_RSP_RR       0x00        /* rx ready rsp */
+#define LLC_2_PDU_CMD_REJ      0x08        /* reject PDU cmd */
+#define LLC_2_PDU_RSP_REJ      0x08        /* reject PDU rsp */
+#define LLC_2_PDU_CMD_RNR      0x04        /* rx not ready cmd */
+#define LLC_2_PDU_RSP_RNR      0x04        /* rx not ready rsp */
+
+#define LLC_S_PF_BIT_MASK      0x01
+#define LLC_S_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_S_PF_BIT_MASK)) ? 0 : 1)
+#define LLC_S_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_S_PF_BIT_MASK) ? 0 : 1)
+
+#define PDU_SUPV_GET_Nr(pdu)   ((pdu->ctrl_2 & 0xFE) >> 1)
+#define PDU_GET_NEXT_Vr(sn)    (++sn & ~LLC_2_SEQ_NBR_MODULO)
+
+/* FRMR information field macros */
+
+#define FRMR_INFO_LENGTH       5           /* 5 bytes of information */
+
+/* 
+ * info is pointer to FRMR info field structure; 'rej_ctrl' is byte pointer
+ * (if U-PDU) or word pointer to rejected PDU control field
+ */
+#define FRMR_INFO_SET_REJ_CNTRL(info,rej_ctrl) \
+   info->rej_pdu_ctrl = ((*((u8 *) rej_ctrl) & LLC_PDU_TYPE_U) != LLC_PDU_TYPE_U ? \
+                           (u16)*((u16 *) rej_ctrl) : \
+                           (((u16) *((u8 *) rej_ctrl)) & 0x00FF))
+
+/* 
+ * Info is pointer to FRMR info field structure; 'vs' is a byte containing
+ * send state variable value in low-order 7 bits (insure the lowest-order
+ * bit remains zero (0)) 
+ */
+#define FRMR_INFO_SET_Vs(info,vs) (info->curr_ssv = (((u8) vs) << 1))
+#define FRMR_INFO_SET_Vr(info,vr) (info->curr_rsv = (((u8) vr) << 1))
+
+/* 
+ * Info is pointer to FRMR info field structure; 'cr' is a byte containing
+ * the C/R bit value in the low-order bit
+ */
+#define FRMR_INFO_SET_C_R_BIT(info, cr)  (info->curr_rsv |= (((u8) cr) & 0x01))
+
+/* 
+ * In the remaining five macros, 'info' is pointer to FRMR info field
+ * structure; 'ind' is a byte containing the bit value to set in the
+ * lowest-order bit)
+ */
+#define FRMR_INFO_SET_INVALID_PDU_CTRL_IND(info, ind) \
+       (info->ind_bits = ((info->ind_bits & 0xFE) | (((u8) ind) & 0x01)))
+
+#define FRMR_INFO_SET_INVALID_PDU_INFO_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xFD) | \
+                                           (((u8) ind) & 0x02)) )
+
+#define FRMR_INFO_SET_PDU_INFO_2LONG_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xFB) | \
+                                           (((u8) ind) & 0x04)) )
+
+#define FRMR_INFO_SET_PDU_INVALID_Nr_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xF7) | \
+                                           (((u8) ind) & 0x08)) )
+
+#define FRMR_INFO_SET_PDU_INVALID_Ns_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xEF) | \
+                                           (((u8) ind) & 0x10)) )
+
+/* Sequence-numbered PDU format (4 bytes in length) */
+typedef struct {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+	u8 ctrl_2;
+} pdu_sn_t;
+
+/* Un-numbered PDU format (3 bytes in length) */
+typedef struct {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+} pdu_un_t;
+
+/* LLC Type 1 XID command/response information fields format */
+typedef struct {
+	u8 fmt_id;             /* always 0x18 for LLC */
+	u8 type;               /* different if NULL/non-NULL LSAP */
+	u8 rw;                 /* sender receive window */   
+} xid_info_t;
+
+/* LLC Type 2 FRMR response information field format */
+typedef struct {
+	u16 rej_pdu_ctrl;       /* bits 1-8 if U-PDU */
+	u8  curr_ssv;           /* current send state variable val */
+	u8  curr_rsv;           /* current receive state variable */
+	u8  ind_bits;           /* indicator bits set with macro */
+} frmr_info_t;
+
+extern void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
+extern void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);
+extern int llc_pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit);
+extern int llc_pdu_decode_cr_bit(struct sk_buff *skb, u8 *cr_bit);
+extern int llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa);
+extern int llc_pdu_decode_da(struct sk_buff *skb, u8 *ds);
+extern int llc_pdu_decode_dsap(struct sk_buff *skb, u8 *dsap);
+extern int llc_pdu_decode_ssap(struct sk_buff *skb, u8 *ssap);
+extern int llc_decode_pdu_type(struct sk_buff *skb, u8 *destination);
+extern void llc_pdu_header_init(struct sk_buff *skb, u8 pdu_type, u8 ssap,
+				u8 dsap, u8 cr);
+extern int llc_pdu_init_as_ui_cmd(struct sk_buff *skb);
+extern int llc_pdu_init_as_xid_cmd(struct sk_buff *skb, u8 svcs_supported,
+			       u8 rx_window);
+extern int llc_pdu_init_as_test_cmd(struct sk_buff *skb);
+extern int llc_pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit);
+extern int llc_pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr);
+extern int llc_pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern int llc_pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern int llc_pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern int llc_pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit);
+extern int llc_pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit);
+extern int llc_pdu_init_as_xid_rsp(struct sk_buff *skb, u8 svcs_supported,
+				   u8 rx_window);
+extern int llc_pdu_init_as_test_rsp(struct sk_buff *skb);
+extern int llc_pdu_init_as_frmr_rsp(struct sk_buff *skb, pdu_sn_t *prev_pdu,
+				u8 f_bit, u8 vs, u8 vr, u8 vzyxw);
+extern int llc_pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern int llc_pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern int llc_pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern int llc_pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit);
+#endif /* LLC_PDU_H */
diff -ruN linux-2.4.18-clean/include/net/llc_s_ac.h linux/include/net/llc_s_ac.h
--- linux-2.4.18-clean/include/net/llc_s_ac.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_s_ac.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,47 @@
+#ifndef LLC_S_AC_H
+#define LLC_S_AC_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* SAP component actions */
+#define SAP_ACT_UNITDATA_IND	1
+#define SAP_ACT_SEND_UI		2
+#define SAP_ACT_SEND_XID_C	3
+#define SAP_ACT_SEND_XID_R	4
+#define SAP_ACT_SEND_TEST_C	5
+#define SAP_ACT_SEND_TEST_R	6
+#define SAP_ACT_REPORT_STATUS	7
+#define SAP_ACT_XID_IND		8
+#define SAP_ACT_TEST_IND	9
+
+/* All action functions must look like this */
+typedef int (*llc_sap_action_t)(struct llc_sap *sap,
+				struct llc_sap_state_ev *ev);
+
+extern int llc_sap_action_unitdata_ind(struct llc_sap *sap,
+				       struct llc_sap_state_ev *ev);
+extern int llc_sap_action_send_ui(struct llc_sap *sap,
+				  struct llc_sap_state_ev *ev);
+extern int llc_sap_action_send_xid_c(struct llc_sap *sap,
+				     struct llc_sap_state_ev *ev);
+extern int llc_sap_action_send_xid_r(struct llc_sap *sap,
+				     struct llc_sap_state_ev *ev);
+extern int llc_sap_action_send_test_c(struct llc_sap *sap,
+				      struct llc_sap_state_ev *ev);
+extern int llc_sap_action_send_test_r(struct llc_sap *sap,
+				      struct llc_sap_state_ev *ev);
+extern int llc_sap_action_report_status(struct llc_sap *sap,
+					struct llc_sap_state_ev *ev);
+extern int llc_sap_action_xid_ind(struct llc_sap *sap,
+				  struct llc_sap_state_ev *ev);
+extern int llc_sap_action_test_ind(struct llc_sap *sap,
+				   struct llc_sap_state_ev *ev);
+#endif /* LLC_S_AC_H */
diff -ruN linux-2.4.18-clean/include/net/llc_s_ev.h linux/include/net/llc_s_ev.h
--- linux-2.4.18-clean/include/net/llc_s_ev.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_s_ev.h	Sat Jun  8 01:52:37 2002
@@ -0,0 +1,105 @@
+#ifndef LLC_S_EV_H
+#define LLC_S_EV_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Defines SAP component events */
+/* Types of events (possible values in 'ev->type') */
+#define LLC_SAP_EV_TYPE_SIMPLE		1
+#define LLC_SAP_EV_TYPE_CONDITION	2
+#define LLC_SAP_EV_TYPE_PRIM		3
+#define LLC_SAP_EV_TYPE_PDU		4   /* command/response PDU */
+#define LLC_SAP_EV_TYPE_ACK_TMR		5
+#define LLC_SAP_EV_TYPE_RPT_STATUS	6
+
+#define LLC_SAP_EV_ACTIVATION_REQ	 1
+#define LLC_SAP_EV_RX_UI		 2
+#define LLC_SAP_EV_UNITDATA_REQ		 3
+#define LLC_SAP_EV_XID_REQ		 4
+#define LLC_SAP_EV_RX_XID_C		 5
+#define LLC_SAP_EV_RX_XID_R		 6
+#define LLC_SAP_EV_TEST_REQ		 7
+#define LLC_SAP_EV_RX_TEST_C		 8
+#define LLC_SAP_EV_RX_TEST_R		 9
+#define LLC_SAP_EV_DEACTIVATION_REQ	10
+
+/* Interfaces for various types of supported events */
+struct llc_sap_ev_simple_if {
+	u8 ev;
+};
+
+struct llc_prim_if_block;
+
+struct llc_sap_ev_prim_if {
+	u8			  prim; /* connect, disconnect, reset, ... */
+	u8			  type; /* request, indicate, response, conf */
+	struct llc_prim_if_block *data;
+};
+
+struct llc_sap_ev_pdu_if {
+	u8		   ev;
+	u8		   reason;
+	struct sk_buff *skb;
+};
+
+struct llc_sap_ev_tmr_if {
+	void *timer_specific;
+};
+
+struct llc_sap_ev_rpt_sts_if {
+	u8 status;
+};
+
+union llc_sap_ev_if {
+	struct llc_sap_ev_simple_if	a;	/* 'a' for simple, easy ... */
+	struct llc_sap_ev_prim_if	prim;
+	struct llc_sap_ev_pdu_if	pdu;
+	struct llc_sap_ev_tmr_if	tmr;
+	struct llc_sap_ev_rpt_sts_if	rsts;	/* report status */
+};
+
+struct llc_prim_if_block;
+
+struct llc_sap_state_ev {
+	u8			  type;
+	u8			  ind_cfm_flag;
+	struct llc_prim_if_block *prim;
+	union llc_sap_ev_if	  data;
+};
+
+struct llc_sap;
+
+typedef int (*llc_sap_ev_t)(struct llc_sap *sap, struct llc_sap_state_ev *ev);
+
+extern int llc_sap_ev_activation_req(struct llc_sap *sap,
+				     struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_rx_ui(struct llc_sap *sap, struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_unitdata_req(struct llc_sap *sap,
+				   struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_xid_req(struct llc_sap *sap,
+			      struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_xid_rsp(struct llc_sap *sap,
+                              struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_rx_xid_c(struct llc_sap *sap,
+			       struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_rx_xid_r(struct llc_sap *sap,
+			       struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_test_req(struct llc_sap *sap,
+			       struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_test_rsp(struct llc_sap *sap,
+                               struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_rx_test_c(struct llc_sap *sap,
+				struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_rx_test_r(struct llc_sap *sap,
+				struct llc_sap_state_ev *ev);
+extern int llc_sap_ev_deactivation_req(struct llc_sap *sap,
+				       struct llc_sap_state_ev *ev); 
+#endif /* LLC_S_EV_H */
diff -ruN linux-2.4.18-clean/include/net/llc_s_st.h linux/include/net/llc_s_st.h
--- linux-2.4.18-clean/include/net/llc_s_st.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_s_st.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,34 @@
+#ifndef LLC_S_ST_H
+#define LLC_S_ST_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Defines SAP component states */
+
+#define LLC_SAP_STATE_INACTIVE         1
+#define LLC_SAP_STATE_ACTIVE           2
+#define LLC_NBR_SAP_STATES             2       /* size of state table */
+/* structures and types */
+/* SAP state table structure */
+struct llc_sap_state_trans {
+	llc_sap_ev_t	  ev;
+	u8		  next_state;
+	llc_sap_action_t *ev_actions;
+};
+
+struct llc_sap_state {
+    u8				 curr_state;
+    struct llc_sap_state_trans **transitions;
+};
+
+/* only access to SAP state table */
+extern struct llc_sap_state llc_sap_state_table[LLC_NBR_SAP_STATES];
+#endif /* LLC_S_ST_H */
diff -ruN linux-2.4.18-clean/include/net/llc_sap.h linux/include/net/llc_sap.h
--- linux-2.4.18-clean/include/net/llc_sap.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_sap.h	Fri Jun  7 12:55:36 2002
@@ -0,0 +1,42 @@
+#ifndef LLC_SAP_H
+#define LLC_SAP_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/skbuff.h>
+/* Defines the SAP component */
+struct llc_sap {
+	u8		    state;
+	struct llc_station *parent_station;
+	u8		    p_bit;		/* only lowest-order bit used */
+	u8		    f_bit;		/* only lowest-order bit used */
+	llc_prim_call_t	    req;		/* provided by LLC layer */
+	llc_prim_call_t	    resp;		/* provided by LLC layer */
+	llc_prim_call_t	    ind;		/* provided by network layer */
+	llc_prim_call_t	    conf;		/* provided by network layer */
+	struct llc_addr	    laddr;		/* SAP value in this 'lsap' */
+	struct list_head    node;		/* entry in station sap_list */
+	struct {
+		spinlock_t	 lock;
+		struct list_head list;
+	} sk_list; /* LLC sockets this one manages */
+	struct sk_buff_head mac_pdu_q;		/* PDUs ready to send to MAC */
+};
+struct llc_sap_state_ev;
+
+extern void llc_sap_assign_sock(struct llc_sap *sap, struct sock *sk);
+extern void llc_sap_unassign_sock(struct llc_sap *sap, struct sock *sk);
+extern struct llc_sap_state_ev *llc_sap_alloc_ev(struct llc_sap *sap);
+extern int llc_sap_send_ev(struct llc_sap *sap, struct llc_sap_state_ev *ev);
+extern void llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb,
+			    struct llc_sap_state_ev *ev);
+extern void llc_sap_send_pdu(struct llc_sap *sap, struct sk_buff *skb);
+#endif /* LLC_SAP_H */
diff -ruN linux-2.4.18-clean/include/net/llc_stat.h linux/include/net/llc_stat.h
--- linux-2.4.18-clean/include/net/llc_stat.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/llc_stat.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,35 @@
+#ifndef LLC_STAT_H
+#define LLC_STAT_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+/* Station component state table */
+/* Station component states */
+#define LLC_STATION_STATE_DOWN             1	/* initial state */
+#define LLC_STATION_STATE_DUP_ADDR_CHK     2
+#define LLC_STATION_STATE_UP               3
+
+#define LLC_NBR_STATION_STATES             3	/* size of state table */
+
+/* Station component state table structure */
+struct llc_station_state_trans {
+	llc_station_ev_t ev;
+	u8 next_state;
+	llc_station_action_t *ev_actions;
+};
+
+struct llc_station_state {
+	u8 curr_state;
+	struct llc_station_state_trans **transitions;
+};
+
+extern struct llc_station_state llc_station_state_table[LLC_NBR_STATION_STATES];
+#endif /* LLC_STAT_H */
diff -ruN linux-2.4.18-clean/include/net/p8022.h linux/include/net/p8022.h
--- linux-2.4.18-clean/include/net/p8022.h	Wed Aug 18 14:38:47 1999
+++ linux/include/net/p8022.h	Fri Jun  7 04:57:42 2002
@@ -1,7 +1,9 @@
 #ifndef _NET_P8022_H
 #define _NET_P8022_H
-
-extern struct datalink_proto *register_8022_client(unsigned char type, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *));
+extern struct datalink_proto *register_8022_client(unsigned char type,
+						   int (*rcvfunc)
+						   	(struct sk_buff *,
+							 struct net_device *,
+							 struct packet_type *));
 extern void unregister_8022_client(unsigned char type);
-
 #endif
diff -ruN linux-2.4.18-clean/include/net/sna_cbs.h linux/include/net/sna_cbs.h
--- linux-2.4.18-clean/include/net/sna_cbs.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/sna_cbs.h	Sat Jun  8 08:23:22 2002
@@ -0,0 +1,1890 @@
+/* sna_cbs.h: Linux-SNA Control blocks and layer specific declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#ifndef __NET_SNA_CBS_H
+#define __NET_SNA_CBS_H
+
+#ifdef __KERNEL__
+
+#include <linux/netdevice.h>
+
+/* CREATE.
+ */
+
+struct sna_hs_create_parms {
+        __u8 lu_id;
+        __u8 hs_id;
+};
+
+struct sna_ps_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+
+        struct sna_tcb *tcb_list_ptr;
+        __u8 tcb_id;
+
+        struct sna_rcb *rcb_list_ptr;
+};
+
+struct sna_rm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_sm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_rm_created {
+        __u8 lu_id;
+};
+
+/* ASM.
+ */
+
+struct sna_session_id {
+        __u16   sidh:8,
+                sidl:8;
+};
+
+/* Structure size is 17bits */
+struct sna_lfsid {
+        __u8    odai:1;		/* Pri = 0x0, Sec = 0x1 */
+        union {
+                __u16 raw;
+                struct sna_session_id hl;
+        } sid;
+};
+
+struct sna_assign_lfsid {
+	unsigned char 	 pc_id[8];
+	unsigned short	 sm_id;
+        struct sna_lfsid lfsid;
+};
+
+struct sna_free_lfsid {
+	unsigned char	 pc_id[8];
+	unsigned short	 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_linfo{
+	__u8		 active:1;	/* 1 = active, 0 = inactive */ 
+	__u16		 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_lfsid_block {
+	struct list_head list;
+
+	struct sna_linfo l[256];
+};
+
+/* one for each PC */
+struct sna_asm_pinfo {
+	struct list_head list;
+
+	unsigned char	pc_id[8];
+	unsigned char   intranode;      /* 0 = internode, 1 = intranode */
+        unsigned char   odai;           /* 0 = Pri, 1 = Sec */
+        unsigned short  max_btu;
+        unsigned char   tx_rx_bind_pacing;
+        unsigned char   dependent_lulu;
+        unsigned char   adp_bind_pacing_dep_lulu;
+        unsigned char   generalized_oadi;
+
+	/* list of 256 unique addresses */
+	unsigned short		blk_count;
+	struct list_head l_blks;
+};
+
+struct sna_activate_as {
+	unsigned char	pc_id[8];
+	unsigned char	intranode;	/* 0 = internode, 1 = intranode */
+	unsigned char	odai;		/* 0 = Pri, 1 = Sec */
+	unsigned short	max_btu;
+	unsigned char	tx_rx_bind_pacing;
+	unsigned char	dependent_lulu;
+	unsigned char	adp_bind_pacing_dep_lulu;
+	unsigned char	generalized_oadi;
+};
+
+/* CS.
+ */
+
+typedef enum {
+	SNA_XID_REMOTE_INIT = 1,
+	SNA_XID_LOCAL_INIT,
+	SNA_XID_INPUT,
+	SNA_XID_ACTIVE,
+	SNA_XID_RESET
+} xid_inputs;
+
+typedef enum {
+	SNA_XID_NULL = 1,
+	SNA_XID_PN,
+	SNA_XID_NEG
+} xid_packets;
+
+typedef enum {
+	XID_RESET = 1,
+	XID_S_NULL,
+	XID_S_PN,
+	XID_S_NEG,
+	XID_S_PRI,
+	XID_S_SEC,
+	XID_R_NULL,
+	XID_R_PN,
+	XID_R_NEG,
+	XID_R_PRI,
+	XID_R_SEC,
+	XID_ACTIVE,
+	XID_FAIL
+} xid_state;
+
+typedef enum {
+	XID_BEGIN = 1,
+	XID_NULL,
+	XID_PN,
+	XID_NEG,
+	XID_PRI,
+	XID_SEC
+} xid_input;
+
+#define	XID_OUTBOUND	0x00		/* XID CMD */
+#define XID_INBOUND	0x01		/* XID RSP */
+
+struct sna_xid_info {
+        struct sk_buff  *last_tx_xid;
+        struct sk_buff  *last_rx_xid;
+
+        xid_state               xid_status;
+        struct timer_list       xid_timer;
+        __u32                   xid_idle_limit;
+        __u32                   xid_retry_interval;
+        __u32                   xid_retry_limit;
+	__u32			xid_retries;
+
+        __u8    xid_initiator;		/* 0x00 = Local / 0x01 = Remote */
+	__u8	xid_direction;		/* 0x00 = cmd / 0x01 = rsp */
+        __u32   xid_count;              /* number of xids exchanged */
+
+        __u16   i_tx_window;
+        __u16   i_rx_window;
+        __u16   i_mtu;                  /* max btu size */
+
+        __u8    tg_type;
+        __u8    tg_id;
+
+	/* detailed xid information */
+	__u8	init_self;
+	__u8	tx_bind_wo_init_self;
+	__u8	tx_bind_piu;
+	__u8	rx_bind_piu;
+
+	__u8	adaptive_tx_bind;
+	__u8	adaptive_rx_bind;
+
+	/* Junk below but keeping around for a while */
+	__u32   adj_node_id;
+        char    real_adj_cp_name[8];
+        __u32   local_odai_value;
+        __u32   sscp_med_sessions;
+        __u32   adj_node_bind_reassembly;
+        __u32   local_cpcp_sessions_supp_status;
+        __u32   adj_node_cpcp_sessions_supp_status;
+        __u32   curr_cpcp_sessions_supp_status;
+        __u32   ss_cpcp_sessions_supp_override;
+        __u32   partner_node_type;
+        __u32   tg_sec_init_nonact_xchg;
+        __u32   restart_nonact_xid3_xchg;
+};
+
+typedef enum {
+	BIND_RESET = 1,
+	BIND_S_BIND,
+	BIND_S_BIND_W_AF,
+	BIND_S_PR_FMD,
+	BIND_S_PR_FMD_W_AF,
+	BIND_S_PR_BIND,
+	BIND_S_PR_BIND_W_AF,
+	BIND_ACTIVE
+} bind_state;
+
+struct sna_session_initiation_info {
+        char    adj_cp_name[8];
+        __u32   real_node_tgs;
+        __u32   virtual_node_tgs;
+        char    virtual_node_cp_name[8];
+};
+
+struct sna_xid_error_info {
+        __u32   sense;
+        __u32   *procedure_name;
+        __u32   byte_offset;
+        __u32   bit_offset;
+        __u32   send_xid;
+};
+
+struct sna_adj_node_cb {
+        struct sna_adj_node_cb *next;
+        struct sna_adj_node_cb *prev;
+
+        char    real_adj_cp_name[8];
+        __u32   last_adj_cp_contacted;
+        __u32   parallel_tgs;
+        __u32   tg_numbers;
+
+        struct sna_cs_process_data *cs_instance;
+};
+
+/*
+ * Link Station data structures.
+ */
+
+struct sna_activate_route {
+	unsigned char	pc_id[8];	/* associated path control */
+	unsigned long	tg_id;		/* tg to use, 0 if intranode */
+	struct sna_netid cp_name;	/* name of adjacent node */
+};
+
+#define SNA_LS_TYPE_DEFINED             0x01
+#define SNA_LS_TYPE_DYNAMIC             0x02
+#define SNA_LS_TYPE_TEMP                0x04
+struct sna_ls_cb {
+	struct list_head list;
+
+        __u32 proc_id;
+        __u16 flags;
+
+        struct sna_port_cb *port;
+        struct sna_dlc_cb *dlc;
+        struct sna_netid netid;
+        unsigned char auto_act;
+        unsigned char auto_deact;
+
+        char devname[8];
+        unsigned char sport;
+
+        /* Destination node information. This is still ugly. */
+	struct sna_netid plu_name;
+        char dname[MAX_ADDR_LEN];                 /* Mac Addr */
+        char daddr[SNA_PORT_ADDR_LEN];  /* Dst. Port */
+
+	unsigned char pc_id[8];
+	unsigned char tg_id;	/* TG used by this LS */
+
+/* Data below is questionable */
+        __u32                   node_act;
+        __u32                   ls_entered_act_state;
+        __u32                   ls_activation;  /* LS capabilities. */
+
+        __u32                   adj_node_type;
+        char                    adj_node_id[8];
+        __u32                   adj_node_session;
+
+        __u32                   bind_pacing_cnt;
+        __u32                   max_tx_btu_size;
+        __u32                   max_rx_btu_size;
+
+        __u32                   tx_win_size;
+        __u32                   rx_win_size;
+
+        __u32   direction;
+        __u32   adj_ls_id;
+
+        struct sna_session_initiation_info *session_initiation_info;
+        struct sna_activate_route *activate_route_list;
+};
+
+/*
+ * Port data structures.
+ */
+
+struct sna_port_cb {
+	struct list_head list;
+
+        struct list_head ls_list;
+        __u32 ls_qlen;
+
+        struct sna_netid netid;
+        struct net_device *dev;
+        char saddr[12];
+
+        __u32   proc_id;
+        __u16   flags;
+        __u32   role;
+
+        __u32   btu;
+        __u32   mia;
+        __u32   moa;
+
+#ifdef CONFIG_SNA_LLC
+	struct llc_sap *llc_dl;
+#endif
+#ifdef CONFIG_SNA_ATM
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+#endif
+#ifdef CONFIG_SNA_SDLC
+#endif
+#ifdef CONFIG_SNA_HDLC
+#endif
+
+/* Not used below */
+        unsigned long   max_adjacent_ls;
+        unsigned long   real_adjacent_ls;
+
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+        unsigned long   link_station_txrx;
+        unsigned long   max_nonack_xid;
+
+        unsigned long   xid_exchange_type;
+};
+
+/*
+ * DLC data structures.
+ */
+
+#ifdef CONFIG_SNA_LLC
+struct sna_dlc_llc_addr {
+        sa_family_t     arphrd;         /* ARPHRD_ETHER */
+        u_int8_t        dsap;
+        u_int8_t        ssap;
+        u_int8_t        dmac[IFHWADDRLEN];
+        u_int8_t        smac[IFHWADDRLEN];
+};
+#endif  /* CONFIG_SNA_LLC */
+
+struct sna_dlc_cb {
+	struct list_head list;
+
+        struct list_head port_list;
+        __u32 port_qlen;
+
+        struct net_device *dev;
+        __u16 flags;
+        __u32 proc_id;
+};
+
+struct sna_cs_pinfo {
+	struct list_head list;
+
+        struct sna_netid        netid;
+	struct sna_nodeid	nodeid;
+        struct sna_dlc_cb       *dlc_list;
+
+	unsigned char		node_type;
+	unsigned char		intranode_pc_id[8];
+
+
+/* Not used below */
+        struct sna_adj_node_cb  *adj_node_cb;
+        struct sna_fq_netid     *netid_cp;
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* DFC.
+ */
+
+struct sna_lulu_cb {
+	struct list_head list;
+
+        struct sna_netid netid;
+	struct sna_netid plu_netid;
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned char polarity;
+	unsigned long proc_id;
+	unsigned char fqpcid[8];
+	
+
+/*	Not used anymore.
+
+        __u8    ps_id;
+        __u8    bracket_id;
+        __u8    first_speaker;
+
+        struct sna_ct   ct_rcv;
+        struct sna_ct   ct_send;
+
+        sna_snf sqn_send_cnt;
+        sna_snf phs_bb_register;
+        sna_snf shs_bb_register;
+        sna_snf current_bracket_sqn;
+
+        __u8    rqd_required_on_ceb;
+        __u8    deallocate_abend;
+
+        __u16   normal_flow_rq_cnt;
+
+        __u8    sig_received;
+        sna_snf sig_snf;
+
+        __u8    betc;
+        __u8    send_error_rsp_state;
+        __u8    bb_rsp_state;
+        __u32   bb_rsp_sense;
+
+        __u8    rtr_rsp_state;
+        __u32   rtr_rsp_sense;
+
+        __u8    sig_rq_outstanding;
+        __u8    alternate_code;
+        __u8    session_just_started;
+        struct sna_mu   *saved_mu_ptr;
+*/
+};
+
+#ifdef NOT
+
+#define SNA_DFC_RQD1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 0)
+#define SNA_DFC_RQE1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 1)
+#define SNA_DFC_RQ1(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQE1(X))
+#define SNA_DFC_RQD1_HEX        0x100
+#define SNA_DFC_RQE1_HEX        0x101
+
+#define SNA_DFC_SET_RQD1(X)     (X->dr1i = 1, X->dr2i = 0, X->eri = 0)
+
+#define SNA_DFC_RQD2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ2(X)          (SNA_DFC_RQD2(X) || SNA_DFC_RQE2(X))
+#define SNA_DFC_RQD2_HEX        0x010
+#define SNA_DFC_RQE2_HEX        0x011
+
+#define SNA_DFC_RQD3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ3(X)          (SNA_DFC_RQD3(req_h) || SNA_DFC_RQE3(req_h))
+#define SNA_DFC_RQD3_HEX        0x110
+#define SNA_DFC_RQE3_HEX        0x111
+
+#define SNA_DFC_RQD(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQD2(X) || SNA_DFC_RQD3(X))
+#define SNA_DFC_RQE(X)          (SNA_DFC_RQE1(X) || SNA_DFC_RQE2(X) || SNA_DFC_RQE3(X))
+
+#define SNA_DFC_POS_RSP(X)      (SNA_DFC_RQD(X))
+#define SNA_DFC_NEG_RSP(X)      (SNA_DFC_RQE(X))
+
+#define SNA_DFC_TRUE    0x1
+#define SNA_DFC_FALSE   0x0
+
+#define SNA_DFC_YES     0x1
+#define SNA_DFC_NO      0x0
+
+#define SNA_DFC_NEG     0x0
+#define SNA_DFC_POS     0x1
+
+#define SNA_DFC_SIG_CURRENT     0x0
+#define SNA_DFC_SIG_STRAY       0x1
+#define SNA_DFC_SIG_FUTURE      0x2
+
+#define SNA_DFC_RESET           0x0
+#define SNA_DFC_NEG_OWED        0x1
+#define SNA_DFC_POS_OWED        0x2
+
+#define SNA_CT_CRV      0x0
+#define SNA_CT_BIS      0x1
+#define SNA_CT_LUSTAT   0x2
+#define SNA_CT_RTR      0x3
+#define SNA_CT_SIG      0x4
+#define SNA_CT_OTHER    0x5
+
+#define SNA_CT_RQCODE_EC        0x6
+
+struct sna_ct {
+        __u8    entry_present;
+        sna_snf snf;
+        __u32   neg_rsp_sense;
+        struct sna_rh rh;
+        __u16   rq_code;
+};
+
+/* Finite State Machine definitions and structures. */
+#define SNA_DFC_FSM_CURRENT     0x0     /* Current FSM state. */
+
+#define SNA_DFC_FSM_R           0x0     /* MU is being received. */
+#define SNA_DFC_FSM_S           0x1     /* MU is being sent. */
+
+#define SNA_DFC_FSM_NO_CHAIN    0x0
+#define SNA_DFC_FSM_BEGIN_CHAIN 0x1
+#define SNA_DFC_FSM_END_CHAIN   0x2
+
+#define SNA_DFC_FSM_BETB        0x01
+#define SNA_DFC_FSM_BETC        0x01
+#define SNA_DFC_FSM_INB         0x02
+#define SNA_DFC_FSM_INC         0x02
+#define SNA_DFC_FSM_NEG         0x03
+#define SNA_DFC_FSM_RSP         0x03
+#define SNA_DFC_FSM_SENT        0x03
+#define SNA_DFC_FSM_PEND        0x04
+#define SNA_DFC_FSM_SEND        0x05
+
+#define SNA_DFC_FSM_PEND_SEND_REPLY     0x06
+#define SNA_DFC_FSM_PEND_RCV_REPLY      0x07
+#define SNA_DFC_FSM_PEND_REPLY          0x08
+
+#define SNA_DFC_FSM_BB                  0x0
+#define SNA_DFC_FSM_RQD                 0x0
+#define SNA_DFC_FSM_RQE                 0x1
+#define SNA_DFC_FSM_REPLY               0x2
+#define SNA_DFC_FSM_BIS                 0x3
+#define SNA_DFC_FSM_RTR                 0x4
+#define SNA_DFC_FSM_FMH5                0x5
+#define SNA_DFC_FSM_FMH12               0x6
+#define SNA_DFC_FSM_LUSTAT              0x7
+#define SNA_DFC_FSM_NOT_BID_REPLY       0x8
+#define SNA_DFC_FSM_CEB_UNCOND          0x9
+
+#endif
+
+/* DS.
+ */
+
+struct sna_ds_pinfo {
+	struct list_head list;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* HS.
+ */
+
+#define SNA_LOCAL_CRV           0x00
+#define SNA_LOCAL_NO_CRV        0x01
+#define SNA_LOCAL_BIS           0x10
+#define SNA_LOCAL_NO_BIS        0x11
+#define SNA_LOCAL_LUSTAT        0x20
+#define SNA_LOCAL_NO_LUSTAT     0x21
+#define SNA_LOCAL_RTR           0x30
+#define SNA_LOCAL_NO_RTR        0x31
+#define SNA_LOCAL_SIG           0x40
+#define SNA_LOCAL_NO_SIG        0x41
+#define SNA_LOCAL_OTHER         0x50
+#define SNA_LOCAL_NO_OTHER      0x51
+
+#define SNA_HS_SEND             0x0
+#define SNA_HS_RECEIVE          0x1
+
+#ifdef NOT
+
+struct sna_hs_local {
+        __u8    hs_id;          /* ID of this HS. */
+        __u8    lu_id;          /* The LU for this HS. */
+        __u8    half_session;   /* SNA_PRI or SNA_SEC. */
+        __u32   sense;
+        __u8    perm_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    rq_code;
+
+        __u8    state;
+
+        struct sna_lulu_cb lulu;       /* Fields only used by DFC. */
+
+        /* Fields only used by TC. */
+        struct sna_tc_cb tcb;
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported:4,
+                crypto:4;
+
+        struct sna_mu *catch_mu;
+
+        struct sna_hs_local *next;
+        struct sna_hs_local *prev;
+};
+
+#endif
+
+/* IPC.
+ */
+
+struct sna_hs_ps_connected {
+        __u8    ps_id;
+        __u8    bracket_id;
+};
+
+struct sna_abend_notification {
+        unsigned char *abending_process;
+        __u8 process_id;
+        __u8 reason;
+};
+
+struct sna_abort_hs {
+        __u8 hs_id;
+        __u8 sense_code;
+};
+
+struct sna_activate_session_rsp {
+        __u8 correlator;
+        __u8 type;
+        __u8 session_information;
+        __u8 error_type;
+};
+
+struct sna_allocate_rcb {
+        __u8 tcb_id;
+        __u8 specific_conv_group;
+        __u8 conversation_group_id;
+        __u8 *lu_name;
+        __u8 *mode_name;
+        __u8 immediate_session;
+        __u8 sync_level;
+        __u8 security_select;
+};
+
+/* request and response structure */
+struct sna_assign_pcid {
+        unsigned short sm_proc_id;
+        unsigned char duplicate_pcid;	/* 0 = no, 1 = yes */
+	unsigned char fqpcid[8];
+};
+
+struct sna_bid {
+        __u8 hs_id;
+};
+
+struct sna_bid_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u32 sense;
+};
+
+struct sna_bid_without_attach {
+        /* Blame IBM */
+};
+
+struct sna_bis_reply {
+        __u8 hs_id;
+};
+
+struct sna_bis_rq {
+        __u8 hs_id;
+};
+
+struct sna_bracket_freed {
+        __u8 bracket_id;
+};
+
+struct sna_cos {
+	unsigned short	type;
+	unsigned char	rsv:5,
+			network_priority:1,
+			tx_priority:2;
+	unsigned char	len;
+	unsigned char	cos_name[8];
+};
+
+struct sna_cos_tpf_vector {
+	unsigned char	mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_cos	v;
+};
+
+/* Control vector 0x80 */
+struct sna_tg_id {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	pcp_len;
+	unsigned char	*pcp_name;
+	unsigned char	pcp_name_id_cn:1,
+			more_cfg_info:1,
+			hpr_support:1,
+			tg_type:2,
+			intersubnet_tg:1,
+			rsv1:1,
+			rtp_support:1;
+	unsigned short	subarea_number;
+};
+
+/* Control vector 0x81 */
+struct sna_tg_cn {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	ptg_number;
+	unsigned short	rsv1;
+};
+
+/* Control vector 0x82 */
+struct sna_tg_dlc_signal {
+	unsigned short	type;
+	unsigned char	mac[MAX_ADDR_LEN];
+	unsigned char	lsap;
+};
+
+/* Control vector 0x83 */
+struct sna_tg_cp_name {
+	unsigned char	type;
+	unsigned char	len;
+	unsigned char	*cp_name;
+	unsigned char	intersubnet_tg;
+};
+
+/* Control vector 0x46 */
+struct sna_tg_desc {
+	unsigned short	type;
+	struct sna_tg_id		id;
+	struct sna_tg_dlc_signal	dlc;
+};
+
+/* Control vector 0x47 */
+struct sna_tg_chars {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	status:1,
+			garbage:1,
+			quiescing:1,
+			cpcp_session:2,
+			rsv1:3;
+	unsigned char	effective_capacity;
+	unsigned char	rsv2[5];
+	unsigned char	cost_per_connect;
+	unsigned char	cost_per_byte;
+	unsigned char	rsv3;
+	unsigned char	security;
+	unsigned char	propagation_delay;
+	unsigned char	rsv4;
+	unsigned char	user1;
+	unsigned char	user2;
+	unsigned char	user3;
+};
+
+struct sna_tg_ttl {
+	unsigned short	type;
+	unsigned char	days;
+};
+
+/* Control vector 0x48 */
+struct sna_tg_trd {
+	unsigned short		type;
+	struct sna_tg_ttl	*ttl;
+};
+
+struct sna_tg_vector {
+	struct sna_tg_vector 	*next;
+	struct sna_tg_vector	*prev;
+
+	struct sna_tg_desc      desc;		/* Cv 0x46 */
+        struct sna_tg_chars     chars;		/* Cv 0x47 */
+	struct sna_tg_trd	trd;
+};
+
+struct sna_tg_update {
+	unsigned char		node_type;
+	unsigned char		routing;
+	struct net_device	*dev;
+	unsigned char		lsap;
+	struct sna_tg_desc	tg_desc;
+	struct sna_tg_chars	tg_chars;
+};
+
+/* Control vector 0x44 */
+struct sna_node_desc {
+	unsigned short	type;
+	unsigned char	cp_len;
+	struct sna_netid cp_name;
+	unsigned char	rsv_len;
+	unsigned char	cn:1,
+			rsv1:7;
+};
+
+/* Control vector 0x80 */
+struct sna_node_type {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	route_resistance;
+	unsigned char	congested:1,
+			interoute_depelted:1,
+			rsv1:1,
+			garbage:1,
+			rsv2:1,
+			quiescing:1,
+			rsv3:2;
+	unsigned char	gateway:1,
+			cds:1,
+			interoute:1,
+			rsv4:1,		/* Set to 1 */
+			rsv5:2,
+			rsv6:2;		/* Set to 11 */
+	unsigned char	peripheral:1,
+			interchange:1,
+			extended:1,
+			hpr:2,
+			rsv7:3;
+};
+
+/* Control vector 0x45 */
+struct sna_node_chars {
+	unsigned short		type;
+	struct sna_node_type	info;
+};
+
+struct sna_node_vector {
+	struct sna_node_desc	desc;
+	struct sna_node_chars	chars;
+};
+
+#define CO_TIMEOUT	3 * HZ
+#define CO_MAX_RETRIES	10
+
+typedef enum {
+	CO_FAIL = 0,
+	CO_RESET,
+	CO_ACTIVE,
+	CO_S_TEST_C,
+	CO_R_TEST_R,
+	CO_TEST_OK,
+} connect_out_status;
+
+struct sna_tg_cb {
+	struct list_head list;
+
+	connect_out_status	co_status;
+	struct timer_list	co_retry;
+	int			co_interval;
+	int			co_retries;
+	int			co_max_retries;
+
+	wait_queue_head_t       sleep;
+
+	unsigned char		lsap;
+	struct net_device 	*dev;
+
+	struct sna_xid_info 	*xid_info;
+
+	unsigned long		frsn;
+	struct timeval		updated;
+	unsigned char		type;
+	unsigned char		partner_node_type;
+	unsigned char		intermediate_routing;
+
+	struct sna_tg_vector	tg_vector;
+	struct list_head	cos_list;
+
+#ifdef CONFIG_SNA_LLC
+	struct sna_dlc_llc_addr	llc_addr;
+	struct llc_sap		*llc_dl;
+#endif
+};
+
+struct sna_tdm_node_cb {
+	struct list_head list;
+
+	struct sna_netid	netid;
+	unsigned long		frsn;
+	struct timeval		updated;
+
+	struct sna_node_vector	node_vector;
+	struct list_head	tg_list;
+	struct list_head	cos_list;
+};
+
+struct sna_tdm_an_cb {
+	struct sna_tdm_an_cb	*next;
+	struct sna_tdm_an_cb	*prev;
+};
+
+struct sna_rss_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+};
+
+/* Control vector 0x0E */
+struct sna_cv_nn {
+	unsigned short		type;
+	unsigned char		nn_type;
+	struct sna_netid	nq_name;
+};
+
+/* Control vector 0x2B */
+struct sna_cv_rs {
+	unsigned short		type;
+	unsigned char		max_hops;
+	unsigned char		current_hops;
+	struct sna_cv_nn	nn;
+	struct sna_tg_desc	tg_desc;
+};
+
+
+struct sna_rq_single_hop_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid	dst_cp_name;
+	unsigned char		sscp;
+	unsigned char		tg_alive;
+	unsigned char		tg_types;
+	struct sna_cv_rs 	rs;
+};
+
+struct sna_rq_tg_vectors {
+	struct sna_netid	org_cp_name;
+	struct sna_netid	dst_cp_name;
+	unsigned char		type;
+	unsigned char		sscp;
+	unsigned char		tg_type;
+	unsigned char		tg_alive;
+	struct sna_tg_vector	*tg_vectors;
+};
+
+struct sna_cinit_signal {
+        __u8 fqpcid;
+        __u8 path_control_id;
+        struct sna_pc_characteristics *pc_characteristics;
+        __u8 cos_tpf_present;
+        struct sna_cos_tpf *cos_tpf;
+};
+
+struct sna_confirmed {
+        __u8 bracket_id;
+};
+
+struct sna_cosm_tg_cb {
+	struct sna_cosm_tg_cb *next;
+	struct sna_cosm_tg_cb *prev;
+
+	unsigned short  rsn;
+
+	unsigned short	min_cost_per_connect;
+	unsigned short	max_cost_per_connect;
+	unsigned short	min_cost_per_byte;
+	unsigned short	max_cost_per_byte;
+	unsigned short	min_security;
+	unsigned short	max_security;
+	unsigned short	min_propagation_delay;
+	unsigned short	max_propagation_delay;
+	unsigned short	min_effective_capacity;
+	unsigned short	max_effective_capacity;
+	unsigned short	min_user1;
+	unsigned short	max_user1;
+	unsigned short	min_user2;
+	unsigned short	max_user2;
+	unsigned short	min_user3;
+	unsigned short	max_user3;
+
+	unsigned char	operational;
+	unsigned char	quiescing;
+	unsigned char	garbage_collection;
+	unsigned char	cpcp_session_status;
+};
+
+struct sna_cosm_node_cb {
+	struct sna_cosm_node_cb *next;
+	struct sna_cosm_node_cb *prev;
+
+	unsigned short	rsn;
+
+	unsigned short	route_resistance;
+	unsigned short	node_congested;
+	unsigned short	inter_routing_depleted;
+	unsigned short	garbage_collection;
+	unsigned short	quiescing;
+	unsigned short	gateway_support;
+	unsigned short	central_directory;
+};
+
+/* Transmission Priorities */
+#define SNA_TP_LOW              0x0
+#define SNA_TP_MEDIUM           0x1
+#define SNA_TP_HIGH             0x2
+#define SNA_TP_NETWORK          0x3
+
+struct sna_cosm_cb {
+	struct list_head list;
+
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+	unsigned short	weight;
+	unsigned short	tx_priority;
+
+	struct sna_cosm_tg_cb	*tg;
+	struct sna_cosm_node_cb	*node;
+
+	unsigned char	default_cos_invalid;
+	unsigned char	default_cos_null;
+};
+
+struct sna_conversation_failure {
+        __u8 rcb_id;
+        __u8 reason;
+};
+
+struct sna_deallocate_rcb {
+        __u8 tcb_id;
+        __u8 rcb_id;
+};
+
+struct sna_init_hs {
+        __u8    hs_id;
+        __u8    lu_id;
+        __u8    pc_id;
+        __u8    type;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        struct sna_lfsid lfsid;
+        __u8    tx_priority;
+
+        struct sna_ru_bind bind;
+};
+
+struct sna_init_hs_rsp {
+        __u8 type;
+        __u8 sense;
+        __u8 hs_id;
+};
+
+struct sna_init_signal_neg_rsp {
+        __u8 fqpcid;
+};
+
+struct sna_init_signal {
+        unsigned short sm_proc_id;
+        unsigned char fqpcid[8];
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid slu_name;
+	struct sna_netid plu_name;	/* Local netid */
+};
+
+struct sna_lfsid_in_use_rsp {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_lfsid_in_use {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_pc_hs_disconnect {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+};
+
+struct sna_rcb_deallocated {
+        /* Blame IBM */
+};
+
+struct sna_receive_error {
+        __u8 bracket_id;
+};
+
+struct sna_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rm_act_session_rq {
+        unsigned long tcb_id;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_sm_act_session_rq {
+	unsigned short correlator;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char polarity;
+};
+
+#define SNA_ACT_SESS_RETRY	0
+
+#define SNA_SESSION_ACTIVE		0
+#define SNA_SESSION_AT_LEAST_INIT_SENT	1
+#define SNA_SESSION_AT_LEAST_BIND_SENT	2
+
+struct sna_rm_deactivate_conv_group {
+        __u8 tcb_id;
+        __u8 gid;
+        __u8 sense;
+};
+
+struct sna_rm_deactivate_session {
+        __u8 tcb_id;
+        __u8 session_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_rm_hs_connected {
+        /* Blame IBM */
+};
+
+struct sna_rsp_to_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rtr_rq {
+        __u8 hs_id;
+};
+
+struct sna_rtr_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u8 sense;
+};
+
+struct sna_send_error {
+        /* Blame IBM */
+};
+
+struct sna_send_rtr {
+        /* Blame IBM */
+};
+
+struct sna_deactivate_session {
+        __u8 status;
+        __u8 correlator;
+        __u8 hs_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_sessend_signal {
+        __u8 sense;
+        __u8 fqpcid;
+        __u8 path_control_id;
+};
+
+struct sna_sessst_signal {
+        __u8 path_control_id;
+};
+
+struct sna_start_tp_reply {
+        __u8 rcode;
+        __u8 tcb_id;
+};
+
+struct sna_terminate_ps {
+        __u8 tcb_id;
+};
+
+struct sna_unbind_protocol_error {
+        __u8 tcb_id;
+        __u8 hs_id;
+        __u8 sense;
+};
+
+struct sna_yield_session {
+        /* Blame IBM */
+};
+
+/* IPM.
+ */
+
+#define SNA_RH_IPM_TYPE         0x830100
+
+struct sna_ipm {
+        __u8    type:2,
+                rscwrc:1,
+                rsv1:5;
+        __u16   format:1,
+                nws:15;
+};
+
+/* IPM type indicators */
+#define SNA_IPM_TYPE_SOL        0x0
+#define SNA_IPM_TYPE_UNSOL      0x1
+#define SNA_IPM_TYPE_RS_ACK     0x2
+#define SNA_IPM_TYPE_RSV        0x3
+
+/* Reset residual-count indicators */
+#define SNA_IPM_RS_CNT_FALSE    0x0
+#define SNA_IPM_RS_CNT_TRUE     0x1
+
+/* Next-window size format indicators. */
+#define SNA_IPM_NWS_FORMAT_0    0x0
+
+/* Path control
+ */
+#define SNA_BIND_RQ		0x01
+#define SNA_BIND_RSP		0x02
+#define SNA_UNBIND_RQ		0x03
+#define SNA_UNBIND_RSP		0x04
+
+#define SNA_LS_FLUSHED          0x0302
+#define SNA_FREE_LFSID          0x0305
+#define SNA_PC_TO_DLC           0x0306
+#define SNA_SEND_MU             0x0307
+#define SNA_FLUSH_LS            0x0308
+#define SNA_INIT_PC             0x0309
+#define SNA_LOCAL_BIND_RQ_SEND  0x030A
+#define SNA_LOCAL_BIND_RSP_SEND 0x030B
+#define SNA_LOCAL_FLUSH_LS      0x030C
+#define SNA_LOCAL_UNBIND_RQ_SEND        0x030D
+#define SNA_LOCAL_UNBIND_RSP_SEND       0x030E
+#define SNA_BIND_IPM_SEND               0x030F
+#define SNA_PC_HS_DISCONNECT            0x0310
+
+#define	SNA_PC_INTRANODE		0x0
+#define SNA_PC_INTERNODE		0x1
+
+struct sna_pc_pinfo {
+	struct list_head list;
+
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;		/* Only for Internode */
+        struct sna_ls_cb        *ls;		/* Only for Internode */
+        struct sna_port_cb	*port;		/* Only for Internode */
+	unsigned char		pc_id[8];
+	unsigned char		type;
+
+	/* TG characteristics */
+	unsigned short	max_tx_btu;
+	unsigned short	max_rx_btu;
+	unsigned char	bind_seg;
+	unsigned char	limited_tg;
+	unsigned char   tg_number;
+
+	unsigned char	odai;		/* 0 pri or 1 sec */
+
+	unsigned char	local_seg;
+	unsigned char	godai;
+};
+
+struct sna_pc_create_parms {
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;
+        struct sna_ls_cb        *ls;
+        struct sna_port_cb      *port;
+	unsigned char		type;
+
+	unsigned char	pc_id[8];
+
+	/* TG characteristics */
+        unsigned short  max_tx_btu;
+        unsigned short  max_rx_btu;
+        unsigned char   bind_seg;
+        unsigned char   limited_tg;
+        unsigned char   tg_number;
+
+        unsigned char   odai;           /* 0 pri or 1 sec */
+        unsigned char   local_seg;
+        unsigned char   godai;
+};
+
+struct sna_pc_hs_table {
+        struct sna_pc_hs_table *next;
+        struct sna_pc_hs_table *prev;
+
+        __u8    odai;   /* OAF/DAF Assignor indicator. */
+        __u8    oaf;    /* Origin Address field. */
+        __u8    daf;    /* Destination Address field. */
+        __u8    sidh;   /* Session identifier high (OAF). */
+        __u8    sidl;   /* Session identifier low (DAF). */
+
+        /* These below may be garbage, we'll see what works best. */
+        __u8    hs_id;
+        __u8    sc_id;
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+/* PS.
+ */
+
+typedef enum {
+        ALLOCATE = 1,
+        CONFIRM,
+        CONFIRMED,
+        DEALLOCATE,
+        FLUSH,
+        GET_ATTRIBUTES,
+        POST_ON_RECEIPT,
+        PREPARE_TO_RECEIVE,
+        RECEIVE_AND_WAIT,
+        RECEIVE_IMMEDIATE,
+        REQUEST_TO_SEND,
+        SEND_DATA,
+        SEND_ERROR,
+        TEST,
+        MC_ALLOCATE,
+        MC_CONFIRM,
+        MC_CONFIRMED,
+        MC_DEALLOCATE,
+        MC_FLUSH,
+        MC_GET_ATTRIBUTES,
+        MC_POST_ON_RECEIPT,
+        MC_PREPARE_TO_RECEIVE,
+        MC_RECEIVE_AND_WAIT,
+        MC_REQUEST_TO_SEND,
+        MC_SEND_DATA,
+        MC_SEND_ERROR,
+        MC_TEST,
+        INITIALIZE_SESSION_LIMIT,
+        CHANGE_SESSION_LIMIT,
+        RESET_SESSION_LIMIT,
+        SET_LUCB,
+        SET_PARTNER_LU,
+        SET_MODE,
+        SET_MODE_OPTIONS,
+        SET_TRANSACTION_PROGRAM,
+        SET_PRIVILAEGED_FUNCTION,
+        SET_RESOURCE_SUPPORTED,
+        SET_SYNC_LEVEL_SUPPORTED,
+        SET_MC_FUNCTION_SUPPORTED_TP,
+        GET_LUCB,
+        GET_PARTNER_LU,
+        GET_MODE,
+        GET_LU_OPTION,
+        GET_MODE_OPTION,
+        GET_TRANSACTION_PROGRAM,
+        GET_PRIVILEGED_FUNCTION,
+        GET_RESOURCE_SUPPORTED,
+        GET_SYNC_LEVEL_SUPPORTED,
+        GET_MC_FUNCTION_SUPPORTED_LU,
+        GET_MC_FUNCTION_SUPPORTED_TP,
+        LIST_PARTNER_LU,
+        LIST_MODE,
+        LIST_LU_OPTION,
+        LIST_MODE_OPTION,
+        LIST_TRANSACTION_PROGRAM,
+        LIST_PRIVILEGED_FUNCTION,
+        LIST_RESOURCE_SUPPORTED,
+        LIST_SYNC_LEVEL_SUPPORTED,
+        LIST_MC_FUNCTION_SUPPORTED_LU,
+        LIST_MC_FUNCTION_SUPPORTED_TP,
+        PROCESS_SESSION_LIMIT,
+        ACTIVATE_SESSION,
+        DEACTIVATE_CONVERSATION_GROUP,
+        DEACTIVATE_SESSION,
+        SYNCPT,
+        BACKOUT,
+        GET_TP_PROPERTIES,
+        GET_TYPE,
+        WAIT
+} ps_verbs;
+
+/* RM.
+ */
+
+#define SNA_RM_FALSE    0x0
+#define SNA_RM_TRUE     0x1
+
+struct sna_lu_cb {
+	struct list_head list;
+
+        struct sna_netid netid;
+        __u8    lu_name[SNA_RESOURCE_NAME_LEN];
+        __u8    sync_point;
+        __u32   lu_sess_limit;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_plu_cb {
+	struct list_head list;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        struct sna_netid netid_fqcp;
+
+        __u8    parallel_ss;
+        __u8    cnv_security;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_lu_count {
+        __u16   sessions;
+        __u16   conwinners;
+        __u16   conlosers;
+};
+
+#define SNA_MODE_MAX_SESSIONS		1200
+#define SNA_MODE_MIN_CONWINNERS		10
+#define SNA_MODE_MIN_CONLOSERS		10
+
+struct sna_mode_cb {
+	struct list_head list;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+	__u8	cos_name[SNA_RESOURCE_NAME_LEN];
+
+        __u32   tx_pacing;
+        __u32   rx_pacing;
+        __u32   max_tx_ru;
+        __u32   max_rx_ru;
+        __u32   crypto;         /* 0 = off / 1 = on */
+
+        __u16   flags;
+        __u32   proc_id;
+
+	struct 	sna_lu_count	active;
+	struct 	sna_lu_count	pending;
+
+	__u16	max_sessions;
+        __u16   min_conwinners;
+        __u16   min_conlosers;
+	__u16	auto_activation;
+};
+
+struct sna_tcb {
+	struct list_head list;
+
+        __u32           tcb_id;
+        __u32           rcb_id;
+	pid_t		pid;
+
+        cpic_state      state;
+
+        __u8            oaf;
+        __u8            daf;
+
+        struct sk_buff_head     receive_queue;
+        struct sk_buff_head     transmit_queue;
+        wait_queue_head_t       sleep;
+
+        /* cmspln */
+        unsigned char   partner_lu_name[18];
+        int             partner_lu_name_length;
+
+        /* cmsmn */
+        unsigned char   mode_name[9];
+        int             mode_name_length;
+
+        /* cmstpn */
+        unsigned char   tp_name[65];
+        int             tp_name_length;
+
+        /* cmsid */
+        unsigned char   init_data[10000];
+        int	        init_data_length;
+
+        /* cmsld */
+        unsigned char   log_data[512];
+        int	        log_data_length;
+
+        /* cmsrt */
+        unsigned long	 receive_type;
+
+        /* cmsaeq */
+        unsigned char   ae_qualifier[1024];
+        unsigned long   ae_qualifier_length;
+        unsigned char   ae_qualifier_format;
+
+        unsigned char   allocate_confirm;
+
+        /* cmsapt */
+        unsigned char   ap_title[1024];
+        unsigned long   ap_title_length;
+        unsigned char   ap_title_format;
+
+        /* cmsacn */
+        unsigned char   application_context_name[256];
+        unsigned long   application_context_length;
+
+        /* cmsbt */
+        unsigned char   begin_transaction;
+
+        /* cmssrm */
+        unsigned long	send_receive_mode;
+
+        /* cmssl */
+        unsigned long	   sync_level;
+
+        /* cmsst */
+        unsigned long	    send_type;
+
+        /* cmsptr */
+        unsigned long	      prepare_to_receive_type;
+
+        /* cmsdt */
+        unsigned long	      deallocate_type;
+
+        /* cmsf */
+        unsigned long	         fill;
+};
+
+/* SCM.
+ */
+
+#define sna_scm_create(x)       sna_isr_create(x);
+#define sna_scm(x)              sna_isr(x);
+
+/* SM.
+ */
+
+#ifdef NOT
+struct sna_session_info {
+        __u8    hs_id;
+        __u8    hs_type;
+        __u8    bracket_type;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    session_id;
+        __u8    *random;
+        __u8    limit_resource;
+};
+
+struct sna_security {
+        __u8    *profile;
+        __u8    *passwd;
+        __u8    *user_id;
+};
+
+struct sna_abend_notify {
+        __u8    process;
+        __u8    process_id;
+        __u8    reason;
+};
+
+struct sna_free_lfsid {
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+struct sna_free_session {
+        __u8    hs_id;
+};
+
+struct sna_get_session {
+        __u8    tcb_id;
+        __u8    rcb_id;
+        __u8    type;
+        __u8    conv_gid;
+};
+
+struct sna_session_activated {
+        struct sna_session_info session_info;
+        __u8    *lu_name;
+        __u8    *mode_name;
+};
+
+struct sna_session_allocated {
+        __u16   send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    in_conver;
+        __u8    rcode;
+};
+
+struct sna_session_deactivated {
+        __u8    hs_id;
+        __u8    reason;
+        __u32   sense;
+};
+
+struct sna_session_route_inop {
+        __u8    pc_id;
+};
+
+struct sna_act_sess_rsp {
+        __u8    correlator;
+        __u8    type;
+        __u8    err_type;
+        struct  sna_session_info sess_info;
+};
+
+struct sna_rcb_allocated {
+        __u8    rcode;
+        __u8    rcb_id;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+};
+
+struct sna_change_sessions {
+        __u8    tcb_id;
+        __u8    rsp;
+        __u8    *lu_name;
+        __u8    *mode_name;
+        __u8    delta;
+};
+
+struct sna_luw {
+        __u8    *fq_lu_name;
+        __u8    instance;
+        __u8    sequence;
+};
+
+/* Transaction control block. */
+struct sna_tcb {
+        struct sna_tcb *next;
+        struct sna_tcb *prev;
+
+        __u8    tcb_id;
+        __u8    tp_name;
+        __u8    own_lu_id;
+
+        struct sna_luw luw_id;
+        struct sna_resource resource_list;
+
+        __u8    ctrl_cmpnt;
+
+        struct sna_security security;
+};
+
+struct sna_scb {
+        __u8    hs_id;
+        __u8    session_id;
+
+        struct sna_conver conversation;
+
+        __u8    *lu_name;
+        __u8    *mode_name;
+
+        __u8    rcb_id;
+        __u8    first_speaker;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    bracket_id;
+
+        __u8    rtr_owed;
+        __u8    *fq_name;
+        __u8    *random;
+
+        __u8    limit_resource;
+
+        struct timer *timer_unique_id;
+};
+
+struct sna_received_info {
+        __u8    type;
+};
+
+struct sna_conver {
+        __u8    correlator;
+        __u8    gid;
+};
+
+struct sna_post_cond {
+        __u8    fill;
+        __u8    max_length;
+};
+
+#endif
+
+typedef enum {
+        FSM_RCB_STATUS_FSP = 1
+} rcb_state;
+
+/* Resource control block. */
+struct sna_rcb {
+	struct list_head list;
+
+        rcb_state       state;
+
+        unsigned long   rcb_id;
+        unsigned long   tcb_id;
+        unsigned long   hs_id;
+        unsigned long   bracket_id;
+
+        unsigned long   conversation_correlator;
+        unsigned long   session_id;
+
+        unsigned long   lfsid;          /* XXX */
+        unsigned char   oaf;            /* XXX */
+        unsigned char   daf;            /* XXX */
+
+        __u8    lu_name_length;
+        __u8    lu_name[SNA_FQCP_NAME_LEN];
+
+        __u8    mode_name_length;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+
+        __u8    tp_name_length;
+        __u8    tp_name[64];
+
+        union {
+                struct sna_ps_to_hs ps_to_hs;
+        } l;
+
+/* Everything below here is questionable */
+
+        __u8    sync_level;
+        __u8    security_select;
+
+//      struct sna_session_parm *sessions_parm_ptr;
+
+        __u8    conversation_type;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+
+//      struct sna_post_cond post_conditions;
+
+        __u8    locks;
+        __u16   send_ru_size;
+        __u8    rq_ro_send_rcvd;
+
+        __u32   mapper_save_area;
+        __u16   mc_max_send_size;
+        __u8    mc_rq_to_send_rcvd;
+};
+
+#ifdef NOT
+
+struct sna_tp {
+        struct sna_tp *next;
+        struct sna_tp *prev;
+
+        __u8    *tp_name;
+
+        struct sna_priv_funct priv_functs;
+        struct sna_rcb rcb;
+
+        __u8    verify_pip;
+        __u8    sub_pips;
+
+        struct sna_sync_level sync_level;
+
+        __u8    max_tp;
+        __u8    tp_cnt;
+        __u8    status;
+
+        struct sna_wait_init_rqs wait_init_rqs;
+
+        struct sna_mc_funct mc_funct;
+};
+
+struct sna_start_tp {
+        __u8    reply;
+        __u8    *tp_name;
+        __u8    security_select;
+        struct sna_security security;
+        __u8    tcb_id;
+        __u8    *pip_data;
+        __u8    fq_lu_name;
+};
+
+struct sna_plu {
+        struct sna_plu *next;
+        struct sna_plu *prev;
+
+        __u8    *lu_name;
+        __u8    *fq_name;
+        __u8    parallel_lus;
+
+        struct sna_mode mode;
+};
+
+struct sna_lucb {
+        struct sna_lucb *next;
+        struct sna_lucb *prev;
+
+        __u8    lu_id;          /* LU ID. */
+        __u8    *fq_lu_name;
+        __u8    slimit;         /* Session limit. */
+
+        struct sna_plu          plu;
+        struct sna_tp           tp;
+        struct sna_rand_data    random;
+};
+
+#endif
+
+/* SS.
+ */
+
+struct sna_ss_pinfo {
+	struct list_head list;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* TC.
+ */
+
+#ifdef NOT
+
+#define SNA_PACING_TYPE_NONE            0x01
+#define SNA_PACING_TYPE_FIXED           0x02
+#define SNA_PACING_TYPE_ADAPTIVE        0x03
+
+struct sna_send_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    first_ws;
+        __u8    rlwi;
+};
+
+struct sna_receive_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    unsolicited_ipm_outstanding;
+        __u8    adjust_ipm_ack_outstanding;
+        __u8    unsolicited_nws;
+};
+
+#define SNA_COMMON_CB_RESERVE_NO        0x01
+#define SNA_COMMON_CB_RESERVE_ALL       0x02
+#define SNA_COMMON_CB_RESERVE_MORE      0x03
+
+#define SNA_CCB_NO_RLW          0x0
+#define SNA_CCB_RLW             0x1
+
+#define SNA_CCB_NO              0x0
+#define SNA_CCB_MORE            0x1
+#define SNA_CCB_ALL             0x2
+
+struct sna_common_cb {
+        __u8    caller;
+        __u8    pc_id;
+        struct sna_lfsid lfsid;
+        __u8    perm_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    tx_priority;
+        __u8    num_bufs_per_ru;
+        __u8    reserve_flag;
+
+        struct sna_send_pacing          send_pacing;
+        struct sna_receive_pacing       receive_pacing;
+};
+
+struct sna_tc_cb {
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported;
+        __u8    crypto;
+        struct sna_common_cb    ccb;
+};
+
+#define SNA_IPM_TYPE_SOLICITED          0x01
+#define SNA_IPM_TYPE_UNSOLICITED        0x02
+#define SNA_IPM_TYPE_RESET_ACK          0x03
+
+#define SNA_IPM_RWI_RESET_WINDOW        0x01
+#define SNA_IPM_RWI_NO_RESET_WINDOW     0x02
+
+#define SNA_IPM_FORMAT_0                0x01
+
+struct sna_ipm_extension {      /* Should only be 3 bytes long. */
+        __u8    type;
+        __u8    rwi;
+        __u8    format_indicator;
+        __u8    nws;
+};
+
+#endif
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_CBS_H */
diff -ruN linux-2.4.18-clean/include/net/sna_errors.h linux/include/net/sna_errors.h
--- linux-2.4.18-clean/include/net/sna_errors.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/sna_errors.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,43 @@
+/* sna_errors.h: Linux-SNA Error codes and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#ifndef __NET_SNA_ERRORS_H
+#define __NET_SNA_ERRORS_H
+
+#ifdef __KERNEL__
+
+#define	RESOURCE_FAILURE_NO_RETRY	1008600B
+
+/* Allocation error codes */
+#define TPN_NOT_RECOGNIZED		10086021
+#define PIP_NOT_ALLOWED			10086031
+#define PIP_NOT_SPECIFIED_CORRECTLY	10086032
+#define CONVERSATION_TYPE_MISMATCH	10086034
+#define SYNC_LEVEL_NOT_SUPPORTED_BY_PGM	10086041
+#define ACCESS_DENIED			080F0983
+#define SECURITY_NOT_VALID		080F6051
+#define BACKED_OUT			08240000
+#define TP_NOT_AVAIL_RETRY		084B6031
+#define TP_NOT_AVAIL_NO_RETRY		084C0000
+#define DEALLOCATE_ABEND_PROG		08640000
+#define DEALLOCATE_ABEND_SVC		08640001
+#define DEALLOCATE_ABEND_TIMER		08640002
+#define PROG_ERROR_NO_TRUNC		08890000
+#define PROG_ERROR_PURGING		08890000
+#define PROG_ERROR_TRUNC		08890001
+#define SVC_ERROR_NO_TRUNC		08890100
+#define SVC_ERROR_PURGING		08890100
+#define SVC_ERROR_TRUNC			08890101
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_ERRORS_H */
diff -ruN linux-2.4.18-clean/include/net/sna_externs.h linux/include/net/sna_externs.h
--- linux-2.4.18-clean/include/net/sna_externs.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/sna_externs.h	Sat Jun  8 13:20:06 2002
@@ -0,0 +1,264 @@
+/* sna_externs.h: Linux-SNA external function declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#ifndef __NET_SNA_EXTERNS_H
+#define __NET_SNA_EXTERNS_H
+
+#ifdef __KERNEL__
+
+extern int sna_netid_to_char(struct sna_netid *n, unsigned char *c);
+extern struct sna_netid *sna_char_to_netid(unsigned char *c);
+extern char *sna_pr_ether(unsigned char *ptr);
+extern char *sna_pr_netid(struct sna_netid *n);
+extern char *sna_pr_nodeid(struct sna_nodeid *n);
+
+/* ASM. */
+extern int sna_asm_assign_lfsid(struct sna_assign_lfsid *as);
+extern int sna_asm_create(struct sna_start_node *start);
+extern int sna_asm_destroy(struct sna_delete_node *delete);
+extern int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_activate_as(struct sna_activate_as *as);
+extern int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* Attach. */
+extern int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb);
+extern int sna_attach_create(struct sna_start_node *start);
+extern int sna_attach_destroy(struct sna_delete_node *delete);
+
+/* COSM. */
+extern int sna_cosm_query_cos(char *arg);
+extern int sna_cosm_create(struct sna_start_node *start);
+extern int sna_cosm_destroy(struct sna_delete_node *delete);
+extern void sna_cosm_init(void);
+extern void sna_cosm_cleanup(void);
+extern int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cosm_define_cos(struct sna_define_cos *cos);
+extern int sna_cosm_delete_cos(struct sna_delete_cos *cos);
+extern int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos);
+extern int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length);
+
+/* CPIC. */
+extern struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id);
+extern unsigned long sna_cpic_create_tcb(int *err);
+extern int sna_cpic_ioctl(int cmd, void *arg);
+extern int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length);
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+extern struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf);
+
+/* CS. */
+extern struct sna_port_cb *sna_cs_find_port(struct sna_dlc_cb *dlc, 
+        char *saddr);
+extern struct sna_dlc_cb *sna_cs_find_dlc_name(char *name);
+extern int sna_cs_connect_in(struct sna_tg_cb *tg, struct sk_buff *skb, 
+	struct net_device *dev);
+extern int sna_cs_rcv_xid(struct sk_buff *skb, struct net_device *dev);
+extern int sna_cs_query_dlc(char *arg);
+extern int sna_cs_query_port(char *arg);
+extern int sna_cs_query_ls(char *arg);
+extern int sna_cs_create(struct sna_start_node *start);
+extern int sna_cs_destroy(struct sna_delete_node *delete);
+extern int sna_cs_define_dlc(struct net_device *dev);
+extern int sna_cs_delete_dlc(struct net_device *dev);
+extern int sna_cs_define_port(struct sna_define_port *port);
+extern int sna_cs_delete_port(struct sna_delete_port *port);
+extern int sna_cs_start_port(struct sna_start_port *port);
+extern int sna_cs_stop_port(struct sna_stop_port *port);
+extern int sna_cs_define_ls(struct sna_define_link_station *dls);
+extern int sna_cs_delete_ls(struct sna_delete_link_station *dls);
+extern int sna_cs_start_ls(struct sna_start_link_station *sls);
+extern int sna_cs_stop_ls(struct sna_stop_link_station *sls);
+extern int sna_cs_activate_route(struct sna_activate_route *ar);
+extern void sna_cs_connect_out(unsigned long data);
+extern int sna_cs_xid_xchg_state(struct sk_buff *skb);
+
+#ifdef CONFIG_PROC_FS
+extern int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length);
+#endif
+
+/* DLC. */
+#ifdef CONFIG_SNA_LLC
+extern int sna_dlc_llc_indicate(struct llc_prim_if_block *prim);
+extern int sna_dlc_llc_confirm(struct llc_prim_if_block *prim);
+#endif
+extern int sna_dlc_test_req(struct sna_tg_cb *tg);
+extern int sna_dlc_xid_min_len(struct sna_tg_cb *tg);
+extern int sna_dlc_xid_reserve(struct sna_tg_cb *tg, struct sk_buff *skb);
+extern int sna_dlc_xid_req(struct sna_tg_cb *tg, struct sk_buff *skb);
+extern int sna_dlc_xid_rsp(struct sna_tg_cb *tg, struct sk_buff *skb);
+
+/* DFC. */
+extern int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb);
+extern int sna_dfc_rcv(struct sk_buff *skb);
+
+/* DS. */
+extern int sna_ds_create(struct sna_start_node *start);
+extern int sna_ds_destroy(struct sna_delete_node *delete);
+
+/* EBCDIC. */
+extern unsigned char etor(unsigned char a);
+extern unsigned char etoa(unsigned char a);
+extern unsigned char atoe(unsigned char a);
+extern char *atoe_strcpy(char *dest, char *src);
+extern char *etoa_strcpy(char *dest, char *src);
+extern char *etor_strncpy(char *dest, char *src, size_t count);
+extern char *atoe_strncpy(char *dest, char *src, size_t count);
+extern char *etoa_strncpy(char *dest, char *src, size_t count);
+extern int atoe_strcmp(const char *acs, const char *ect);
+extern int etoa_strcmp(const char *ecs, const char *act);
+extern int atoe_strncmp(const char *acs, const char *ect, size_t count);
+extern int etoa_strncmp(const char *ecs, const char *act, size_t count);
+extern char *fatoe_strncpy(char *dest, char *src, size_t count);
+
+/* HS. */
+extern int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+        struct sna_rcb *rcb);
+
+/* ISR. */
+extern void sna_isr_init(void);
+extern void sna_isr_cleanup(void);
+
+/* NOF. */
+extern int sna_nof_ioctl(int cmd, void *arg);
+extern int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *len);
+extern int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_nof_define_dlc(struct net_device *dev);
+extern int sna_nof_delete_dlc(struct net_device *dev);
+extern struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n);
+
+/* PC. */
+extern void sna_pc_cleanup(void);
+extern void sna_pc_init_layer(void);
+extern int sna_pc_init(struct sna_pc_create_parms *npc);
+extern int sna_pc_destroy(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n);
+extern int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_pc_mu_error_checker(struct sk_buff *skb);
+extern int sna_pc_mu_rcv_router(struct sk_buff *skb);
+extern struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb);
+
+/* PS. */
+extern int sna_ps_conv(int verb, struct sna_tcb *tcb);
+extern int sna_ps_mc(int verb, struct sna_tcb *tcb);
+extern int sna_ps_copr(int verb, struct sna_tcb *tcb);
+extern int sna_ps_sync(int verb, struct sna_tcb *tcb);
+extern int sna_ps_verb_router(int verb, struct sna_tcb *tcb);
+extern int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb);
+
+/* RM. */
+extern struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id);
+extern __u8 sna_rm_allocate_rcb(struct sna_tcb *tcb);
+extern int sna_rm_process_hs_to_rm(struct sk_buff *skb);
+extern struct sna_rcb *sna_search_rcb(__u8 id);
+extern struct sna_tcb *sna_search_tcb(__u8 id);
+extern struct sna_scb *sna_search_scb(__u8 id);
+extern struct sna_tp *sna_search_tp(__u8 id);
+extern struct sna_partner_lu *sna_search_plu(__u8 id);
+extern struct sna_lucb *sna_search_lucb(__u8 id);
+extern struct sna_lu_lu_cb *sna_search_lulucb(__u8 id);
+extern int sna_rm_destroy(struct sna_delete_node *d);
+extern int sna_rm_define_mode(struct sna_define_mode *dm);
+extern int sna_rm_delete_mode(struct sna_delete_mode *dm);
+extern int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu);
+extern int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu);
+extern int sna_rm_define_local_lu(struct sna_define_local_lu *dlu);
+extern int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu);
+extern int sna_rm_query_mode(char *arg);
+extern int sna_rm_query_lu(char *arg);
+extern int sna_rm_query_plu(char *arg);
+extern int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_activate_session(struct sna_rm_act_session_rq *as);
+extern struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id);
+extern struct sna_mode_cb *sna_rm_find_mode(char *mode_name);
+
+/* RSS. */
+extern int sna_rss_create(struct sna_start_node *start);
+extern int sna_rss_destroy(struct sna_delete_node *delete);
+extern void sna_rss_init(void);
+extern void sna_rss_cleanup(void);
+extern int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r);
+
+/* SM. */
+extern int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l);
+extern int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal);
+extern int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as);
+
+/* SS. */
+extern int sna_ss_create(struct sna_start_node *start);
+extern int sna_ss_destroy(struct sna_delete_node *delete);
+extern int sna_ss_process_init_signal(struct sna_init_signal *init);
+extern int sna_ss_assign_pcid(struct sna_assign_pcid *pcid);
+extern int sna_ss_generate_pcid(char *net, char *name);
+extern int sna_ss_update_pcid(unsigned char *r);
+
+/* TC. */
+extern int sna_attach_rcv(struct sk_buff *skb);
+extern int sna_tc_transmit(struct sk_buff *skb);
+extern int sna_tc_send_data(struct sk_buff *skb);
+extern struct sk_buff *sna_tc_receive_data(void);
+extern int sna_tc_init(void);
+extern int sna_tc_send_mu(struct sk_buff *skb);
+extern int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* TDM. */
+extern int sna_tdm_create(struct sna_start_node *start);
+extern int sna_tdm_destroy(struct sna_delete_node *delete);
+extern void sna_tdm_init(void);
+extern void sna_tdm_cleanup(void);
+extern int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_define_node_chars(struct sna_define_node_chars *n);
+extern int sna_tdm_tg_update(struct sna_tg_update *utg);
+extern int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v);
+extern struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid);
+extern struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n,
+        unsigned char tg_num);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num);
+extern int sna_tdm_init_tg_update(struct sna_tg_update *tg);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac);
+
+/* TRS. */
+extern int sna_trs_create(struct sna_start_node *start);
+extern int sna_trs_destroy(struct sna_delete_node *delete);
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_EXTERNS_H */
diff -ruN linux-2.4.18-clean/include/net/sna_formats.h linux/include/net/sna_formats.h
--- linux-2.4.18-clean/include/net/sna_formats.h	Wed Dec 31 19:00:00 1969
+++ linux/include/net/sna_formats.h	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,4382 @@
+/* sna_formats.h: Linux-SNA data headers and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#ifndef __NET_SNA_FORMATS_H
+#define __NET_SNA_FORMATS_H
+
+#ifdef __KERNEL__
+
+/* MU.
+ */
+
+#ifdef NOT
+struct sna_sender {
+        __u8 id;
+        __u8 type;
+};
+
+struct sna_bind_rq_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        struct sna_lfsid *lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_send {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 path_id;
+        __u8 free_lfsid;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_unbind_rq {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptaive_pace;
+};
+
+struct sna_unbind_rsp_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_pc_character {
+        __u16 max_send_btu_size;
+        __u16 max_rcv_btu_size;
+        __u8 adjacent_node_bind_reasm;
+        __u8 limit_resource;
+};
+
+struct sna_bind_rq_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        struct sna_pc_character *pc_characteristics;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 tx_priority;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+#endif
+
+struct sna_hs_to_rm {
+        __u8 hs_id;
+};
+
+struct sna_rm_to_ps {
+        __u8 hs_id;
+        __u8 tcb_id;
+        __u8 rcb_id;
+        __u8 send_ru_size;
+        __u8 limit_buf_pool_id;
+        __u8 perm_buf_pool_id;
+        __u8 rcode;
+};
+
+struct sna_hs_to_ps {
+        __u8 bracket_id;
+        __u8 fmh;
+        __u8 type;
+};
+
+struct sna_ps_to_hs {
+        __u8 bracket_id;
+        __u8 ps_to_hs_variant;
+        __u8 allocate;
+        __u8 fmh;
+        __u8 type;
+};
+
+/* COMPRESSION.
+ */
+
+#ifdef NOT
+
+/* Compression algorithms */
+#define RU_COMPRESS_RLE 000
+#define RU_COMPRESS_LZ  001
+
+/* Compression header */
+struct sna_ru_compress
+{
+        unsigned char   compress:4,     /* Compression algorithm */
+                        length:4;       /* Uncmprssd data type/cmprssn hdr sz */        __u16           size;
+};
+
+/* SCB data type */
+#define RU_SCB_RAW      00
+#define RU_SCB_RESRV    01
+#define RU_SCB_MSTR_CHR 10
+#define RU_SCB_DUP_CHR  11
+
+struct sna_ru_compress_scb
+{
+        __u8    type:2,         /* SCB type */
+                count:6;        /* Uncompressed size of following data */
+};
+
+/* LZ command indicators */
+#define LZ_RESET        0x001
+#define LZ_FREEZE       0x002
+#define LZ_UNFREEZE     0x003
+
+/* LZ control sequence header */
+struct sna_lz_9bit
+{
+        __u16   cntl:9,         /* 9 bit LZ compression */
+                cmd:7;          /* LZ command */
+};
+
+struct sna_lz_10bit
+{
+        __u16   cntl:10,        /* 10 bit LZ compression */
+                cmd:6;          /* LZ command */
+};
+
+struct sna_lz_12bit
+{
+        __u16   cntl:12,        /* 12 but LZ compression  */
+                cmd:4;          /* LZ command */
+};
+
+struct sna_ru_compress_lz
+{
+        union {
+                struct sna_lz_9bit      9bit;
+                struct sna_lz_10bit     10bit;
+                struct sna_lz_12bit     12bit;
+        } size;
+};
+
+#endif
+
+/* EBCDIC.
+ */
+
+static unsigned char const ebcdic_to_rotated[256] = {
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,         /* 24 -   31 */
+         32,  33,  34,  35,  36,  37,  38,  39,         /* 32 -   39 */
+         40,  41,  42,  43,  44,  45,  46,  47,         /* 40 -   47 */
+         48,  49,  50,  51,  52,  53,  54,  55,         /* 48 -   55 */
+         56,  57,  58,  59,  60,  61,  62,  63,         /* 56 -   63 */
+         1,  65,  66,  67,  68,  69,  70,  71,          /* 64 -   71 */
+         72,  73,  74,  75,  76,  77,  78,  79,         /* 72 -   79 */
+         80,  81,  82,  83,  84,  85,  86,  87,         /* 80 -   87 */
+         88,  89,  90, 109,  92,  93,  94,  95,         /* 88 -   95 */
+         96,  97,  98,  99, 100, 101, 102, 103,         /* 96 -  103 */
+        104, 105, 106, 107, 108, 109, 110, 111,         /* 104 - 111 */
+        112, 113, 114, 115, 116, 117, 118, 119,         /* 112 - 119 */
+        120, 121, 122, 237, 241, 125, 126, 127,         /* 120 - 127 */
+        128, 129, 130, 131, 132, 133, 134, 135,         /* 128 - 135 */
+        136, 137, 138, 139, 140, 141, 142, 143,         /* 136 - 143 */
+        144, 145, 146, 147, 148, 149, 150, 151,         /* 144 - 151 */
+        152, 153, 154, 155, 156, 157, 158, 159,         /* 152 - 159 */
+        160, 161, 162, 163, 164, 165, 166, 167,         /* 160 - 167 */
+        168, 169, 170, 171, 172, 173, 174, 175,         /* 168 - 175 */
+        176, 177, 178, 179, 180, 181, 182, 183,         /* 176 - 183 */
+        184, 185, 186, 187, 188, 189, 190, 191,         /* 184 - 191 */
+        192,   7,  11,  14,  19,  23,  27,  31,         /* 192 - 199 */
+         35,  39, 202, 203, 204, 205, 206, 207,         /* 200 - 207 */
+        208,  71,  75,  79,  83,  87,  91,  95,         /* 208 - 215 */
+         99, 103, 218, 219, 220, 221, 222, 223,         /* 216 - 223 */
+        224, 225, 139, 143, 147, 151, 155, 159,         /* 224 - 231 */
+        163, 167, 234, 235, 236, 237, 238, 239,         /* 232 - 239 */
+        195, 199, 203, 207, 211, 215, 219, 223,         /* 240 - 247 */
+        227, 231, 250, 251, 252, 253, 254, 255          /* 248 - 255 */
+};
+
+static unsigned char const ebcdic_to_ascii_sna[256] =
+{
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,
+         32,  33,  34,  35,  36,  37,  38,  39,
+         40,  41,  42,  43,  44,  45,  46,  47,
+         48,  49,  50,  51,  52,  53,  54,  55,
+         56,  57,  58,  59,  60,  61,  62,  63,
+         32,  65,  66,  67,  68,  69,  70,  71,
+         72,  73,  74,  75,  76,  77,  78,  79,
+         80,  81,  82,  83,  84,  85,  86,  87,
+         88,  89,  90,  91,  92,  93,  94,  95,
+         96,  97,  98,  99, 100, 101, 102, 103,
+        104, 105, 106, 107, 108, 109, 110, 111,
+        112, 113, 114, 115, 116, 117, 118, 119,
+        120, 121, 122, 123, 124, 125, 126, 127,
+        128, 129, 130, 131, 132, 133, 134, 135,
+        136, 137, 138, 139, 140, 141, 142, 143,
+        144, 145, 146, 147, 148, 149, 150, 151,
+        152, 153, 154, 155, 156, 157, 158, 159,
+        160, 161, 162, 163, 164, 165, 166, 167,
+        168, 169, 170, 171, 172, 173, 174, 175,
+        176, 177, 178, 179, 180, 181, 182, 183,
+        184, 185, 186, 187, 188, 189, 190, 191,
+        192,  65,  66,  67,  68,  69,  70,  71,
+         72,  73, 202, 203, 204, 205, 206, 207,
+        208,  74,  75,  76,  77,  78,  79,  80,
+         81,  82, 218, 219, 220, 221, 222, 223,
+        224, 225,  83,  84,  85,  86,  87,  88,
+         89,  90, 234, 235, 236, 237, 238, 239,
+        240, 241, 242, 243, 244, 245, 246, 247,
+        248, 249, 250, 251, 252, 253, 254, 255
+};
+
+static unsigned char const ascii_to_ebcdic_sna[256] =
+{
+          0,   1,   2,   3,  55,  45,  46,  47,         /* 0  -    7 */
+         22,   5,  37,  11,  12,  13,  14,  15,         /* 8  -   15 */
+         16,   0,   0,   0,   0,  61,  50,  38,         /* 16 -   23 */
+         24,  25,  63,  39,   0,   0,   0,   0,         /* 24 -   31 */
+         64,   0, 127, 123,  80, 108,  91, 121,         /* 32 -   39 */
+         77,  93,  53,  78, 107,  96,  75,  97,         /* 40 -   47 */
+        240, 241, 242, 243, 244, 245, 246, 247,         /* 48 -   55 */
+        248, 249, 122,  94,  76, 126, 110, 111,         /* 56 -   63 */
+        124, 193, 194, 195, 196, 197, 198, 199,         /* 64 -   71 */
+        200, 201, 209, 210, 211, 212, 213, 214,         /* 72 -   79 */
+        215, 216, 217, 226, 227, 228, 229, 230,         /* 80 -   87 */
+        231, 232, 233,  74, 224,   0,  95, 109,         /* 88 -   95 */
+        125, 129, 130, 131, 132, 133, 134, 135,         /* 96 -  103 */
+        136, 137, 145, 146, 147, 148, 149, 150,         /* 104 - 111 */
+        151, 152, 153, 162, 163, 164, 165, 166,         /* 112 - 119 */
+        167, 168, 169, 192, 106, 208, 161,   7,         /* 120 - 127 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 128 - 135 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 136 - 143 */
+          0,   0,   0,   0,   0,   0,   0		/* 144 - 150 */
+};
+
+/* FM.
+ */
+
+/* FMH type indicators */
+#define FMH_1                   0x01            /* FMH-1 */
+#define FMH_2                   0x02            /* FMH-2 */
+#define FMH_3			0x03
+#define FMH_4                   0x04            /* FMH-4 */
+#define FMH_5                   0x05            /* FMH-5 */
+#define FMH_6                   0x06            /* FMH-6 */
+#define FMH_7                   0x07            /* FMH-7 */
+#define FMH_10                  0x0A       	/* FMH-10 */
+#define FMH_12                  0x0C            /* FMH-12 */
+#define FMH_18			0x12
+#define FMH_19			0x13
+
+/* FMH header descriptions. */
+#define SNA_FMH_HDR_ERROR       FMH_1
+#define SNA_FMH_HDR_ATTACH      FMH_1
+#define SNA_FMH_HDR_SECURITY    FMH_1
+
+/* FMH concatenation indicators */
+#define FMH_CONCAT_TRUE         1
+#define FMH_CONCAT_FALSE        0
+
+/* FMH media indicators */
+#define FMH_CONSOLE             0000    /* Console */
+#define FMH_XCHANGE             0001    /* Exchange */
+#define FMH_CARD                0010    /* Card */
+#define FMH_DOCUMENT            0011    /* Document */
+#define FMH_NXCHANGE_DISK       0100    /* Non-exchange disk */
+#define FMH_XDOCUMENT           0101    /* Extended document */
+#define FMH_XCARD               0110    /* Extended card */
+#define FMH_DATA_SELECT         0111    /* Data set name select destination */
+#define FMH_WP_1                1000    /* Word processing media 1 */
+#define FMH_WP_2                1001    /* Word processing media 2 */
+#define FMH_WP_3                1010    /* Word processing media 3 */
+#define FMH_RESRV_1             1011    /* Reserved */
+#define FMH_WP_4                1100    /* Word processing media 4 */
+#define FMH_RESRV_2             1101    /* Reserved */
+#define FMH_RESRV_3             1110    /* Reserved */
+#define FMH_RESRV_4             1111    /* Reserved */
+
+/* FMH data stream profile indicators */
+#define DSP_DEFAULT             0000    /* Default */
+#define DSP_BASE                0001    /* Base */
+#define DSP_GENERAL             0010    /* General */
+#define DSP_JOB                 0011    /* Job */
+#define DSP_WP_RAW              0100    /* WP raw-form text */
+#define DSP_WP_XCHANGE_DISK     0101    /* WP exchange diskette */
+#define DSP_RESRV_1             0110    /* Reserved */
+#define DSP_OII_2               0111    /* Office Info. Interchange level 2 */
+#define DSP_RESRV_2             1000    /* Reserved */
+#define DSP_RESRV_3             1001    /* Reserved */
+#define DSP_DOC_INTERCHANGE     1010    /* Document interchange */
+#define DSP_STRUCT              1011    /* Structured field */
+#define DSP_RESRV_4             1100    /* Reserved */
+#define DSP_RESRV_5             1101    /* Reserved */
+#define DSP_RESRV_6             1110    /* Reserved */
+#define DSP_RESRV_7             1111    /* Reserved */
+
+/* FMH destination selection indicators */
+#define DSSEL_RESUME            000     /* Resume */
+#define DSSEL_END               001     /* End */
+#define DSSEL_BEGIN             010     /* Begin */
+#define DSSEL_BEGIN_END         011     /* Begin/end */
+#define DSSEL_SUSPEND           100     /* Suspend */
+#define DSSEL_END_ABORT         101     /* End-abort */
+#define DSSEL_CONTINUE          110     /* Continue */
+#define DSSEL_RESRV_1           111     /* Reserved */
+
+/* FMH compaction indicators */
+#define FMH_COMPACT_TRUE        1       /* Compaction */
+#define FMH_COMPACT_FLASE       0       /* No compaction */
+
+/* SNA Function Managment 1 header */
+struct sna_fmh1
+{
+        __u8    medium:4,       /* Desired medium for data */
+                lsubaddr:4;     /* Logical subaddress */
+        __u8    sri:1,          /* Stack Reference indicator */
+                dmsel:1,        /* Demand select */
+                rsv_1:2,        /* Reserved */
+                dsp:4;          /* Data stream profiles */
+        __u8    dssel:3,        /* Destination selection */
+                dst:1,          /* Data set transmission */
+                rsv_2:1,        /* Reserved */
+                cmi:1,          /* FMH-1 SCB compression indicator */
+                cpi:1,          /* Compaction indicator */
+                rsv_3:1;        /* Reserved */
+        __u8    ecrl;           /* Exchange record length */
+        __u16   rsv_4;          /* Reserved */
+        __u8    dslen;          /* Length of destination name */
+
+        unsigned char *dsname;  /* Destination name, unlimited length */
+};
+
+/* FMH-2 function indicators */
+#define FMH2_PDIR               0x01    /* Peripheral data information record */#define FMH2_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH2_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH2_XCUTE_PG_OFFLN     0x07    /* Execute program offline */
+#define FMH2_CREATE_DATA_SET    0x20    /* Create data set */
+#define FMH2_SCRATCH_DATA_SET   0x21    /* Scratch data set */
+#define FMH2_ERASE_DATA_SET     0x22    /* Erase data set */
+#define FMH2_PASSWORD           0x23    /* Password */
+#define FMH2_ADD                0x24    /* Add */
+#define FMH2_REPLACE            0x25    /* Replace */
+#define FMH2_ADD_REPLICATE      0x26    /* Add replicate */
+#define FMH2_REPLACE_REPLIACTE  0x27    /* Replace replicate */
+#define FMH2_QUERY_DATA_SET     0x28    /* Query for data set */
+#define FMH2_NOTE               0x29    /* Note */
+#define FMH2_REC_ID             0x2B    /* Record ID */
+#define FMH2_ERASE_REC          0x2C    /* Erase record */
+#define FMH2_SCRATCH_ALL_SETS   0x2D    /* Scratch all data sets */
+#define FMH2_VOL_ID             0x2E    /* Volume ID */
+#define FMH2_NOTE_REPLY         0xAA    /* Note reply */
+
+/* FMH-3 function indicators */
+#define FMH3_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH3_QUERY_COMPACT_TBLE 0x03    /* Query for compaction table */
+#define FMH3_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH3_STATUS             0x05    /* Status */
+#define FMH3_SERIES_ID          0x06    /* Series ID */
+
+/* SNA Function Managment 2 and 3 header */
+struct sna_fmh2
+{
+        __u8    sri:1,          /* Stack reference indicator */
+                fmh2cmd:7;      /* FMH-2 function to be performed */
+
+        unsigned char *fmh2opt; /* Parameter fields, unlimited length */
+};
+
+/* FMH-4 block transmission type indicators */
+#define FMH4_INHERIT            0x00    /* Inherit code */
+/* FMH4 0x01 - 0x3F */                  /* Reserved */
+#define FMH4_FFR_FNI            0x40    /* FFR-FNI record */
+#define FMH4_FFR_FS             0x41    /* FFR-FS record */
+#define FMH4_FFR_FS2            0x42    /* FFR-FS2 record */
+/* FMH4 0x43 - 0x4F */                  /* Reserved */
+/* FMH4 0x50 - 0xFF */                  /* Reserved */
+
+/* FMH-4 command indicators */
+#define FMH4_CRT_NU_BLK         0x00    /* CRT-NU-BLK */
+#define FMH4_CRT_SU_BLK         0x02    /* CRT-SU-BLK */
+#define FMH4_CRT_SN_BLK         0x03    /* CRT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_DEL_SN_BLK         0x23    /* DEL-SN-BLK */
+#define FMH4_UPD_SU_BLK         0x32    /* UPD-SU-BLK */
+#define FMH4_UPD_SN_BLK         0x33    /* UPD-SN-BLK */
+#define FMH4_RPL_SU_BLK         0x42    /* RPL-SU-BLK */
+#define FMH4_RPL_SN_BLK         0x43    /* RPL-SN-BLK */
+
+/* SNA Function Managment 4 header */
+struct sna_fmh4
+{
+        __u8    fmh4fxct;       /* Length of fixed length parameters */
+        __u8    fmh4tt1;        /* Block transmission type */
+        __u8    fm4htt2;        /* Block transmission type qualifier */
+        __u8    fmh4cmd;        /* Command */
+        __u8    rsv1:2,         /* Reserved */
+                f4rdescr:2,     /* Record descriptor flag */
+                rsv2:2,         /* Reserved */
+                fmh4bdtf:1,     /* Block data transform flag */
+                fmh4rdtf:1;     /* Reserved */
+        __u8    fmh4lbn;        /* Length of FMH4BN */
+
+        __u8    *fmh4bn;        /* Name of block */
+
+        __u8    fmh4lbdt;       /* Length of FMH4BDT */
+
+        unsigned char fmh4bdt;  /* Block data transform */
+
+        __u8    fmh4lvid;       /* Length of FMH4VID */
+
+        unsigned char fmh4vid;  /* Version identifier */
+};
+
+struct fmh5_sec_access
+{
+        __u8    length;         /* Length */
+        __u8    type;           /* Subfield type */
+        unsigned char data;     /* Security data about receiver */
+};
+
+/* PIP header */
+struct piph
+{
+        __u16   length;
+        __u16   gds;            /* GDS indicator */
+
+        /* PIP sub-fields of structure piph, unlimited length */
+        unsigned char sub_pip;
+};
+
+/* SNA Function Managment 5 header (LU 6.2) */
+struct sna_fmh5
+{
+        __u16   cmd     __attribute__ ((packed));               /* Command code
+*/
+        __u8    vid:1,          /* Already-verified indicator */
+                pvid:2,         /* Persistent-verification indicator */
+                spwdi:1,        /* Substituted password indicator */
+                pipi:1,         /* Program init parameter (PIP) presence */
+                xaid:1,         /* Extended authentication indicator */
+                rsv1:2;         /* Reserved */
+        __u8    fxct    __attribute__ ((packed));               /* Fixed length
+parameters */
+
+        __u8    resrc_type      __attribute__ ((packed));
+        __u8    rsv2    __attribute__ ((packed));
+        __u8    sync_level:2,
+                rsv3:6;
+        /* The options start here */
+        __u8    raw;
+};
+
+#ifdef NOT_LU62
+
+/* SNA Function Managment 5 header (Not LU 6.2) */
+struct sna_fmh5
+{
+        __u8    length;         /* Length of FMH-5 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000101 */
+        __u8    fmh5cmd;        /* Command code */
+        __u8    fmh5mod;        /* Modifier */
+        __u8    fmh5fxct;       /* Fixed length parameters */
+        __u8    attdsp;
+        __u8    attdba;
+
+        unsigned char *names;   /* Resource names, unlimited length */
+};
+
+#endif  /* CONFIG_SNA_LU62 */
+
+/* SNA Function Managment 6 header */
+struct sna_fmh6
+{
+        __u8    length;         /* Length of FMH-6 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000110 */
+        __u8    fmh6cmd;        /* Command code */
+        __u8    fmh6lnsz:1,     /* Length of parameter length fields */
+                rsv1:7;         /* Reserved */
+
+        /* Many variable lenth params */
+};
+
+/* SNA Function Managment 7 header (LU 6.2) */
+struct sna_fmh7
+{
+        __u8    length;         /* Length of FMH-7 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0000111 */
+        __u32   erpsense;       /* Sense Data */
+        __u8    erplog:1,       /* Error log variable presence */
+                rsv2:7;         /* Reserved */
+};
+
+/* SNA Function Managment 8 header (LU 6.1) */
+struct sna_fmh8
+{
+        __u8    *raw;
+};
+
+/* SNA Function Managment 10 header */
+struct sna_fmh10
+{
+        __u8    length;         /* Length of FMH-10 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0001010 */
+        __u16   spccmd;         /* Sync point command */
+        __u16   spcmod;         /* Sync point modifier */
+};
+
+/* SNA Function Managment 12 header (LU 6.2) */
+struct sna_fmh12
+{
+        __u8    length;         /* Length of FMH-12 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0001100 */
+
+        unsigned char fmh12mac[7];      /* DES Message Authentication Code */
+};
+
+struct fmhdr {
+        __u8    len     __attribute__ ((packed));
+	__u8	type	__attribute__ ((packed));
+/*
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    type:7  __attribute__ ((packed));
+*/
+
+        union {
+                struct sna_fmh1         f1      __attribute__ ((packed));
+                struct sna_fmh2         f2      __attribute__ ((packed));
+                struct sna_fmh4         f4      __attribute__ ((packed));
+                struct sna_fmh5         f5      __attribute__ ((packed));
+                struct sna_fmh6         f6      __attribute__ ((packed));
+                struct sna_fmh7         f7      __attribute__ ((packed));
+                struct sna_fmh8         f8      __attribute__ ((packed));
+                struct sna_fmh10        f10     __attribute__ ((packed));
+                struct sna_fmh12        f12     __attribute__ ((packed));
+        } fm;
+};
+
+/* GDS.
+ */
+
+/*
+ * SNA GDS (Global Data Stream) definitions
+ *
+ * Identifer registery
+ * 0000 - 01FF          3270
+ * 03xx                 3270
+ * 06xx                 3270
+ * 09xx                 3270
+ * 0B00 - 0EFF          3270
+ * 0Fxx                 3270
+ * 101x                 3270
+ * 1030 - 1034          Print Job Restart
+ * 1058 - 105B          Workstation Platform/2
+ * 1100 - 1104          SNA Character String
+ * 12xx                 LU 6.2 and APPN
+ * 13xx                 SNA/Management Services
+ * 140x                 3820 Page Priner
+ * 1500                 Dependent LU Requester/Server
+ * 1501                 Subarea Routing Services
+ * 1520                 DLSw Capabilities eXchange
+ * 1521                 DLSw Capabilities eXchange Positive Response
+ * 1522                 DLSw Capabilities eXchange Negative Response
+ * 1530 - 1531          SNA File Services
+ * 1532                 SNA Condition Report
+ * 1533 - 154F          SNA File Services
+ * 1550 - 155F          SNA File Services
+ * 1570 - 158F          SNA/Distribution Services
+ * 4000 - 41FF          3270
+ * 4A00 - 4CFF          3270
+ * 71xx                 3250
+ * 8000 - 81FF          3270
+ * C00x                 Document Interchange Architecture
+ * C100 - C104          Document Interchange Architecture
+ * C105                 SNA/Distribution Services
+ * C10A - C122          Document Interchange Architecture
+ * C123 - C124          SNA/Distribution Services
+ * C219                 Document Interchange Architecture
+ * C300 - C345          Document Interchange Architecture
+ * C350 - C361          SNA/Distribution Services
+ * C366 - C46F          Document Interchange Architecture
+ * C500 - C56F          Document Interchange Architecture
+ * C600 - C66F          Document Interchange Architecture
+ * C7xx                 Graphical Display Data Manager
+ * C800 - C87F          Document Interchange Architecture
+ * C900 - CB0F          Document Interchange Architecture
+ * CC00 - CC3F          Document Interchange Architecture
+ * CF0x                 Document Interchange Architecture
+ * D0xx                 Distributed Data Management
+ * D3xx                 Document Content Architecture
+ * D6xx                 Intelligent Printer Data Stream
+ * D780 - D7BF          Facsimile Architecture
+ * D820 - D821          AS/400 (5250)
+ * D822 - D826          AS/400 (5394)
+ * D930 - D95F          AS/400 (5250)
+ * E10x                 Level-3 Document Content Architecture
+ * E20x                 Level-3 Document Content Architecture
+ * E30x                 Level-3 Document Content Architecture
+ * E40x                 Level-3 Document Content Architecture
+ * E50x                 Level-3 Document Content Architecture
+ * E60x                 Level-3 Document Content Architecture
+ * E70x                 Level-3 Document Content Architecture
+ * E80x                 Level-3 Document Content Architecture
+ * E90x                 Level-3 Document Content Architecture
+ * EA0x                 Level-3 Document Content Architecture
+ * EFFF                 IBM TokenRing Network PC Adapter
+ * F000 - FEFF          Non-IBM Reserve Block
+ * FFxx                 Context-Dependent Block
+ */
+
+/*
+ * SNA Service Transaction Programs (STPs)
+ */
+#define SNA_GDS_CHG_NUM_SESS            0x1210
+typedef struct {
+        __u8    rsv1:4,
+                service_flag:4;
+        __u8    reply_mod;
+        __u8    action;
+        __u8    rsv2:3,
+                src_lu_drain:1,
+                rsv3:3,
+                dst_lu_drain:1;
+        __u8    rsv4:7,
+                sess_deact_resp:1;
+        __u16   rsv5:1,
+                max_sess_cnt:15;
+        __u16   rsv6:1,
+                src_g_min_cont_win:15;
+        __u16   rsv7:1,
+                dst_g_min_cont_win:15;
+        __u8    rsv8:7,
+                affect_mode_names:1;
+        __u8    mode_name_len;
+        __u8    mode_name;                      /* Start of Mode Name */
+} gds_chg_num_sess;
+
+struct sna_gds {
+        __u16   cvlen:16;
+        __u16   cvid:16;
+
+        union {
+
+        } cv;
+};
+
+/* HPR.
+ */
+
+/* Switching mode defines */
+#define HPR_FUNCT_RT    101
+#define HPR_ANR         110
+
+/* NLP Time-Sensitivity */
+#define NLP_NOT_TIME_SENSE      0
+#define NLP_TIME_SENSE          1
+
+/* Congestion defines */
+#define NLP_SLOW1_TRUE          1
+#define NLP_SLOW1_FLASE         0
+#define NLP_SLOW2_TRUE          1
+#define NLP_SLOW2_FLASE         0
+
+/* HPR Network Layer Header (NHDR) */
+struct sna_nhdr
+{
+        __u8    sm:3,           /* Switching mode */
+                __pad1:2,
+                tpf:2,          /* Transmission priority field */
+                __pad2:1;
+        __u8    ftype:4,        /* Function type */
+                tsdata:1,       /* Time-sensitive packet indicator */
+                slow1:1,        /* Slowdown (minor) indicator */
+                slow2:1,        /* Slowdown (significant) indicator */
+                __pad3:1;
+
+        /* Variable length data fields */
+};
+
+/* PS.
+ */
+
+/* Flag structures for PS10 header */
+struct psh10_prepare
+{
+        __u8    luname:1,       /* LU names indicator */
+                wait:1,         /* Wait for outcome indicator */
+                __pad1:3,
+                locks:1,        /* LOCKS parameter indicator */
+                __pad2:2;
+};
+
+struct psh10_rqcommit
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                wait:1,         /* Wait for outcome indicator */
+                reliable:1,     /* Resource reliability indicator */
+                sprq:1,         /* OK to leave out sync-point request */
+                rreport:1,      /* Initiator read-only reporting */
+                locks:1,        /* LOCKS parameter indicator */
+                __pad1:2;
+};
+
+struct psh10_committed
+{
+        __u8    __pad1:1,
+                resync:1,       /* Resync processing status */
+                sluwid:1,       /* Source of next LUWID */
+                sprq:1,         /* OK to leave out sync-point request */
+                ifexcpt:1,      /* Implied Forget expectation indicator */
+                __pad2:3;
+};
+
+struct psh10_forget
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                resync:1,       /* Resync processing status */
+                __pad1:6;
+};
+
+struct psh10_hm
+{
+        __u8    __pad1:2,
+                sluwid:1,       /* Source of next LUWID */
+                __pad2:5;
+};
+
+struct psh10_nluwid
+{
+        __u8    __pad1;
+};
+
+/* PS10 header */
+struct sna_psh10
+{
+        __u8    length;         /* Length */
+
+        __u8    rsv:1,
+                type:7;
+
+        union {
+                struct psh10_prepare    prepare;
+                struct psh10_rqcommit   rqcommit;
+                struct psh10_committed  committed;
+                struct psh10_forget     forget;
+                struct psh10_hm         hm;
+                struct psh10_nluwid     nluwid;
+        } flags;
+
+        __u8    spptype;        /* Sync-point command type */
+
+        /* Command specific data here */
+
+        __u16   flowmod;        /* Modifier specifying next flow */
+
+        unsigned char sndlen[7];        /* Number of bytes sent */
+
+        /* All kinds of variable length structures */
+};
+
+/* TH.
+ */
+
+#define SNA_TH_FID0     0x0
+#define SNA_TH_FID1     0x1
+#define SNA_TH_FID2     0x2
+#define SNA_TH_FID3     0x3
+#define SNA_TH_FID4     0x4
+#define SNA_TH_FID5     0x5
+#define SNA_TH_FIDF     0xF
+
+#define SNA_TH_MPF_BBIU         0x2     /* 10 */
+#define SNA_TH_MPF_EBIU         0x1     /* 01 */
+#define SNA_TH_MPF_WHOLE_BIU    0x3     /* 11 */
+#define SNA_TH_MPF_NO_BIU       0x0     /* 00 */
+#define SNA_TH_MPF_MID_MIU      SNA_TH_MPF_NO_BIU
+
+#define SNA_TH_EFI_NORM         0x0
+#define SNA_TH_EFI_EXP          0x1
+
+typedef struct {
+        __u16   biui:1,
+                sqn:15;
+} sna_snf;
+
+/* FID0 and FID1 formats are used between adjacent subarea nodes when
+ * either or both nodes do not support ER and VR protocols.
+ */
+struct sna_fid0 {
+	__u8	ft:4;
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                 efi:1;         /* Expedited Flow Indicator. */
+        __u8    rsv2;
+        __u16   daf;            /* Destination Address Field. */
+        __u16   oaf;            /* Origin Address Field. */
+        sna_snf snf;            /* Sequence Number Field. */
+        __u16   dcf;            /* Data Count Field. */
+};
+
+struct sna_fid2_cheat {
+	__u8	bits[6];
+};
+
+struct sna_fid2 {
+	__u8    ft:4    __attribute__ ((packed));
+        __u8    mpf:2   __attribute__ ((packed));
+        __u8    odai:1  __attribute__ ((packed));
+        __u8    efi:1   __attribute__ ((packed));
+        __u8    rsv1    __attribute__ ((packed));
+        __u8    daf     __attribute__ ((packed));
+        __u8    oaf     __attribute__ ((packed));
+        sna_snf snf     __attribute__ ((packed));
+};
+
+struct sna_fid3 {
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                efi:1;          /* Expedited Flow indicator. */
+        __u8    lsid;           /* Local session identification. */
+};
+
+struct sna_fid4 {
+        __u8    tg_sweep:1,
+                er_vr_supp_ind:1,
+                vr_pac_cnt_ind:1,
+                ntwk_prty:1;
+
+        __u8    tgsf:2,
+                rsv1:2,
+                chk:1,
+                hft:1,
+                piubf:2;
+
+        __u8    nlpoi:1,
+                nlp_cnt:3,
+                ern:4;
+
+        __u8    vrn:4,
+                rsv2:2,
+                tpf:2;
+
+        __u16   vr_cwi:1,
+                tg_nonfifo_ind:1,
+                vr_sqti:2,
+                tg_snf:12;
+
+        __u16   vrprq:1,
+                vrprs:1,
+                vr_cwri:1,
+                vr_rwi:1,
+                vr_snf_send:12;
+
+        __u8    dsaf[4];
+        __u8    osaf[4];
+
+        __u8    rsv3:3,
+                snai:1,
+                mpf:2,
+                rsv4:1,
+                efi:1;
+
+        __u8    rsv5;
+
+        __u16   def;
+        __u16   oef;
+        sna_snf snf;
+        __u16   dcf;
+};
+
+struct sna_fid5 {
+        __u8    mpf:2,
+                rsv1:1,
+                efi:1;
+
+        __u8    rsv2;
+
+        sna_snf snf;
+
+        __u8    sa[8];
+};
+
+struct sna_fidf {
+        __u8    rsv1:4;
+        __u8    rsv2;
+        __u8    cmd_fmt;        /* 0x01. */
+        __u8    cmd_type;       /* 0x01. */
+        __u16   cmd_snf;
+        __u8    rsv3[18];
+        __u16   dcf;
+};
+
+struct snathdr {
+        union {
+                struct sna_fid0 f0      __attribute__ ((packed));
+                struct sna_fid2 f2      __attribute__ ((packed));
+                struct sna_fid3 f3      __attribute__ ((packed));
+                struct sna_fid4 f4      __attribute__ ((packed));
+                struct sna_fid5 f5      __attribute__ ((packed));
+                struct sna_fidf ff      __attribute__ ((packed));
+        } fid;
+};
+
+/* RH.
+ */
+
+#define SNA_RH_RRI_REQ          0x0
+#define SNA_RH_RRI_RSP          0x1
+
+#define SNA_RH_RU_FMD           0x0     /* 00 */
+#define SNA_RH_RU_NC            0x1     /* 01 */
+#define SNA_RH_RU_DFC           0x2     /* 10 */
+#define SNA_RH_RU_SC            0x3     /* 11 */
+
+#define SNA_RH_FI_NO_FMH        0x0
+#define SNA_RH_FI_FMH           0x1
+
+#define SNA_RH_SDI_NO_SD        0x0
+#define SNA_RH_SDI_SD           0x1
+
+#define SNA_RH_BCI_NO_BC        0x0
+#define SNA_RH_BCI_BC           0x1
+
+#define SNA_RH_ECI_NO_EC        0x0
+#define SNA_RH_ECI_EC           0x1
+
+#define SNA_RH_DR1I_NO_DR1      0x0
+#define SNA_RH_DR1I_DR1         0x1
+
+#define SNA_RH_LLCI_NO_LLC      0x0
+#define SNA_RH_LLCI_LLC         0x1
+
+#define SNA_RH_DR2I_NO_DR2      0x0
+#define SNA_RH_DR2I_DR2         0x1
+
+#define SNA_RH_RTI_POS          0x0
+#define SNA_RH_RTI_NEG          0x1
+
+#define SNA_RH_RLWI_NO_RLW      0x0
+#define SNA_RH_RLWI_RLW         0x1
+
+#define SNA_RH_QRI_NO_QR        0x0
+#define SNA_RH_QRI_QR           0x1
+
+#define SNA_RH_PI_NO_PAC        0x0
+#define SNA_RH_PI_PAC           0x1
+
+#define SNA_RH_BBI_NO_BB        0x0
+#define SNA_RH_BBI_BB           0x1
+
+#define SNA_RH_EBI_NO_EB        0x0
+#define SNA_RH_EBI_EB           0x1
+
+#define SNA_RH_CDI_NO_CD        0x0
+#define SNA_RH_CDI_CD           0x1
+
+#define SNA_RH_CSI_CODE0        0x0
+#define SNA_RH_CSI_CODE1        0x1
+
+#define SNA_RH_EDI_NO_ED        0x0
+#define SNA_RH_EDI_ED           0x1
+
+#define SNA_RH_PDI_NO_PD        0x0
+#define SNA_RH_PDI_PD           0x1
+
+#define SNA_RH_CEBI_NO_CEB      0x0
+#define SNA_RH_CEBI_CEB         0x1
+
+struct snarhdr {
+        /* 1st byte */
+        __u8    rri:1   __attribute__ ((packed));
+        __u8    ru:2    __attribute__ ((packed));
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    fi:1    __attribute__ ((packed));
+        __u8    sdi:1   __attribute__ ((packed));
+        __u8    bci:1   __attribute__ ((packed));
+        __u8    eci:1   __attribute__ ((packed));
+
+        /* 2nd byte */
+        __u8    dr1i:1  __attribute__ ((packed));
+        __u8    llci:1  __attribute__ ((packed));
+        __u8    dr2i:1  __attribute__ ((packed));
+        __u8    rti:1   __attribute__ ((packed));
+        __u8    rsv2:1  __attribute__ ((packed));
+        __u8    rlwi:1  __attribute__ ((packed));
+        __u8    qri:1   __attribute__ ((packed));
+        __u8    pi:1    __attribute__ ((packed));
+
+        /* 3rd byte */
+        __u8    bbi:1   __attribute__ ((packed));
+        __u8    ebi:1   __attribute__ ((packed));
+        __u8    cdi:1   __attribute__ ((packed));
+        __u8    rsv3:1  __attribute__ ((packed));
+        __u8    csi:1   __attribute__ ((packed));
+        __u8    edi:1   __attribute__ ((packed));
+        __u8    pdi:1   __attribute__ ((packed));
+        __u8    cebi:1  __attribute__ ((packed));
+};
+
+/* RU.
+ */
+
+/* ABCONN (Abandon Connection) */
+struct sna_abconn {
+        __u16 ena;
+};
+
+/* ABCONNOUT (Abandon Connect Out) */
+struct sna_abconnout {
+        __u16 ena;
+};
+
+/* Type of activation indicators */
+#define COLD    0x1
+#define ERP     0x2
+
+struct sna_sscp_id {
+        __u8    format:4,
+                pu_type:4;
+        char    id[4];
+};
+
+/* ACTDRM (Activate Cross-Domain Resource Manager) */
+struct sna_actcdrm {
+        __u8    request;        /* 0x14 */
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile;
+        __u8    ts_profile;
+        char    contents_id[7];
+        struct  sna_sscp_id *sscp_id;
+        __u8    __pad1:2,
+                primary_hs_rcv_win_size:6;
+};
+
+/* ACTCONNIN (Activate Conect In) */
+struct sna_actconnin {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    incoming_call:1,
+                info_rq:1,
+                __pad1:6;
+};
+
+/* ACTLINK (Activate Link) */
+struct sna_actlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    switched_subarea:1,
+                sub_llink:1,
+                __pad1:6;
+};
+
+/* ACTLU (Activate Logical Unit) */
+struct sna_actlu {
+        __u8    request_code;
+        __u8    eami:1,         /* Enhanced Addr. Management Indicator */
+                sdai:1,         /* Static/dynamic addr. indicator */
+                __pad1:4,
+                type_activation:2;
+        __u8    fm_profile:4,
+                ts_profile:4;
+};
+
+/* ACTPU (Activate Physical Unit) */
+struct sna_actpu {
+        __u8    request_code;
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile:4,
+                ts_profile:4;
+        struct sna_sscp_id *sscp_id;
+};
+
+/* ACTTRACE (Activate Trace) */
+struct sna_trace_bit {
+        __u8    tx_group:1,
+                piu:1,
+                __pad1:2,
+                scanner_internal:1,
+                __pad2:1,
+                all_frames:1,
+                link:1;
+};
+
+struct sna_acttrace {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct sna_trace_bit *trace;
+
+        /* Some trace specific trailers */
+};
+
+/* ADDLINK (Add Link) */
+struct sna_addlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u16   __pad1;
+        __u8    size_llink_id;
+        /* 8-n llink ID */
+};
+
+/* ADDLINKSTA (Add Link Station) */
+struct sna_fid_bit {
+        __u8    fid0:1,
+                fid1:1,
+                fid2:1,
+                fid3:1,
+                fid4:1,
+                __pad1:3;
+};
+
+struct sna_addlinksta {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct  sna_fid_bit *fid;
+        __u8    __pad1;
+        __u8    size_linksta_id;
+        /* 8-n Link station ID */
+};
+
+/* ANA (Assign Network Addresses) */
+struct sna_ana {
+        /* Retired */
+};
+
+/* BFCINIT (BF Control Initiate) */
+struct sna_bfcinit {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:1,
+                sub_source:1,
+                save_rscv:1,
+                copy_rscv:1,
+                sub_names:2,
+                ext_bind:1,
+                __pad3:1;
+        char    __pad4[4];
+        __u16   size_bind_image;
+        /* Bind Image */
+        /* Other variable length goodies */
+};
+
+/* BFCLEANUP (BF Cleanup) */
+struct sna_bfcleanup {
+        /* 0-2 NS header, 0x812629 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   __pad2;
+
+        /* Session keys */
+        /* Control Vectors */
+};
+
+/* BFINIT (BF Initiate) */
+struct sna_bfinit {
+        /* 0-2 NS header, 0x812681 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   size_bind_image;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSEND (BF Session Ended) */
+struct sna_bfsessend {
+        /* 0-2 NS header, 0x812688 */
+        __u16   ena;
+        __u8    format:4,
+                lu_role:1,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSINFO (BF Session Information) */
+struct sna_bfsessinfo {
+        /* 0-2 NS header, 0x81268C */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    als_takeover:1,
+                lu_takeover:1,
+                auth_lu:1,
+                sdai:1,
+                static_lu_addr_status:1,
+                __pad2:3;
+        __u16   __pad3;
+        __u8    size_lu_name;
+
+        /* Network Qualified LU name */
+        /* Control Vectors */
+};
+
+/* BFSESSST (BF Session Started) */
+struct sna_bfsessst {
+        /* 0-2 NS header, 0x812686 */
+        __u16   ena;
+        __u8    format:4,
+                __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFTERM (BF Terminate) */
+struct sna_bfterm {
+        /* 0-2 NS header, 0x812683 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BID (BID) Not for LU6.2 */
+struct sna_nonlu62_bid {
+        __u8    request_code;
+};
+
+/* BIND (BIND Session) */
+#define BIND_RQ			0x31
+
+#define BIND_FORMAT_NEG		0x00
+#define BIND_FORMAT_NONNEG	0x01
+
+#define TSH_2			0x02
+#define TSH_3			0x03
+#define TSH_4			0x04
+#define TSH_7			0x07
+
+#define CV_COS_TPF		0x2C
+#define CV_FQ_PCID		0x60
+#define CV_ROUTE_SEL		0x2B
+#define CV_TG_DESC		0x46
+#define CV_TG_ID		0x80
+
+#pragma pack(1)
+struct sna_bind {
+/* 0 */ __u8    request_code		__attribute__ ((packed));
+/* 1 */ __u8    format:4,
+                type:4			__attribute__ ((packed));
+/* 2 */ __u8    fm_profile		__attribute__ ((packed));
+/* 3 */ __u8    ts_profile		__attribute__ ((packed));
+/* 4 */ __u8	pri_flags		__attribute__ ((packed));
+/* 5 */ __u8 	sec_flags		__attribute__ ((packed));
+/* 6 */ __u8	cm1_flags		__attribute__ ((packed));
+/* 7 */	__u8	cm2_flags		__attribute__ ((packed));
+
+/* TS Usage */
+/* 8 */ __u8    sec_tx_win_size		__attribute__ ((packed));
+/* 9 */ __u8    sec_rx_win_size		__attribute__ ((packed));
+/*10 */ __u8    shs_max_ru_size		__attribute__ ((packed));
+/*11 */ __u8    phs_max_ru_size		__attribute__ ((packed));
+/*12 */ __u8    pri_tx_win_size		__attribute__ ((packed));
+/*13 */ __u8    pri_rx_win_size		__attribute__ ((packed));
+
+/* PS profile */
+/*14 */ __u8    lu_type			__attribute__ ((packed));
+
+/* PS usage */
+/*15 */ __u8    lu6_level		__attribute__ ((packed));
+/*16 */ __u8    __pad5[7]		__attribute__ ((packed));
+/*23 */ __u8    ps1_flags		__attribute__ ((packed));
+/*24 */ __u8    ps2_flags		__attribute__ ((packed));
+
+/* User data and control vectors */
+	__u8	raw;
+};
+#pragma pack()
+
+typedef struct {
+        __u8    chain_sel:1,
+                request_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                __pad1:1,
+                scbi:1,
+                send_end_bracket:1;
+} sna_fm_usage_bit;
+
+struct sna_reason_bit {
+        __u8    plu:1,
+                bind:1,
+                setup_rej_plu:1,
+                setup_rej_slu:1,
+                __pad1:4;
+};
+
+/* BINDF (Bind Failure) */
+struct sna_bindf {
+        /* 0-2 NS header, 0x810685 */
+        char    sense_data[3];
+        struct  sna_reason_bit *reason;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BIS (Bracket Initiation Stopped) */
+struct sna_bis {
+        __u8    request_code;
+};
+
+/* CANCEL (Cancel) */
+struct sna_cancel {
+        __u8    request_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate) */
+struct sna_cdcinit {
+        /* 0-2 NS header, 0x81864B */
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:7,
+                xrf_bind:1;
+        char    pcid[7];
+
+        /* Session pair identifiers */
+};
+
+/* CDINIT (Cross-Domain Initiate) */
+struct sna_cdinit {
+        /* 0-2 NS header, 0x818641 */
+        __u8    format:4,
+                __pad1:4;
+
+        /* A mess of stuff after here */
+};
+
+/* CDSESSEND (Cross-Domain Session Ended) */
+struct sna_cdsessend {
+        /* 0-2 NS header, 0x818648 */
+        char    pcid[7];
+        __u8    format:4,
+                __pad1:4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSSF (Cross-Domain Session Setup Failure) */
+struct sna_cdsesssf {
+        /* Retired */
+};
+
+/* CDSESSST (Cross-Domain Session Started) */
+struct sna_cdsessst {
+        /* 0-2 NS header, 0x818646 */
+        char    pcid[7];
+        __u8    __pad1;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSTF (Cross-Domain Session Takedown Failure) */
+struct sna_cdsesstf {
+        /* Retired */
+};
+
+struct sna_cdtaked {
+        /* 0-2 NS header, 0x818649 */
+        char    pcid[7];
+        __u8    type:2,
+                takedown:2,
+                sscp_sscp_term:1,
+                __pad1:3;
+        struct  sna_reason_bit *reason;
+};
+
+/* CDTAKEDC (Cross-Domain Takedown Complete) */
+struct sna_cdtakedc {
+        /* 0-2 NS header, 0x81864A */
+        char    pcid[7];
+        __u8    type;
+        __u8    status;
+};
+
+/* CDTERM (Cross-Domain Terminate) */
+struct sna_cdterm {
+        /* 0-2 NS header, 0x818643 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    type:2,
+                termination_type:1,
+                send_dactlu_to_dlu:1,
+                __pad2:1,
+                __pad3:2,
+                __termination:1;
+        char    pcid[7];
+        __u8    network:1,
+                normal:1,
+                reason_code:1,
+                sess_setup:1,
+                cinit_cterm_err:1,
+                bind_unbind_err:1,
+                setup_taked_rej:1,
+                setup_rej:1;
+        __u16   __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CHASE (Chase) */
+struct sna_chase {
+        __u8    request_code;
+};
+
+/* CINIT (Control Initiate) */
+struct sna_cinit {
+        /* 0-2 NS header, 0x810601 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    init_lu_olu:1,
+                sub_source:1,
+                lu_olu:1,
+                __pad2:1,
+                name_sub:2,
+                ext_bind:1,
+                bind_xrf:1;
+        char    sess_key[4];
+        __u16   size_bind_image;
+
+        /* Lots of variable length crap */
+};
+
+/* RU packet type */
+#define RU_RQ	0	/* Request Unit */
+#define RU_RSP	1	/* Response Unit */
+
+/* RU category */
+#define RU_FM_DATA_UNIT	00
+#define RU_NC_UNIT	01
+#define RU_DFC_UNIT	10
+#define RU_SC_UNIT	11
+
+/* RU format indicator */
+#define RU_FMH_TRUE	1
+#define RU_FMH_FALSE	0
+
+/* RU sense data indicator */
+#define RU_SDI_TRUE	1
+#define RU_SDI_FALSE	0
+
+/* Begin/End chain indicator */
+#define RU_BC_FIRST_TRUE	1
+#define RU_BC_FIRST_FALSE	0 
+#define RU_EC_LAST_TRUE		1
+#define RU_EC_LAST_FALSE	0
+
+/* Definite response 1 indicator */
+#define RU_DR1_TRUE	1
+#define RU_DR1_FALSE	0
+
+/* Length checked compression indicator */
+#define RU_LCC_TRUE	1
+#define RU_LCC_FALSE	0
+
+/* Definate response 2 indicator */
+#define RU_DR2_TRUE	1
+#define RU_DR2_FLASE	0
+
+/* Response type indicators */
+#define RU_RT_POSITIVE	0
+#define RU_RT_NEGATIVE	1
+
+/* Request larger window indicator */
+#define RU_RLW_TRUE	1
+#define RU_RLW_FLASE	0
+
+/* Queue response indicators */
+#define RU_QR_PASS_TC_QUEUE	0
+#define RU_QR_TC_QUEUE		1
+
+/* Pacing indicators */
+#define RU_PACE_TRUE	1
+#define RU_PACE_FLASE	0
+
+/* Begin bracket indicators */
+#define RU_BB_TRUE	1
+#define RU_BB_FLASE	0
+
+/* End bracket indicators */
+#define RU_EB_TRUE	1
+#define RU_EB_FLASE	0
+
+/* Change direction indicators */
+#define RU_CD_TRUE	1
+#define RU_CD_FALSE	0
+
+/* Code selection indicators */
+#define RU_CS_TRUE	1
+#define RU_CS_FASE	0
+
+/* Enciphered data indicators */
+#define RU_ED_TRUE	1
+#define RU_ED_FALSE	0
+
+/* Padded data indicators */
+#define RU_PD_TRUE	1
+#define RU_PD_FALSE	0
+
+/* Conditional end bracket indicator */
+#define RU_CEB_TRUE	1
+#define RU_CEB_FALSE	0
+
+/* Session-level crypto indicators. */
+#define SNA_RU_CRYPTO_NO	0x0
+#define SNA_RU_CRYPTO_SELECT	0x1
+#define SNA_RU_CRYPTO_MANDATORY	0x3
+
+struct sna_ru_ipm {
+	__u8	ipmtype:2,
+		rwi:1,
+		rsv1:5;
+	__u16	nwfmt:1,
+		nws:15;
+};
+
+struct sna_send_parm {
+	__u8	allocate;
+	__u8	fmh;
+	__u8	type;
+	__u8	*data;
+};
+
+struct sna_security_reply_2 {
+	struct sna_send_parm send_parm;
+};
+
+/* ABCONN (Abandon Connection). Request the PU to deactive the link connection
+ * for the specified link.
+ */
+struct sna_ru_abconn {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACONNOUT (Abandon Connection Out). Requests the PU to terminate a
+ * connect-out procedure on the designated link.
+ */
+struct sna_ru_abconnout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACTCDRM (Activate Cross-Domain Resource Manager). ACTCDRM is sent
+ * from one SSCP to another SSCP to activate a session between them and
+ * to exchange information about the SSCPs.
+ */
+struct sna_ru_actcdrm {
+	__u8	req_code;	/* 0x14 request code. */
+	__u8	format:4,	/* Format: 0x0. */
+		act_type:4;	/* Type of activation requested:
+				 * 0x1 - cold.
+				 * 0x2 - ERP.
+				 */
+	__u8	fm_profile;
+	__u8	ts_profile;
+	__u8	contents_id[8];
+	__u8	sscp_id[6];
+
+	__u8	rsv1:2,
+		pri_hs_rcv_window_size:6;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTCONNIN (Activate Connection In). ACTCONNIN requests the PU to enable
+ * the specified link to accept incomming calls. It can also be used to
+ * solicit information about an existing connection on the link.
+ */
+struct sna_ru_actconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	incomming_call:1,
+		info_reqi:1,
+		rsv1:6;
+	__u8	*ctrl_vectors;
+};
+
+/* ACTLINK (Activate Link). ACTLINK initiates a procedure at the PU to
+ * activate the protocol boundary between a link station in the node (as
+ * specified by the link network address parameter in the request) and
+ * the link connection attached to it.
+ */
+struct sna_ru_actlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	swsai:1,	/* Switched subarea support indicator. */
+		slli:1,		/* Subordinate logical link indicator. */
+		rsv1:6;
+};
+
+/* ACTLU (Activate Logical Unit). ACTLU is sent from an SSCP to an LU to
+ * activate a session betwrrn the SSCP and the LU and to establish common
+ * session parameters.
+ */
+struct sna_ru_actlu {
+	__u8	req_code;	/* 0x0D. */
+	__u8	eami:1,		/* Enhanced Address Managment indicator. */
+		sdai:1,		/* Static/Dynamic Address indicator. */
+		rsv1:4,
+		act_type:2;	/* Activation type request. */
+
+	__u8	fm_profile:4,
+		ts_profile:4;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTPU (Activate Physical Unit). ACTPU is sent by the SSCP to activate a
+ * session with the PU, and to obtain certain information about the PU.
+ */
+struct sna_ru_actpu {
+	__u8	req_code;		/* 0x11. */
+	__u8	format:4,
+		act_type:4;
+	__u8	fm_profile:4,
+		ts_profile:4;
+	__u8	sscp_id_format:4,	/* 0x0000. */
+		sscp_node_type:4;
+	__u8	sscp_id_desc[5];
+	__u8	*ctrl_vectors;
+};
+
+/* ACTTRACE (Activate Trace). ACTTRACE requests the PU to activate a
+ * specified type of trace for a specified resource or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_acttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* Trace type. */
+	__u8	tg_trace:1,	/* Transmission group trace. */
+		piu_trace:1,	/* Generalized PIU trace (GPT). */
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	/* Trace specific data. */
+};
+
+/* ADDLINK (Add Link). ADDLINK is sent from the SSCP to the PU to obtain a
+ * link network address that will be mapped to the locally-used link
+ * identifier specified in the request.
+ */
+struct sna_ru_addlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u16	rsv1;
+	__u8	llid_len;	/* Local Link ID length. */
+	__u8	*llid;		/* Local Link ID. */
+};
+
+/* ADDLINKSTA (Add Link Station). ADDLINKSTA is sent from the SSCP to the PU
+ * to obtain an adjacent link station network address to be associated with
+ * the locally-used link station identifier specified in the request.
+ */
+struct sna_ru_addlinksta {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* FID type supported. */
+	__u8	fid0:1,
+		fid1:1,
+		fid2:1,
+		fid3:1,
+		fid4:1,
+		rsv1:3;
+	__u8 	rsv2;
+	__u8	lsid_len;		/* Link Station ID length. */
+	__u8	*lsid;			/* Link Station ID. */
+};
+
+/* BFCINIT (BF Control Initiate). BCFINIT requests the BF(LU) to attempt to
+ * activate, via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_bfcinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+
+	__u8	rsv2:1,
+		sub_src:1,	/* Substitution source. */
+		save_rscv:1,
+		copy_rscv:1,
+		names_sub:2,
+		no_ext_bind:1,
+		ext_bind:1;
+
+	__u8	rsv3[5];
+
+	__u16	bind_image_len;
+
+	__u8	*bind_image;
+};
+
+/* BFCLEANUP (BF Cleanup). BFCLEANUP is sent with definite response
+ * requested to request that the BF(PLU) ot BF(SLU) attempt to deactivate
+ * the identified session.
+ */
+struct sna_ru_bfcleanup {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFINIT (BF Initiate). BFINIT from the BF(LU) requests the initiation of
+ * a session between the two LUs named in the BIND image.
+ */
+struct sna_ru_bfinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+};
+
+/* BFSESSEND (BF Session Ended). BFSESSEND notifies the SSCP that the LU-LU
+ * session identified has been deactivated.
+ */
+struct sna_ru_bfsessend {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESSINFO (BF Session Information). BFSESSINFO provides the SSCP with
+ * information about sessions with SSCP-independent LUs in a peripheral
+ * node taken over by the receiving SSCP.
+ */
+struct sna_ru_bfsessinfo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	als_takeover:1,
+		lu_takeover:1,
+		auth_lui:1,		/* Authorized LU indicator. */
+		sdai:1,			/* Static/Dynamic address indicator. */
+		slu_addr:1,		/* Static LU address. */
+		rsv2:2;
+	__u16	rsv3;
+
+	__u8	nq_lu_name_len;
+	__u8	*nq_lu_name;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESST (BF Session Started). BFSESSST informs the SSCP that a new LU-LU
+ * session has been activated and provides information about the active
+ * session.
+ */
+struct sna_ru_bfsessst {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		lu_role:1,
+		rsv1:3;
+
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFTERM (BF Terminate). BFTERM from the BF(LU) requests that the SSCP
+ * assist in the termination of the identified LU-LU session.
+ */
+struct sna_ru_bfterm {
+	__u8	ns_hdr[3];
+	__u16	element_type;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BID (BID). BID is used by the bidder to request permission to initiate
+ * a bracket, and is used only when using brackets. This RU is not used for
+ * LU 6.2.
+ */
+struct sna_ru_bid {
+	__u8	req_code;
+};
+
+/* BIND (BIND Session). BIND is sent from a primary LU to a seconday LU to
+ * activate a session between the LUs. The secondary LU uses the BIND
+ * parameters to help determine whether it will response positively or
+ * negativly to BIND.
+ */
+struct sna_ru_bind_fm_use {
+	__u8    chaining:1,
+                req_cntl_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                rsv1:1,
+                fmh1_scb_cmp:1,
+                sebi:1;                 /* Send end bracket indicator. */
+};
+
+struct sna_ru_bind_crypto {
+	__u8	opts:2,
+		sess_level_crypto:2,
+		sess_level_crypto_opts:4;
+	__u8	sess_crypto_key_meth:2,
+		rsv1:2,
+		crypto_cipher_meth:4;
+	__u8	*crypto_key;
+};
+
+struct sna_ru_bind_user_data {
+	__u8	urc_len;
+	__u8	*urc;
+
+	__u8	sec_lu_name_len;
+	__u8	*sec_lu_name;
+
+	__u8	*ctrl_vectors;
+};
+
+#define SNA_RU_BIND_ADAPT_NO_SUPP	0x0
+#define SNA_RU_BIND_ADAPT_SUPP		0x1
+
+struct sna_ru_bind {
+	__u8	req_code;
+	__u8	format:4,
+		type:4;
+	__u8	fm_profile;
+	__u8	ts_profile;
+
+	struct sna_ru_bind_fm_use	pri_lu_proto;
+	struct sna_ru_bind_fm_use	sec_lu_proto;
+
+	__u8	whole_biu:1,
+		fm_hdr:1,
+		bracket_use:1,
+		backet_term:1,
+		alt_code:1,
+		seq_avail_sync_point:1,
+		bis_send:1,
+		bind_queue:1;
+
+	__u8	normal_flow_mode:2,
+		recovery:1,
+		contention:1,
+		alt_code_proc:2,
+		ctrl_vect_include:1,
+		half_dup_ff_reset:1;
+
+	__u8	staging:1,
+		rsv1:1,
+		sec_sws:6;		/* Secondary send window size. */
+
+	__u8	adapt_pace:1,
+		rsv2:1,
+		sec_rws:6;		/* Secondary receive window size. */
+
+	__u8	pri_hs_max_ru_size_sent;
+	__u8	sec_hs_max_ru_size_sent;
+
+	__u8	pri_sec_staging:1,
+		rsv3:1,
+		pri_sws:6;	/* Primary send window size. */
+	__u8	rsv4:2,
+		pri_rws:6;	/* Primary receive window size. */
+
+	__u8	ps_use_format:1,
+		lu_type:7;
+
+	__u8	lu6_level;
+	__u8	rsv6[5];
+
+	__u8	ext_security:1,
+		ext_security_sense:1,
+		rsv7:6;
+
+	__u8	rsv8:3,
+		converstation_level_security:1,
+		lu_lu_verification:1,
+		passwd_sub:1,
+		already_verified:1,
+		persistent_verification:1;
+
+	__u8	rsv9:1,
+		sync_level:2,
+		rsv10:1,
+		reinit_responsibility:2,
+		parallel_sess:1,
+		chg_num_sess:1;
+
+	__u8	rsv11:1,
+		limit_resc_sess:1,
+		rsv12:4,
+		len_chk_compression:2;
+
+	/* End of short bind image. */
+
+	struct sna_ru_bind_crypto crypto;
+
+	__u8	pri_lu_name_len;
+	__u8	*pri_lu_name;
+
+	/* User data field. */
+	__u8	user_data_len;
+	__u8	user_data_key;
+
+	union {
+		__u8	*user_data;
+		struct	sna_ru_bind_user_data *struct_user_data;
+	} data;
+};
+
+/* BINDF (BIND Failure). BINDF is sent, with no-response requested, by the
+ * PLU to notify the SSCP that the attempt to activate the session between
+ * the specified LUs has failed.
+ */
+struct sna_ru_bindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	reason;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BIS (Bracket Initiation Stopped). BIS is sent by the half-session to
+ * indicate that it will not attempt to begin any more brackets.
+ */
+struct sna_ru_bis {
+	__u8	req_code;
+};
+
+/* CANCEL (Cancel). CANCEL may be sent by a half-session to terminate a
+ * partially sent chain of FMD requests. CANCEL may be sent only when
+ * a chain is in process. The sending half-session may send CANCEL to end
+ * a partially sent chain if a negative response is received for a request
+ * in the chain, or for some other reason. This RU is not used by LU 6.2.
+ */
+struct sna_ru_cancel {
+	__u8	req_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate). CDCINIT passes information about
+ * the SLU from the SSCP(SLU) to the SSCP(PLU) and requests that the SSCP(PLU)
+ * send CINIT to the PLU.
+ */
+struct sna_ru_cdcinit_format0 {
+	__u16	plu_addr;
+	__u16	slu_addr;
+};
+
+struct sna_ru_cdcinit_format1 {
+	__u8	*session_key;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	__u16	char_field;
+	__u8	char_format;
+	__u8	*desc;
+
+	__u8	sess_crypto_key_len;
+	__u8	*pri_sess_crypto_key;
+
+	__u8	*ctrl_vectors;
+};
+
+struct sna_ru_cdcinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:7,
+		xrf_slu_supp:1;
+	__u8	*sess_pair_id;
+
+	union {
+		struct sna_ru_cdcinit_format0 format0;
+		struct sna_ru_cdcinit_format1 format1;
+	} format1;
+};
+
+/* CDINIT (Cross-Domain Initiate). CDINIT requests another SSCP to assist in
+ * initiating an LU-LU session for the specified (OLU,DLU) pair.
+ */
+struct sna_ru_cdinit {
+	__u8	*raw;
+};
+
+/* CDSESSEND (Cross-Domain Session Ended). CDSESSEND notifies the SSCP that the
+ * LU-LU session identified by the session key has been successfully
+ * deactivated, or that knowledge of session deactivation has been lost due to
+ * session outage with one or more of the participating LUs, gatewat nodes, or
+ * adjacent SSCPs. In the latter case, the session may still be active, but
+ * explicit notification of session deactivation is no longer possible.
+ */
+struct sna_ru_cdsessend {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDSESSST (Cross-Domain Session Started). CDSESSST notifies the SSCP(SLU)
+ * that the LU-LU session identified by the Session Key content field and
+ * the specified PCID for the initiation procedure has been sucessfully
+ * activated.
+ */
+struct sna_ru_cdsessst {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	rsv1;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDTAKED (Cross-Domain Take Down). CDTAKED initiates a procedure to cause
+ * the takedown of all cross-domain LU-LU sessions (active, pending-active,
+ * and queued) involving the domains of both the sending and receiving SSCP.
+ * It also prevents the initiation of new LU-LU sessions between these domains.
+ */
+struct sna_ru_cdtaked {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	lu_lu_type:2,
+		takedown:2,
+		sscp_sscp_term:1,
+		rsv1:3;
+
+	/* Reason. */
+	__u8	user:1,
+		state:1,
+		rsv2:6;
+};
+
+/* CDTAKEDC (Cross-Domain Take-Down Complete). Except when the Cleanup
+ * option was specified, the SSCP that received CDTAKED (and responded
+ * positively to it) sends CDTAKEDC upon completion of its domain takedown
+ * procedure. The other SSCP, after completing its domain takedown procedure
+ * and receivinf a CDTAKEDC, also sends a CDTAKEDC.
+ */
+struct sna_ru_cdtakedc {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	type;
+	__u8	status;
+};
+
+/* CDTERM (Cross-Domain Terminate). CDTERM requests that the receiving SSCP
+ * assist in the termination of the cross-domain LU-LU session identified
+ * by the Session Key and the Type byte of the RU. Each SSCP executes that
+ * portion of termination processing that relates to the LU in its domain.
+ */
+struct sna_ru_cdterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	type;
+	__u8	pcid[8];
+	__u8	reason;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u16	rsv3;
+	__u8	*ctrl_vectors;
+};
+
+/* CHASE (Chase). CHASE is sent by a half-session to request the receiving
+ * half-session to return all outstanding normal-flow responses to requests
+ * previously received from the issuer of CHASE. The receiver of CHASE sends
+ * the response to CHASE after processing (and sending any necessary responses
+ * to) all requests received before the CHASE. This RU is not used for LU 6.2.
+ */
+struct sna_ru_chase {
+	__u8	req_code;
+};
+
+/* CINIT (Control Initiate). CINIT requests the PLU to attempt to activate,
+ * via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_cinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	init_origin:1,
+		sub_source:1,
+		slu_plu_olu:1,
+		rsv2:1,
+		name_sub_plu_slu:2,
+		ext_bind_slu:1,
+		xrf_supp_slu:1;
+	__u8	session_key[5];
+
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	/* There is more. */
+};
+
+/* CLEANUP (Clean Up session). CLEANUP is sent by the SSCP to an LU (in a
+ * subarea node or BF for peripheral LU) requesting that the LU of BF
+ * attempt to deactivate the session for the specified (PLU, SLU) network
+ * address pair.
+ */
+struct sna_ru_cleanup {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2;
+	__u8	user:1,
+		status:1,
+		rsv3:6;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CLEAR (Clear). CLEAR is sent by primary session control to reset the
+ * data traffic. FSMs and subtrees (for example, brackets, pacing, sequence
+ * numbers) in the primary and seconday half-session (and boundary function,
+ * if any). CLEAR also resets compression and decompression tables in sessions
+ * using length-checked compression. This RU is not used for LU 6.2.
+ */
+struct sna_ru_clear {
+	__u8	req_code;
+};
+
+/* CONNOUT (Connect Out). CONNOUT requests the PU to initiate a connect-out
+ * procedure on the specified link.
+ */
+struct sna_ru_connout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	ls_id;		/* Link station ID. */
+	__u8	connect_type:1,
+		connect_out_feature:2,
+		rsv1:2,
+		connect_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		sdai:1;		/* Static/Dynamic address indicator. */
+
+	__u8	retry_limit;
+	__u8	number;
+	__u8	*dial_digits;
+
+	__u8	id_number;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACT (Contact). CONTACT requests the initiation of a procedure at the
+ * PU to activate DLC-level contact with the adjacent link station specified
+ * in the request. The DLC-level contact must be activated before any PIUs
+ * can be exchanged with the adjacent node over the link.
+ */
+struct sna_ru_contact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1:1,
+		eami:1,		/* Enhanced addr managment indicator. */
+		sdai:1,
+		limit_resource:1,
+		cp_cp_sess_supp:1,
+		conn_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		nnn_id_usage:1;	/* Nonnative network id usage indicator. */
+
+	__u8	tg_num;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACTED (Contacted). CONTACTED is issued by the PU to indicate to the
+ * SSCP the completion of the DLC contact procedure. A status parameter
+ * conveyed by this request informs SSCP configuration services whether or
+ * not the contact procedure was successful; if not sucessful, the status
+ * indicates whether an adjacent node load is required or whether an error
+ * occured on the contact procedure.
+ */
+struct sna_ru_contacted {
+	__u8	*raw;
+};
+
+/* CRV (Cryptogrpahy Verification). CRV, a valid request only when
+ * session-level cryptography was selected in BIND, is sent by the primary
+ * LU sesion control to verify cryptography security and thereby enable
+ * sending and receiving of FMD requests by both half-sessions.
+ */
+struct sna_ru_crv {
+	__u8	rq_code;
+	__u8	crypto_seed[7];
+};
+
+/* CTERM (Control Terminate). CTERM requests that the PLU attempt to deactivate
+ * a session identified by the specified (PLU,SLU) network address pair.
+ */
+struct sna_ru_cterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:2,
+		type:2,
+		rsv3:4;
+	__u8	user:1,
+		status:1,
+		rsv4:6;
+	__u16	rsv5;
+	__u8	*session_key;
+	__u16	rsv6;
+};
+
+/* DACTCDRM (Deactivate Cross-Domain Resource Manager). DACTCDRM is sent
+ * to deactivate a SSCP-SSCP session.
+ */
+struct sna_ru_dactcdrm {
+	__u8	req_code;
+	__u8	format:4,
+		deact_type:4;
+
+	/* Type 2 cont. */
+	__u32	reason;
+
+	/* Type 3 cont. */
+	__u8	cause;
+	__u8	rsv1;
+
+	/* Type 4 cont. */
+	__u8	rsv2;
+};
+
+/* DACTCONNIN (Deactivate Connect In). DACTCONNIN requests the PU to
+ * disable the specified link from accepting incoming calls.
+ */
+struct sna_ru_dactconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DACTLINK (Deactivate Link). DACTLINK initiates a procedure at the PU to
+ * deactivate the protocol boundary between a link station in the node
+ * (as specified by the link network address parameter in the request) and
+ * the link connection attached to it. The normal type is used after all
+ * adjacent link stations on the specified link have been discontacted.
+ * The unconditional type may be used at any time to reset immediately a
+ * link and its attached stations, regardless of their current state. If any
+ * other control points were actively sharing control of the link at the time
+ * of reset, thy are notified via INOP with a unique code. The give-back type
+ * gives back link ownership without disrupting LU-LU sessions.
+ */
+struct sna_ru_dactlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dactlink_type;
+};
+
+/* DACTLU (Deactivate Logical Unit). DACTLU is sent to deactivate the session
+ * between the SSCP and the LU.
+ */
+struct sna_ru_dactlu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTPU (Deactivate Physical Unit). DACTPU is sent to deactivate the
+ * session between the SSCP and the PU.
+ */
+struct sna_ru_dactpu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTTRACE (Deactivate Trace). DACTTRACE requests the PU to deactivate
+ * a specified type of trace for a specified resource (or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_dacttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	tg_trace:1,
+		piu_trace:1,
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	__u8	*trace_data;
+};
+
+/* DELETENR (Delete Network Resource). DELETENR is sent to free a network
+ * address addigned to a link or adjacent link station.
+ */
+struct sna_ru_deletenr {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISCONTACT (Discontact). DISCONTACT requests the PU to deactivate DLC-level
+ * contact with the specified adjacent node. The discontact procedure is
+ * DLC-dependent; if applicable, polling is stopped. DISCONTACT may be used
+ * to terminate contact, IPL, or dump procedures before their completion. The
+ * PU responds negatively to DISCONTACT if any uninterruptable link-level
+ * procedure is in progress at the primary link station of the specified link.
+ */
+struct sna_ru_discontact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISPSTOR (Display Storage). DISPSTOR requests the PU to send a RECSTOR RU
+ * containing a specified number of bytes of storage beginning at a specified
+ * location, or the names and related information for load modules and dump
+ * (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_dispstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	target_addr_space:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	display_bytes;
+	__u32	begin_local_display;
+};
+
+/* DSRLST (Direct Search List). DSRLST specifies a list search argument to
+ * be used at the receiving SSCP to identify a control list type to be
+ * returned on RSP(DSRLST).
+ */
+struct sna_ru_dsrlst {
+	__u8	ns_hdr[3];
+	__u8	search_arg;
+	__u8	*ctrl_vectors;
+};
+
+/* DUMPFINAL (Dump Final). DUMPFINAL performs one of two functions depending
+ * on the address used in the request:
+ * - When the DUMPFINAL request contains the link station address of an
+ *   adjacent T4 node. DUMPFINAL terminates the dump sequence in progress
+ *   (whether DUMPTEST is used or not). A positive response by the T4/5 node
+ *   to this form of DUMPFINAL indicates that the dump sequence is complete.
+ * - Then the DUMPFINAL request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node) and a link station address of
+ *   0x0000, the DUMPFINAL request causes an ABEND at the T4 node. The T4
+ *   node then dumps to local disk. No response is returned to the requester
+ *   for this form of DUMPFINAL.
+ */
+struct sna_ru_dumpfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DUMPINIT (Dump Initial). DUMPINIT performs one of two functions, depending
+ * on the address used in the request:
+ * - When the node to be dumped is identified by an adjacent link station
+ *   address, DUMPINIT causes the receiving T4/5 node to initiate a DLC-level
+ *   dump from the adjacent T4 node (identified in the DUMPINIT) to the
+ *   receiving T4/5 node; this dump is sent to the SSCP on subsequent
+ *   RSP(DUMPTEXT)s.
+ * - When the DUMPINIT request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node), a link station address of 0x0000
+ *   and a Dump Control byte equal to 0x80, the DUMPINIT interrogates the
+ *   status of the receiving node's system-defined local options (to react
+ *   to a subsequent DUMPFINAL), and its capacity to store a dump of its own
+ *   contents to local disk storage. A positive response to the request
+ *   indicates that a DUMPFINAL request can be accepted ( and the local dump
+ *   be performed). A negative response indicates either that the system
+ *   defined local options conflict with those of the requester, or
+ *   insufficient disk capacity exists to at the DUMPINIT receiver hold the
+ *   dump.
+ */
+struct sna_ru_dumpinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dump_type;
+};
+
+/* DUMPTEXT (Dump Text). If further dump data is required, DUMPINIT may be
+ * followed by DUMPTEXT. DUMPTEXT causes the dump data specified by the
+ * starting-address parameter to be returned to the SSCP on the response.
+ * The T4/5 obtains the dump data from the T4 node, using a DLC-level
+ * interchange.
+ */
+struct sna_ru_dumptext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	start_dump_addr;
+	__u16	text_len;
+};
+
+/* ER_TESTED (Explicit Route Tested). ER_TESTED is sent by a subarea node
+ * to one or more SSCPs to provide the status of an ER as determined by
+ * explicit route test procedures.
+ */
+struct sna_ru_er_tested {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	er_max_len;
+	__u32	subarea_addr_dst;
+	__u8	rsv1;
+	__u8	rsv2:4,
+		ern_of_er:4;
+	__u32	subarea_addr_src;
+	__u16	rev_ern_mask;
+	__u16	max_piu_len;
+	__u16	max_piu_size;
+	__u16	ns_er_test_origin_sscp_subarea_num;
+	__u16	ns_er_test_origin_sscp_element_num;
+	__u8	req_corr[9];
+
+	/* More. */
+};
+
+/* ESLOW (Entering Slowdown) ESLOW informs the SSCP that the node of the
+ * sending PU has entered a slowdown state. This state is generally
+ * associated with buffer depletion, and requires traffic through the node
+ * to be selectively reduced or suspended.
+ */
+struct sna_ru_eslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* EXECTEST (Execute Test). EXECTEST requests the PU to activate the specified
+ * test type related to the specified network address. The test code specifies
+ * the test type and defines the contents of the test data field. The test may
+ * be for the PU, or for the LUs or links supported by the PU.
+ */
+struct sna_ru_exectest {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*test_data;
+};
+
+/* EXPD (Expedited Data). EXPD is an expediated-flow request that can be
+ * sent between half-sessions, regardless of the status of the normal flows,
+ * to carry TP-defined data. This RU is defined for LU 6.2 only.
+ */
+struct sna_ru_expd {
+	__u8	req_code;
+	__u8	rsv1;
+	__u16	exp_data_len;
+	__u8	*exp_data;
+};
+
+/* EXSLOW (Exiting Slowdown). EXSLOW informs the SSCP that the node of the
+ * sending PU is no longer in the slowdown state and regular traffic can
+ * resume.
+ */
+struct sna_ru_exslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* FNA (Free Network Addresses). FNA is sent from an SSCP to request the PU
+ * T4/5 to free the identified element address(es) associated with the
+ * target resource. If ENA is not supported, the entire network address is
+ * in each Element Address field throughout this RU.
+ */
+struct sna_ru_fna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	num_element_addrs;
+
+	__u8	rsv1:1,
+		eami:1,			/* Enhanced Address Managment Indi. */
+		sdai:1,			/* Static/Dynamic Addr Indi. */
+		rsv2:5;
+
+	__u16	first_element_addr;
+	__u16	*other_element_addrs;
+};
+
+/* INIT_OTHER (Initiate Other). INIT_OTHER from the ILU requests the initiation
+ * of a session between the two LUs named in the RU. The requester may be a
+ * third-party LU or one of the two named LUs. This RU is not used by LU 6.2
+ * although it can be used by a third-party LU for LU 6.2.
+ */
+struct sna_ru_init_other {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	iqi:2,		/* Initiate/Enqueue Indicator. */
+		rsv21:4,
+		pluslu_spec:1,
+		rsv2:1;
+};
+
+/* INITPROC (Initiate Procedure). INITPROC is sent to the subarea PU adjacent
+ * to a PU T2 in order to initiate a PU T4/5 PU T2 load operation.
+ */
+struct sna_ru_initproc {
+	__u8	ns_hdr[3];
+	__u8	rsv1[3];
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	*ipl_load_module;
+};
+
+/* IPLFINAL (IPL Final). IPLFINAL completes an IPL sequence and supplies the
+ * load-module entry point to the T4 node. A positive response to IPLFINAL
+ * indicates that the T4 node is successfully loaded, or the load module
+ * has been successfully added to or replaced on the T4 node's local disk.
+ */
+struct sna_ru_iplfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	entry_point;
+	__u8	ipl_sli:1,	/* IPL save load indicator. */
+		ui:1,		/* Usage indicator. */
+		daipli:1,	/* Disk automatic IPL indicator. */
+		dadi:1,		/* Disk automatic dump indicator. */
+		rsv1:4;
+};
+
+/* IPLINIT (IPL Initial). IPLINIT either initiates a DLC-level load of an
+ * adjacent T4 node from the T4 node receiving the IPLINIT, when the node to
+ * be loaded is identified by the adjacent link station address contained in
+ * the request, or initiates the adding, replacing, or purging of the load
+ * module on the local disk of the T4 node receiving the request when the
+ * address in the request is the network address of the PU T4 receiving the
+ * request. In the case of purging, no IPLFINAL is sent, a positive response
+ * to IPLINIT indicates that the load module has been successfully purged.
+ */
+struct sna_ru_iplinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dipli:1,	/* Disk IPL indicator. */
+		rsv1:7;
+	__u8	load_module_name[8];
+	__u8	lmi:2,
+		rsv2:6;
+};
+
+/* IPLTEXT (IPL Text). IPLTEXT transfers load module information to the PU T4,
+ * which passes it in a DLC-level load to the T4 adjacent node or adds or
+ * replaces the load module on its local disk. Following an IPLINIT, any
+ * number of IPLTEXT commands are valid, except that for purging and loading
+ * from local disk, IPLTEXT is not sent.
+ */
+struct sna_ru_ipltext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*text;
+};
+
+/* LCP (Lost Control Point). LCP notifies the SSCP that a subarea PU's session
+ * with another SSCP has failed. The SSCP displays the information for the
+ * network operator.
+ */
+struct sna_ru_lcp {
+	__u8	ns_hdr[3];
+	__u8	reason_code;
+	__u8	rsv1;
+	__u8	net_addr[5];
+};
+
+/* LUSTAT (Logical Unit Status). LUSTAT is used by one half-session to send
+ * up to four bytes of status information to its paired half-session. The
+ * RU format allows the sending of either end-user information or LU status
+ * information. If the high-order two bytes of the status information are 0,
+ * the low-order two bytes carry end-user information and may be set to any
+ * value. In general, LUSTAT is used to report about failures and error
+ * recovery conditions for a local device of an LU.
+ */
+struct sna_ru_lustat {
+	__u8	req_code;
+	__u32	status;
+};
+
+/* NC_ACTVR (Activate Virtual-Route). NC_ACTVR initializes the state and
+ * attributes of the VR at each of its end nodes.
+ */
+struct sna_ru_nc_actvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u16	rcv_ern_mask;
+	__u16	send_ern_mask;
+	__u16	rsv3:4,
+		init_vr_send_sqn:12;
+	__u8	rsv4;
+	__u8	max_vr_window;
+	__u8	rsv5;
+	__u8	min_vr_window;
+	__u16	max_piu_size;
+	__u16	max_piu_len;
+};
+
+/* NC_DACTVR (Deactivate Virtual Route). NC_DACTVR deactivates a virtual
+ * route.
+ */
+struct sna_ru_nc_dactvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+};
+
+/* NC_ER_ACT (Explicit Route Activate). NC_ER_ACT is sent by the ER manager
+ * in a subarea node in order to activate an explicit route.
+ */
+struct sna_ru_nc_er_act {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	route_def_cap:1,
+		rsv3:7;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	src_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_len;
+	__u8	rsv5[8];
+	__u8	act_req_sni[8];
+};
+
+/* NC_ER_INOP (Explicit Route Inoperative). NC_ER_INOP is initiated when the
+ * last remaining link of the transmission group has failed or is disconnected
+ * via a link-level procedure.
+ */
+struct sna_ru_nc_er_inop {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	reason_code;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	num_dst_subareas;
+	__u8	inop_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	inop_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_OP (Explicit Route Operative). NC_ER_OP is generated when a link of
+ * an inoperative transmission group becomes operative.
+ */
+struct sna_ru_nc_er_op {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	tg_number;
+	__u8	num_subarea_addrs;
+	__u8	op_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	op_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_TEST (Explicit Route Test). NC_ER_TEST is sent by a subarea node that
+ * requires testing of an explicit route to a specified destination subarea.
+ */
+struct sna_ru_nc_er_test {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv3;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	orig_subarea_addr;
+	__u16	reverse_er_mask;
+	__u16	max_piu_size;
+	__u16	rsv5;
+	__u8	orig_sscp_net_addr[6];
+	__u8	rq_cv[10];		/* Request Correlation Value. */
+};
+
+/* NC_ER_TEST_REPLY (Explicit Route Test Reply). NC_ER_TEST_REPLY is returned
+ * to signal the successful or unsuccessful completion of te NC_ER_TEST.
+ */
+struct sna_ru_nc_er_test_reply {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv2;
+	__u8	rsv3:4,
+		ern:4;
+	__u32	orig1_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_size_permit;
+	__u16	max_piu_size_accum;
+	__u8	orig_network_addr[6];
+	__u8	rq_cv[10];
+	__u32	orig2_subarea_addr;
+	__u32	subarea_addr_type;
+	__u8	tgn;
+	__u8	*ctrl_vectors;
+};
+
+/* NC_IPL_ABORT (NC IPL Abort). NC_IPL_ABORT contains sense data indicating
+ * the reason for a failure during IPL.
+ */
+struct sna_ru_nc_ipl_abort {
+	__u8	req_code;
+	__u32	sense;
+};
+
+/* NC_IPL_FINAL (NC IPL Final). NC_IPL_FINAL contains the entry point location
+ * of the IPL module.
+ */
+struct sna_ru_nc_ipl_final {
+	__u8	req_code;
+	__u32	entry_point;
+};
+
+/* NC_IPL_INIT (NC IPL Init). NC_IPL_INIT is sent from a PU T4/5 to a PU T2
+ * after the PU T4/5 processes an INITPROC (Type = IPL) RU.
+ */
+struct sna_ru_nc_ipl_init {
+	__u8	req_code;
+	__u8	rsv1;
+	__u8	ipl_load_module[8];
+};
+
+/* NC_IPL_TEXT (NC IPL Text). NC_IP_TEXT contains the IPL data. */
+struct sna_ru_nc_ipl_text {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* NMVT (Network Managment Vector Transport). NMVT carries management services
+ * (MS) requests and replies between an SSCP and a PU.
+ */
+struct sna_ru_nmvt {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	rsv2:2,
+		rsv3:2,
+		prid:12;
+	__u8	si:1,		/* Solicitation Indicator. */
+		sf:2,		/* Sequence field. */
+		sna_addr_list:1,
+		rsv4:4;
+	__u8	*ms_ctrl_vectors;
+};
+
+/* PROCSTAT (Procedure Status). PROCSTAT reports to the SSCP either the 
+ * successful completion or the failure of the load operation. If the procedure
+ * failed, the request code of the failing RU and sense data are included as
+ * parameters in the PROCSTAT RU.
+ */
+struct sna_ru_procstat {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	proc_status;
+	__u16	rsv2;
+	__u8	status_qualifier[5];
+	__u8	fail_ru_req_code;
+	__u32	sense;
+};
+
+/* QC (Quiesce Complete). QC is sent by a halfpsession after receving QEC, to
+ * indicate that it has quiesced. This RU is not used for LU 6.2
+ */
+struct sna_ru_qc {
+	__u8	req_code;
+};
+
+/* QEC (Quiesce at End of Chain). QEC is sent by a half session to quiesce its
+ * partner half-session after it (the partner) finishes sending the current
+ * chain (if any). This RU is not used for LU 6.2.
+ */
+struct sna_ru_qec {
+	__u8	req_code;
+};
+
+/* RECFMS (Record Formatted Maintenance Statistics). RECFMS permits the passing
+ * of maintenance related information from a PU to managment services at the
+ * SSCP.
+ */
+struct sna_ru_recfms {
+	__u8	ns_hdr[3];
+	__u16	cnm_target;
+	__u16	rsv1:2,
+		cnm_target_id:2,
+		prid:12;
+	__u8	si:1,
+		ntri:1,
+		req_type_code:6;
+	__u32	block_num:12,
+		id_num:20;
+	__u16	rsv2;
+
+	/* There is more. */
+};
+
+/* RECSTOR (Record Storage). RECSTOR carries the storage dump as requested by
+ * a DISPSTOR RU, or the names and related information for load modules and
+ * dump (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_recstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	display_src:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	size;
+	__u32	begin_location;
+	__u8	*storage_display;
+};
+
+/* RECTD (Record Test Data). RECTD returns the status and results of a test
+ * requested by EXECTEST to SSCP maintenance services.
+ */
+struct sna_ru_rectd {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*data;
+};
+
+/* RELQ (Release Quiesce). RELQ is used to release a half-session from a
+ * quiesced state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_relq {
+	__u8	req_code;
+};
+
+/* REQACTCDRM (Request Acitivation of Cross-Network Resource Manager).
+ * REQACTCDRM prompts the receiving SSCP to issue RNAA and SETCV to setup a
+ * cross-network address transform. ACTCDRM will then be sent to activate an
+ * SSCP-SSCP session with the other-network SSCP identified in this request.
+ */
+struct sna_ru_reqactcdrm {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format;
+	__u8	tsr:1,
+		vrid:1,
+		rsv2:6;
+	__u8	*session_key;
+	__u8	*bad_actcdrm;
+};
+
+/* REQACTLU (Request Activate Logical Unit). REQACTLU is sent from the PU to an
+ * SSCP to request that ACTLU be sent to the LU named in the RU.
+ */
+struct sna_ru_reqactlu {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	type;
+	__u8	len;
+	__u8	*symbol_name;
+};
+
+/* REQACTPU (Request Activate Physical Unit). REQACTPU is sent from the PU to
+ * SSCP to request that ACTPU be sent to the PU named in the corresponding
+ * FID2 Encapsulation (0x1500) GDS variable.
+ */
+struct sna_ru_reqactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+};
+
+/* REQCONT (Request Contact). REQCONT notifies the SSCP that a connection with
+ * an adjacent secondary link station (in a T1/2 node) has be activated via a
+ * successful connect-in or connect-out procedure. A DLC-level indentification
+ * exchange (XID) is required before issuing REQCONT.
+ */
+struct sna_ru_reqcontx {
+	__u16	vector_hdr;
+	__u8	tg_status:1,
+		rsv1:7;
+};
+
+struct sna_ru_reqcont {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*xid_ifield_image;
+	__u8	*ctrl_vectors;
+};
+
+/* REQDACTPU (Request Deactivate Physical Unit). REQDACTPU is sent from the PU
+ * to an SSCP to request that DACTPU be sent to the PU.
+ */
+struct sna_ru_reqdactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+	__u8	cause;
+};
+
+/* REQDISCONT (Request Discontact). With REQDISCONT, the PU T2 requests the
+ * SSCP to start a procedure that will ultimately discontact the secondary
+ * station in the T2 node.
+ */
+struct sna_ru_reqdiscont {
+	__u8	ns_hdr[3];
+	__u8	type:4,
+		contact:4;
+};
+
+/* REQFNA (Request Free Network Address). REQFNA is sent from a PU T4/5 to an
+ * SSCP to request the SSCP to send FNA to the PU T4/5 in order to free all
+ * addresses for the specified LU.
+ */
+struct sna_ru_reqfna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1;
+	__u8	req_type;
+};
+
+/* REQMS (Request Maintenance Statisitics). REQMS requests the managment
+ * services associated with the PU to provide maintenance statistics for the
+ * resource indicated by the CNM target ID in the CNM header.
+ */
+struct sna_ru_reqms {
+	__u8	*raw;
+};
+
+/* RNAA (Request Network Address Assignment). RNAA requests the PU to
+ * assign addresses:
+ * - To an adjacent link station, as identified in the RNAA request by a link
+ *   element address and secondary link station link-level address.
+ * - To a dependent LU, where the LU is identified in the RNAA by a adjacent
+ *   link station address and the LU local address.
+ * - To a subarea LU that supports parallel sessions; in order to assign an
+ *   additional element address, the LU is identified in the RNAA request
+ *   by the LU element address used for the SSCP-LU session.
+ * - As alias addresses for a cross-network SSCP-SSCP or LU-LU session, where
+ *   the name pair and session characteristics are identified in the RNAA
+ *   request.
+ * - To an LU to be used as a PLU address for an independent LU or to be used
+ *   as an indepenedent or depenedent LU, where the LU is identified by an ALS
+ *   address, an LU name, and an optional LU address.
+ *
+ * If ENA is not supported on this SSCP-to-PU T4/5 session, the entire network
+ * address is in each element address field throughout this RU.
+ */
+struct sna_ru_rnaa {
+	__u8	*raw;
+};
+
+/* ROUTE_INOP (Route Inoperative). ROUTE_INOP notifies the CP when either a
+ * virtual route or an explicit route has become inoperative as the result of
+ * a transmission group having become inoperative somewhere in the network.
+ * This RU is retired for route dynamics.
+ */
+struct sna_ru_route_inop {
+	__u8	*raw;
+};
+
+/* ROUTE_SETUP (Route Setup). ROUTE_SETUP is used between adjacent HPR CPs when
+ * at leat one of them does not support the Control Flows over RTP (1402) option
+ * set; it carries the Route Setup GDS variable and is preceded by a FID2 TH
+ * set to FID2, BBIU, EBIU, ODAI = 0, EFI = 1, DAF = 0, OAF - 0, and SNA = 0
+ * (ie, TH = 0x2D0000000000) and an RH set to RQ, NC, FI = 1, SDI = 0, BC, EC
+ * DR1 = DR2 = ECI = 0 (RQN or no-response requested), with all other bits
+ * 0 (ie RH = 0x2B0000).
+ */
+struct sna_ru_route_setup {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* ROUTE_TEST (Route Test). ROUTE_TEST requests the PC_ROUTE_MANAGER component
+ * of PU.SVC_MGR to return the status (for example, active, operative, not
+ * defined), as know in the control blocks in the node, of various explicit
+ * and/or virutal routes.
+ */
+struct sna_ru_route_test {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format;
+	__u8	test_code;
+	__u8	test_routes;
+	__u8	rsv1:6,
+		tx_priority:2;
+	__u8	rsv2:1,
+		congestion_data:1,
+		vrdi:1,
+		rsv3:5;
+	__u8	max_exp_er_len;
+	__u32	dst_subarea_addr;
+	__u16	bit_route_test;
+	__u8	req_cf[10];
+	__u8	network_id[8];
+};
+
+/* RPO (Remote Power Off). RPO Causes the receiving PU T4/5 to initiate a
+ * DLC-level power-off sequence to the T4 node specified by the adjacent link
+ * station address conveyed in the request. The node being powered off does not
+ * need to have an active SSCP-PU half-session not be contacted.
+ */
+struct sna_ru_rpo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* RQR (Request Recovery). RQR is sent by the secondary to request the primary
+ * to initiate recovery for the session by sending CLEAR or to deactivate the
+ * session. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rqr {
+	__u8	req_code;
+};
+
+/* RSHUTD (Request Shutdown). RSHUTD is sent from the secondary to the primary
+ * to indicate that the secondary is ready to have the session deactivated.
+ * RSHUTD does not request a shutdown; therefor, SHUTD is not a proper reply;
+ * RSHUTD requests an UNBIND. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rshutd {
+	__u8	req_code;
+};
+
+/* RTR (Ready to Receive). RTR indicates to the bidder that it is now allowed
+ * to initiate a bracket. RTR is sent only be the first speaker.
+ */
+struct sna_ru_rtr {
+	__u8	req_code;
+};
+
+/* SBI (Stop Bracket Indication). SBI is sent by either half-session to request
+ * that the receiving half-session stop initiating brackets by continued sending
+ * of BB and the BID request. This RU is not used by LU 6.2.
+ */
+struct sna_ru_sbi {
+	__u8	req_code;
+};
+
+/* SDT (Start Data Traffic). SDT is sent by the primary session control to the
+ * secondary session control to enable the sending and receiving of FMD and
+ * DFC requests and responses by both half-sessions. This RU is not used
+ * by LU 6.2.
+ */
+struct sna_ru_sdt {
+	__u8	req_code;
+};
+
+/* SESSEND (Session Ended). SESSEND is sent, with no-response requested, by
+ * the LU (or boundary function on behalf of the LU in a periheral node) to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully deactivated.
+ */
+struct sna_ru_sessend {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*raw;
+};
+
+/* SESSST (Session Started). SESSST is sent, with no response requested, to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully activated.
+ */
+struct sna_ru_sessst {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	*raw;
+};
+
+/* SHUTC (Shutdown Complete). SHUTC is sent by a secondary to indicate that it
+ * is in the shutdown (quiesced) state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutc {
+	__u8	req_code;
+};
+
+/* SHUTD (Shutdown). SHUTD is sent by the primary to request that the secondary
+ * shut down (quiesce) as soon as convenient. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutd {
+	__u8	req_code;
+};
+
+/* SIG (Signal). SIG is an expediated request that can be sent between
+ * half-sessions, regardless of the status of the normal flows. It carries a
+ * four-byte value, of which the first two bytes are the signal code and the
+ * last two bytes are the signal extension value.
+ */
+struct sna_ru_sig {
+	__u8	req_code;
+	__u16	signal_code;
+	__u16	signal_ext;
+};
+
+/* STSN (Set and Test Sequence Numbers). STSN is sent by the primary 
+ * half-session sync point manager to resynchronize the values of the 
+ * half-session sequence numbers, for one or both of the normal flows at both
+ * ends of the session. The RU is not used for LU 6.2.
+ */
+struct sna_ru_stsn {
+	__u8	req_code;
+	__u8	sp_act_code:2,
+		ps_act_code:2,
+		rsv1:4;
+	__u16	sp_snf;
+	__u16	ps_snf;
+};
+
+/* SWITCH (Switch Data Traffic). SWITCH is sent by the PLU to the SLU to change
+ * the (XRF) state of their LU-LU session from XRF-backup to XRF-active.
+ */
+struct sna_ru_switch {
+	__u8	req_code;
+	__u8	type;
+};
+
+/* TERM_OTHER (Terminate Other). TERM_OTHER from the TLU requests that the
+ * SSCP assist in terminating one or more sessions between the two LUs named in
+ * the RU. The requester may be a third-party LU or onr of the two named LUs.
+ * This RU is not used by LU 6.2, although it can be used by a third party
+ * LU for LU 6.2.
+ */
+struct sna_ru_term_other {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 0 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender
+ * of the request (TLU = OLU) and the DLU. This RU is not used for LU 6.2;
+ * refer to TERM_SELF FORMAT 1.
+ */
+struct sna_ru_term_self_fmt0 {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 1 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender of
+ * the request (TLU = OLU) and the DLU.
+ */
+struct sna_ru_term_self_fmt1 {
+	__u8	*raw;
+};
+
+/* TESTMODE (Test Mode). TESTMODE requests the management services associated
+ * with the PU to manage a test procedure. The test procedure begins with the
+ * TESTMODE request that initiates a test and ends when the test results and
+ * status are returned in a RECTR reply request corresponding to the initial
+ * TESTMODE request.
+ */
+struct sna_ru_testmode {
+	__u8	ns_hdr[3];
+	__u16	cnm_target_id;
+	__u16	rsv1:2,
+		cnm_target_id_desc:2,
+		prid:12;
+	__u8	*data;
+};
+
+/* UNBIND (Unbind Session). UNBIND is sent to deactivate an active session
+ * between the two LUs.
+ */
+struct sna_ru_unbind {
+	__u8	req_code;
+	__u8	unbind_type;
+	__u32	sense;
+	__u8	*ctrl_vectors;
+};
+
+/* UNBINDF (Unbind Failure). UNBINDF is sent, with no-response requested, by
+ * the PLU to notify the SSCP that the attempt to deactivate the session
+ * between the specified LUs has failed (for example, because of a path failure)
+ */
+struct sna_ru_unbindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	rsv1:1,
+		unbind_err_slu:1,
+		takedown_rej_plu:1,
+		rsv2:5;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* RU NS Header indicators. */
+#define SNA_RU_NS_CONTACT		0x010201
+#define SNA_RU_NS_DISCONTACT		0x010202
+#define SNA_RU_NS_IPLINIT		0x010203
+#define SNA_RU_NS_IPLTEXT		0x010204
+#define SNA_RU_NS_IPLFINAL		0x010205
+#define SNA_RU_NS_DUMPINIT		0x010206
+#define SNA_RU_NS_DUMPTEXT		0x010207
+#define SNA_RU_NS_DUMPFINAL		0x010208
+#define SNA_RU_NS_RPO			0x010209
+#define SNA_RU_NS_ACTLINK		0x01020A
+#define SNA_RU_NS_DACTLINK		0x01020B
+#define SNA_RU_NS_CONNOUT		0x01020E
+#define SNA_RU_NS_ABCONN		0x01020F
+#define SNA_RU_NS_SETCV			0x010211
+#define SNA_RU_NS_ESLOW			0x010214
+#define SNA_RU_NS_EXSLOW		0x010215
+#define SNA_RU_NS_ACTCONNIN		0x010216
+#define SNA_RU_NS_DACTCONNIN		0x010217
+#define SNA_RU_NS_ABCONNOUT		0x010218
+#define SNA_RU_NS_ANA			0x010219
+#define SNA_RU_NS_FNA			0x01021A
+#define SNA_RU_NS_REQDISCONT		0x01021B
+#define SNA_RU_NS_CONTACTED		0x010280
+#define SNA_RU_NS_INOP			0x010281
+#define SNA_RU_NS_REQCONT		0x010284
+#define SNA_RU_NS_NS_LSA		0x010285
+#define SNA_RU_NS_EXECTEST		0x010301
+#define SNA_RU_NS_ACTTRACE		0x010302
+#define SNA_RU_NS_DISPSTOR		0x010331
+#define SNA_RU_NS_RECSTOR		0x010334
+#define SNA_RU_NS_RECMS			0x010381
+#define SNA_RU_NS_RECTD			0x010382
+#define SNA_RU_NS_RECTRD		0x010383
+#define SNA_RU_NS_NSPE			0x010604
+#define SNA_RU_NS_INIT_SELF_FMT0	0x010681
+#define SNA_RU_NS_TERM_SELF_FMT0	0x010683
+#define SNA_RU_NS_RNAA			0x410210
+#define SNA_RU_NS_DELETENR		0x41021C
+#define SNA_RU_NS_ER_INOP		0x41021D
+#define SNA_RU_NS_ADDLINK		0x41021E
+#define SNA_RU_NS_ADDLINKSTA		0x410221
+#define SNA_RU_NS_VR_INOP		0x410223
+#define SNA_RU_NS_INITPROC		0x410235
+#define SNA_RU_NS_PROCSTAT		0x410236
+#define SNA_RU_NS_LDREQD		0x410237
+#define SNA_RU_NS_REQACTPU		0x41023E
+#define SNA_RU_NS_REQDACTPU		0x41023F
+#define SNA_RU_NS_REQACTLU		0x410240
+#define SNA_RU_NS_NS_IPL_INIT		0x410243
+#define SNA_RU_NS_NS_IPL_TEXT		0x410244
+#define SNA_RU_NS_NS_IPL_FINAL		0x410245
+#define SNA_RU_NS_NS_IPL_ABORT		0x410246
+#define SNA_RU_NS_REQFNA		0x410286
+#define SNA_RU_NS_LCP			0x410287
+#define SNA_RU_NS_ROUTE_INOP		0x410289
+#define SNA_RU_NS_REQACTCDRM		0x41028A
+#define SNA_RU_NS_REQMS			0x410304
+#define SNA_RU_NS_TESTMODE		0x410305
+#define SNA_RU_NS_ROUTE_TEST		0x410307
+#define SNA_RU_NS_RECFMS		0x410384
+#define SNA_RU_NS_RECTR			0x410385
+#define SNA_RU_NS_ER_TESTED		0x410386
+#define SNA_RU_NS_NMVT			0x41038D
+#define SNA_RU_NS_REQECHO		0x810387
+#define SNA_RU_NS_ECHOTEST		0x810389
+#define SNA_RU_NS_CINIT			0x810601
+#define SNA_RU_NS_CTERM			0x810602
+#define SNA_RU_NS_NOTIFY		0x810620
+#define SNA_RU_NS_CLEANUP		0x810629
+#define SNA_RU_NS_INIT_OTHER		0x810680
+#define SNA_RU_NS_INIT_SELF_FMT1	0x810681
+#define SNA_RU_NS_TERM_OTHER		0x810682
+#define SNA_RU_NS_TERM_SELF_FMT1	0x810683
+#define SNA_RU_NS_BINDF			0x810685
+#define SNA_RU_NS_SESSST		0x810686
+#define SNA_RU_NS_UNBINDF		0x810687
+#define SNA_RU_NS_SESSEND		0x810688
+#define SNA_RU_NS_FORWARD		0x810810
+#define SNA_RU_NS_DELIVER		0x810812
+#define SNA_RU_NS_BFCINIT		0x812601
+#define SNA_RU_NS_BFCLEANUP		0x812629
+#define SNA_RU_NS_BFINIT		0x812681
+#define SNA_RU_NS_BFTERM		0x812683
+#define SNA_RU_NS_BFSESSST		0x812686
+#define SNA_RU_NS_BFSESSEND		0x812688
+#define SNA_RU_NS_BFSESSINFO		0x81268C
+#define SNA_RU_NS_DSRLST		0x818627
+#define SNA_RU_NS_INIT_OTHER_CD		0x818640
+#define SNA_RU_NS_CDINIT		0x818641
+#define SNA_RU_NS_CDTERM		0x818643
+#define SNA_RU_NS_CDSESSF		0x818645
+#define SNA_RU_NS_CDSESST		0x818646
+#define SNA_RU_NS_CDSESSTF		0x818647
+#define SNA_RU_NS_CDSESSEND		0x818648
+#define SNA_RU_NS_CDTAKED		0x818649
+#define SNA_RU_NS_CDTAKEDC		0x81864A
+#define SNA_RU_NS_CDCINIT		0x81864B
+
+/* RU Request Codes. */
+#define SNA_RU_RC_NC_IPL_FINAL		0x02
+#define SNA_RU_RC_NC_IPL_INIT		0x03
+#define SNA_RU_RC_EXPD			0x03
+#define SNA_RU_RC_LUSTAT		0x04
+#define SNA_RU_RC_NC_IPL_TEXT		0x04
+#define SNA_RU_RC_RTR			0x05
+#define SNA_RU_RC_LSA			0x05
+#define SNA_RU_RC_NC_ER_INOP		0x06
+#define SNA_RU_RC_NC_ER_TEST		0x09
+#define SNA_RU_RC_NC_ER_TEST_REPLY	0x0A
+#define SNA_RU_RC_NC_ER_ACT		0x0B
+#define SNA_RU_RC_NC_ER_ACT_REPLY	0x0C
+#define SNA_RU_RC_ACTLU			0x0D
+#define SNA_RU_RC_NC_ACTVR		0x0D
+#define SNA_RU_RC_DACTLU		0x0E
+#define SNA_RU_RC_NC_DACTVR		0x0E
+#define SNA_RU_RC_NC_ER_OP		0x0F
+#define SNA_RU_RC_ROUTE_SETUP		0x10
+#define SNA_RU_RC_ACTPU			0x11
+#define SNA_RU_RC_DACTPU		0x12
+#define SNA_RU_RC_ACTCDRM		0x14
+#define SNA_RU_RC_DACTCDRM		0x15
+#define SNA_RU_RC_BIND			0x31
+#define SNA_RU_RC_UNBIND		0x32
+#define SNA_RU_RC_SWITCH		0x33
+#define SNA_RU_RC_NC_IPL_ABORT		0x46
+#define SNA_RU_RC_BIS			0x70
+#define SNA_RU_RC_SBI			0x71
+#define SNA_RU_RC_QEC			0x80
+#define SNA_RU_RC_QC			0x81
+#define SNA_RU_RC_RELQ			0x82
+#define SNA_RU_RC_CANCEL		0x83
+#define SNA_RU_RC_CHASE			0x84
+#define SNA_RU_RC_SDT			0xA0
+#define SNA_RU_RC_CLEAR			0xA1
+#define SNA_RU_RC_STSN			0xA2
+#define SNA_RU_RC_RQR			0xA3
+#define SNA_RU_RC_SHUTD			0xC0
+#define SNA_RU_RC_CRV			0xC0
+#define SNA_RU_RC_SHUTC			0xC1
+#define SNA_RU_RC_RSHUTD		0xC2
+#define SNA_RU_RC_BID			0xC8
+#define SNA_RU_RC_SIG			0xC9
+
+struct snaruhdr {
+	union {
+		struct sna_ru_abconn		abconn;
+		struct sna_ru_abconnout		abconnout;
+		struct sna_ru_actcdrm		actcdrm;
+		struct sna_ru_actconnin		actconnin;
+		struct sna_ru_actlink		actlink;
+		struct sna_ru_actlu		actlu;
+		struct sna_ru_actpu		actpu;
+		struct sna_ru_acttrace		acttrace;
+		struct sna_ru_addlink		addlink;
+		struct sna_ru_addlinksta	addlinksta;
+		struct sna_ru_bfcinit		bfcinit;
+		struct sna_ru_bfcleanup		bfcleanup;
+		struct sna_ru_bfinit		bfinit;
+		struct sna_ru_bfsessend		bfsessend;
+		struct sna_ru_bfsessinfo	bfsessinfo;
+		struct sna_ru_bfsessst		bfsessst;
+		struct sna_ru_bfterm		bfterm;
+		struct sna_ru_bid		bid;
+		struct sna_ru_bind		bind;
+		struct sna_ru_bindf		bindf;
+		struct sna_ru_bis		bis;
+		struct sna_ru_cancel		cancel;
+		struct sna_ru_cdcinit		cdcinit;
+		struct sna_ru_cdinit		cdinit;
+		struct sna_ru_cdsessend		cdsessend;
+		struct sna_ru_cdsessst		cdsessst;
+		struct sna_ru_cdtaked		cdtaked;
+		struct sna_ru_cdtakedc		cdtakedc;
+		struct sna_ru_cdterm		cdterm;
+		struct sna_ru_chase		chase;
+		struct sna_ru_cinit		cinit;
+		struct sna_ru_cleanup		cleanup;
+		struct sna_ru_clear		clear;
+		struct sna_ru_connout		connout;
+		struct sna_ru_contact		contact;
+		struct sna_ru_contacted		contacted;
+		struct sna_ru_crv		crv;
+		struct sna_ru_cterm		cterm;
+		struct sna_ru_dactcdrm		dactcdrm;
+		struct sna_ru_dactconnin	dactconnin;
+		struct sna_ru_dactlink		dactlink;
+		struct sna_ru_dactlu		dactlu;
+		struct sna_ru_dactpu		dactpu;
+		struct sna_ru_dacttrace		dacttrace;
+		struct sna_ru_deletenr		deletenr;
+		struct sna_ru_discontact	discontact;
+		struct sna_ru_dispstor		dispstor;
+		struct sna_ru_dsrlst		dsrlst;
+		struct sna_ru_dumpfinal		dumpfinal;
+		struct sna_ru_dumpinit		dumpinit;
+		struct sna_ru_dumptext		dumptext;
+		struct sna_ru_er_tested		er_tested;
+		struct sna_ru_eslow		eslow;
+		struct sna_ru_exectest		exectest;
+		struct sna_ru_expd		expd;
+		struct sna_ru_exslow		exslow;
+		struct sna_ru_fna		fna;
+		struct sna_ru_init_other	init_other;
+		struct sna_ru_initproc		initproc;
+		struct sna_ru_iplfinal		iplfinal;
+		struct sna_ru_iplinit		iplinit;
+		struct sna_ru_ipltext		ipltext;
+		struct sna_ru_lcp		lcp;
+		struct sna_ru_lustat		lustat;
+		struct sna_ru_nc_actvr		nc_actvr;
+		struct sna_ru_nc_er_act		nc_er_act;
+		struct sna_ru_nc_er_inop	nc_er_inop;
+		struct sna_ru_nc_er_op		nc_er_op;
+		struct sna_ru_nc_er_test	nc_er_test;
+		struct sna_ru_nc_er_test_reply	nc_er_test_reply;
+		struct sna_ru_nc_ipl_abort	nc_ipl_abort;
+		struct sna_ru_nc_ipl_final	nc_ipl_final;
+		struct sna_ru_nc_ipl_init	nc_ipl_init;
+		struct sna_ru_nc_ipl_text	nc_ipl_text;
+		struct sna_ru_nmvt		nmvt;
+		struct sna_ru_procstat		procstat;
+		struct sna_ru_qc		qc;
+		struct sna_ru_qec		qec;
+		struct sna_ru_recfms		recfms;
+		struct sna_ru_recstor		recstor;
+		struct sna_ru_rectd		rectd;
+		struct sna_ru_relq		relq;
+		struct sna_ru_reqactcdrm	reqactcdrm;
+		struct sna_ru_reqactlu		reqactlu;
+		struct sna_ru_reqactpu		reqactpu;
+		struct sna_ru_reqcontx		reqcontx;
+		struct sna_ru_reqcont		reqcont;
+		struct sna_ru_reqdactpu		reqdactpu;
+		struct sna_ru_reqdiscont	reqdiscont;
+		struct sna_ru_reqfna		reqfna;
+		struct sna_ru_reqms		reqms;
+		struct sna_ru_rnaa		rnaa;
+		struct sna_ru_route_inop	route_inop;
+		struct sna_ru_route_setup	route_setup;
+		struct sna_ru_route_test	route_test;
+		struct sna_ru_rpo		rpo;
+		struct sna_ru_rqr		rqr;
+		struct sna_ru_rshutd		rshutd;
+		struct sna_ru_rtr		rtr;
+		struct sna_ru_sbi		sbi;
+		struct sna_ru_sdt		sdt;
+		struct sna_ru_sessend		sessend;
+		struct sna_ru_sessst		sessst;
+		struct sna_ru_shutc		shutc;
+		struct sna_ru_shutd		shutd;
+		struct sna_ru_sig		sig;
+		struct sna_ru_stsn		stsn;
+		struct sna_ru_switch		ru_switch;
+		struct sna_ru_term_other	term_other;
+		struct sna_ru_term_self_fmt0	term_self_fmt0;
+		struct sna_ru_term_self_fmt1	term_self_fmt1;
+		struct sna_ru_testmode		testmode;
+		struct sna_ru_unbind		unbind;
+		struct sna_ru_unbindf		unbindf;
+		struct sna_security_reply_2	security_reply_2;
+		struct sna_fmh1			fmh1;
+		struct sna_fmh2			fmh2;
+		struct sna_fmh4			fmh4;
+		struct sna_fmh5			fmh5;
+		struct sna_fmh6			fmh6;
+		struct sna_fmh7			fmh7;
+		struct sna_fmh8			fmh8;
+		struct sna_fmh10		fmh10;
+		struct sna_fmh12		fmh12;
+		struct sna_ru_ipm		ipm;
+		__u16				*raw;
+	} ru;
+};
+
+/* MS.
+ */
+
+/* Solicitation indicators */
+#define NMVT_UNSOL      0x0
+#define NMVT_SOL        0x1
+
+/* NMVT sequence indicators */
+#define NMVT_SINGLE     0x00
+#define NMVT_LAST       0x01
+#define NMVT_FIRST      10
+#define NMVT_MIDDLE     11
+
+/* Network Managment Vector Transport (NMVT) header */
+struct sna_nmvt
+{
+//         sna_ru_request  *ru_request;
+
+        unsigned char __pad1[2];
+
+        __u16   __pad2:2,
+                __pad3:2,
+                prid:12;        /* Procedure related identifier */
+
+        __u8    si:1,           /* Solicitation indicator */
+                seqf:2,
+                sals:1,         /* SNA Address List subvector indicator */
+                __pad4:4;
+
+        unsigned char msvect;   /* One or more MS major vectors */
+};
+
+/* Record formatted maintenance statistics headers */
+
+/* CNM indicators */
+#define CNM_LSID        00
+#define CNM_ELEMENT     01
+
+/* Not last indicators */
+#define CNM_LAST_REQUEST_TRUE   0
+#define CNM_LAST_REQUEST_FALSE  1
+
+struct recfms_request
+{
+        __u8    solic:1,        /* Solicitation indicator */
+                nlri:1,         /* Not-last request indicator */
+                rqcode:6;       /* Request-specific type code */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+
+        __u16   __pad1;
+};
+
+#ifdef NOT
+
+/* Alert indicators */
+#define ALERT_EPERM             0x1     /* Permanent error */
+#define ALERT_ETEMP             0x2     /* Temporary error */
+#define ALERT_EPERFORMANCE      0x3     /* Performance error */
+#define ALERT_EINVALD           0x4     /* Unsupported or invalid use */
+#define ALERT_EBUSY             0x4     /* Busy */
+#define ALERT_EAPP              0x5     /* Application generated */
+#define ALERT_EOPRTR            0x6     /* Operator triggered */
+#define ALERT_SNA               0x7     /* SNA summary */
+
+/* Alert Major probable cause indicators */
+#define ALERT_MJ_HRDW           0x1     /* hardware */
+#define ALERT_MJ_SFTW           0x2     /* software */
+#define ALERT_MJ_LINK           0x3     /* link connection */
+#define ALERT_MJ_PROTO          0x4     /* protocol */
+#define ALERT_MJ_ENVIR          0x5     /* environment */
+#define ALERT_MJ_RMMEDIA        0x6     /* removable media */
+#define ALERT_MJ_HRDW_SFTW      0x7     /* hardware or software */
+#define ALERT_MJ_LOGIC          0x8     /* logical */
+#define ALERT_MJ_OPRTR_SNDPD    0x9     /* operator of sending product */
+#define ALERT_MJ_UNDEFINE       0xF     /* undetermined */
+
+/* Alert Minor probablt casue indicators */
+#define ALERT_MN_BPROCESSOR     0x01    /* base processor */
+#define ALERT_MN_SPROCESSOR     0x02    /* service processor */
+#define ALERT_MN_MICROCODE      0x03    /* microcode */
+#define ALERT_MN_MAINSTORAGE    0x04    /* main storage */
+#define ALERT_MN_DASD           0x05    /* DASD drive */
+#define ALERT_MN_PRINTER        0x06    /* printer */
+#define ALERT_MN_CARD           0x07    /* card reader/punch */
+#define ALERT_MN_TAPE           0x08    /* tape drive */
+#define ALERT_MN_KEYBOARD       0x09    /* keyboard */
+#define ALERT_MN_PEN            0x0A    /* selector pen */
+#define ALERT_MN_MAGREADER      0x0B    /* magnetic stripe reader */
+#define ALERT_MN_DIS_PRINTER    0x0C    /* display or printer */
+#define ALERT_MN_DISPLAY        0x0D    /* display unit */
+#define ALERT_MN_REMOTE         0x0E    /* remote product */
+#define ALERT_MN_POWER_INT      0x0F    /* power internal to this product */
+#define ALERT_MN_IOCTRLR        0x10    /* I/O attached controller */
+#define ALERT_MN_COMM_SCAN      0x11    /* communications controller scanner */
+#define ALERT_MN_COMM_ADPTR     0x12    /* communications link adapter  */
+#define ALERT_MN_LINK_ADPTR     0x13    /* link adapter */
+#define ALERT_MN_CHNL_ADPTR     0x14    /* channel adapter */
+#define ALERT_MN_LOOP_ADPTR     0x15    /* loop adapter */
+#define ALERT_MN_DIR_ADPTR      0x16    /* adapter for direct attach devices */
+#deifne ALERT_MN_MISC_ADPTR     0x17    /* miscellaneous adapter */
+#define ALERT_MN_S390_CHNL      0x18    /* System/390 channel */
+#define ALERT_MN_LINK           0x19    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LINK_COMN      0x1A    /* common carrier transmission medium */#define ALERT_MN_LINK_CUST      0x1B    /* customer transmission medium */
+#define ALERT_MN_LOOP           0x1C    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LOOP_COMN      0x1D    /* common carrier transmission medium */#define ALERT_MN_LOOP_CUST      0x1E    /* customer transmission medium */
+#define ALERT_MN_X21_EXT        0x1F    /* X.21 link conn ext to this prod */
+#define ALERT_MN_X25_EXT        0x20    /* X.25 link conn ext to this prod */
+#define ALERT_MN_X21_IFACE      0x21    /* local X.21 interface:  DTE-DCE */
+#define ALERT_MN_X25_IFACE      0x22    /* local X.25 interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_MODEM    0x23    /* local modem */
+#define ALERT_MN_REMOTE_MODEM   0x24    /* remote modem */
+#define ALERT_MN_MODEM_LIFACE   0x25    /* local modem interface:  DTE-DCE */
+#define ALERT_MN_MODEM_RIFACE   0x26    /* remote modem interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_PROBE    0x27    /* local probe */
+#define ALERT_MN_REMOTE_PROBE   0x28    /* remote probe */
+#define ALERT_MN_PROBE_LIFACE   0x29    /* local probe interface */
+#define ALERT_MN_PROBE_RIFACE   0x2A    /* remote probe interface */
+#define ALERT_MN_NETCONN        0x2B    /* network connection */
+#define ALERT_MN_IBM_HOST_PG    0x2C    /* IBM host program */
+#define ALERT_MN_IBM_HOST_APP   0x2D    /* IBM host application program */
+#define ALERT_MN_IBM_HOST_TELE  0x2E    /* IBM host telecommunication access */
+#define ALERT_MN_CUST_APP       0x2F    /* customer host application */
+#define ALERT_MN_IBM_COMM_CTRL  0x30    /* IBM comm controller program */
+#define ALERT_MN_IBM_CTRL_PG    0x31    /* IBM control program */
+#define ALERT_MN_RMT_IFMDM      0x32    /* remote modem iface or remote prod */
+#define ALERT_MN_RMT_MDM_TRANS  0x33    /* transmission med. or remote modem */
+#define ALERT_MN_SDLC_XFMT      0x34    /* SDLC format exception */
+#define ALERT_MN_BSC_XFMT       0x35    /* BSC format exception */
+#define ALERT_MN_SS_XFMT        0x36    /* start/stop format exception */
+#define ALERT_MN_SNA_XFMT       0x37    /* SNA format exception */
+#define ALERT_MN_POWER_EXT      0x38    /* power external to product */
+#define ALERT_MN_THERMAL        0x39    /* thermal */
+#define ALERT_MN_PAPER          0x3A    /* paper */
+#define ALERT_MN_TAPE           0x3B    /* tape */
+#define ALERT_MN_DASD           0x3C    /* DASD - removable media */
+#define ALERT_MN_CARD           0x3D    /* card */
+#define ALERT_MN_MAG_STRIP      0x3E    /* magnetic stripe card */
+#define ALERT_MN_NEG_SNA_RESP   0x3F    /* negative SNA response */
+#define ALERT_MN_SYS_DEF_ERR    0x40    /* system definition error */
+#define ALERT_MN_INSTALL_REST   0x41    /* installation restrictions */
+#define ALERT_MN_LS_OFFLINE     0x42    /* adjacent link station offline */
+#define ALERT_MN_LS_BUSY        0x43    /* adjacent link station busy */
+#define ALERT_MN_DEVICE         0x44    /* controller or device */
+#define ALERT_MN_LOCAL_PROBE    0x45    /* local probe or modem */
+#define ALERT_MN_DRIVE          0x46    /* tape or drive */
+#define ALERT_MN_CARD           0x47    /* card readr/punch or display/printr */#define ALERT_MN_CTRL_APP       0x48    /* controller application program */
+#define ALERT_MN_KEY_DISPLAY    0x49    /* keyboard or display */
+#define ALERT_MN_SCU            0x4A    /* storage control unit */
+#define ALERT_MN_CHNL_SCU       0x4B    /* channel or storage control unit */
+#define ALERT_MN_SCU_CTRL       0x4C    /* storage control unit or controller */#define ALERT_MN_CU             0x4D    /* control unit */
+#define ALERT_MN_DASD_M_D_D     0x4E    /* DASD data or media or drive */
+#define ALERT_MN_DASD_M_D       0x4F    /* DASD data or media */
+#define ALERT_MN_DISK           0x50    /* diskette */
+#define ALERT_MN_DISK_DRIVE     0x51    /* diskette or drive */
+#define ALERT_MN_UNDETERMINE    0xFF    /* undetermined */
+
+#endif
+
+struct recfms_alert
+{
+        __u8    alert:2,        /* 00 - Alert */
+                acode:6;        /* Alert type code - 0000 */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+        __u16   __pad1;
+
+        /* Alert classification */
+        __u8    aformat:2,      /* Alert Class Format */
+                __pad2:6;
+        __u8    atype:4,        /* Alert type, see Alert codes */
+                amjcause:4;     /* Alert major cause */
+        __u8    amncause;       /* Alert minor cause */
+        __u8    __pad3;
+        __u8    actcode;        /* User action code */
+        __u8    __pad4;
+
+        unsigned char cnmvectors;       /* Appended CNM vectors */
+};
+
+struct sna_sdlc_stats
+{
+        struct recfms_request *request; /* header */
+        __u16   wvfcs;
+        __u16   vfcs;
+};
+
+struct sna_summary_err
+{
+        struct recfms_request *request; /* header */
+        __u16   errcnt:1,       /* 1 if product error counter is valid */
+                commcnt:1,      /* 1 if comm adapter error counter is valid */
+                negcnt:1,       /* 1 if SNA neg response counter is valid */
+                __pad1:5;
+
+        __u8    __pad2;
+
+        __u8    __pad3:7,
+                commflag:1;     /* Comm adapter err flg RECFMS types 02 or 03 */
+        __u16   prodcnt;        /* Product error counter */
+        __u16   comadptr;       /* Communication adapter error counter */
+        __u16   snaneg;         /* SNA neg resps originating at this node */
+};
+
+/* Comm adapter error set indicators */
+#define COMM_ADPTR_SET1         0x01
+#define COMM_ADPTR_SET2         0x02
+#define COMM_ADPTR_SET3         0x03
+#define COMM_ADPTR_SET4         0x04
+#define COMM_ADPTR_SET5         0x05
+#define COMM_ADPTR_SET6         0x06
+
+/* Data for counters sets 1 and 2 */
+struct sna_comm_adptr_set1
+{
+        /* Communication adapter counter validity mask bytes */
+
+        __u8    nonprod_to:1,   /* Nonproductive time-out */
+                idle_to:1,      /* Idle time-out counter */
+                wrty:1,         /* Write retry counter */
+                ovrn:1,         /* Overrun counter */
+                undrn:1,        /* Underrun counter */
+                connprb:1,      /* Connection problem counter */
+                fcserr:1,       /* FCS error counter */
+                psabort:1;      /* Primary station abort counter */
+
+        __u8    cmdrej:1,       /* SDLC Command reject counter */
+                dceerr:1,       /* SDLC DCE error counter */
+                wto:1,          /* Write time-out counter */
+                inval:1,        /* Invalid status counter */
+                comm_chk:1,     /* Comm adapter machine check counter */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u8    nonprod_to_cnt; /* Nonproductive time-out counter */
+        __u8    idle_to_cnt;    /* Idle time-out counter */
+        __u8    wrty_cnt;       /* Write retry counter */
+        __u8    ovrn_cnt;       /* Overrun counter */
+        __u8    undrn_cnt;      /* Underrun counter */
+        __u8    connprb_cnt;    /* Connection problem counter */
+        __u8    fcserr_cnt;     /* FCS error counter */
+        __u8    psabort_cnt;    /* Primary station abort counter */
+        __u8    cmdrej_cnt;     /* SDLC command reject counter */
+        __u8    dceerr_cnt;     /* SDLC DCE error counter */
+        __u8    wto_cnt;        /* Write time-out counter */
+        __u8    inval_cnt;      /* Invalid status counter */
+        __u8    comm_chk_cnt;   /* Communication adapter machine check cntr */
+};
+
+/* Data for counters set 3 */
+struct sna_comm_adptr_set3
+{
+        __u8    tx_iframes:1,   /* Total transmitted I-frames counter */
+                wrty:1,         /* Write retry counter */
+                rx_iframes:1,   /* Total received I-frames counter */
+                fcserr:1,       /* FCS error counter */
+                cmdrej:1,       /* SDLC command reject counter */
+                dceerr:1,       /* DCE error counter */
+                noprod_to:1,    /* Nonproductive time-out counter */
+                __pad1;
+
+        __u16   __pad2;
+
+        __u16   tx_iframes_cnt; /* Total transmitted I-frames counter */
+        __u16   wrty_cnt;       /* Write retry counter */
+        __u16   rx_iframes_cnt; /* Total received I-frames counter */
+        __u16   fcserr_cnt;     /* FCS error counter */
+        __u16   cmdrej_cnt;     /* SDLC command reject counter */
+        __u16   dceerr_cnt;     /* DCE error counter */
+        __u16   noprod_to_cnt;  /* Nonproductive time-out counter */
+};
+
+struct sna_comm_adptr_set4
+{
+        __u8    cmdrejwni:1,    /* Command-reject-while-not-initialized cnt */
+                cmdnrec:1,      /* Command-not-recognized counter */
+                sensewni:1,     /* Sense-while-not-initialized counter */
+                chnlpcdss:1,    /* Channel-prty-chk-during-selection-seq cnt */
+                chnlpcddws:1,   /* Channel-parity-chk-during-data-wrt-seq cnt */                oppcacu:1,      /* Output-parity-check-at-control-unit cnt */
+                ippcacu:1,      /* Input-parity-check-at-control-unit counter */
+                ipcaac:1;       /* Input-parity-check-at-adapter counter */
+
+        __u8    dataeaa:1,      /* Data-error-at-adapter counter */
+                datasseq:1,     /* Data-stop-sequence counter */
+                shrtfolchk:1,   /* Short-frame-or-length-check counter */
+                connrcvwac:1,   /* Connect-rcvd-when-already-connected cnt */
+                disrcvwpuact:1, /* Disconnect-received-while-PU-active cnt */
+                longru:1,       /* Long-RU counter */
+                connprmold:1,   /* Connect-parameter-error counter */
+                rdstrtoldrcv:1; /* Read-Start-Old-received counter */
+
+        __u8    __pad1;
+
+        __u8    cmdrejwni_cnt;  /* Command-reject-while-not-initialized cnt */
+        __u8    cmdnrec_cnt;    /* Command-not-recognized counter */
+        __u8    sensewni_cnt;   /* Sense-while-not-initialized counter */
+        __u8    chnlpcdss_cnt;  /* Channel-prty-chk-during-selection-seq cnt */
+        __u8    chnlpcddws_cnt; /* Channel-parity-chk-during-data-wrt-seq cnt */        __u8    oppcacu_cnt;    /* Output-parity-check-at-control-unit cnt */
+        __u8    ippcacu_cnt;    /* Input-parity-check-at-control-unit counter */        __u8    ipcaac_cnt;     /* Input-parity-check-at-adapter counter */
+        __u8    dataeaa_cnt;    /* Data-error-at-adapter counter */
+        __u8    datasseq_cnt;   /* Data-stop-sequence counter */
+        __u8    shrtfolchk_cnt; /* Short-frame-or-length-check counter */
+        __u8    connrcvwac_cnt; /* Connect-rcvd-when-already-connected cnt */
+        __u8    disrcvwpuact_cnt;       /* Disconn-rcvd-while-PU-active cnt */
+        __u8    longru_cnt;     /* Long-RU counter */
+        __u8    connprmold_cnt; /* Connect-parameter-error counter */
+        __u8    rdstrtoldrcv_cnt;       /* Read-Start-Old-received counter */
+};
+
+struct sna_comm_adptr_set5
+{
+        __u8    tx_iframes:1,   /* I-frames transmitted counter */
+                rx_iframes:1,   /* I-frames received counter */
+                tx_rrframes:1,  /* RR frames transmitted counter */
+                rx_rrframes:1,  /* RR frames received counter */
+                tx_rnrframes:1, /* RNR frames transmitted counter */
+                rx_rnrframes:1, /* RNR frames received counter */
+                tx_rejframes:1, /* REJ frames transmitted counter */
+                rx_rejframes:1; /* REJ frames received counter */
+
+        __u8    retransmit:1,   /* Number of retransmissions counter */
+                fcs_frames:1,   /* Number of frames rcvd with FCS errors cnt */
+                rcverr:1,       /* Number of errors on receive side counter */
+                ovrn_rxs:1,     /* Number of overruns on receive side counter */                undrn_txs:1,    /* Number of underruns on transmit side cntr */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u16   tx_iframes_cnt; /* I-frames transmitted counter */
+        __u16   rx_iframes_cnt; /* I-frames received counter */
+        __u16   tx_rrframes_cnt;        /* RR frames transmitted counter */
+        __u16   rx_rrframes_cnt;        /* RR frames received counter */
+        __u16   tx_rnrframes_cnt;       /* RNR frames transmitted counter */
+        __u16   rx_rnrframes_cnt;       /* RNR frames received counter */
+        __u16   tx_rejframes_cnt;       /* REJ frames transmitted counter */
+        __u16   rx_rejframes_cnt;       /* REJ frames received counter */
+        __u16   retransmit_cnt; /* Number of retransmissions counter */
+        __u16   fcs_frames_cnt; /* Number of frames rcvd with FCS errors cnt */
+        __u16   rcverr_cnt;     /* Number of errors on receive side counter */
+        __u16   ovrn_rxs_cnt;   /* Number of overruns on receive side counter */        __u16   undrn_txs_cnt;  /* Number of underruns on transmit side cnt */
+};
+
+struct sna_comm_adptr_set6
+{
+        __u8    tx_ipackets:1,  /* data packets transmitted counter */
+                rx_ipackets:1,  /* data packets received counter */
+                tx_rrpackets:1, /* RR packets transmitted counter */
+                rx_rrpackets:1, /* RR packets received counter */
+                tx_rnrpackets:1,        /* RNR packets transmitted counter */
+                rx_rnrpackets:1,        /* RNR packets received counter */
+                tx_intpackets:1,        /* interrupt packets transmitted cnt */
+                rx_intpackets:1;        /* interrupt packets received counter */
+        __u8    connreq:1,      /* Number of connection requests counter */
+                conns:1,        /* Number of connections counter */
+                rstindic:1,     /* Number of reset indications counter */
+                clrindic:1,     /* Number of clear indications counter */
+                tx_dbit:1,      /* data packets with D-bit transmitted cnt */
+                rx_dbit:1,      /* data packets with D-bit received counter */
+                __pad1:2;
+
+        __u8    __pad2;
+
+        __u16   tx_ipackets_cnt;        /* I packets transmitted */
+        __u16   rx_ipackets_cnt;        /* I packets received */
+        __u16   tx_rrpackets_cnt;       /* RR packets transmitted */
+        __u16   rx_rrpackets_cnt;       /* RR packets received */
+        __u16   tx_rnrpackets_cnt;      /* RNR packets transmitted counter */
+        __u16   rx_rnrpackets_cnt;      /* RNR packets received counter */
+        __u16   tx_intpackets_cnt;      /* interrupt packets transmitted cnt */
+        __u16   rx_intpackets_cnt;      /* interrupt packets received counter */        __u16   connreq_cnt;    /* Total number of connection requests */
+        __u16   conns_cnt;      /* Total number of connections*/
+        __u16   rstindic_cnt;   /* Number of reset indications */
+        __u16   clrindic_cnt;   /* Number of clear indications */
+        __u16   tx_dbit_cnt;    /* Number of data pkts with D-bit transmitted */        __u16   rx_dbit_cnt;    /* Number of data packets with D-bit received */};
+
+struct sna_comm_adptr_stats
+{
+        struct recfms_request *request; /* header */
+        __u8    errset;         /* Comm adapter error counter sets */
+
+        union {         /* Data sets */
+                struct sna_comm_adptr_set1      set1;
+                struct sna_comm_adptr_set1      set2;
+                struct sna_comm_adptr_set3      set3;
+                struct sna_comm_adptr_set4      set4;
+                struct sna_comm_adptr_set5      set5;
+                struct sna_comm_adptr_set6      set6;
+        } counter;
+};
+
+struct sna_generic_stats
+{
+        struct recfms_request *request;
+        unsigned char *data;
+};
+
+/* Data selection indicators */
+#define LCSUB_LSC_SEQ           0x02
+#define LCSUB_RMT_DTE_STATS     0x03
+#define LCSUB_RMT_MDM_STEST     0x04
+
+/* Link connection subsystem type */
+#define LCSUB_TYPE1     0x01
+#define LCSUB_TYPE2     0x02
+
+/* Validity indicators */
+#define LCSUB_DATA_VALID        00
+#define LCSUB_NRSP_MDM          01
+#define LCSUB_ERSP_MDM          10
+#define LCSUB_DATA_NOTVALID     11
+
+struct sna_lcsub_stats
+{
+        struct recfms_request *request;
+
+        __u8    datasel;        /* Data selection */
+        __u8    lctype;         /* Link connection subsystem type */
+
+        /* Validity indicators */
+        __u16   rmodem_stat:2,  /* Remote modem status */
+                lmodem_stat:2,  /* Local modem status */
+                modem_stest:2,  /* Modem self test */
+                __pad1:2,
+                rdte_stat:2,    /* Remote DTE interface status */
+                __pad2:4,
+                lfmt:2;         /* Link conn subsystem data format indicator */
+
+        /* Remote modem status */
+        __u16   rhcount:6,      /* Hit count */
+                rrinit:1,       /* Modem reinitialization was performed */
+                rlrcvsig:1,     /* Loss of receive line signal */
+                rquaderr:4,     /* Quadratic error value */
+                rrdtepwroff:1,  /* Remote DTE power off detected */
+                rldtr:1,        /* Data Terminal Ready loss detected */
+                rswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                rdtestream:1;   /* DTE streaming condition detected */
+
+        /* Local modem status */
+        __u16   lhcount:6,      /* Hit count */
+                lrinit:1,       /* Modem reinitialization was performed */
+                llrcvsig:1,     /* Loss of receive line signal */
+                lquaderr:4,     /* Quadratic error value */
+                lrdtepwroff:1,  /* Remote DTE power off detected */
+                lspeed:1,       /* Speed */
+                lswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                ldtestream:1;   /* DTE streaming condition detected */
+
+        __u16   modelbits:3,    /* Model bits */
+                linktype:1,     /* Link connection type */
+                config:1,       /* Configuration */
+                mrole:1,        /* Modem role */
+                ctds:1,         /* Clear To Send delay */
+                rcvlsigdet:1,   /* Received line signal detector sensitivity */
+                modelbit1:1,    /* Model bit */
+                stest:1,        /* Modem self-test result */
+                rttest:1,       /* Remote tone test result */
+                fcarderr:1,     /* Feature card suspected in error */
+                rcvxcard:1,     /* Receiver card extension suspected in error */                frntcard:1,     /* Front end card is suspected in error */
+                modelbit2:1,    /* Model bit */
+                fcardinst:1;    /* Feature card installed */
+        __u8    swntwkbkup:1,   /* Switched-Network-Back-Up installed */
+                modelbit3:1,    /* Model bit */
+                modelbit4:1,    /* Model bit */
+                microcode:5;    /* Microcode EC level */
+
+        __u8    rts:1,          /* Request To Send */
+                cts:1,          /* Clear To Send */
+                __pad3:1,
+                td:1,           /* Transmit Data */
+                __pad4:1,
+                dtr:1,          /* Data Terminal Ready */
+                speed:1,        /* Speed */
+                dtepwrloss:1;   /* DTE power loss */
+
+        __u8    rtqc:1,         /* Request To Send changed at least once */
+                ctsc:1,         /* Clear To Send changed at least once */
+                rdc:1,          /* Received Data changed state */
+                tdc:1,          /* Transmit Data changed state */
+                rcvlsigc:1,     /* Received Line Signal loss was detected */
+                dtrd:1,         /* Data Terminal Ready dropped */
+                speedc:1,       /* Modem speed was changed */
+                dtepwrlossc:1;  /* DTE power loss was detected */
+
+                /* Channelization status */
+        __u8    channelized:1,  /* Is associated with a channelized modem */
+                tailed:1,       /* Is associated with a tailed link chnl mdm */
+                channela:1,     /* associated with channel A */
+                __pad5:5;
+
+        __u16   channelnum;     /* Channelization correlation number */
+
+        __u8    ldblvl;         /* Local modem receive dB level */
+        unsigned char __pad6[6];
+
+        __u8    rdblvl;         /* Remote modem receive dB level */
+        unsigned char __pad7[6];
+
+        __u8    lladdr;         /* Link-level addr used to addr the rmt modem */        __u8    rdteifacex;     /* Remote DTE Interface Extension */
+
+        unsigned char   __pad8[5];
+};
+
+/* CNM Vectors not included here */
+
+struct sna_recfms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {         /* Request specific information */
+                struct sna_sdlc_stats           sdlc;
+                struct sna_summary_err          sna;
+                struct sna_comm_adptr_stats     adptr;
+                struct sna_generic_stats        pulu;
+                struct sna_generic_stats        enginr;
+                struct sna_lcsub_stats          lcsub;
+        } stats;
+};
+
+struct sna_rms_gen_specific
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+};
+
+struct sna_rms_pulu
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        unsigned char *data;    /* PU- or LU-dependent request parameters */
+};
+
+struct sna_rms_lcsub
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        __u8    dselrq;         /* Data selection requested */
+
+};
+
+struct sna_rms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {
+                struct sna_rms_gen_specific     request;
+                struct sna_rms_gen_specific     sdlc;
+                struct sna_rms_gen_specific     sna;
+                struct sna_rms_gen_specific     adptr;
+                struct sna_rms_pulu             pulu;
+                struct sna_rms_gen_specific     enginr;
+                struct sna_rms_lcsub            lcsub;
+        } rms;
+};
+
+/* Control Vectors.
+ */
+
+typedef enum {
+	CV_NETNAME = 1,
+	CV_PRODUCT_ID
+} cv_type;
+
+#define CV_KEY_NETNAME		0x0E
+#define CV_KEY_PRODUCT_ID	0x10
+
+#define CV_CP_NAME		0xF4
+
+/* XID.
+ */
+
+/* Default timer values */
+#define SNA_XID_RETRY_LIMIT     10
+#define SNA_XID_IDLE_LIMIT      (60 * HZ)
+#define SNA_XID_RETRY_INTERVAL  (10 * HZ)
+
+/* XID I-field structures. The goal is to provide one set of XID headers
+ * for all device types, Eth, Tr, Sdlc, X.25, Channel, etc, etc..
+ */
+#define SNA_XID_TYPE_0          0x00    /* Xid Type 0 */
+#define SNA_XID_TYPE_1          0x01    /* Xid Type 1 */
+#define SNA_XID_TYPE_2          0x02    /* Xid Type 2 */
+#define SNA_XID_TYPE_3          0x03    /* Xid Type 3 */
+
+#define SNA_XID_NODE_T1         0x01    /* T1 node */
+#define SNA_XID_NODE_T2         0x02    /* T2.0 or T2.1 node */
+#define SNA_XID_NODE_T4         0x04    /* T4 or T5 node */
+#define SNA_XID_NODE_T5         SNA_XID_NODE_T4
+
+#define SNA_XID_XSTATE_NOSUPP	0x00
+#define SNA_XID_XSTATE_NONACT	0x01
+#define SNA_XID_XSTATE_NEG	0x02
+#define SNA_XID_XSTATE_PN	0x03
+
+typedef struct {
+        __u16   rsv1;
+        __u8    rsv2:2,
+                ls_role:1,
+                rsv3:1,
+                ls_txrx_cap:4;
+        __u8    rsv4:2,
+                seg_asm_cap:2,
+                rsv5:2,
+                sh_mode_status:1,
+                sh_mode_support:1;
+        __u16   format:1,
+                max_ifield_len:15;
+        __u8    rsv6:4,
+                sdlc_cmd_rsp_profile:4;
+        __u8    rsv7:2,
+                sdlc_init_mode:1,
+                rsv8:5;
+        __u16   rsv9;
+        __u8    rsv10:1,
+                max_rx_iframe_win:7;
+        __u8    rsv11;
+
+        /* SDLC address assignment field */
+        /*
+         * Not supported yet.
+         */
+} sna_xid1;
+
+typedef struct {
+        __u8    raw;
+} sna_xid2;
+
+typedef struct {
+        unsigned        rsv1:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+        unsigned        abm_nonact_xid:1        __attribute__ ((packed));
+        unsigned        rsv2:7                  __attribute__ ((packed));
+        unsigned        max_btu_len_format:1    __attribute__ ((packed));
+        __u16           max_btu_len:15          __attribute__ ((packed));
+        unsigned        rsv3                    __attribute__ ((packed));
+        unsigned        rsv4:2                  __attribute__ ((packed));
+        unsigned        dlc_init_mode:1         __attribute__ ((packed));
+        unsigned        rsv5:5                  __attribute__ ((packed));
+        __u16           rsv6                    __attribute__ ((packed));
+        unsigned        rsv7:1                  __attribute__ ((packed));
+        unsigned        max_rx_iframes:7        __attribute__ ((packed));
+} sna_xid_dlc_satf;
+
+typedef struct {
+        __u16   cdlc_chg:1,
+                attn_timeout_sup:1,
+                data_stream:1,
+                cdlc_chg_sup:1,
+                rsv1:12;
+        __u16   max_lpiu_len;
+        __u8    buf_prefetch;
+        __u16   num_read_cmds;
+        __u16   buf_size;
+        __u16   blocking_delay;
+        __u16   attn_timeout;
+        __u16   pre_num_read_cmds;
+        __u16   prev_pri_buf_size;
+        __u8    time_unit;
+} sna_xid_dlc_s390_channel;
+
+typedef struct {
+        __u8    rsv1:2,
+                xid_role:2,
+                rsv2:4;
+        __u8    rsv3;
+        __u16   max_btu_size;
+
+        /* Start of Control Vectors */
+        __u8    cv;
+} sna_xid_dlc_appn_channel;
+
+#pragma pack(1)
+typedef struct {
+	/* Byte 0 */
+	__u8    xid_node:4              	__attribute__ ((packed));
+        __u8    xid_type:4              	__attribute__ ((packed));
+
+	/* Byte 1 */
+        __u8    len:8                   	__attribute__ ((packed));
+
+	/* Byte 2 - 5 */
+        __u32   block_id:12,
+		pu_id:20			__attribute__ ((packed));
+
+	/* Byte 6 - 7 */
+        __u16   rsv1                            __attribute__ ((packed));
+
+	/* Byte 8 - 9 */
+	__u8		nc1			__attribute__ ((packed));
+	__u8		nc2			__attribute__ ((packed));
+/*
+        __u16        	init_self:1,
+                	stand_alone_bind:1,
+                	whole_bind:1,
+                	whole_bind_piu_req:1,
+        	        rsv2:4,
+        	        actpu_suppression:1,
+        	        network_node:1,
+        	        cp_services:1,
+        	        cp_cp_support:1,
+        	        xid_xstate:2,
+        	        nonact_xchg_sec:1,
+        	        cp_name_chg:1           __attribute__ ((packed));
+*/
+
+	/* Byte 10 */
+        /* Bind pacing support over TG */
+        __u8        	tx_adptv_bind_pacing:1,
+        		rx_adprv_bind_pacing:1,
+        		quiesce_tg_req:1,
+        		pu_cap_sup:1,
+        		appn_pbn:1,
+        		rsv3:1,
+        		adptv_bind_pacing:2     __attribute__ ((packed));
+
+	/* Byte 11 */
+        __u8        	rsv4:1,
+                	tg_sharing_prohibited:1,
+                	dedicated_scv:1,
+              		rsv5:5                  __attribute__ ((packed));
+
+	/* Byte 12 - 14 */
+	__u8		rsv6[3]			__attribute__ ((packed));
+
+	/* byte 15 */
+        __u8        	parallel_tg_sup:1,
+             		dlur_actpu:1,
+               		dlus_lu_reg:1,
+                	xhpr_bn:1,
+                	gen_odai_usage_opt_set:1,
+			rsv7:3			__attribute__ ((packed));
+
+	/* byte 16 */
+        __u8            tg_num                  __attribute__ ((packed));
+
+	/* Byte 17 */
+        __u8            dlc_type                __attribute__ ((packed));
+
+	/* Byte 18 */
+	__u8		dlc_len			__attribute__ ((packed));
+
+	/* byte 19 */
+	__u8		ls_flags		__attribute__ ((packed));
+
+/*
+	unsigned        rsv8:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+*/
+
+	/* byte 20 */
+        __u8		abm_nonact_xid:1,
+        		rsv9:7                  __attribute__ ((packed));
+
+	/* byte 21 - 22 */
+	__u16		max_btu_len		__attribute__ ((packed));
+/*
+        __u16		max_btu_len_format:1,
+        		max_btu_len:15          __attribute__ ((packed));
+*/
+
+	/* byte 23 */
+        __u8        	rsv10                   __attribute__ ((packed));
+
+	/* byte 24 */
+        __u8		rsv11:2,
+        		dlc_init_mode:1,
+        		rsv12:5                  __attribute__ ((packed));
+
+	/* byte 25 - 26 */
+        __u16           rsv13                    __attribute__ ((packed));
+
+	/* byte 27 */
+	__u8		max_rx_iframes		__attribute__ ((packed));
+/*
+        __u8		rsv14:1,
+        		max_rx_iframes:7        __attribute__ ((packed));
+*/
+} sna_xid3;
+#pragma pack()
+
+struct sna_xid {
+        __u8    xid_node:4              __attribute__ ((packed));
+        __u8    xid_type:4              __attribute__ ((packed));
+        __u8    len:8                   __attribute__ ((packed));
+        __u32   node_block_num:12       __attribute__ ((packed));
+        __u32   node_id_num:20          __attribute__ ((packed));
+
+        union {
+                sna_xid1        x1 __attribute__ ((packed));
+                sna_xid2        x2 __attribute__ ((packed));
+                sna_xid3        x3 __attribute__ ((packed));
+        } fmt;
+};
+
+#endif  /* __KERNEL__ */
+#endif  /* __NET_SNA_FORMATS_H */
diff -ruN linux-2.4.18-clean/include/net/sock.h linux/include/net/sock.h
--- linux-2.4.18-clean/include/net/sock.h	Fri Dec 21 12:42:04 2001
+++ linux/include/net/sock.h	Sat Jun  8 08:00:35 2002
@@ -24,6 +24,8 @@
  *		Alan Cox	:	Eliminate low level recv/recvfrom
  *		David S. Miller	:	New socket lookup architecture.
  *              Steve Whitehouse:       Default routines for sock_ops
+ *              Arnaldo C. Melo :	include netbeui_opt in sock->tp_pinfo,
+ *              			llc_opt and llc_ui_opt in sock->protinfo
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
@@ -94,7 +96,15 @@
 #if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
 #include <net/irda/irda.h>
 #endif
-
+#if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
+#include <linux/netbeui.h>	/* struct netbeui_opt */
+#endif
+#if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)
+#include <net/llc_conn.h>	/* struct llc_opt */
+#if defined(CONFIG_LLC_UI)
+#include <linux/llc.h>		/* struct llc_ui_opt */
+#endif
+#endif
 #if defined(CONFIG_ATM) || defined(CONFIG_ATM_MODULE)
 struct atm_vcc;
 #endif
@@ -584,7 +594,9 @@
 #if defined(CONFIG_SPX) || defined (CONFIG_SPX_MODULE)
 		struct spx_opt		af_spx;
 #endif /* CONFIG_SPX */
-
+#if defined(CONFIG_NETBEUI) || defined(CONFIG_NETBEUI_MODULE)
+		struct netbeui_opt      af_netbeui;
+#endif
 	} tp_pinfo;
 
 	int			err, err_soft;	/* Soft holds errors that don't
@@ -653,8 +665,17 @@
 #if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
 		struct irda_sock        *irda;
 #endif
+#if defined(CONFIG_LLC) || defined(CONFIG_LLC_MODULE)
+		struct llc_opt		core_llc;
+#endif
+#if defined(CONFIG_LLC_UI)
+		struct llc_ui_opt	af_llc;
+#endif
 #if defined(CONFIG_WAN_ROUTER) || defined(CONFIG_WAN_ROUTER_MODULE)
                struct wanpipe_opt      *af_wanpipe;
+#endif
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+		struct sna_opt		*af_sna;
 #endif
 	} protinfo;  		
 
diff -ruN linux-2.4.18-clean/net/802/p8022.c linux/net/802/p8022.c
--- linux-2.4.18-clean/net/802/p8022.c	Mon Oct 16 15:42:53 2000
+++ linux/net/802/p8022.c	Fri Jun  7 04:57:42 2002
@@ -11,11 +11,10 @@
  *		matches. The control byte is ignored and handling of such items
  *		is up to the routine passed the frame.
  *
- *		Unlike the 802.3 datalink we have a list of 802.2 entries as there
- *		are multiple protocols to demux. The list is currently short (3 or
- *		4 entries at most). The current demux assumes this.
+ *		Unlike the 802.3 datalink we have a list of 802.2 entries as
+ *		there are multiple protocols to demux. The list is currently
+ *		short (3 or 4 entries at most). The current demux assumes this.
  */
-
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
@@ -25,8 +24,13 @@
 #include <linux/init.h>
 #include <net/p8022.h>
 
-static struct datalink_proto *p8022_list = NULL;
+extern void llc_register_sap(unsigned char sap,
+			       int (*rcvfunc)(struct sk_buff *,
+					      struct net_device *,
+					       struct packet_type *));
+extern void llc_unregister_sap(unsigned char sap);
 
+static struct datalink_proto *p8022_list;
 /*
  *	We don't handle the loopback SAP stuff, the extended
  *	802.2 command set, multicast SAP identifiers and non UI
@@ -34,91 +38,68 @@
  *	IP and Appletalk phase 2. See the llc_* routines for
  *	support libraries if your protocol needs these.
  */
-
 static struct datalink_proto *find_8022_client(unsigned char type)
 {
-	struct datalink_proto	*proto;
-
-	for (proto = p8022_list;
-		((proto != NULL) && (*(proto->type) != type));
-		proto = proto->next)
-		;
+	struct datalink_proto *proto = p8022_list;
 
+	while (proto && *(proto->type) != type)
+		proto = proto->next;
 	return proto;
 }
 
-int p8022_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)
+int p8022_rcv(struct sk_buff *skb, struct net_device *dev,
+	      struct packet_type *pt)
 {
-	struct datalink_proto	*proto;
+	struct datalink_proto *proto;
+	int rc = 0;
 
 	proto = find_8022_client(*(skb->h.raw));
-	if (proto != NULL) 
-	{
-		skb->h.raw += 3;
-		skb->nh.raw += 3;
-		skb_pull(skb,3);
-		return proto->rcvfunc(skb, dev, pt);
+	if (!proto) {
+		skb->sk = NULL;
+		kfree_skb(skb);
+		goto out;
 	}
-
-	skb->sk = NULL;
-	kfree_skb(skb);
-	return 0;
+	skb->h.raw += 3;
+	skb->nh.raw += 3;
+	skb_pull(skb, 3);
+	rc = proto->rcvfunc(skb, dev, pt);
+out:	return rc;
 }
 
 static void p8022_datalink_header(struct datalink_proto *dl,
-		struct sk_buff *skb, unsigned char *dest_node)
+				  struct sk_buff *skb, unsigned char *dest_node)
 {
-	struct net_device	*dev = skb->dev;
-	unsigned char	*rawp;
+	struct net_device *dev = skb->dev;
+	unsigned char *rawp = skb_push(skb, 3);
 
-	rawp = skb_push(skb,3);
 	*rawp++ = dl->type[0];
 	*rawp++ = dl->type[0];
-	*rawp = 0x03;	/* UI */
+	*rawp	= 0x03;	/* UI */
 	dev->hard_header(skb, dev, ETH_P_802_3, dest_node, NULL, skb->len);
 }
 
-static struct packet_type p8022_packet_type =
-{
-	0,	/* MUTTER ntohs(ETH_P_8022),*/
-	NULL,		/* All devices */
-	p8022_rcv,
-	NULL,
-	NULL,
-};
-
-EXPORT_SYMBOL(register_8022_client);
-EXPORT_SYMBOL(unregister_8022_client);
-
-static int __init p8022_init(void)
-{
-	p8022_packet_type.type=htons(ETH_P_802_2);
-	dev_add_pack(&p8022_packet_type);
-	return 0;
-}
-
-module_init(p8022_init);
-
-struct datalink_proto *register_8022_client(unsigned char type, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *))
-{
-	struct datalink_proto	*proto;
-
-	if (find_8022_client(type) != NULL)
-		return NULL;
-
-	proto = (struct datalink_proto *) kmalloc(sizeof(*proto), GFP_ATOMIC);
-	if (proto != NULL) {
-		proto->type[0] = type;
-		proto->type_len = 1;
-		proto->rcvfunc = rcvfunc;
-		proto->header_length = 3;
-		proto->datalink_header = p8022_datalink_header;
-		proto->string_name = "802.2";
-		proto->next = p8022_list;
-		p8022_list = proto;
+struct datalink_proto *register_8022_client(unsigned char type,
+					    int (*rcvfunc)(struct sk_buff *,
+						    	   struct net_device *,
+							  struct packet_type *))
+{
+	struct datalink_proto *proto = NULL;
+
+	if (find_8022_client(type))
+		goto out;
+	proto = kmalloc(sizeof(*proto), GFP_ATOMIC);
+	if (proto) {
+		proto->type[0]		= type;
+		proto->type_len		= 1;
+		proto->rcvfunc		= rcvfunc;
+		proto->header_length	= 3;
+		proto->datalink_header	= p8022_datalink_header;
+		proto->string_name	= "802.2";
+		proto->next		= p8022_list;
+		p8022_list		= proto;
+		llc_register_sap(type, p8022_rcv);
 	}
-
-	return proto;
+out:	return proto;
 }
 
 void unregister_8022_client(unsigned char type)
@@ -128,17 +109,18 @@
 
 	save_flags(flags);
 	cli();
-
-	while ((tmp = *clients) != NULL)
-	{
+	while (*clients) {
+		tmp = *clients;
 		if (tmp->type[0] == type) {
 			*clients = tmp->next;
 			kfree(tmp);
+			llc_unregister_sap(type);
 			break;
-		} else {
-			clients = &tmp->next;
 		}
+		clients = &tmp->next;
 	}
-
 	restore_flags(flags);
 }
+
+EXPORT_SYMBOL(register_8022_client);
+EXPORT_SYMBOL(unregister_8022_client);
diff -ruN linux-2.4.18-clean/net/802/tr.c linux/net/802/tr.c
--- linux-2.4.18-clean/net/802/tr.c	Mon Oct 16 15:42:53 2000
+++ linux/net/802/tr.c	Fri Jun  7 04:57:42 2002
@@ -36,7 +36,8 @@
 #include <linux/init.h>
 #include <net/arp.h>
 
-static void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh, struct net_device *dev);
+void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh,
+		     struct net_device *dev);
 static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev);
 static void rif_check_expire(unsigned long dummy);
 
@@ -65,7 +66,7 @@
  *	up a lot.
  */
  
-rif_cache rif_table[RIF_TABLE_SIZE]={ NULL, };
+rif_cache rif_table[RIF_TABLE_SIZE];
 
 static spinlock_t rif_lock = SPIN_LOCK_UNLOCKED;
 
@@ -230,7 +231,8 @@
  *	We try to do source routing... 
  */
 
-static void tr_source_route(struct sk_buff *skb,struct trh_hdr *trh,struct net_device *dev) 
+void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh,
+		     struct net_device *dev) 
 {
 	int i, slack;
 	unsigned int hash;
diff -ruN linux-2.4.18-clean/net/Config.in linux/net/Config.in
--- linux-2.4.18-clean/net/Config.in	Mon Feb 25 14:38:14 2002
+++ linux/net/Config.in	Fri Jun  7 04:57:42 2002
@@ -15,6 +15,9 @@
    bool '  Network packet filtering debugging' CONFIG_NETFILTER_DEBUG
 fi
 bool 'Socket Filtering'  CONFIG_FILTER
+bool 'Advanced Linux Network Buffers' CONFIG_ADV_SKB
+bool 'Common Programming Interface Communications (CPI-C)' CONFIG_CPIC
+bool 'Advanced Program-to-Program Communications (APPC)' CONFIG_APPC
 tristate 'Unix domain sockets' CONFIG_UNIX
 bool 'TCP/IP networking' CONFIG_INET
 if [ "$CONFIG_INET" = "y" ]; then
@@ -50,6 +53,11 @@
 fi
 
 comment ' '
+tristate 'SNA Networking' CONFIG_SNA
+if [ "$CONFIG_SNA" != "n" ]; then
+   source net/sna/Config.in
+fi
+comment ' '
 tristate 'The IPX protocol' CONFIG_IPX
 if [ "$CONFIG_IPX" != "n" ]; then
    source net/ipx/Config.in
@@ -63,11 +71,12 @@
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
    tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
-   bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
+   tristate 'ANSI/IEEE 802.2 Data link layer protocol' CONFIG_LLC
+   if [ "$CONFIG_LLC" != "n" ]; then
+      bool '  ANSI/IEEE 802.2 Data link layer User Interface SAPs' CONFIG_LLC_UI
+      tristate 'The NETBEUI protocol' CONFIG_NETBEUI
+   fi
    bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
-#   if [ "$CONFIG_LLC" = "y" ]; then
-#      bool '  Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
-#   fi
    if [ "$CONFIG_INET" = "y" ]; then
       tristate 'Acorn Econet/AUN protocols (EXPERIMENTAL)' CONFIG_ECONET
    fi
diff -ruN linux-2.4.18-clean/net/Makefile linux/net/Makefile
--- linux-2.4.18-clean/net/Makefile	Mon Feb 25 14:38:14 2002
+++ linux/net/Makefile	Fri Jun  7 04:57:42 2002
@@ -7,7 +7,7 @@
 
 O_TARGET :=	network.o
 
-mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda bluetooth atm netlink sched
+mod-subdirs :=	ipv4/netfilter ipv6/netfilter ipx irda bluetooth atm netlink sched llc netbeui
 export-objs :=	netsyms.o
 
 subdir-y :=	core ethernet
@@ -45,9 +45,12 @@
 subdir-$(CONFIG_DECNET)		+= decnet
 subdir-$(CONFIG_ECONET)		+= econet
 subdir-$(CONFIG_VLAN_8021Q)           += 8021q
-
-
-obj-y	:= socket.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
+subdir-$(CONFIG_LLC)		+= llc
+subdir-$(CONFIG_NETBEUI)	+= netbeui
+subdir-$(CONFIG_SNA)            += sna
+  
+  
+obj-y	:= socket.o cpic.o attach.o appc.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_MODULES)		+= netsyms.o
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
diff -ruN linux-2.4.18-clean/net/README linux/net/README
--- linux-2.4.18-clean/net/README	Fri Dec 21 12:42:05 2001
+++ linux/net/README	Fri Jun  7 04:57:42 2002
@@ -24,3 +24,4 @@
 x25			g4klx@g4klx.demon.co.uk
 bluetooth		maxk@qualcomm.com
 8021q                   greearb@candelatech.com, vlan@scry.wanfear.com
+sna			jschlst@linux-sna.org
diff -ruN linux-2.4.18-clean/net/appc.c linux/net/appc.c
--- linux-2.4.18-clean/net/appc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/appc.c	Fri Jun  7 12:06:28 2002
@@ -0,0 +1,98 @@
+/* appc.c: Advanced Program-to-Program Communications.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+
+#include <linux/appc.h>
+
+#define APPC_DEBUG 10
+#ifndef APPC_DEBUG
+#define appc_debug(level, format, arg...)
+#else
+#define appc_debug(level, format, arg...) \
+        if(APPC_DEBUG >= level)  \
+		printk(__FILE__ ":" __FUNCTION__ ": " format, ## arg)
+#endif  /* APPC_DEBUG */
+
+#define MAX_APPC_ADDR   1024
+		
+static struct appc_ops *appc_client_ops[NPROTO];
+
+static int appc_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if (ulen < 0|| ulen > MAX_APPC_ADDR)
+                return -EINVAL;
+        if (ulen == 0)
+                return 0;
+        if (copy_from_user(kaddr,uaddr,ulen))
+                return -EFAULT;
+        return 0;
+}
+
+static int appc_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if (klen < 0 || klen > MAX_APPC_ADDR)
+                return -EINVAL;
+        if (klen) {
+		if (copy_to_user(uaddr,kaddr,klen))
+                        return -EFAULT;
+        }
+        return 0;
+}
+
+asmlinkage void sys_appcall(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr)
+{
+	switch (opcode) {
+		default:
+			break;
+	}
+	return;
+}
+
+int appc_register(struct appc_ops *ops)
+{
+        int err = -ENOBUFS;
+
+        if (ops->family >= NPROTO) {
+                appc_debug(5, "appc protocol %d >= NPROTO(%d)\n", 
+			ops->family, NPROTO);
+		goto out;
+        }
+        err = -EEXIST;
+        if (appc_client_ops[ops->family] == NULL) {
+                appc_client_ops[ops->family] = ops;
+                err = 0;
+        }
+out:	return err;
+}
+
+int appc_unregister(int family)
+{
+        if (family < 0 || family >= NPROTO)
+                return -1;
+        appc_client_ops[family] = NULL;
+        return 0;
+}
diff -ruN linux-2.4.18-clean/net/attach.c linux/net/attach.c
--- linux-2.4.18-clean/net/attach.c	Wed Dec 31 19:00:00 1969
+++ linux/net/attach.c	Fri Jun  7 15:53:51 2002
@@ -0,0 +1,415 @@
+/* attach.c: Linux-SNA Attach Manager Kernel Stub.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/kmod.h>
+
+#include <linux/attach.h>
+
+#define ATTACH_DEBUG 10
+#ifndef ATTACH_DEBUG
+#define attach_debug(level, format, arg...)
+#else
+#define attach_debug(level, format, arg...) \
+        if(ATTACH_DEBUG >= level)  \
+                printk(__FILE__ ":" __FUNCTION__ ": " format, ## arg)
+#endif  /* ATTACH_DEBUG */
+
+int attach_close(struct inode *inode, struct file *flip);
+
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} attach_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+
+static struct attach_ops *attach_client_ops[NPROTO];
+static struct vfsmount *attach_mnt;
+
+/* IDs for TPs connected to an attach manager */
+static unsigned long attach_tp_ids = 0;
+
+#define ATTACHFS_MAGIC 0x634F567B
+
+static int atfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type 	= ATTACHFS_MAGIC;
+        buf->f_bsize 	= 1024;
+        buf->f_namelen 	= 255;
+        return 0;
+}
+
+static struct super_operations atfs_ops = {
+        statfs:         atfs_statfs,
+};
+
+static struct super_block * atfs_read_super(struct super_block *sb, 
+	void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode 		= S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid 		= root->i_gid = 0;
+        root->i_atime 		= root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize 	= 1024;
+        sb->s_blocksize_bits 	= 10;
+        sb->s_magic 		= ATTACHFS_MAGIC;
+        sb->s_op 		= &atfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "attach:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb 	= sb;
+        sb->s_root->d_parent 	= sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(attach_fs_type, "attachfs", atfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int atfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations atfs_dentry_operations = {
+        d_delete:       atfs_delete_dentry,
+};
+
+int attach_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return -ENXIO;
+}
+
+static struct file_operations attach_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		attach_no_open,         /* special open code 
+						 * to disallow open by proc 
+						 */
+        release:	attach_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+extern __inline__ struct attach *ati_lookup(struct inode *inode)
+{
+        return &inode->u.attach_i;
+}
+
+int attach_map_fd(struct attach *at)
+{
+	struct qstr this;
+	char name[32];
+	int fd;
+	
+        /*
+         *      Find a file descriptor suitable for return to the user.
+         */
+
+        fd = get_unused_fd();
+        if (fd >= 0) {
+                struct file *file = get_empty_filp();
+
+                if (!file) {
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", at->inode->i_ino);
+                this.name = name;
+                this.len  = strlen(name);
+                this.hash = at->inode->i_ino;
+
+		file->f_dentry = d_alloc(attach_mnt->mnt_sb->s_root, &this);
+                if (!file->f_dentry) {
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+		file->f_dentry->d_op = &atfs_dentry_operations;
+                d_add(file->f_dentry, at->inode);
+                file->f_vfsmnt = mntget(attach_mnt);
+
+		at->file 	= file;
+                file->f_op 	= at->inode->i_fop = &attach_file_ops;
+                file->f_mode 	= 3;
+                file->f_flags 	= O_RDWR;
+                file->f_pos 	= 0;
+                fd_install(fd, file);
+        }
+out:	return fd;
+}
+
+struct attach *attachfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct attach *attach;
+
+        if (!(file = fget(fd))) {
+                *err = -EBADF;
+                return NULL;
+        }
+        inode = file->f_dentry->d_inode;
+        if (!inode || !inode->i_attach || !(attach = ati_lookup(inode))) {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+        if (attach->file != file) {
+                attach_debug(5, "attach file changed!\n");
+                attach->file = file;
+        }
+        return attach;
+}
+
+struct attach *attach_alloc(void)
+{
+        struct inode *inode;
+        struct attach *at;
+
+        inode = get_empty_inode();
+        if (!inode)
+                return NULL;
+        at = ati_lookup(inode);
+	if (!at)
+		return NULL;
+	
+        inode->i_mode 	= S_IFSOCK|S_IRWXUGO;
+        inode->i_attach = 1;
+        inode->i_uid 	= current->fsuid;
+        inode->i_gid 	= current->fsgid;
+
+        init_waitqueue_head(&at->wait);
+        at->fasync_list = NULL;
+        at->inode     	= inode;
+        at->flags     	= 0;
+        at->ops       	= NULL;
+        at->file      	= NULL;
+	INIT_LIST_HEAD(&at->tps);
+	attach_in_use[smp_processor_id()].counter++;
+        return at;
+}
+
+int attach_create(struct attach **a)
+{
+	struct attach *at;
+
+	if (!attach_client_ops[PF_SNA]) {
+		request_module("sna");
+		if (!attach_client_ops[PF_SNA])
+			return -ESHUTDOWN;
+	}
+	if (!(at = attach_alloc()))
+		return -ENOMEM;
+	at->ops	= attach_client_ops[PF_SNA];	/* Bad - I know */
+	*a 	= at;
+	return 0;
+}
+
+void attach_release(struct attach *at)
+{
+        attach_in_use[smp_processor_id()].counter--;
+        if (!at->file) {
+                iput(at->inode);
+                return;
+        }
+        at->file = NULL;
+}
+
+static struct attach_tps *attach_find_tp(struct attach *at, char *name)
+{
+	struct attach_tps *tps;
+	struct list_head *le;
+	
+	list_for_each(le, &at->tps) {
+		tps = list_entry(le, struct attach_tps, list);
+		if (!strcmp(tps->tp_name, name))
+			return tps;
+	}
+	return NULL;
+}
+
+/* Returns TP fd, needs attch fd and tp_info */
+asmlinkage int sys_tp_register(int s, struct tp_info *tpi)
+{
+	struct attach_tps *tp;
+	struct tp_info tpii;
+	struct attach *at;
+	int err;
+	
+	if ((at = attachfd_lookup(s, &err)) == NULL)
+		return -EBADF;
+	if(copy_from_user(&tpii, tpi, sizeof(struct tp_info)))
+                return -EFAULT;
+	tp = attach_find_tp(at, tpii.tp_name);
+	if (tp)
+		return -EEXIST;
+	tp = (struct attach_tps *)kmalloc(sizeof(struct attach_tps),GFP_ATOMIC);
+	if (!tp)
+		return -ENOMEM;
+	strncpy(tp->tp_name, tpii.tp_name, 64);
+	tp->state	= AT_INIT;
+	tp->flags	= 0;
+	tp->pid		= -1;
+	tp->id		= attach_tp_ids++;
+	list_add_tail(&tp->list, &at->tps);
+        return err;
+}
+
+/* Needs attach fd, and tp fd to unregister */
+asmlinkage int sys_tp_unregister(int a, int b)
+{
+	struct list_head *le, *se;
+	struct attach_tps *tps;
+	struct attach *at;
+	int err;
+
+	if ((at = attachfd_lookup(a, &err)) == NULL)
+                return -EBADF;
+	list_for_each_safe(le, se, &at->tps) {
+		tps = list_entry(le, struct attach_tps, list);
+		if (tps->id == b) {
+			list_del(&tps->list);
+			kfree(tps);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+/* Open an SNA Attach session, grab an unused FD and setup everything for
+ * the attach manager to start registering TPs.
+ */
+asmlinkage int sys_attach_open(void)
+{
+	int retval;
+	struct attach *a;
+
+	retval = attach_create(&a);
+	if (retval < 0)
+		goto out;
+	retval = attach_map_fd(a);
+	if (retval < 0)
+		goto out_release;
+	goto out;
+
+out_release:
+	attach_release(a);
+out:	return retval;
+}
+
+extern __inline__ void attachfd_put(struct attach *at)
+{
+        fput(at->file);
+}
+
+asmlinkage int sys_attach_listen(int s, void *ubuf, int len, unsigned int flags)
+{
+	struct attach *at;
+	int err;
+
+	at = attachfd_lookup(s, &err);
+	if (!at)
+		goto out;
+	err = at->ops->attach_listen(at, ubuf, len);
+	attachfd_put(at);
+out:	return err;
+}
+
+asmlinkage int sys_tp_correlate(int s, pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+        struct attach *at;
+        int err;
+
+        attach_debug(5, "%d %ld\n", pid, tcb_id);
+        at = attachfd_lookup(s, &err);
+        if (!at)
+                goto out;
+        err = at->ops->tp_correlate(pid, tcb_id, tp_name);
+out:	return err;
+}
+
+asmlinkage int sys_attach_close(int s)
+{
+	struct attach *at;
+	int err;
+
+	if ((at = attachfd_lookup(s, &err)) != NULL)
+		attach_release(at);
+        return err;
+}
+
+int attach_close(struct inode *inode, struct file *flip)
+{
+        if (!inode) {
+                attach_debug(5, "NULL inode\n");
+                return 0;
+        }
+        unlock_kernel();
+        attach_release(ati_lookup(inode));
+        lock_kernel();
+        return 0;
+}
+
+int attach_register(struct attach_ops *ops)
+{
+        int err = -ENOBUFS;
+
+        if (ops->family >= NPROTO) {
+                attach_debug(5, "attach %d >= NPROTO(%d)\n", 
+			ops->family, NPROTO);
+		goto out;
+        }
+        err = -EEXIST;
+        if (attach_client_ops[ops->family] == NULL) {
+                attach_client_ops[ops->family] = ops;
+                err = 0;
+        }
+	register_filesystem(&attach_fs_type);
+        attach_mnt = kern_mount(&attach_fs_type);
+out:	return err;
+}
+
+int attach_unregister(int family)
+{
+        if (family < 0 || family >= NPROTO)
+                return -1;
+        attach_client_ops[family] = NULL;
+        return 0;
+}
diff -ruN linux-2.4.18-clean/net/core/Makefile linux/net/core/Makefile
--- linux-2.4.18-clean/net/core/Makefile	Tue Oct 30 18:08:12 2001
+++ linux/net/core/Makefile	Fri Jun  7 04:57:42 2002
@@ -9,7 +9,7 @@
 
 O_TARGET := core.o
 
-export-objs := netfilter.o profile.o
+export-objs := ext8022.o netfilter.o profile.o
 
 obj-y := sock.o skbuff.o iovec.o datagram.o scm.o
 
@@ -22,6 +22,10 @@
 obj-$(CONFIG_FILTER) += filter.o
 
 obj-$(CONFIG_NET) += dev.o dev_mcast.o dst.o neighbour.o rtnetlink.o utils.o
+
+ifneq ($(CONFIG_LLC),n)
+obj-y += ext8022.o
+endif
 
 obj-$(CONFIG_NETFILTER) += netfilter.o
 obj-$(CONFIG_NET_DIVERT) += dv.o
diff -ruN linux-2.4.18-clean/net/core/ext8022.c linux/net/core/ext8022.c
--- linux-2.4.18-clean/net/core/ext8022.c	Wed Dec 31 19:00:00 1969
+++ linux/net/core/ext8022.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,76 @@
+/*
+ * (ext8022.c)
+ * 
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the 
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/brlock.h>
+
+typedef int (*func_type)(struct sk_buff *skb, struct net_device *dev,
+			 struct packet_type *pt);
+static int llc_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *);
+
+static func_type llc_sap_table[128];
+static int llc_users;
+
+static struct packet_type llc_packet_type = {
+	type:	__constant_htons(ETH_P_802_2),
+	func:	llc_rcv,
+};
+static struct packet_type llc_tr_packet_type = {
+	type:	__constant_htons(ETH_P_TR_802_2),
+	func:	llc_rcv,
+};
+
+static int llc_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt)
+{
+ 	unsigned char n = (*(skb->h.raw)) >> 1;
+
+	br_read_lock(BR_LLC_LOCK);
+	if (llc_sap_table[n])
+            llc_sap_table[n](skb, dev, pt);
+        else
+            kfree_skb(skb);
+	br_read_unlock(BR_LLC_LOCK);
+        return 0;
+}
+
+void llc_register_sap(unsigned char sap, func_type rcvfunc)
+{
+	sap >>= 1;
+	br_write_lock_bh(BR_LLC_LOCK);
+	llc_sap_table[sap] = rcvfunc;            
+	if (!llc_users) {
+		dev_add_pack(&llc_packet_type);
+		dev_add_pack(&llc_tr_packet_type);
+        }
+	llc_users++;
+	br_write_unlock_bh(BR_LLC_LOCK);
+}
+
+void llc_unregister_sap(unsigned char sap)
+{
+	sap >>= 1;
+	br_write_lock_bh(BR_LLC_LOCK);
+        llc_sap_table[sap] = NULL;
+	if (!--llc_users) {
+		dev_remove_pack(&llc_packet_type);
+		dev_remove_pack(&llc_tr_packet_type);
+        } 
+	br_write_unlock_bh(BR_LLC_LOCK);
+}
+
+EXPORT_SYMBOL(llc_register_sap);
+EXPORT_SYMBOL(llc_unregister_sap);
diff -ruN linux-2.4.18-clean/net/cpic.c linux/net/cpic.c
--- linux-2.4.18-clean/net/cpic.c	Wed Dec 31 19:00:00 1969
+++ linux/net/cpic.c	Fri Jun  7 15:53:44 2002
@@ -0,0 +1,970 @@
+/* cpic.c: Common Programming Interface Communications, v2.1 compliant.
+ *  - Protocol independent CPI-C functions. This file does all the
+ *    high-level work for a net layer using CPI-C, and condences the CPI-C
+ *    functions into a few protocol specific parts. Basicly that breaking
+ *    down into cpic.c doing error checking on the call and user-kernel
+ *    data structure transfers.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+#include <linux/kmod.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+#define CPIC_DEBUG 10
+#ifndef CPIC_DEBUG
+#define cpic_debug(level, format, arg...)
+#else
+#define cpic_debug(level, format, arg...) \
+	if(CPIC_DEBUG >= level)  \
+                printk(__FILE__ ":" __FUNCTION__ ": " format, ## arg)
+#endif  /* CPIC_DEBUG */
+
+#define CPICFS_MAGIC 	0x634D128F
+#define MAX_CPIC_ADDR   1024
+		
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} cpics_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+static struct cpic_ops *cpic_client_ops[NPROTO];
+
+static unsigned long cpic_side_id = 0;
+static LIST_HEAD(cpic_side_list);
+static struct vfsmount *cpic_mnt;
+
+static int cpic_map_fd(struct cpic *cpic);
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare);
+int cpic_close(struct inode *inode, struct file *flip);
+
+static int cpicfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type 	= CPICFS_MAGIC;
+        buf->f_bsize 	= 1024;
+        buf->f_namelen 	= 255;
+        return 0;
+}
+
+static struct super_operations cpicfs_ops = {
+        statfs:         cpicfs_statfs,
+};
+
+static struct super_block * cpicfs_read_super(struct super_block *sb, 
+	void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode 		= S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid 		= root->i_gid = 0;
+        root->i_atime 		= root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize 	= 1024;
+        sb->s_blocksize_bits 	= 10;
+        sb->s_magic 		= CPICFS_MAGIC;
+        sb->s_op 		= &cpicfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "cpic:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb 	= sb;
+        sb->s_root->d_parent 	= sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(cpic_fs_type, "cpicfs", cpicfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int cpicfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations cpicfs_dentry_operations = {
+        d_delete:       cpicfs_delete_dentry,
+};
+
+static int cpic_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if (ulen < 0|| ulen > MAX_CPIC_ADDR)
+                return -EINVAL;
+        if (ulen == 0)
+                return 0;
+        if (copy_from_user(kaddr,uaddr,ulen))
+                return -EFAULT;
+        return 0;
+}
+
+static int cpic_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if (klen < 0 || klen > MAX_CPIC_ADDR)
+                return -EINVAL;
+        if (klen) {
+                if (copy_to_user(uaddr,kaddr,klen))
+                        return -EFAULT;
+        }
+        return 0;
+}
+
+int cpic_error(void *uaddr, __u32 return_code)
+{
+        return cpic_ktou(&return_code, sizeof(return_code), uaddr);
+}
+
+int cpic_get_cvid(unsigned char CM_PTR conversation_id)
+{
+        __u32 cvid = 0;
+
+        copy_from_user(&cvid, conversation_id, sizeof(__u32));
+        return (int)cvid;
+}
+
+static struct file_operations cpic_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		cpic_no_open,		/* special open code 
+						 * to disallow open via /proc
+						 */
+        release:	cpic_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+void cpic_release(struct cpic *cpic)
+{
+	if (cpic->ops)
+		cpic->ops->release(cpic);
+	cpics_in_use[smp_processor_id()].counter--;
+	return;
+}
+
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return -ENXIO;
+}
+
+extern __inline__ struct cpic *cpici_lookup(struct inode *inode)
+{
+        return &inode->u.cpic_i;
+}
+
+extern struct cpic *cpicfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct cpic *cpic;
+
+        if (!(file = fget(fd))) {
+                *err = -EBADF;
+                return NULL;
+        }
+
+        inode = file->f_dentry->d_inode;
+        if (!inode || !inode->i_cpic || !(cpic = cpici_lookup(inode))) {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+
+        if (cpic->file != file) {
+                cpic_debug(5, "cpic file changed!\n");
+                cpic->file = file;
+        }
+	return cpic;
+}
+
+struct cpic_side_info *cpic_find_side_info(unsigned char *name)
+{
+        struct cpic_side_info *cpic;
+	struct list_head *le;
+	
+	list_for_each(le, &cpic_side_list) {
+		cpic = list_entry(le, struct cpic_side_info, list);
+		cpic_debug(5, "com -%s- -%s-\n", name, cpic->sym_dest_name);
+                if (!strncmp(cpic->sym_dest_name, name, 8))
+                        return cpic;
+	}
+        return NULL;
+}
+
+int cpic_unregister_side_info(struct cpic_delete_side_info *side)
+{
+        struct cpic_side_info *cpic;
+	struct list_head *le, *se;
+
+        list_for_each_safe(le, se, &cpic_side_list) {
+		cpic = list_entry(le, struct cpic_side_info, list);
+                if (!strncmp(cpic->sym_dest_name, side->sym_dest_name, 8)) {
+			list_del(&cpic->list);
+                        kfree(cpic);
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+struct netid *char_to_netid(unsigned char *b)
+{
+        struct netid *n;
+        unsigned char c[40];
+        int i;
+
+        strcpy(c, b);   /* always use protection */
+        n = (struct netid *)kmalloc(sizeof(struct netid), GFP_KERNEL);
+	if (!n)
+		return NULL;
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for (i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for (i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for (i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+        for (i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return n;
+}
+
+char *pr_netid(struct netid *n)
+{
+        struct netid p;
+        char *buff;
+        int i;
+
+        buff = (char *)kmalloc(20, GFP_ATOMIC);
+	if (!buff)
+		return "";
+        memcpy(&p, n, sizeof(struct netid));
+        for(i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for(i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+        return buff;
+}
+
+int cpic_register_side_info(struct cpic_define_side_info *side)
+{
+        struct cpic_side_info *cs;
+	int i;
+
+        cs = cpic_find_side_info(side->sym_dest_name);
+        if (cs)
+                return -EEXIST;
+        cs = (struct cpic_side_info *)kmalloc(sizeof(struct cpic_side_info),
+                GFP_ATOMIC);
+	if (!cs)
+		return -ENOMEM;
+	memset(cs, '\0', sizeof(struct cpic_side_info));
+	memcpy(&cs->netid, char_to_netid(side->netid), sizeof(struct netid));
+	memcpy(&cs->netid_plu, char_to_netid(side->netid_plu), 
+		sizeof(struct netid));
+        strncpy(cs->sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+	for (i = strlen(cs->sym_dest_name); i < 8; i++)
+		cs->sym_dest_name[i] = 0x20;
+        strncpy(cs->mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cs->tp_name, side->tp_name, 65);
+        cs->service_tp 		= side->service_tp;
+        cs->security_level 	= side->security_level;
+        strncpy(cs->username, side->username, 11);
+        strncpy(cs->password, side->password, 11);
+        cs->proc_id             = cpic_side_id++;
+	list_add_tail(&cs->list, &cpic_side_list);
+        return 0;
+}
+
+int cpic_ginfo(struct cpic_side_info *side, char *buf, int len)
+{
+        struct cpicsreq cr;
+        int done = 0;
+
+        if (!buf) {
+                done += sizeof(cr);
+                return done;
+        }
+        if (len < (int)sizeof(cr))
+                return done;
+        memset(&cr, '\0', sizeof(struct cpicsreq));
+
+        /* Move the data here */
+	sprintf(cr.netid, "%s", pr_netid(&side->netid));
+	sprintf(cr.netid_plu, "%s", pr_netid(&side->netid_plu));
+        strncpy(cr.sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+        strncpy(cr.mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cr.tp_name, side->tp_name, 65);
+        strncpy(cr.username, side->username, 11);
+        strncpy(cr.password, side->password, 11);
+        cr.service_tp     = side->service_tp;
+        cr.security_level = side->security_level;
+        cr.proc_id        = side->proc_id;
+
+        if (copy_to_user(buf, &cr, sizeof(struct cpicsreq)))
+                return -EFAULT;
+        buf  += sizeof(struct cpicsreq);
+        len  -= sizeof(struct cpicsreq);
+        done += sizeof(struct cpicsreq);
+        return done;
+}
+
+int cpic_query_side_info(char *arg)
+{
+        struct cpic_side_info *cpic;
+	struct list_head *le;
+	struct cpicsconf cc;
+        int len, total, err;
+	char *pos;
+
+        if (copy_from_user(&cc, arg, sizeof(cc)))
+                return -EFAULT;
+        pos = cc.cpicsc_buf;
+        len = cc.cpics_len;
+
+        total = 0;
+	list_for_each(le, &cpic_side_list) {
+		cpic = list_entry(le, struct cpic_side_info, list);
+                if (pos == NULL)
+                        err = cpic_ginfo(cpic, NULL, 0);
+                else
+                        err = cpic_ginfo(cpic, pos + total, len - total);
+                if (err < 0)
+                        return -EFAULT;
+                total += err;
+        }
+        cc.cpics_len = total;
+        if (copy_to_user(arg, &cc, sizeof(cc)))
+                return -EFAULT;
+        return 0;
+}
+
+int cpic_close(struct inode *inode, struct file *flip)
+{
+	if (!inode) {
+                cpic_debug(5, "NULL inode\n");
+                return 0;
+        }
+        unlock_kernel();
+//        cpic_fasync(-1, filp, 0);
+        cpic_release(cpici_lookup(inode));
+        lock_kernel();
+        return 0;
+}
+
+struct cpic *cpic_alloc(void)
+{
+	struct inode *inode;
+	struct cpic *cpic;
+
+	if (!cpic_client_ops[PF_SNA]) {
+		request_module("sna");
+		if (!cpic_client_ops[PF_SNA])
+			return NULL;
+	}
+	inode = get_empty_inode();
+        if (!inode)
+                return NULL;
+	cpic = cpici_lookup(inode);
+	if (!cpic)
+		return NULL;
+	
+	inode->i_mode = S_IFSOCK|S_IRWXUGO;
+        inode->i_cpic = 1;
+        inode->i_uid = current->fsuid;
+        inode->i_gid = current->fsgid;
+
+        init_waitqueue_head(&cpic->wait);
+	cpic->fasync_list 	= NULL;
+	cpic->inode     	= inode;
+	cpic->state		= CM_INIT;
+	cpic->flags		= 0;
+	cpic->side		= NULL;
+	cpic->file		= NULL;
+	cpic->pid		= 0;
+	cpic->ops 		= cpic_client_ops[PF_SNA];
+	cpics_in_use[smp_processor_id()].counter++;
+	return cpic;
+}
+
+int cpic_create(struct cpic_side_info *side, struct cpic **cpic)
+{
+	struct cpic *c;
+
+	if (!(c = cpic_alloc()))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	c->side	= side;
+	*cpic 	= c;
+	if (side)
+		c->ops->create(c, 1);
+	return CM_OK;
+}
+
+unsigned long cpic_cmaccp(unsigned char CM_PTR conversation_id, pid_t *p)
+{
+        struct cpic *cpic;
+	struct sna_tcb *tcb;
+	int fd;
+	__u32 rc;
+
+        /* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(NULL, &cpic);
+        if (rc != CM_OK)
+                goto out;
+
+	/* Now this is a local (server) tp being launched.
+	 * So we need to located the already allocated tcb and link
+	 * it to this cpic session. We do this by using the pid
+	 * provided by the user.
+	 */
+	cpic_utok(p, sizeof(pid_t), &cpic->pid);
+	tcb = cpic->vi.sna;
+	tcb = cpic->ops->find_tcb_by_pid(cpic->pid);
+	if (!tcb) {
+		cpic_debug(5, "No TCB found by PID %d\n", cpic->pid);
+		rc = CM_PRODUCT_SPECIFIC_ERROR;
+		goto out_r;
+	}
+	cpic->vi.sna = tcb;
+
+        fd = cpic_map_fd(cpic);
+        if (fd < 0)
+                goto out_r;
+        else
+                cpic_ktou(&fd, sizeof(int), conversation_id);
+	tcb->state = CM_INIT_INCOMING;
+	goto out;
+out_r:  cpic_release(cpic);
+out:    return rc;
+}
+
+unsigned long cpic_cmcnvi(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return CM_OK;
+}
+
+unsigned long cpic_cmcnvo(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return CM_OK;
+}
+
+static int cpic_map_fd(struct cpic *cpic)
+{
+	int fd;
+	struct qstr this;
+        char name[32];
+
+	/* Find a file descriptor suitable for return to the user. */
+        fd = get_unused_fd();
+        if (fd >= 0) {
+                struct file *file = get_empty_filp();
+
+                if (!file) {
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", cpic->inode->i_ino);
+                this.name = name;
+                this.len  = strlen(name);
+                this.hash = cpic->inode->i_ino;
+
+                file->f_dentry = d_alloc(cpic_mnt->mnt_sb->s_root, &this);
+                if (!file->f_dentry) {
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+
+		file->f_dentry->d_op = &cpicfs_dentry_operations;
+                d_add(file->f_dentry, cpic->inode);
+                file->f_vfsmnt 	= mntget(cpic_mnt);
+
+		cpic->file 	= file;
+                file->f_op 	= cpic->inode->i_fop = &cpic_file_ops;
+                file->f_mode 	= 3;
+                file->f_flags 	= O_RDWR;
+                file->f_pos 	= 0;
+                fd_install(fd, file);
+        }
+out:	return fd;
+}
+
+unsigned long cpic_cminit(unsigned char CM_PTR conversation_id,
+	unsigned char CM_PTR sym_dest_name)
+{
+	struct cpic_side_info *side;
+	struct cpic *cpic;
+	unsigned char sdn[9];
+	__u32 rc;
+	int fd, err;
+
+	/* Locate the side information entry */
+	err = cpic_utok(sym_dest_name, sizeof(sdn), &sdn);
+	if (err < 0)
+		return CM_PRODUCT_SPECIFIC_ERROR;
+
+	side = cpic_find_side_info(sdn);
+	if (!side)
+		return CM_PROGRAM_PARAMETER_CHECK;
+
+	/* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(side, &cpic);
+        if (rc != CM_OK)
+		goto out;
+	fd = cpic_map_fd(cpic);
+	if (fd < 0)
+		goto out_r;
+	else
+		cpic_ktou(&fd, sizeof(int), conversation_id);
+	goto out;
+out_r:  cpic_release(cpic);
+out:	return rc;
+}
+
+CM_ENTRY sys_cmrltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	ops->cmrltp(tp_name, tp_name_length, return_code);
+	return;
+}
+
+CM_ENTRY sys_cmsltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	cpic_client_ops[PF_SNA]->cmsltp(tp_name, tp_name_length, return_code);
+	return;
+}
+
+CM_ENTRY sys_cmwcmp(unsigned char CM_PTR ooid_list,
+	CM_INT32 CM_PTR ooid_list_count,
+	CM_INT32 CM_PTR timeout,
+	unsigned char CM_PTR completed_op_index_list,
+	CM_INT32 CM_PTR completed_op_count,
+	unsigned char CM_PTR user_field_list,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+	return;
+}
+
+unsigned long cpic_cmembs(__u32 *max_buffer_size)
+{
+	__u32 size = sizeof(__u32);
+        cpic_ktou(&size, sizeof(__u32), max_buffer_size);
+
+	return CM_OK;
+}
+
+asmlinkage CM_ENTRY sys_cpicall(unsigned char CM_PTR conversation_id, 
+	unsigned short opcode, void *uaddr, CM_RETURN_CODE CM_PTR return_code) 
+{
+	unsigned long rc = CM_OK;
+	struct cpic *cpic = NULL;
+        cpic_args *args = NULL;
+	int err;
+
+	/* Copy call arguments from user space */
+	args = (cpic_args *)kmalloc(sizeof(cpic_args), GFP_ATOMIC);
+	if (!args) {
+		rc = CM_PRODUCT_SPECIFIC_ERROR;
+		goto out;
+	}
+	cpic_utok(uaddr, sizeof(cpic_args), args);
+
+	/* Get the local cpic structure if available. */
+	if ((opcode != CM_CMINIT && opcode != CM_CMCNVI && opcode != CM_CMCNVO
+		&& opcode != CM_CMEMBS && opcode != CM_CMRLTP
+		&& opcode != CM_CMSLTP && opcode != CM_CMWCMP
+		&& opcode != CM_CMACCP)
+		&& ((cpic = cpicfd_lookup(cpic_get_cvid(conversation_id), &err))
+		== NULL)) {
+		rc = CM_PROGRAM_PARAMETER_CHECK;
+		goto out;
+	} 
+
+	switch (opcode) {
+		case CM_CMACCI:
+			rc = cpic->ops->cmacci(cpic);
+			break;
+		case CM_CMACCP:
+			rc = cpic_cmaccp(conversation_id, (pid_t *)args->a1);
+			break;
+		case CM_CMALLC:
+			rc = cpic->ops->cmallc(cpic);
+			break;
+		case CM_CMCANC:
+			rc = cpic->ops->cmcanc(cpic);
+			break;
+		case CM_CMCFM:
+			rc = cpic->ops->cmcfm(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMCFMD:
+			rc = cpic->ops->cmcfmd(cpic);
+			break;
+		case CM_CMCNVI:	/* No Cvid */
+			rc = cpic_cmcnvi((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+		case CM_CMCNVO:	/* No Cvid */
+			rc = cpic_cmcnvo((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+		case CM_CMDEAL:
+			rc = cpic->ops->cmdeal(cpic);
+			break;
+		case CM_CMDFDE:
+			rc = cpic->ops->cmdfde(cpic);
+			break;
+		case CM_CMEACN:
+			rc = cpic->ops->cmeacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMEAEQ:
+			rc = cpic->ops->cmeaeq(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMEAPT:
+			rc = cpic->ops->cmeapt(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMECS:
+			rc = cpic->ops->cmecs(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMECT:
+			rc = cpic->ops->cmect(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMECTX:
+			rc = cpic->ops->cmectx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMEID:
+			rc = cpic->ops->cmeid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMEMBS:	/* No Cvid */
+			rc = cpic_cmembs((__u32 *)args->a1);
+			break;
+		case CM_CMEMN:
+			rc = cpic->ops->cmemn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMEPID:
+			rc = cpic->ops->cmepid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6, (__u32 *)args->a7);
+			break;
+		case CM_CMEPLN:
+			rc = cpic->ops->cmepln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMESI:
+			rc = cpic->ops->cmesi(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+		case CM_CMESL:
+			rc = cpic->ops->cmesl(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMESRM:
+			rc = cpic->ops->cmesrm(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMESUI:
+			rc = cpic->ops->cmesui(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMETC:
+			rc = cpic->ops->cmetc(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMETPN:
+			rc = cpic->ops->cmetpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMFLUS:
+			rc = cpic->ops->cmflus(cpic);
+			break;
+		case CM_CMINCL:
+			rc = cpic->ops->cmincl(cpic);
+			break;
+		case CM_CMINIC:
+			rc = cpic->ops->cminic(cpic);
+			break;
+		case CM_CMINIT:	/* No Cvid */
+			rc = cpic_cminit(conversation_id, (__u8 *)args->a1);
+			break;
+		case CM_CMPREP:
+			rc = cpic->ops->cmprep(cpic);
+			break;
+		case CM_CMPTR:
+			rc = cpic->ops->cmptr(cpic);
+			break;
+		case CM_CMRCV:
+			rc = cpic->ops->cmrcv(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5,
+				(__u32 *)args->a6);
+			break;
+		case CM_CMRCVX:
+			rc = cpic->ops->cmrcvx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5);
+			break;
+		case CM_CMRLTP:	/* No Cvid */
+			break;
+		case CM_CMRTS:
+			rc = cpic->ops->cmrts(cpic);
+			break;
+		case CM_CMSAC:
+			rc = cpic->ops->cmsac(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSACN:
+			rc = cpic->ops->cmsacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSAEQ:
+			rc = cpic->ops->cmsaeq(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMSAPT:
+			rc = cpic->ops->cmsapt(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMSBT:
+			rc = cpic->ops->cmsbt(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSCSP:
+			rc = cpic->ops->cmscsp(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSCST:
+			rc = cpic->ops->cmscst(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSCSU:
+			rc = cpic->ops->cmscsu(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSCT:
+			rc = cpic->ops->cmsct(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSCU:
+			rc = cpic->ops->cmscu(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSDT:
+			rc = cpic->ops->cmsdt(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSED:
+			rc = cpic->ops->cmsed(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSEND:
+			rc = cpic->ops->cmsend(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMSERR:
+			rc = cpic->ops->cmserr(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSF:
+			rc = cpic->ops->cmsf(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSID:
+			rc = cpic->ops->cmsid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSLD:
+			rc = cpic->ops->cmsld(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSLTP:	/* No Cvid */
+			break;
+		case CM_CMSMN:
+			rc = cpic->ops->cmsmn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSNDX:
+			rc = cpic->ops->cmsndx(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+		case CM_CMSPDP:
+			rc = cpic->ops->cmspdp(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSPID:
+			rc = cpic->ops->cmspid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6);
+			break;
+		case CM_CMSPLN:
+			rc = cpic->ops->cmspln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMSPM:
+			rc = cpic->ops->cmspm(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSPTR:
+			rc = cpic->ops->cmsptr(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSQCF:
+			rc = cpic->ops->cmsqcf(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+		case CM_CMSQPM:
+			rc = cpic->ops->cmsqpm(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+		case CM_CMSRC:
+			rc = cpic->ops->cmsrc(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSRT:
+			rc = cpic->ops->cmsrt(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSSL:
+			rc = cpic->ops->cmssl(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSSRM:
+			rc = cpic->ops->cmssrm(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSST:
+			rc = cpic->ops->cmsst(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSTC:
+			rc = cpic->ops->cmstc(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMSTPN:
+			rc = cpic->ops->cmstpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+		case CM_CMTRTS:
+			rc = cpic->ops->cmtrts(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMWAIT:
+			rc = cpic->ops->cmwait(cpic, (__u32 *)args->a1);
+			break;
+		case CM_CMWCMP:	/* No Cvid */
+			break;
+		default:
+			rc = CM_PROGRAM_PARAMETER_CHECK;
+			goto out;
+	}
+out:	cpic_error(return_code, rc);
+	return;
+}
+
+int cpic_register(struct cpic_ops *ops)
+{
+	int err = -ENOBUFS;
+
+	if(ops->family >= NPROTO) {
+		cpic_debug(5, "cpic protocol %d >= NPROTO(%d)\n", 
+			ops->family, NPROTO);
+		goto out;
+        }
+	err = -EEXIST;
+	if (cpic_client_ops[ops->family] == NULL) {
+		cpic_client_ops[ops->family] = ops;
+		err = 0;
+	} 
+	register_filesystem(&cpic_fs_type);
+        cpic_mnt = kern_mount(&cpic_fs_type);
+out:	return err;
+}
+
+int cpic_unregister(int family)
+{
+	struct cpic_side_info *cpic;
+	struct list_head *le, *se;
+	
+	if (family < 0 || family >= NPROTO)
+		return -1;
+	list_for_each_safe(le, se, &cpic_side_list) {
+		cpic = list_entry(le, struct cpic_side_info, list);
+		list_del(&cpic->list);
+		kfree(cpic);
+	}
+	cpic_client_ops[family] = NULL;
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct cpic_side_info *cpic;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+        len += sprintf(buffer, "%-18s%-18s%-9s%-10s%-s\n",
+                "netid.node", "netid.plu", "sym_name", "mode_name", "tp_name");
+
+	list_for_each(le, &cpic_side_list) {
+		cpic = list_entry(le, struct cpic_side_info, list);
+                len += sprintf(buffer + len, "%-18s", 
+			pr_netid((struct netid *)&cpic->netid));
+                len += sprintf(buffer + len, "%-18s",
+			pr_netid((struct netid *)&cpic->netid_plu));
+                len += sprintf(buffer + len, "%-9s", cpic->sym_dest_name);
+		len += sprintf(buffer + len, "%-10s", cpic->mode_name);
+		len += sprintf(buffer + len, "%-s\n", cpic->tp_name);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif	/* CONFIG_PROC_FS */
diff -ruN linux-2.4.18-clean/net/llc/Makefile linux/net/llc/Makefile
--- linux-2.4.18-clean/net/llc/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/Makefile	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,38 @@
+###########################################################################
+# Makefile for the Linux 802.2 LLC (fully-functional) layer.
+#
+# Note 1! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+#
+# Copyright (c) 1997 by Procom Technology,Inc.
+#		2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+#
+# This program can be redistributed or modified under the terms of the 
+# GNU General Public License as published by the Free Software Foundation.
+# This program is distributed without any warranty or implied warranty
+# of merchantability or fitness for a particular purpose.
+#
+# See the GNU General Public License for more details.
+###########################################################################
+
+O_TARGET := llc.o
+
+obj-y := llc_if.o llc_c_ev.o llc_c_ac.o llc_mac.o llc_sap.o llc_s_st.o \
+	 llc_main.o llc_s_ac.o llc_conn.o llc_c_st.o llc_stat.o llc_actn.o \
+	 llc_s_ev.o llc_evnt.o llc_pdu.o
+
+ifeq ($(CONFIG_LLC_UI),y)
+  obj-y += llc_sock.o
+endif
+
+# Objects that export symbols.
+export-objs := llc_if.o
+
+ifeq ($(CONFIG_LLC),m)
+  obj-m += $(O_TARGET)
+endif
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.18-clean/net/llc/llc_actn.c linux/net/llc/llc_actn.c
--- linux-2.4.18-clean/net/llc/llc_actn.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_actn.c	Sat Jun  8 01:54:41 2002
@@ -0,0 +1,147 @@
+/*
+ * llc_actn.c - Implementation of actions of station component of LLC
+ *
+ * Description :
+ *   Functions in this module are implementation of station component actions.
+ *   Details of actions can be found in IEEE-802.2 standard document.
+ *   All functions have one station and one event as input argument. All of
+ *   them return 0 On success and 1 otherwise.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <net/llc_if.h>
+#include <net/llc_main.h>
+#include <net/llc_evnt.h>
+#include <net/llc_pdu.h>
+#include <net/llc_mac.h>
+
+static void llc_station_ack_tmr_callback(unsigned long timeout_data);
+
+int llc_station_ac_start_ack_timer(struct llc_station *station,
+				   struct llc_station_state_ev *ev)
+{
+	del_timer(&station->ack_timer);
+	station->ack_timer.expires  = jiffies + LLC_ACK_TIME * HZ;
+	station->ack_timer.data     = (unsigned long)station;
+	station->ack_timer.function = llc_station_ack_tmr_callback;
+	add_timer(&station->ack_timer);
+	station->ack_tmr_running = 1;
+	return 0;
+}
+
+int llc_station_ac_set_retry_cnt_0(struct llc_station *station,
+				   struct llc_station_state_ev *ev)
+{
+	station->retry_count = 0;
+	return 0;
+}
+
+int llc_station_ac_inc_retry_cnt_by_1(struct llc_station *station,
+				      struct llc_station_state_ev *ev)
+{
+	station->retry_count++;
+	return 0;
+}
+
+int llc_station_ac_set_xid_r_cnt_0(struct llc_station *station,
+				   struct llc_station_state_ev *ev)
+{
+	station->xid_r_count = 0;
+	return 0;
+}
+
+int llc_station_ac_inc_xid_r_cnt_by_1(struct llc_station *station,
+				      struct llc_station_state_ev *ev)
+{
+	station->xid_r_count++;
+	return 0;
+}
+
+int llc_station_ac_send_null_dsap_xid_c(struct llc_station *station,
+					struct llc_station_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (!skb)
+		goto out;
+	rc = 0;
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, 0, 0, LLC_PDU_CMD);
+	llc_pdu_init_as_xid_cmd(skb, XID_NULL_CLASS_2, 127);
+	lan_hdrs_init(skb, station->mac_sa, station->mac_sa);
+	llc_station_send_pdu(station, skb);
+out:	return rc;
+}
+
+int llc_station_ac_send_xid_r(struct llc_station *station,
+			      struct llc_station_state_ev *ev)
+{
+	u8 mac_da[MAC_ADDR_LEN], dsap;
+	int rc = 1;
+	struct sk_buff *ev_skb;
+	struct sk_buff* skb = llc_alloc_frame();
+
+	if (!skb)
+		goto out;
+	rc = 0;
+	ev_skb = ev->data.pdu.skb;
+	skb->dev = ev_skb->dev;
+	llc_pdu_decode_sa(ev_skb, mac_da);
+	llc_pdu_decode_ssap(ev_skb, &dsap);
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);
+	llc_pdu_init_as_xid_rsp(skb, XID_NULL_CLASS_2, 127);
+	lan_hdrs_init(skb, station->mac_sa, mac_da);
+	llc_station_send_pdu(station, skb);
+out:	return rc;
+}
+
+int llc_station_ac_send_test_r(struct llc_station *station,
+			       struct llc_station_state_ev *ev)
+{
+	u8 mac_da[MAC_ADDR_LEN], dsap;
+	int rc = 1;
+	struct sk_buff *ev_skb;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (!skb)
+		goto out;
+	rc = 0;
+	ev_skb = ev->data.pdu.skb;
+	skb->dev = ev_skb->dev;
+	llc_pdu_decode_sa(ev_skb, mac_da);
+	llc_pdu_decode_ssap(ev_skb, &dsap);
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);
+       	llc_pdu_init_as_test_rsp(skb);
+	lan_hdrs_init(skb, station->mac_sa, mac_da);
+	llc_station_send_pdu(station, skb);
+out:	return rc;
+}
+
+int llc_station_ac_report_status(struct llc_station *station,
+				 struct llc_station_state_ev *ev)
+{
+	return 0;
+}
+
+static void llc_station_ack_tmr_callback(unsigned long timeout_data)
+{
+	struct llc_station *station = (struct llc_station *)timeout_data;
+	struct llc_station_state_ev *ev;
+
+	station->ack_tmr_running = 0;
+	ev = llc_station_alloc_ev(station);
+	if (ev) {
+		ev->type = LLC_STATION_EV_TYPE_ACK_TMR;
+		ev->data.tmr.timer_specific = NULL;
+		llc_station_send_ev(station, ev);
+	}
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_c_ac.c linux/net/llc/llc_c_ac.c
--- linux-2.4.18-clean/net/llc/llc_c_ac.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_c_ac.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,1639 @@
+/*
+ * llc_c_ac.c - actions performed during connection state transition.
+ *
+ * Description:
+ *   Functions in this module are implementation of connection component actions
+ *   Details of actions can be found in IEEE-802.2 standard document.
+ *   All functions have one connection and one event as input argument. All of
+ *   them return 0 On success and 1 otherwise.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/sock.h>
+#include <net/llc_main.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_c_ac.h>
+#include <net/llc_c_st.h>
+#include <net/llc_pdu.h>
+#include <net/llc_mac.h>
+
+static void llc_conn_pf_cycle_tmr_cb(unsigned long timeout_data);
+static void llc_conn_ack_tmr_cb(unsigned long timeout_data);
+static void llc_conn_rej_tmr_cb(unsigned long timeout_data);
+static void llc_conn_busy_tmr_cb(unsigned long timeout_data);
+static int llc_conn_ac_inc_vs_by_1(struct sock *sk,
+				   struct llc_conn_state_ev *ev);
+static void llc_process_tmr_ev(struct sock *sk, struct llc_conn_state_ev *ev);
+static int llc_conn_ac_data_confirm(struct sock *sk,
+				    struct llc_conn_state_ev *ev);
+
+#define INCORRECT 0
+
+int llc_conn_ac_clear_remote_busy(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (llc->remote_busy_flag) {
+		u8 nr;
+		pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+		llc->remote_busy_flag = 0;
+		del_timer(&llc->busy_state_timer.timer);
+		llc->busy_state_timer.running = 0;
+		nr = LLC_I_GET_NR(rx_pdu);
+		llc_conn_resend_i_pdu_as_cmd(sk, nr, 0);
+	}
+	return 0;
+}
+
+int llc_conn_ac_conn_ind(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = ev->data.pdu.skb;
+	union llc_u_prim_data *prim_data = llc_ind_prim.data;
+	struct llc_prim_if_block *prim = &llc_ind_prim;
+	struct llc_sap *sap;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc_pdu_decode_dsap(skb, &prim_data->conn.daddr.lsap);
+	sap = llc_sap_find(prim_data->conn.daddr.lsap);
+	if (sap) {
+		llc_pdu_decode_sa(skb, llc->daddr.mac);
+		llc_pdu_decode_da(skb, llc->laddr.mac);
+		llc->dev = skb->dev;
+		prim_data->conn.pri = 0;
+		prim_data->conn.sk = sk;
+		memcpy(&prim_data->conn.daddr, &llc->laddr, sizeof(llc->laddr));
+		memcpy(&prim_data->conn.saddr, &llc->daddr, sizeof(llc->daddr));
+		prim->data = prim_data;
+		prim_data->conn.dev = skb->dev;
+		prim->prim = LLC_CONN_PRIM;
+		prim->sap = llc->sap;
+		ev->flag = 1;
+		ev->ind_prim = prim;
+		rc = 0;
+	}
+	return rc;
+}
+
+int llc_conn_ac_conn_confirm(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	union llc_u_prim_data *prim_data = llc_cfm_prim.data;
+	struct sk_buff *skb = ev->data.pdu.skb;
+	/* FIXME: wtf, this is global, so the whole thing is really non
+	 * reentrant... */
+	struct llc_prim_if_block *prim = &llc_cfm_prim;
+	struct llc_sap *sap = LLC_SK(sk)->sap;
+
+	prim_data->conn.sk     = sk;
+	prim_data->conn.pri    = 0;
+	prim_data->conn.status = ev->status;
+	prim_data->conn.link   = LLC_SK(sk)->link;
+	if (skb)
+		prim_data->conn.dev    = skb->dev;
+	else
+		printk(KERN_ERR __FUNCTION__ "ev->data.pdu.skb == NULL\n");
+	prim->data	       = prim_data;
+	prim->prim	       = LLC_CONN_PRIM;
+	prim->sap	       = sap;
+	ev->flag	       = 1;
+	ev->cfm_prim	       = prim;
+	return 0;
+}
+
+static int llc_conn_ac_data_confirm(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = &llc_cfm_prim;
+	union llc_u_prim_data *prim_data = llc_cfm_prim.data;
+
+	prim_data->data.sk     = sk;
+	prim_data->data.pri    = 0;
+	prim_data->data.link   = LLC_SK(sk)->link;
+	prim_data->data.status = LLC_STATUS_RECEIVED;
+	prim_data->data.skb    = NULL;
+	prim->data	       = prim_data;
+	prim->prim	       = LLC_DATA_PRIM;
+	prim->sap	       = LLC_SK(sk)->sap;
+	ev->flag	       = 1;
+	ev->cfm_prim	       = prim;
+	return 0;
+}
+
+int llc_conn_ac_data_ind(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	llc_conn_rtn_pdu(sk, ev->data.pdu.skb, ev);
+	return 0;
+}
+
+int llc_conn_ac_disc_ind(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	u8 reason = 0;
+	int rc = 1;
+	union llc_u_prim_data *prim_data = llc_ind_prim.data;
+	struct llc_prim_if_block *prim = &llc_ind_prim;
+
+	if (ev->type == LLC_CONN_EV_TYPE_PDU) {
+		pdu_un_t *rx_pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+		if (!LLC_PDU_IS_RSP(rx_pdu) &&
+		    !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+		    LLC_U_PDU_RSP(rx_pdu) == LLC_2_PDU_RSP_DM) {
+			reason = LLC_DISC_REASON_RX_DM_RSP_PDU;
+			rc = 0;
+		} else if (!LLC_PDU_IS_CMD(rx_pdu) &&
+			   !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+			   LLC_U_PDU_CMD(rx_pdu) == LLC_2_PDU_CMD_DISC) {
+			reason = LLC_DISC_REASON_RX_DISC_CMD_PDU;
+			rc = 0;
+		}
+	} else if (ev->type == LLC_CONN_EV_TYPE_ACK_TMR) {
+		reason = LLC_DISC_REASON_ACK_TMR_EXP;
+		rc = 0;
+	} else {
+		reason = 0;
+		rc = 1;
+	}
+	if (!rc) {
+		prim_data->disc.sk     = sk;
+		prim_data->disc.reason = reason;
+		prim_data->disc.link   = LLC_SK(sk)->link;
+		prim->data	       = prim_data;
+		prim->prim	       = LLC_DISC_PRIM;
+		prim->sap	       = LLC_SK(sk)->sap;
+		ev->flag	       = 1;
+		ev->ind_prim	       = prim;
+	}
+	return rc;
+}
+
+int llc_conn_ac_disc_confirm(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	union llc_u_prim_data *prim_data = llc_cfm_prim.data;
+	struct llc_prim_if_block *prim = &llc_cfm_prim;
+
+	prim_data->disc.sk     = sk;
+	prim_data->disc.reason = ev->status;
+	prim_data->disc.link   = LLC_SK(sk)->link;
+	prim->data	       = prim_data;
+	prim->prim	       = LLC_DISC_PRIM;
+	prim->sap	       = LLC_SK(sk)->sap;
+	ev->flag	       = 1;
+	ev->cfm_prim	       = prim;
+	return 0;
+}
+
+int llc_conn_ac_rst_ind(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	u8 reason = 0;
+	int rc = 1;
+	pdu_un_t *rx_pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+	union llc_u_prim_data *prim_data = llc_ind_prim.data;
+	struct llc_prim_if_block *prim = &llc_ind_prim;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	switch (ev->type) {
+		case LLC_CONN_EV_TYPE_PDU:
+			if (!LLC_PDU_IS_RSP(rx_pdu) &&
+			    !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+			    LLC_U_PDU_RSP(rx_pdu) == LLC_2_PDU_RSP_FRMR) {
+				reason = LLC_RESET_REASON_LOCAL;
+				rc = 0;
+			} else if (!LLC_PDU_IS_CMD(rx_pdu) &&
+				   !LLC_PDU_TYPE_IS_U(rx_pdu) &&
+				   LLC_U_PDU_CMD(rx_pdu) ==
+				   			LLC_2_PDU_CMD_SABME) {
+				reason = LLC_RESET_REASON_REMOTE;
+				rc = 0;
+			} else {
+				reason = 0;
+				rc  = 1;
+			}
+			break;
+		case LLC_CONN_EV_TYPE_ACK_TMR:
+		case LLC_CONN_EV_TYPE_P_TMR:
+		case LLC_CONN_EV_TYPE_REJ_TMR:
+		case LLC_CONN_EV_TYPE_BUSY_TMR:
+			if (llc->retry_count > llc->n2) {
+				reason = LLC_RESET_REASON_LOCAL;
+				rc = 0;
+			} else
+				rc = 1;
+			break;
+	}
+	if (!rc) {
+		prim_data->res.sk     = sk;
+		prim_data->res.reason = reason;
+		prim_data->res.link   = llc->link;
+		prim->data	      = prim_data;
+		prim->prim	      = LLC_RESET_PRIM;
+		prim->sap	      = llc->sap;
+		ev->flag	      = 1;
+		ev->ind_prim	      = prim;
+	}
+	return rc;
+}
+
+int llc_conn_ac_rst_confirm(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	union llc_u_prim_data *prim_data = llc_cfm_prim.data;
+	struct llc_prim_if_block *prim = &llc_cfm_prim;
+
+	prim_data->res.sk   = sk;
+	prim_data->res.link = LLC_SK(sk)->link;
+	prim->data	    = prim_data;
+	prim->prim	    = LLC_RESET_PRIM;
+	prim->sap	    = LLC_SK(sk)->sap;
+	ev->flag	    = 1;
+	ev->cfm_prim	    = prim;
+	return 0;
+}
+
+int llc_conn_ac_report_status(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return 0;
+}
+
+int llc_conn_ac_clear_remote_busy_if_f_eq_1(struct sock *sk,
+					struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_RSP(rx_pdu) &&
+	    !LLC_PDU_TYPE_IS_I(rx_pdu) &&
+	    !LLC_I_PF_IS_1(rx_pdu) && LLC_SK(sk)->ack_pf)
+		llc_conn_ac_clear_remote_busy(sk, ev);
+	return 0;
+}
+
+int llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2(struct sock *sk,
+						 struct llc_conn_state_ev *ev)
+{
+	if (LLC_SK(sk)->data_flag == 2) {
+		del_timer(&LLC_SK(sk)->rej_sent_timer.timer);
+		LLC_SK(sk)->rej_sent_timer.running = 0;
+	}
+	return 0;
+}
+
+int llc_conn_ac_send_disc_cmd_p_set_x(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		u8 p_bit = 1;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_disc_cmd(skb, p_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	llc_conn_ac_set_p_flag_1(sk, ev);
+	return rc;
+}
+
+int llc_conn_ac_send_dm_rsp_f_set_p(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		struct sk_buff *rx_skb = ev->data.pdu.skb;
+		u8 f_bit;
+
+		skb->dev = llc->dev;
+		llc_pdu_decode_pf_bit(rx_skb, &f_bit);
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_dm_rsp(skb, f_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_dm_rsp_f_set_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_dm_rsp(skb, f_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_dm_rsp_f_set_f_flag(struct sock *sk,
+					 struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = llc->f_flag;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_dm_rsp(skb, f_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_frmr_rsp_f_set_x(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u8 f_bit;
+	int rc = 1;
+	struct sk_buff *skb, *ev_skb = ev->data.pdu.skb;
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev_skb->nh.raw;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->rx_pdu_hdr = (u32)*((u32 *)rx_pdu);
+	if (!LLC_PDU_IS_CMD(rx_pdu))
+		llc_pdu_decode_pf_bit(ev_skb, &f_bit);
+	else
+		f_bit = 0;
+	skb = llc_alloc_frame();
+	if (skb) {
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, llc->vS,
+					 llc->vR, INCORRECT);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_resend_frmr_rsp_f_set_0(struct sock *sk,
+					struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		pdu_sn_t *rx_pdu = (pdu_sn_t *)&llc->rx_pdu_hdr;
+		u8 f_bit = 0;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, llc->vS,
+					 llc->vR, INCORRECT);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_resend_frmr_rsp_f_set_p(struct sock *sk,
+					struct llc_conn_state_ev *ev)
+{
+	u8 f_bit;
+	int rc = 1;
+	struct sk_buff *skb;
+
+	llc_pdu_decode_pf_bit(ev->data.pdu.skb, &f_bit);
+	skb = llc_alloc_frame();
+	if (skb) {
+		pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_frmr_rsp(skb, rx_pdu, f_bit, llc->vS,
+					 llc->vR, INCORRECT);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_i_cmd_p_set_1(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	u8 p_bit = 1;
+	struct sk_buff *skb = ev->data.prim.data->data->data.skb;
+	struct llc_opt *llc = LLC_SK(sk);
+	struct llc_sap *sap = llc->sap;
+
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_I, sap->laddr.lsap,
+			    llc->daddr.lsap, LLC_PDU_CMD);
+	llc_pdu_init_as_i_cmd(skb, p_bit, llc->vS, llc->vR);
+	lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+	llc_conn_send_pdu(sk, skb);
+	llc_conn_ac_inc_vs_by_1(sk, ev);
+	return 0;
+}
+
+int llc_conn_ac_send_i_cmd_p_set_0(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	u8 p_bit = 0;
+	struct sk_buff *skb = ev->data.prim.data->data->data.skb;
+	struct llc_opt *llc = LLC_SK(sk);
+	struct llc_sap *sap = llc->sap;
+
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_I, sap->laddr.lsap,
+			    llc->daddr.lsap, LLC_PDU_CMD);
+	llc_pdu_init_as_i_cmd(skb, p_bit, llc->vS, llc->vR);
+	lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+	llc_conn_send_pdu(sk, skb);
+	llc_conn_ac_inc_vs_by_1(sk, ev);
+	return 0;
+}
+
+int llc_conn_ac_resend_i_cmd_p_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 nr = LLC_I_GET_NR(rx_pdu);
+
+	llc_conn_resend_i_pdu_as_cmd(sk, nr, 1);
+	return 0;
+}
+
+int llc_conn_ac_resend_i_cmd_p_set_1_or_send_rr(struct sock *sk,
+						struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 nr = LLC_I_GET_NR(rx_pdu);
+	int rc = llc_conn_ac_send_rr_cmd_p_set_1(sk, ev);
+
+	if (!rc)
+		llc_conn_resend_i_pdu_as_cmd(sk, nr, 0);
+	return rc;
+}
+
+int llc_conn_ac_send_i_xxx_x_set_0(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	u8 p_bit = 0;
+	struct sk_buff *skb = ev->data.prim.data->data->data.skb;
+	struct llc_opt *llc = LLC_SK(sk);
+	struct llc_sap *sap = llc->sap;
+
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_I, sap->laddr.lsap,
+			    llc->daddr.lsap, LLC_PDU_CMD);
+	llc_pdu_init_as_i_cmd(skb, p_bit, llc->vS, llc->vR);
+	lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+	llc_conn_send_pdu(sk, skb);
+	llc_conn_ac_inc_vs_by_1(sk, ev);
+	return 0;
+}
+
+int llc_conn_ac_resend_i_xxx_x_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 nr = LLC_I_GET_NR(rx_pdu);
+
+	llc_conn_resend_i_pdu_as_cmd(sk, nr, 0);
+	return 0;
+}
+
+int llc_conn_ac_resend_i_xxx_x_set_0_or_send_rr(struct sock *sk,
+						struct llc_conn_state_ev *ev)
+{
+	u8 nr;
+	u8 f_bit = 0;
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	if (rc) {
+		nr = LLC_I_GET_NR(rx_pdu);
+		rc = 0;
+		llc_conn_resend_i_pdu_as_cmd(sk, nr, f_bit);
+	}
+	return rc;
+}
+
+int llc_conn_ac_resend_i_rsp_f_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 nr = LLC_I_GET_NR(rx_pdu);
+
+	llc_conn_resend_i_pdu_as_rsp(sk, nr, 1);
+	return 0;
+}
+
+int llc_conn_ac_send_rej_cmd_p_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 p_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_rej_cmd(skb, p_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rej_rsp_f_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		u8 f_bit = 1;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rej_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rej_xxx_x_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 0;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rej_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rnr_cmd_p_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 p_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_rnr_cmd(skb, p_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rnr_rsp_f_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rnr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rnr_xxx_x_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		u8 f_bit = 0;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rnr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_set_remote_busy(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (!llc->remote_busy_flag) {
+		llc->remote_busy_flag = 1;
+		llc->busy_state_timer.timer.expires = jiffies +
+					llc->busy_state_timer.expire * HZ;
+		llc->busy_state_timer.timer.data     = (unsigned long)sk;
+		llc->busy_state_timer.timer.function = llc_conn_busy_tmr_cb;
+		add_timer(&llc->busy_state_timer.timer);
+		llc->busy_state_timer.running = 1;
+	}
+	return 0;
+}
+
+int llc_conn_ac_opt_send_rnr_xxx_x_set_0(struct sock *sk,
+					 struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 0;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rnr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rr_cmd_p_set_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		u8 p_bit = 1;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_rr_cmd(skb, p_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_ack_cmd_p_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		u8 p_bit = 1;
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_rr_cmd(skb, p_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rr_rsp_f_set_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_ack_rsp_f_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 1;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_rr_xxx_x_set_0(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 0;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_ack_xxx_x_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = 0;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_sabme_cmd_p_set_x(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+	struct llc_opt *llc = LLC_SK(sk);
+	u8 p_bit = 1;
+
+	if (skb) {
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_CMD);
+		llc_pdu_init_as_sabme_cmd(skb, p_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	llc->p_flag = p_bit;
+	return rc;
+}
+
+int llc_conn_ac_send_ua_rsp_f_set_f_flag(struct sock *sk,
+				         struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = llc->f_flag;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_ua_rsp(skb, f_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_send_ua_rsp_f_set_p(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	u8 f_bit;
+	int rc = 1;
+	struct sk_buff *rx_skb = ev->data.pdu.skb;
+	struct sk_buff *skb;
+
+	llc_pdu_decode_pf_bit(rx_skb, &f_bit);
+	skb = llc_alloc_frame();
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_ua_rsp(skb, f_bit);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+int llc_conn_ac_set_s_flag_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->s_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_s_flag_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->s_flag = 1;
+	return 0;
+}
+
+int llc_conn_ac_start_p_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->p_flag = 1;
+	del_timer(&llc->pf_cycle_timer.timer);
+	llc->pf_cycle_timer.timer.expires  = jiffies +
+						llc->pf_cycle_timer.expire * HZ;
+	llc->pf_cycle_timer.timer.data     = (unsigned long)sk;
+	llc->pf_cycle_timer.timer.function = llc_conn_pf_cycle_tmr_cb;
+	add_timer(&llc->pf_cycle_timer.timer);
+	llc->pf_cycle_timer.running = 1;
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_send_ack_if_needed - check if ack is needed
+ *	@sk: current connection structure
+ *	@ev: current event
+ *
+ *	Checks number of received PDUs which have not been acknowledged, yet,
+ *	If number of them reaches to "npta"(Number of PDUs To Acknowledge) then
+ *	sends an RR response as acknowledgement for them.  Returns 0 for
+ *	success, 1 otherwise.
+ */
+int llc_conn_ac_send_ack_if_needed(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	u8 pf_bit;
+	struct sk_buff *skb = ev->data.pdu.skb;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc_pdu_decode_pf_bit(skb, &pf_bit);
+	llc->ack_pf |= pf_bit & 1;
+	if (!llc->ack_must_be_send) {
+		llc->first_pdu_Ns = llc->vR;
+		llc->ack_must_be_send = 1;
+		llc->ack_pf = pf_bit & 1;
+	}
+	if (((llc->vR - llc->first_pdu_Ns + 129) % 128) >= llc->npta) {
+		llc_conn_ac_send_rr_rsp_f_set_ackpf(sk, ev);
+		llc->ack_must_be_send	= 0;
+		llc->ack_pf		= 0;
+		llc_conn_ac_inc_npta_value(sk, ev);
+	}
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_rst_sendack_flag - resets ack_must_be_send flag
+ *	@sk: current connection structure
+ *	@ev: current event
+ *
+ *	This action resets ack_must_be_send flag of given connection, this flag
+ *	indicates if there is any PDU which has not been acknowledged yet.
+ *	Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_rst_sendack_flag(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->ack_must_be_send = LLC_SK(sk)->ack_pf = 0;
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_send_i_rsp_f_set_ackpf - acknowledge received PDUs
+ *	@sk: current connection structure
+ *	@ev: current event
+ *
+ *	Sends an I response PDU with f-bit set to ack_pf flag as acknowledge to
+ *	all received PDUs which have not been acknowledged, yet. ack_pf flag is
+ *	set to one if one PDU with p-bit set to one is received.  Returns 0 for
+ *	success, 1 otherwise.
+ */
+int llc_conn_ac_send_i_rsp_f_set_ackpf(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	struct sk_buff *skb = ev->data.prim.data->data->data.skb;
+	struct llc_opt *llc = LLC_SK(sk);
+	u8 p_bit = llc->ack_pf;
+	struct llc_sap *sap = llc->sap;
+
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_I, sap->laddr.lsap,
+			    llc->daddr.lsap, LLC_PDU_RSP);
+	llc_pdu_init_as_i_cmd(skb, p_bit, llc->vS, llc->vR);
+	lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+	llc_conn_send_pdu(sk, skb);
+	llc_conn_ac_inc_vs_by_1(sk, ev);
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_send_i_as_ack - sends an I-format PDU to acknowledge rx PDUs
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	This action sends an I-format PDU as acknowledge to received PDUs which
+ *	have not been acknowledged, yet, if there is any. By using of this
+ *	action number of acknowledgements decreases, this technic is called
+ *	piggy backing. Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_send_i_as_ack(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (llc->ack_must_be_send) {
+		llc_conn_ac_send_i_rsp_f_set_ackpf(sk, ev);
+		llc->ack_must_be_send = 0 ;
+		llc->ack_pf = 0;
+	} else
+		llc_conn_ac_send_i_cmd_p_set_0(sk, ev);
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_send_rr_rsp_f_set_ackpf - ack all rx PDUs not yet acked
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	This action sends an RR response with f-bit set to ack_pf flag as
+ *	acknowledge to all received PDUs which have not been acknowledged, yet,
+ *	if there is any. ack_pf flag indicates if a PDU has been received with
+ *	p-bit set to one. Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_send_rr_rsp_f_set_ackpf(struct sock *sk,
+					struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct sk_buff *skb = llc_alloc_frame();
+
+	if (skb) {
+		struct llc_opt *llc = LLC_SK(sk);
+		struct llc_sap *sap = llc->sap;
+		u8 f_bit = llc->ack_pf;
+
+		skb->dev = llc->dev;
+		llc_pdu_header_init(skb, LLC_PDU_TYPE_S, sap->laddr.lsap,
+				    llc->daddr.lsap, LLC_PDU_RSP);
+		llc_pdu_init_as_rr_rsp(skb, f_bit, llc->vR);
+		lan_hdrs_init(skb, llc->dev->dev_addr, llc->daddr.mac);
+		rc = 0;
+		llc_conn_send_pdu(sk, skb);
+	}
+	return rc;
+}
+
+/**
+ *	llc_conn_ac_inc_npta_value - tries to make value of npta greater
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	After "inc_cntr" times calling of this action, "npta" increase by one.
+ *	this action tries to make vale of "npta" greater as possible; number of
+ *	acknowledgements decreases by increasing of "npta". Returns 0 for
+ *	success, 1 otherwise.
+ */
+int llc_conn_ac_inc_npta_value(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (!llc->inc_cntr) {
+		llc->dec_step = 0;
+		llc->dec_cntr = llc->inc_cntr = 2;
+		++llc->npta;
+		if (llc->npta > 127)
+			llc->npta = 127 ;
+	} else
+		--llc->inc_cntr;
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_adjust_npta_by_rr - decreases "npta" by one
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	After receiving "dec_cntr" times RR command, this action decreases
+ *	"npta" by one. Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_adjust_npta_by_rr(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (!llc->connect_step && !llc->remote_busy_flag) {
+		if (!llc->dec_step) {
+			if (!llc->dec_cntr) {
+				llc->inc_cntr = llc->dec_cntr = 2;
+				if (llc->npta > 0)
+					llc->npta = llc->npta - 1;
+			} else
+				llc->dec_cntr -=1;
+		}
+	} else
+		llc->connect_step = 0 ;
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_adjust_npta_by_rnr - decreases "npta" by one
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	After receiving "dec_cntr" times RNR command, this action decreases
+ *	"npta" by one. Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_adjust_npta_by_rnr(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (llc->remote_busy_flag)
+		if (!llc->dec_step) {
+			if (!llc->dec_cntr) {
+				llc->inc_cntr = llc->dec_cntr = 2;
+				if (llc->npta > 0)
+					--llc->npta;
+			} else
+				--llc->dec_cntr;
+		}
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_dec_tx_win_size - decreases tx window size
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	After receiving of a REJ command or response, transmit window size is
+ *	decreased by number of PDUs which are outstanding yet. Returns 0 for
+ *	success, 1 otherwise.
+ */
+int llc_conn_ac_dec_tx_win_size(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+	u8 unacked_pdu = skb_queue_len(&llc->pdu_unack_q);
+
+	llc->k -= unacked_pdu;
+	if (llc->k < 2)
+		llc->k = 2;
+	return 0;
+}
+
+/**
+ *	llc_conn_ac_inc_tx_win_size - tx window size is inc by 1
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	After receiving an RR response with f-bit set to one, transmit window
+ *	size is increased by one. Returns 0 for success, 1 otherwise.
+ */
+int llc_conn_ac_inc_tx_win_size(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->k += 1;
+	if (llc->k > 128)
+		llc->k = 128 ;
+	return 0;
+}
+
+int llc_conn_ac_stop_all_timers(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	del_timer(&llc->pf_cycle_timer.timer);
+	llc->pf_cycle_timer.running = 0;
+	del_timer(&llc->ack_timer.timer);
+	llc->ack_timer.running = 0;
+	del_timer(&llc->rej_sent_timer.timer);
+	llc->rej_sent_timer.running = 0;
+	del_timer(&llc->busy_state_timer.timer);
+	llc->busy_state_timer.running = 0;
+	llc->ack_must_be_send = 0;
+	llc->ack_pf = 0;
+	return 0;
+}
+
+int llc_conn_ac_stop_other_timers(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	del_timer(&llc->rej_sent_timer.timer);
+	llc->rej_sent_timer.running = 0;
+	del_timer(&llc->pf_cycle_timer.timer);
+	llc->pf_cycle_timer.running = 0;
+	del_timer(&llc->busy_state_timer.timer);
+	llc->busy_state_timer.running = 0;
+	llc->ack_must_be_send = 0;
+	llc->ack_pf = 0;
+	return 0;
+}
+
+int llc_conn_ac_start_ack_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	del_timer(&llc->ack_timer.timer);
+	llc->ack_timer.timer.expires  = jiffies + llc->ack_timer.expire * HZ;
+	llc->ack_timer.timer.data	 = (unsigned long)sk;
+	llc->ack_timer.timer.function = llc_conn_ack_tmr_cb;
+	add_timer(&llc->ack_timer.timer);
+	llc->ack_timer.running = 1;
+	return 0;
+}
+
+int llc_conn_ac_start_rej_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	del_timer(&llc->rej_sent_timer.timer);
+	llc->rej_sent_timer.timer.expires = jiffies +
+					    llc->rej_sent_timer.expire * HZ;
+	llc->rej_sent_timer.timer.data     = (unsigned long)sk;
+	llc->rej_sent_timer.timer.function = llc_conn_rej_tmr_cb;
+	add_timer(&llc->rej_sent_timer.timer);
+	llc->rej_sent_timer.running = 1;
+	return 0;
+}
+
+int llc_conn_ac_start_ack_tmr_if_not_running(struct sock *sk,
+					   struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (!llc->ack_timer.running) {
+		llc->ack_timer.timer.expires  = jiffies +
+						llc->ack_timer.expire * HZ;
+		llc->ack_timer.timer.data     = (unsigned long)sk;
+		llc->ack_timer.timer.function = llc_conn_ack_tmr_cb;
+		add_timer(&llc->ack_timer.timer);
+		llc->ack_timer.running = 1;
+	}
+	return 0;
+}
+
+int llc_conn_ac_stop_ack_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	del_timer(&LLC_SK(sk)->ack_timer.timer);
+	LLC_SK(sk)->ack_timer.running = 0;
+	return 0;
+}
+
+int llc_conn_ac_stop_p_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	del_timer(&llc->pf_cycle_timer.timer);
+	llc->pf_cycle_timer.running = 0;
+	llc->p_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_stop_rej_timer(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	del_timer(&LLC_SK(sk)->rej_sent_timer.timer);
+	LLC_SK(sk)->rej_sent_timer.running = 0;
+	return 0;
+}
+
+int llc_conn_ac_upd_nr_received(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	int acked;
+	u16 unacked = 0;
+	u8 fbit;
+	struct sk_buff *skb = ev->data.pdu.skb;
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)skb->nh.raw;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->last_nr = PDU_SUPV_GET_Nr(rx_pdu);
+	acked = llc_conn_remove_acked_pdus(sk, llc->last_nr, &unacked);
+	/* On loopback we don't queue I frames in unack_pdu_q queue. */
+	if (acked > 0 || (llc->dev->flags & IFF_LOOPBACK)) {
+		llc->retry_count = 0;
+		del_timer(&llc->ack_timer.timer);
+		llc->ack_timer.running = 0;
+		if (llc->failed_data_req) {
+			/* already, we did not accept data from upper
+			 * layer(tx_window full or unacceptable state). now, we
+			 * can send data and must inform to upper layer. */
+			llc->failed_data_req = 0;
+			llc_conn_ac_data_confirm(sk, ev);
+		}
+		if (unacked) {
+			llc->ack_timer.timer.expires  = jiffies +
+						   llc->ack_timer.expire * HZ;
+			llc->ack_timer.timer.data     = (unsigned long)sk;
+			llc->ack_timer.timer.function = llc_conn_ack_tmr_cb;
+			add_timer(&llc->ack_timer.timer);
+			llc->ack_timer.running = 1;
+	       }
+	} else if (llc->failed_data_req) {
+		llc_pdu_decode_pf_bit(skb, &fbit);
+		if (fbit == 1) {
+			llc->failed_data_req = 0;
+			llc_conn_ac_data_confirm(sk, ev);
+		}
+	}
+	return 0;
+}
+
+int llc_conn_ac_upd_p_flag(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct sk_buff *skb = ev->data.pdu.skb;
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)skb->nh.raw;
+	u8 f_bit;
+
+	if (!LLC_PDU_IS_RSP(rx_pdu) &&
+	    !llc_pdu_decode_pf_bit(skb, &f_bit) && f_bit) {
+		LLC_SK(sk)->p_flag = 0;
+		llc_conn_ac_stop_p_timer(sk, ev);
+	}
+	return 0;
+}
+
+int llc_conn_ac_set_data_flag_2(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->data_flag = 2;
+	return 0;
+}
+
+int llc_conn_ac_set_data_flag_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->data_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_data_flag_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->data_flag = 1;
+	return 0;
+}
+
+int llc_conn_ac_set_data_flag_1_if_data_flag_eq_0(struct sock *sk,
+						  struct llc_conn_state_ev *ev)
+{
+	if (!LLC_SK(sk)->data_flag)
+		LLC_SK(sk)->data_flag = 1;
+	return 0;
+}
+
+int llc_conn_ac_set_p_flag_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->p_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_p_flag_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->p_flag = 1;
+	return 0;
+}
+
+int llc_conn_ac_set_remote_busy_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->remote_busy_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_cause_flag_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->cause_flag = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_cause_flag_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->cause_flag = 1;
+	return 0;
+}
+
+int llc_conn_ac_set_retry_cnt_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->retry_count = 0;
+	return 0;
+}
+
+int llc_conn_ac_inc_retry_cnt_by_1(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->retry_count++;
+	return 0;
+}
+
+int llc_conn_ac_set_vr_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->vR = 0;
+	return 0;
+}
+
+int llc_conn_ac_inc_vr_by_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->vR = PDU_GET_NEXT_Vr(LLC_SK(sk)->vR);
+	return 0;
+}
+
+int llc_conn_ac_set_vs_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->vS = 0;
+	return 0;
+}
+
+int llc_conn_ac_set_vs_nr(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->vS = LLC_SK(sk)->last_nr;
+	return 0;
+}
+
+int llc_conn_ac_inc_vs_by_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->vS = (LLC_SK(sk)->vS + 1) % 128;
+	return 0;
+}
+
+int llc_conn_ac_set_f_flag_p(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	llc_pdu_decode_pf_bit(ev->data.pdu.skb, &LLC_SK(sk)->f_flag);
+	return 0;
+}
+
+void llc_conn_pf_cycle_tmr_cb(unsigned long timeout_data)
+{
+	struct sock *sk = (struct sock *)timeout_data;
+	struct llc_conn_state_ev *ev;
+
+	LLC_SK(sk)->pf_cycle_timer.running = 0;
+	ev = llc_conn_alloc_ev(sk);
+	if (ev) {
+		ev->type = LLC_CONN_EV_TYPE_P_TMR;
+		ev->data.tmr.timer_specific = NULL;
+		llc_process_tmr_ev(sk, ev);
+	}
+}
+
+static void llc_conn_busy_tmr_cb(unsigned long timeout_data)
+{
+	struct sock *sk = (struct sock *)timeout_data;
+	struct llc_conn_state_ev *ev;
+
+	LLC_SK(sk)->busy_state_timer.running = 0;
+	ev = llc_conn_alloc_ev(sk);
+	if (ev) {
+		ev->type = LLC_CONN_EV_TYPE_BUSY_TMR;
+		ev->data.tmr.timer_specific = NULL;
+		llc_process_tmr_ev(sk, ev);
+	}
+}
+
+void llc_conn_ack_tmr_cb(unsigned long timeout_data)
+{
+	struct sock* sk = (struct sock *)timeout_data;
+	struct llc_conn_state_ev *ev;
+
+	LLC_SK(sk)->ack_timer.running = 0;
+	ev = llc_conn_alloc_ev(sk);
+	if (ev) {
+		ev->type = LLC_CONN_EV_TYPE_ACK_TMR;
+		ev->data.tmr.timer_specific = NULL;
+		llc_process_tmr_ev(sk, ev);
+	}
+}
+
+static void llc_conn_rej_tmr_cb(unsigned long timeout_data)
+{
+	struct sock *sk = (struct sock *)timeout_data;
+	struct llc_conn_state_ev *ev;
+
+	LLC_SK(sk)->rej_sent_timer.running = 0;
+	ev = llc_conn_alloc_ev(sk);
+	if (ev) {
+		ev->type = LLC_CONN_EV_TYPE_REJ_TMR;
+		ev->data.tmr.timer_specific = NULL;
+		llc_process_tmr_ev(sk, ev);
+	}
+}
+
+int llc_conn_ac_rst_vs(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	LLC_SK(sk)->X = LLC_SK(sk)->vS;
+	llc_conn_ac_set_vs_nr(sk, ev);
+	return 0;
+}
+
+int llc_conn_ac_upd_vs(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *rx_pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 nr = PDU_SUPV_GET_Nr(rx_pdu);
+
+	if (llc_circular_between(LLC_SK(sk)->vS, nr, LLC_SK(sk)->X))
+		llc_conn_ac_set_vs_nr(sk, ev);
+	return 0;
+}
+
+/*
+ * Non-standard actions; these not contained in IEEE specification; for
+ * our own usage
+ */
+/**
+ *	llc_conn_disc - removes connection from SAP list and frees it
+ *	@conn: closed connection
+ *	@ev: occurred event
+ *
+ *	Returns 2, to indicate the state machine that the connection was freed.
+ */
+int llc_conn_disc(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	llc_sap_unassign_sock(LLC_SK(sk)->sap, sk);
+	llc_sock_free(sk);
+	return 2;
+}
+
+/**
+ *	llc_conn_reset - resets connection
+ *	@sk : reseting connection.
+ *	@ev: occurred event.
+ *
+ *	Stop all timers, empty all queues and reset all flags.
+ */
+int llc_conn_reset(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	llc_sock_reset(sk);
+	return 0;
+}
+
+/**
+ *	llc_circular_between - designates that b is between a and c or not
+ *	@a: lower bound
+ *	@b: element to see if is between a and b
+ *	@c: upper bound
+ *
+ *	This function designates that b is between a and c or not (for example,
+ *	0 is between 127 and 1). Returns 1 if b is between a and c, 0
+ *	otherwise.
+ */
+u8 llc_circular_between(u8 a, u8 b, u8 c)
+{
+	b = b - a;
+	c = c - a;
+	return b <= c;
+}
+
+/**
+ *	llc_process_tmr_ev - timer backend
+ *	@conn: active connection
+ *	@ev: occurred event
+ *
+ *	This function is called from timer callback functions. When connection
+ *	is busy (during sending a data frame) timer expiration event must be
+ *	queued. Otherwise this event can be sent to connection state machine.
+ *	Queued events will process by process_rxframes_events function after
+ *	sending data frame.  Returns 0 for success, 1 otherwise.
+ */
+static void llc_process_tmr_ev(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	bh_lock_sock(sk);
+	if (LLC_SK(sk)->state == LLC_CONN_OUT_OF_SVC) {
+		printk(KERN_WARNING "timer called on closed connection\n");
+		llc_conn_free_ev(ev);
+		goto out;
+	}
+	if (!sk->lock.users)
+		llc_conn_send_ev(sk, ev);
+	else {
+		struct sk_buff *skb = alloc_skb(1, GFP_ATOMIC);
+
+		if (skb) {
+			skb->cb[0] = LLC_EVENT;
+			skb->data = (void *)ev;
+			sk_add_backlog(sk, skb);
+		} else
+			llc_conn_free_ev(ev);
+	}
+out:	bh_unlock_sock(sk);
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_c_ev.c linux/net/llc/llc_c_ev.c
--- linux-2.4.18-clean/net/llc/llc_c_ev.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_c_ev.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,868 @@
+/*
+ * llc_c_ev.c - Connection component state transition event qualifiers
+ *
+ * A 'state' consists of a number of possible event matching functions,
+ * the actions associated with each being executed when that event is
+ * matched; a 'state machine' accepts events in a serial fashion from an
+ * event queue. Each event is passed to each successive event matching
+ * function until a match is made (the event matching function returns
+ * success, or '0') or the list of event matching functions is exhausted.
+ * If a match is made, the actions associated with the event are executed
+ * and the state is changed to that event's transition state. Before some
+ * events are recognized, even after a match has been made, a certain
+ * number of 'event qualifier' functions must also be executed. If these
+ * all execute successfully, then the event is finally executed.
+ *
+ * These event functions must return 0 for success, to show a matched
+ * event, of 1 if the event does not match. Event qualifier functions
+ * must return a 0 for success or a non-zero for failure. Each function
+ * is simply responsible for verifying one single thing and returning
+ * either a success or failure.
+ *
+ * All of followed event functions are described in 802.2 LLC Protocol
+ * standard document except two functions that we added that will explain
+ * in their comments, at below.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/sock.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_pdu.h>
+
+#if 0
+#define dprintk(args...) printk(KERN_DEBUG args)
+#else
+#define dprintk(args...)
+#endif
+
+extern u16 llc_circular_between(u8 a, u8 b, u8 c);
+
+/**
+ *	llc_util_ns_inside_rx_window - check if sequence number is in rx window
+ *	@ns: sequence number of received pdu.
+ *	@vr: sequence number which receiver expects to receive.
+ *	@rw: receive window size of receiver.
+ *
+ *	Checks if sequence number of received PDU is in range of receive
+ *	window. Returns 0 for success, 1 otherwise
+ */
+static u16 llc_util_ns_inside_rx_window(u8 ns, u8 vr, u8 rw)
+{
+	return !llc_circular_between(vr, ns,
+				     (vr + rw - 1) % LLC_2_SEQ_NBR_MODULO);
+}
+
+/**
+ *	llc_util_nr_inside_tx_window - check if sequence number is in tx window
+ *	@sk: current connection.
+ *	@nr: N(R) of received PDU.
+ *
+ *	This routine checks if N(R) of received PDU is in range of transmit
+ *	window; on the other hand checks if received PDU acknowledges some
+ *	outstanding PDUs that are in transmit window. Returns 0 for success, 1
+ *	otherwise.
+ */
+static u16 llc_util_nr_inside_tx_window(struct sock *sk, u8 nr)
+{
+	u8 nr1, nr2;
+	struct sk_buff *skb;
+	pdu_sn_t *pdu;
+
+	if (LLC_SK(sk)->dev->flags & IFF_LOOPBACK)
+		return 0;
+	if (!skb_queue_len(&LLC_SK(sk)->pdu_unack_q))
+		return 1;
+	skb = skb_peek(&LLC_SK(sk)->pdu_unack_q);
+	pdu = (pdu_sn_t *)skb->nh.raw;
+	nr1 = LLC_I_GET_NS(pdu);
+	skb = skb_peek_tail(&LLC_SK(sk)->pdu_unack_q);
+	pdu = (pdu_sn_t *)skb->nh.raw;
+	nr2 = LLC_I_GET_NS(pdu);
+	return !llc_circular_between(nr1, nr, (nr2 + 1) % LLC_2_SEQ_NBR_MODULO);
+}
+
+int llc_conn_ev_conn_req(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_CONN_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_conn_ev_conn_resp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_CONN_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_RESP ? 0 : 1;
+}
+
+int llc_conn_ev_data_req(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_DATA_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_conn_ev_disc_req(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_DISC_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_conn_ev_rst_req(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_RESET_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_conn_ev_rst_resp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->data.prim.prim == LLC_RESET_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_RESP ? 0 : 1;
+}
+
+int llc_conn_ev_local_busy_detected(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	return ev->type == LLC_CONN_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev == LLC_CONN_EV_LOCAL_BUSY_DETECTED ? 0 : 1;
+}
+
+int llc_conn_ev_local_busy_cleared(struct sock *sk,
+				   struct llc_conn_state_ev *ev)
+{
+	return ev->type == LLC_CONN_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev == LLC_CONN_EV_LOCAL_BUSY_CLEARED ? 0 : 1;
+}
+
+int llc_conn_ev_rx_bad_pdu(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return 1;
+}
+
+int llc_conn_ev_rx_disc_cmd_pbit_set_x(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_CMD(pdu) == LLC_2_PDU_CMD_DISC ? 0 : 1;
+}
+
+int llc_conn_ev_rx_dm_rsp_fbit_set_x(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_DM ? 0 : 1;
+}
+
+int llc_conn_ev_rx_frmr_rsp_fbit_set_x(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_FRMR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_cmd_pbit_set_0(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_0(pdu) &&
+	       LLC_I_GET_NS(pdu) == LLC_SK(sk)->vR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_cmd_pbit_set_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_1(pdu) &&
+	       LLC_I_GET_NS(pdu) == LLC_SK(sk)->vR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns(struct sock *sk,
+					      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_0(pdu) && ns != vr &&
+	       !llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns(struct sock *sk,
+					      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_1(pdu) && ns != vr &&
+	       !llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_cmd_pbit_set_x_inval_ns(struct sock *sk,
+					     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t * pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+	u16 rc = !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+		 llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+	if (!rc)
+		dprintk(KERN_WARNING "rx_i_cmd_p_bit_set_x_inval_ns matched,"
+			"state = %d, ns = %d, vr = %d\n",
+			LLC_SK(sk)->state, ns, vr);
+	return rc;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_0(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_0(pdu) &&
+	       LLC_I_GET_NS(pdu) == LLC_SK(sk)->vR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_1(pdu) &&
+	       LLC_I_GET_NS(pdu) == LLC_SK(sk)->vR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_x(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       LLC_I_GET_NS(pdu) == LLC_SK(sk)->vR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns(struct sock *sk,
+					      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_0(pdu) && ns != vr &&
+	       !llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns(struct sock *sk,
+					      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) &&
+	       !LLC_I_PF_IS_1(pdu) && ns != vr &&
+	       !llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns(struct sock *sk,
+					      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+	       !llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+}
+
+int llc_conn_ev_rx_i_rsp_fbit_set_x_inval_ns(struct sock *sk,
+					     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vr = LLC_SK(sk)->vR;
+	u8 ns = LLC_I_GET_NS(pdu);
+	u16 rc = !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_I(pdu) && ns != vr &&
+		 llc_util_ns_inside_rx_window(ns, vr, LLC_SK(sk)->rw) ? 0 : 1;
+	if (!rc)
+		dprintk(KERN_WARNING "conn_ev_rx_i_rsp_fbit_set_x_inval_ns "
+			"matched : state = %d, ns = %d, vr = %d\n",
+			LLC_SK(sk)->state, ns, vr);
+	return rc;
+}
+
+int llc_conn_ev_rx_rej_cmd_pbit_set_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_REJ ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rej_cmd_pbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_REJ ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rej_rsp_fbit_set_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rej_rsp_fbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rej_rsp_fbit_set_x(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_REJ ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rnr_cmd_pbit_set_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RNR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rnr_cmd_pbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RNR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rnr_rsp_fbit_set_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RNR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rnr_rsp_fbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RNR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rr_cmd_pbit_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rr_cmd_pbit_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_CMD(pdu) == LLC_2_PDU_CMD_RR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rr_rsp_fbit_set_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_0(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_rr_rsp_fbit_set_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_S(pdu) &&
+	       !LLC_S_PF_IS_1(pdu) &&
+	       LLC_S_PDU_RSP(pdu) == LLC_2_PDU_RSP_RR ? 0 : 1;
+}
+
+int llc_conn_ev_rx_sabme_cmd_pbit_set_x(struct sock *sk,
+					struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_CMD(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_CMD(pdu) == LLC_2_PDU_CMD_SABME ? 0 : 1;
+}
+
+int llc_conn_ev_rx_ua_rsp_fbit_set_x(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return !LLC_PDU_IS_RSP(pdu) && !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_RSP(pdu) == LLC_2_PDU_RSP_UA ? 0 : 1;
+}
+
+int llc_conn_ev_rx_xxx_cmd_pbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_CMD(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+			if (!LLC_I_PF_IS_1(pdu))
+				rc = 0;
+		} else if (!LLC_PDU_TYPE_IS_U(pdu) && !LLC_U_PF_IS_1(pdu))
+			rc = 0;
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_xxx_cmd_pbit_set_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_CMD(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+			if (!LLC_I_PF_IS_0(pdu))
+				rc = 0;
+		} else if (!LLC_PDU_TYPE_IS_U(pdu))
+			switch (LLC_U_PDU_CMD(pdu)) {
+				case LLC_2_PDU_CMD_SABME:
+				case LLC_2_PDU_CMD_DISC:
+					if (!LLC_U_PF_IS_0(pdu))
+						rc = 0;
+					break;
+			}
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_xxx_cmd_pbit_set_x(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_CMD(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+			rc = 0;
+		else if (!LLC_PDU_TYPE_IS_U(pdu))
+			switch (LLC_U_PDU_CMD(pdu)) {
+				case LLC_2_PDU_CMD_SABME:
+				case LLC_2_PDU_CMD_DISC:
+					rc = 0;
+					break;
+			}
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_xxx_rsp_fbit_set_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_RSP(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+			if (!LLC_I_PF_IS_1(pdu))
+				rc = 0;
+		} else if (!LLC_PDU_TYPE_IS_U(pdu))
+			switch (LLC_U_PDU_RSP(pdu)) {
+				case LLC_2_PDU_RSP_UA:
+				case LLC_2_PDU_RSP_DM:
+				case LLC_2_PDU_RSP_FRMR:
+					if (!LLC_U_PF_IS_1(pdu))
+						rc = 0;
+					break;
+			}
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_xxx_rsp_fbit_set_x(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_IS_RSP(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+			rc = 0;
+		else if (!LLC_PDU_TYPE_IS_U(pdu))
+			switch (LLC_U_PDU_RSP(pdu)) {
+				case LLC_2_PDU_RSP_UA:
+				case LLC_2_PDU_RSP_DM:
+				case LLC_2_PDU_RSP_FRMR:
+					rc = 0;
+					break;
+			}
+	}
+
+	return rc;
+}
+
+int llc_conn_ev_rx_xxx_yyy(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu))
+		rc = 0;
+	else if (!LLC_PDU_TYPE_IS_U(pdu))
+		switch (LLC_U_PDU_CMD(pdu)) {
+			case LLC_2_PDU_CMD_SABME:
+			case LLC_2_PDU_CMD_DISC:
+			case LLC_2_PDU_RSP_UA:
+			case LLC_2_PDU_RSP_DM:
+			case LLC_2_PDU_RSP_FRMR:
+				rc = 0;
+				break;
+		}
+	return rc;
+}
+
+int llc_conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr(struct sock *sk,
+					       struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vs = LLC_SK(sk)->vS;
+	u8 nr = LLC_I_GET_NR(pdu);
+
+	if (!LLC_PDU_IS_CMD(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+			if (nr != vs &&
+			    llc_util_nr_inside_tx_window(sk, nr)) {
+				dprintk(KERN_ERR "conn_ev_rx_zzz_cmd_inv_nr "
+					"matched, state = %d, vs = %d, "
+					"nr = %d\n", LLC_SK(sk)->state, vs, nr);
+				rc = 0;
+			}
+		}
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr(struct sock *sk,
+					       struct llc_conn_state_ev *ev)
+{
+	u16 rc = 1;
+	pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+	u8 vs = LLC_SK(sk)->vS;
+	u8 nr = LLC_I_GET_NR(pdu);
+
+	if (!LLC_PDU_IS_RSP(pdu)) {
+		if (!LLC_PDU_TYPE_IS_I(pdu) || !LLC_PDU_TYPE_IS_S(pdu)) {
+			if (nr != vs &&
+			    llc_util_nr_inside_tx_window(sk, nr)) {
+				rc = 0;
+				dprintk(KERN_ERR "conn_ev_rx_zzz_fbit_set"
+					"_x_inval_nr matched, state = %d, "
+					"vs = %d, nr = %d\n",
+					LLC_SK(sk)->state, vs, nr);
+			}
+		}
+	}
+	return rc;
+}
+
+int llc_conn_ev_rx_any_frame(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return 0;
+}
+
+int llc_conn_ev_p_tmr_exp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->type != LLC_CONN_EV_TYPE_P_TMR;
+}
+
+int llc_conn_ev_ack_tmr_exp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->type != LLC_CONN_EV_TYPE_ACK_TMR;
+}
+
+int llc_conn_ev_rej_tmr_exp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->type != LLC_CONN_EV_TYPE_REJ_TMR;
+}
+
+int llc_conn_ev_busy_tmr_exp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->type != LLC_CONN_EV_TYPE_BUSY_TMR;
+}
+
+int llc_conn_ev_any_tmr_exp(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+
+	return ev->type == LLC_CONN_EV_TYPE_P_TMR ||
+	       ev->type == LLC_CONN_EV_TYPE_ACK_TMR ||
+	       ev->type == LLC_CONN_EV_TYPE_REJ_TMR ||
+	       ev->type == LLC_CONN_EV_TYPE_BUSY_TMR ? 0 : 1;
+}
+
+int llc_conn_ev_init_p_f_cycle(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return 1;
+}
+
+int llc_conn_ev_tx_buffer_full(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return ev->type == LLC_CONN_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev == LLC_CONN_EV_TX_BUFF_FULL ? 0 : 1;
+}
+
+/* --------------------- EVENT QUALIFIER FUNCTIONS ----------------------- *
+ * these functions simply verify the value of a state flag associated with
+ * the connection and return either a 0 for success or a non-zero value
+ * for not-success; verify the event is the type we expect
+ * ----------------------------------------------------------------------- */
+
+int llc_conn_ev_qlfy_data_flag_eq_1(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->data_flag != 1;
+}
+
+int llc_conn_ev_qlfy_data_flag_eq_0(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->data_flag;
+}
+
+int llc_conn_ev_qlfy_data_flag_eq_2(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->data_flag != 2;
+}
+
+int llc_conn_ev_qlfy_p_flag_eq_1(struct sock *sk,
+				 struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->p_flag != 1;
+}
+
+/**
+ *	conn_ev_qlfy_last_frame_eq_1 - checks if frame is last in tx window
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	This function determines when frame which is sent, is last frame of
+ *	transmit window, if it is then this function return zero else return
+ *	one.  This function is used for sending last frame of transmit window
+ *	as I-format command with p-bit set to one. Returns 0 if frame is last
+ *	frame, 1 otherwise.
+ */
+int llc_conn_ev_qlfy_last_frame_eq_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	return !(skb_queue_len(&LLC_SK(sk)->pdu_unack_q) + 1 == LLC_SK(sk)->k);
+}
+
+/**
+ *	conn_ev_qlfy_last_frame_eq_0 - checks if frame isn't last in tx window
+ *	@sk: current connection structure.
+ *	@ev: current event.
+ *
+ *	This function determines when frame which is sent, isn't last frame of
+ *	transmit window, if it isn't then this function return zero else return
+ *	one. Returns 0 if frame isn't last frame, 1 otherwise.
+ */
+int llc_conn_ev_qlfy_last_frame_eq_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	return skb_queue_len(&LLC_SK(sk)->pdu_unack_q) + 1 == LLC_SK(sk)->k;
+}
+
+int llc_conn_ev_qlfy_p_flag_eq_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->p_flag;
+}
+
+int llc_conn_ev_qlfy_p_flag_eq_f(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	u8 f_bit;
+	struct sk_buff *skb;
+
+	if (ev->type == LLC_CONN_EV_TYPE_PDU)
+		skb = ev->data.pdu.skb;
+	else
+		skb = ev->data.prim.data->data->conn.skb;
+	llc_pdu_decode_pf_bit(skb, &f_bit);
+	return LLC_SK(sk)->p_flag == f_bit ? 0 : 1;
+}
+
+int llc_conn_ev_qlfy_remote_busy_eq_0(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->remote_busy_flag;
+}
+
+int llc_conn_ev_qlfy_remote_busy_eq_1(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	return !LLC_SK(sk)->remote_busy_flag;
+}
+
+int llc_conn_ev_qlfy_retry_cnt_lt_n2(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	return !(LLC_SK(sk)->retry_count < LLC_SK(sk)->n2);
+}
+
+int llc_conn_ev_qlfy_retry_cnt_gte_n2(struct sock *sk,
+				      struct llc_conn_state_ev *ev)
+{
+	return !(LLC_SK(sk)->retry_count >= LLC_SK(sk)->n2);
+}
+
+int llc_conn_ev_qlfy_s_flag_eq_1(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return !LLC_SK(sk)->s_flag;
+}
+
+int llc_conn_ev_qlfy_s_flag_eq_0(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->s_flag;
+}
+
+int llc_conn_ev_qlfy_cause_flag_eq_1(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	return !LLC_SK(sk)->cause_flag;
+}
+
+int llc_conn_ev_qlfy_cause_flag_eq_0(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	return LLC_SK(sk)->cause_flag;
+}
+
+int llc_conn_ev_qlfy_init_p_f_cycle(struct sock *sk,
+				    struct llc_conn_state_ev *ev)
+{
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_conn(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_CONN;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_disc(struct sock *sk,
+				     struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_DISC;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_impossible(struct sock *sk,
+					   struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_IMPOSSIBLE;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_failed(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_FAILED;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_remote_busy(struct sock *sk,
+					    struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_REMOTE_BUSY;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_received(struct sock *sk,
+					 struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_RECEIVED;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_refuse(struct sock *sk,
+				       struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_REFUSE;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_conflict(struct sock *sk,
+					 struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_CONFLICT;
+	return 0;
+}
+
+int llc_conn_ev_qlfy_set_status_rst_done(struct sock *sk,
+					 struct llc_conn_state_ev *ev)
+{
+	ev->status = LLC_STATUS_RESET_DONE;
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_c_st.c linux/net/llc/llc_c_st.c
--- linux-2.4.18-clean/net/llc/llc_c_st.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_c_st.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,4911 @@
+/*
+ * llc_c_st.c - This module contains state transition of connection component.
+ *
+ * Description of event functions and actions there is in 802.2 LLC standard,
+ * or in "llc_c_ac.c" and "llc_c_ev.c" modules.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/types.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_c_ac.h>
+#include <net/llc_c_st.h>
+
+#define LLC_NO_EVENT_QUALIFIERS   NULL
+#define LLC_NO_TRANSITION_ACTIONS NULL
+
+/* ----------------- COMMON CONNECTION STATE transitions ----------------- *
+ * Common transitions for
+ * LLC_CONN_STATE_NORMAL,
+ * LLC_CONN_STATE_BUSY,
+ * LLC_CONN_STATE_REJECT,
+ * LLC_CONN_STATE_AWAIT,
+ * LLC_CONN_STATE_AWAIT_BUSY and
+ * LLC_CONN_STATE_AWAIT_REJECT states
+ */
+/* State transitions for LLC_CONN_EV_DISC_REQ event */
+static llc_conn_action_t llc_common_actions_1[] = {
+	llc_conn_ac_send_disc_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_1 = {
+	llc_conn_ev_disc_req,
+	LLC_CONN_STATE_D_CONN,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RESET_REQ event */
+static llc_conn_action_t llc_common_actions_2[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_2 = {
+	llc_conn_ev_rst_req,
+	LLC_CONN_STATE_RESET,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_common_actions_3[] = {
+	llc_conn_ac_stop_all_timers,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_rst_ind,
+	llc_conn_ac_set_p_flag_0,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_reset,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_3 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_common_actions_4[] = {
+	llc_conn_ac_stop_all_timers,
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_disc_ind,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_4 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_FRMR_RSP_Fbit_SET_X event */
+static llc_conn_action_t llc_common_actions_5[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_rst_ind,
+	llc_conn_ac_set_cause_flag_0,
+	llc_conn_reset,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_5 = {
+	llc_conn_ev_rx_frmr_rsp_fbit_set_x,
+	LLC_CONN_STATE_RESET,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event */
+static llc_conn_action_t llc_common_actions_6[] = {
+	llc_conn_ac_disc_ind,
+	llc_conn_ac_stop_all_timers,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_6 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_RX_ZZZ_CMD_Pbit_SET_X_INVAL_Nr event */
+static llc_conn_action_t llc_common_actions_7a[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_7a = {
+	llc_conn_ev_rx_zzz_cmd_pbit_set_x_inval_nr,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_7a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_X_INVAL_Ns event */
+static llc_conn_action_t llc_common_actions_7b[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_7b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_x_inval_ns,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_7b
+};
+
+/* State transitions for LLC_CONN_EV_RX_ZZZ_RSP_Fbit_SET_X_INVAL_Nr event */
+static llc_conn_action_t llc_common_actions_8a[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_8a = {
+	llc_conn_ev_rx_zzz_rsp_fbit_set_x_inval_nr,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_8a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_X_INVAL_Ns event */
+static llc_conn_action_t llc_common_actions_8b[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_8b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_x_inval_ns,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_8b
+};
+
+/* State transitions for LLC_CONN_EV_RX_BAD_PDU event */
+static llc_conn_action_t llc_common_actions_8c[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_8c = {
+	llc_conn_ev_rx_bad_pdu,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_8c
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event */
+static llc_conn_action_t llc_common_actions_9[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_9 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_common_actions_9
+};
+
+/* State transitions for LLC_CONN_EV_RX_XXX_RSP_Fbit_SET_1 event */
+#if 0
+static llc_conn_ev_qfyr_t llc_common_ev_qfyrs_10[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_common_actions_10[] = {
+	llc_conn_ac_send_frmr_rsp_f_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_10 = {
+	llc_conn_ev_rx_xxx_rsp_fbit_set_1,
+	LLC_CONN_STATE_ERROR,
+	llc_common_ev_qfyrs_10,
+	llc_common_actions_10
+};
+#endif
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_common_ev_qfyrs_11a[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_common_actions_11a[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_11a = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_common_ev_qfyrs_11a,
+	llc_common_actions_11a
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_common_ev_qfyrs_11b[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_common_actions_11b[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_11b = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_common_ev_qfyrs_11b,
+	llc_common_actions_11b
+};
+
+/* State transitions for LLC_CONN_EV_REJ_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_common_ev_qfyrs_11c[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_common_actions_11c[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_11c = {
+	llc_conn_ev_rej_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_common_ev_qfyrs_11c,
+	llc_common_actions_11c
+};
+
+/* State transitions for LLC_CONN_EV_BUSY_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_common_ev_qfyrs_11d[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_common_actions_11d[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_stop_other_timers,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_common_state_trans_11d = {
+	llc_conn_ev_busy_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_common_ev_qfyrs_11d,
+	llc_common_actions_11d
+};
+
+/*
+ * Common dummy state transition; must be last entry for all state
+ * transition groups
+ */
+static struct llc_conn_state_trans llc_common_state_trans_n = {
+	NULL,
+	0,
+	NULL,
+	NULL
+};
+
+/* --------------------- LLC_CONN_STATE_ADM transitions -------------------- */
+/* State transitions for LLC_CONN_EV_CONN_REQ event */
+static llc_conn_action_t llc_adm_actions_1[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_s_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_adm_state_trans_1 = {
+	llc_conn_ev_conn_req,
+	LLC_CONN_STATE_SETUP,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_adm_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_adm_actions_2[] = {
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_p_flag_0,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_ac_conn_ind,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_adm_state_trans_2 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_adm_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_adm_actions_3[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_adm_state_trans_3 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_adm_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_XXX_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_adm_actions_4[] = {
+	llc_conn_ac_send_dm_rsp_f_set_1,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_adm_state_trans_4 = {
+	llc_conn_ev_rx_xxx_cmd_pbit_set_1,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_adm_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_XXX_YYY event */
+static llc_conn_action_t llc_adm_actions_5[] = {
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_adm_state_trans_5 = {
+	llc_conn_ev_rx_any_frame,
+	LLC_CONN_OUT_OF_SVC,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_adm_actions_5
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_adm_state_transitions[] = {
+	&llc_adm_state_trans_1,     // Request
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,  // local_busy
+	&llc_common_state_trans_n,  // init_pf_cycle
+	&llc_common_state_trans_n,  // timer
+	&llc_adm_state_trans_2,     // Receive frame
+	&llc_adm_state_trans_3,
+	&llc_adm_state_trans_4,
+	&llc_adm_state_trans_5,
+	&llc_common_state_trans_n
+};
+
+/* ---------------------  LLC_CONN_STATE_SETUP transitions ----------------- */
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_setup_actions_1[] = {
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_set_s_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_1 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_SETUP,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_setup_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	llc_conn_ev_qlfy_set_status_conn,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_2[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_ac_conn_confirm,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_2 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_setup_ev_qfyrs_2,
+	llc_setup_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_s_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_conn,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_3[] = {
+	llc_conn_ac_set_p_flag_0,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_ac_conn_confirm,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_3 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_NORMAL,
+	llc_setup_ev_qfyrs_3,
+	llc_setup_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_4[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_conn_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_4 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_setup_ev_qfyrs_4,
+	llc_setup_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_5[] = {
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_5[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_conn_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_5 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_setup_ev_qfyrs_5,
+	llc_setup_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_7[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	llc_conn_ev_qlfy_s_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_7[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_7 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_SETUP,
+	llc_setup_ev_qfyrs_7,
+	llc_setup_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_setup_ev_qfyrs_8[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	llc_conn_ev_qlfy_s_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_failed,
+	NULL
+};
+
+static llc_conn_action_t llc_setup_actions_8[] = {
+	llc_conn_ac_conn_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_setup_state_trans_8 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ADM,
+	llc_setup_ev_qfyrs_8,
+	llc_setup_actions_8
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_setup_state_transitions[] = {
+	&llc_common_state_trans_n,  // Request
+	&llc_common_state_trans_n,  // local busy
+	&llc_common_state_trans_n,  // init_pf_cycle
+	&llc_setup_state_trans_3,   // Timer
+	&llc_setup_state_trans_7,
+	&llc_setup_state_trans_8,
+	&llc_common_state_trans_n,
+	&llc_setup_state_trans_1,    // Receive frame
+	&llc_setup_state_trans_2,
+	&llc_setup_state_trans_4,
+	&llc_setup_state_trans_5,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_NORMAL transitions ------------------ */
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_last_frame_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_1[] = {
+	llc_conn_ac_send_i_as_ack,
+	llc_conn_ac_start_ack_tmr_if_not_running,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_1,
+	llc_normal_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_last_frame_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_2[] = {
+	llc_conn_ac_send_i_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_2 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_2,
+	llc_normal_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_2_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_1,
+	llc_conn_ev_qlfy_set_status_remote_busy,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_2_1[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_2_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_2_1,
+	llc_normal_actions_2_1
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_3[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_3 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_BUSY,
+	llc_normal_ev_qfyrs_3,
+	llc_normal_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_4[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_4 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_BUSY,
+	llc_normal_ev_qfyrs_4,
+	llc_normal_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_5a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_5a[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_5a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_normal_ev_qfyrs_5a,
+	llc_normal_actions_5a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_5b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_5b[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_5b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_normal_ev_qfyrs_5b,
+	llc_normal_actions_5b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_5c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_5c[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_5c = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_normal_ev_qfyrs_5c,
+	llc_normal_actions_5c
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_6a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_6a[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_6a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_normal_ev_qfyrs_6a,
+	llc_normal_actions_6a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_6b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_6b[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_6b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_normal_ev_qfyrs_6b,
+	llc_normal_actions_6b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_normal_actions_7[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rej_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_7 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_8a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_8[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	llc_conn_ac_send_ack_if_needed,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_8a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_8a,
+	llc_normal_actions_8
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_8b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_8b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_8b,
+	llc_normal_actions_8
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_9a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_9a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_ack_if_needed,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_9a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_9a,
+	llc_normal_actions_9a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_9b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_9b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_ack_if_needed,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_9b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_9b,
+	llc_normal_actions_9b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_normal_actions_10[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_send_ack_rsp_f_set_1,
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_data_ind,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_10 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_10
+};
+
+/* State transitions for * LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_normal_actions_11a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_11a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_11a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_normal_actions_11b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_11b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_11b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_11c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_11c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_inc_tx_win_size,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_11c = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_11c,
+	llc_normal_actions_11c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_normal_actions_12[] = {
+	llc_conn_ac_send_ack_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_adjust_npta_by_rr,
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_12 = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_12
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_normal_actions_13a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_13a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_13a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_normal_actions_13b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_13b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_13b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_13c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_13c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_13c = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_13c,
+	llc_normal_actions_13c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_normal_actions_14[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_adjust_npta_by_rnr,
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_14 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_14
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_15a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_15a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_dec_tx_win_size,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_15a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_15a,
+	llc_normal_actions_15a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_15b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_15b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_dec_tx_win_size,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_15b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_15b,
+	llc_normal_actions_15b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_16a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_16a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_dec_tx_win_size,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_16a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_16a,
+	llc_normal_actions_16a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_16b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_16b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_dec_tx_win_size,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_16b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_16b,
+	llc_normal_actions_16b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_normal_actions_17[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_dec_tx_win_size,
+	llc_conn_ac_resend_i_rsp_f_set_1,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_17 = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_normal_actions_17
+};
+
+/* State transitions for LLC_CONN_EV_INIT_P_F_CYCLE event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_18[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_18[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_18 = {
+	llc_conn_ev_init_p_f_cycle,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_18,
+	llc_normal_actions_18
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_19[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_19[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_rst_vs,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_19 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT,
+	llc_normal_ev_qfyrs_19,
+	llc_normal_actions_19
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_20a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_20a[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_rst_vs,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_20a = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_AWAIT,
+	llc_normal_ev_qfyrs_20a,
+	llc_normal_actions_20a
+};
+
+/* State transitions for LLC_CONN_EV_BUSY_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_20b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_20b[] = {
+	llc_conn_ac_rst_sendack_flag,
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_rst_vs,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_20b = {
+	llc_conn_ev_busy_tmr_exp,
+	LLC_CONN_STATE_AWAIT,
+	llc_normal_ev_qfyrs_20b,
+	llc_normal_actions_20b
+};
+
+/* State transitions for LLC_CONN_EV_TX_BUFF_FULL event */
+static llc_conn_ev_qfyr_t llc_normal_ev_qfyrs_21[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_normal_actions_21[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_normal_state_trans_21 = {
+	llc_conn_ev_tx_buffer_full,
+	LLC_CONN_STATE_NORMAL,
+	llc_normal_ev_qfyrs_21,
+	llc_normal_actions_21
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_normal_state_transitions[] = {
+	&llc_normal_state_trans_1,     // Requests
+	&llc_normal_state_trans_2,
+	&llc_normal_state_trans_2_1,
+	&llc_common_state_trans_1,
+	&llc_common_state_trans_2,
+	&llc_common_state_trans_n,
+	&llc_normal_state_trans_21,
+	&llc_normal_state_trans_3,     // Local busy
+	&llc_normal_state_trans_4,
+	&llc_common_state_trans_n,
+	&llc_normal_state_trans_18,    // Init pf cycle
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_11a,   // Timers
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_normal_state_trans_19,
+	&llc_normal_state_trans_20a,
+	&llc_normal_state_trans_20b,
+	&llc_common_state_trans_n,
+	&llc_normal_state_trans_8b,    // Receive frames
+	&llc_normal_state_trans_9b,
+	&llc_normal_state_trans_10,
+	&llc_normal_state_trans_11b,
+	&llc_normal_state_trans_11c,
+	&llc_normal_state_trans_5a,
+	&llc_normal_state_trans_5b,
+	&llc_normal_state_trans_5c,
+	&llc_normal_state_trans_6a,
+	&llc_normal_state_trans_6b,
+	&llc_normal_state_trans_7,
+	&llc_normal_state_trans_8a,
+	&llc_normal_state_trans_9a,
+	&llc_normal_state_trans_11a,
+	&llc_normal_state_trans_12,
+	&llc_normal_state_trans_13a,
+	&llc_normal_state_trans_13b,
+	&llc_normal_state_trans_13c,
+	&llc_normal_state_trans_14,
+	&llc_normal_state_trans_15a,
+	&llc_normal_state_trans_15b,
+	&llc_normal_state_trans_16a,
+	&llc_normal_state_trans_16b,
+	&llc_normal_state_trans_17,
+	&llc_common_state_trans_3,
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	//&llc_common_state_trans_10,
+	&llc_common_state_trans_n
+};
+
+/* --------------------- LLC_CONN_STATE_BUSY transitions ------------------- */
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_1[] = {
+	llc_conn_ac_send_i_xxx_x_set_0,
+	llc_conn_ac_start_ack_tmr_if_not_running,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_1,
+	llc_busy_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_2[] = {
+	llc_conn_ac_send_i_xxx_x_set_0,
+	llc_conn_ac_start_ack_tmr_if_not_running,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_2 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_2,
+	llc_busy_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_2_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_1,
+	llc_conn_ev_qlfy_set_status_remote_busy,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_2_1[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_2_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_2_1,
+	llc_busy_actions_2_1
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_data_flag_eq_1,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_3[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_3 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_REJECT,
+	llc_busy_ev_qfyrs_3,
+	llc_busy_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_data_flag_eq_1,
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_4[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_4 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_REJECT,
+	llc_busy_ev_qfyrs_4,
+	llc_busy_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_5[] = {
+	llc_conn_ev_qlfy_data_flag_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_5[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_5 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_NORMAL,
+	llc_busy_ev_qfyrs_5,
+	llc_busy_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_6[] = {
+	llc_conn_ev_qlfy_data_flag_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_6[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_6 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_NORMAL,
+	llc_busy_ev_qfyrs_6,
+	llc_busy_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_7[] = {
+	llc_conn_ev_qlfy_data_flag_eq_2,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_7[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_7 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_REJECT,
+	llc_busy_ev_qfyrs_7,
+	llc_busy_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_8[] = {
+	llc_conn_ev_qlfy_data_flag_eq_2,
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_8[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_8 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_REJECT,
+	llc_busy_ev_qfyrs_8,
+	llc_busy_actions_8
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_X_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_9a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_9a[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_data_flag_1_if_data_flag_eq_0,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_9a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_x_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_9a,
+	llc_busy_actions_9a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_9b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_9b[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_data_flag_1_if_data_flag_eq_0,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_9b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_9b,
+	llc_busy_actions_9b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_10a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_10a[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_data_flag_1_if_data_flag_eq_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_10a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_10a,
+	llc_busy_actions_10a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_10b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_10b[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_data_flag_1_if_data_flag_eq_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_10b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_10b,
+	llc_busy_actions_10b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_busy_actions_11[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_data_flag_1_if_data_flag_eq_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_11 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_11
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_busy_actions_12[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_12 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_12
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_13a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_13a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2,
+	llc_conn_ac_set_data_flag_0,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_13a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_x,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_13a,
+	llc_busy_actions_13a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_13b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_13b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2,
+	llc_conn_ac_set_data_flag_0,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_13b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_13b,
+	llc_busy_actions_13b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_14a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_14a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_14a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_14a,
+	llc_busy_actions_14a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_14b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_14b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_tmr_if_data_flag_eq_2,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_14b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_14b,
+	llc_busy_actions_14b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_busy_actions_15a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_15a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_15a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_busy_actions_15b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_15b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_15b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_15c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_15c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_15c = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_15c,
+	llc_busy_actions_15c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_busy_actions_16[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_16 = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_16
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_busy_actions_17a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_17a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_17a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_busy_actions_17b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_17b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_17b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_17c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_17c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_17c = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_17c,
+	llc_busy_actions_17c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_busy_actions_18[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_18 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_18
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_19a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_19a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_19a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_19a,
+	llc_busy_actions_19a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_19b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_19b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_19b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_x,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_19b,
+	llc_busy_actions_19b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_20a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_20a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_20a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_20a,
+	llc_busy_actions_20a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_20b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_20b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_20b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_20b,
+	llc_busy_actions_20b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_busy_actions_21[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_21 = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_busy_actions_21
+};
+
+/* State transitions for LLC_CONN_EV_INIT_P_F_CYCLE event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_22[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_22[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_22 = {
+	llc_conn_ev_init_p_f_cycle,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_22,
+	llc_busy_actions_22
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_23[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_23[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_rst_vs,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_23 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_busy_ev_qfyrs_23,
+	llc_busy_actions_23
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_24a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_24a[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_24a = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_busy_ev_qfyrs_24a,
+	llc_busy_actions_24a
+};
+
+/* State transitions for LLC_CONN_EV_BUSY_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_24b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_24b[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_24b = {
+	llc_conn_ev_busy_tmr_exp,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_busy_ev_qfyrs_24b,
+	llc_busy_actions_24b
+};
+
+/* State transitions for LLC_CONN_EV_REJ_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_25[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_25[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	llc_conn_ac_set_data_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_25 = {
+	llc_conn_ev_rej_tmr_exp,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_busy_ev_qfyrs_25,
+	llc_busy_actions_25
+};
+
+/* State transitions for LLC_CONN_EV_REJ_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_busy_ev_qfyrs_26[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_busy_actions_26[] = {
+	llc_conn_ac_set_data_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_busy_state_trans_26 = {
+	llc_conn_ev_rej_tmr_exp,
+	LLC_CONN_STATE_BUSY,
+	llc_busy_ev_qfyrs_26,
+	llc_busy_actions_26
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_busy_state_transitions[] = {
+	&llc_common_state_trans_1,      // Request
+	&llc_common_state_trans_2,
+	&llc_busy_state_trans_1,
+	&llc_busy_state_trans_2,
+	&llc_busy_state_trans_2_1,
+	&llc_common_state_trans_n,
+	&llc_busy_state_trans_3,        // Local busy
+	&llc_busy_state_trans_4,
+	&llc_busy_state_trans_5,
+	&llc_busy_state_trans_6,
+	&llc_busy_state_trans_7,
+	&llc_busy_state_trans_8,
+	&llc_common_state_trans_n,
+	&llc_busy_state_trans_22,       // Initiate PF cycle
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_11a,    // Timer
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_busy_state_trans_23,
+	&llc_busy_state_trans_24a,
+	&llc_busy_state_trans_24b,
+	&llc_busy_state_trans_25,
+	&llc_busy_state_trans_26,
+	&llc_common_state_trans_n,
+	&llc_busy_state_trans_9a,       // Receive frame
+	&llc_busy_state_trans_9b,
+	&llc_busy_state_trans_10a,
+	&llc_busy_state_trans_10b,
+	&llc_busy_state_trans_11,
+	&llc_busy_state_trans_12,
+	&llc_busy_state_trans_13a,
+	&llc_busy_state_trans_13b,
+	&llc_busy_state_trans_14a,
+	&llc_busy_state_trans_14b,
+	&llc_busy_state_trans_15a,
+	&llc_busy_state_trans_15b,
+	&llc_busy_state_trans_15c,
+	&llc_busy_state_trans_16,
+	&llc_busy_state_trans_17a,
+	&llc_busy_state_trans_17b,
+	&llc_busy_state_trans_17c,
+	&llc_busy_state_trans_18,
+	&llc_busy_state_trans_19a,
+	&llc_busy_state_trans_19b,
+	&llc_busy_state_trans_20a,
+	&llc_busy_state_trans_20b,
+	&llc_busy_state_trans_21,
+	&llc_common_state_trans_3,
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	// &llc_common_state_trans_10,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_REJECT transitions ------------------ */
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_1[] = {
+	llc_conn_ac_send_i_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_1,
+	llc_reject_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_0,
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_2[] = {
+	llc_conn_ac_send_i_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_2 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_2,
+	llc_reject_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_2_1[] = {
+	llc_conn_ev_qlfy_remote_busy_eq_1,
+	llc_conn_ev_qlfy_set_status_remote_busy,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_2_1[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_2_1 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_2_1,
+	llc_reject_actions_2_1
+};
+
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_3[] = {
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_2,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_3 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_BUSY,
+	llc_reject_ev_qfyrs_3,
+	llc_reject_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_4[] = {
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_2,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_4 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_BUSY,
+	llc_reject_ev_qfyrs_4,
+	llc_reject_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_reject_actions_5a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_5a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_5a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_reject_actions_5b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_5b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_5b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_5c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_5c[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_5c = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_5c,
+	llc_reject_actions_5c
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_reject_actions_6[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_6 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_7a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_7a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_send_ack_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	llc_conn_ac_stop_rej_timer,
+	NULL
+
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_7a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_reject_ev_qfyrs_7a,
+	llc_reject_actions_7a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_7b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_7b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_send_ack_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy_if_f_eq_1,
+	llc_conn_ac_stop_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_7b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_reject_ev_qfyrs_7b,
+	llc_reject_actions_7b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_8a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_8a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_ack_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_8a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_reject_ev_qfyrs_8a,
+	llc_reject_actions_8a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_8b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_8b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_ack_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_8b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_NORMAL,
+	llc_reject_ev_qfyrs_8b,
+	llc_reject_actions_8b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_reject_actions_9[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_ack_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_stop_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_9 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_9
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_reject_actions_10a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_10a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_10a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_reject_actions_10b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_10b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_10b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_10c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_10c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_10c = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_10c,
+	llc_reject_actions_10c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_reject_actions_11[] = {
+	llc_conn_ac_send_ack_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_11 = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_11
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_reject_actions_12a[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_12a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_12a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_reject_actions_12b[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_12b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_12b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_12c[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_12c[] = {
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_12c = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_12c,
+	llc_reject_actions_12c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_reject_actions_13[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_13 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_13
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_14a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_14a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_14a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_14a,
+	llc_reject_actions_14a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_X event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_14b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_14b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_14b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_x,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_14b,
+	llc_reject_actions_14b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_15a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_15a[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_15a = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_15a,
+	llc_reject_actions_15a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_15b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_15b[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_15b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_15b,
+	llc_reject_actions_15b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_reject_actions_16[] = {
+	llc_conn_ac_set_vs_nr,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_resend_i_rsp_f_set_1,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_16 = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_reject_actions_16
+};
+
+/* State transitions for LLC_CONN_EV_INIT_P_F_CYCLE event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_17[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_17[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_17 = {
+	llc_conn_ev_init_p_f_cycle,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_17,
+	llc_reject_actions_17
+};
+
+/* State transitions for LLC_CONN_EV_REJ_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_18[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_18[] = {
+	llc_conn_ac_send_rej_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_18 = {
+	llc_conn_ev_rej_tmr_exp,
+	LLC_CONN_STATE_REJECT,
+	llc_reject_ev_qfyrs_18,
+	llc_reject_actions_18
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_19[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_19[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_19 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_reject_ev_qfyrs_19,
+	llc_reject_actions_19
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_20a[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_20a[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_20a = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_reject_ev_qfyrs_20a,
+	llc_reject_actions_20a
+};
+
+/* State transitions for LLC_CONN_EV_BUSY_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_reject_ev_qfyrs_20b[] = {
+	llc_conn_ev_qlfy_p_flag_eq_0,
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_reject_actions_20b[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	llc_conn_ac_rst_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_reject_state_trans_20b = {
+	llc_conn_ev_busy_tmr_exp,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_reject_ev_qfyrs_20b,
+	llc_reject_actions_20b
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_reject_state_transitions[] = {
+	&llc_common_state_trans_1,      // Request
+	&llc_common_state_trans_2,
+	&llc_common_state_trans_n,
+	&llc_reject_state_trans_1,
+	&llc_reject_state_trans_2,
+	&llc_reject_state_trans_2_1,
+	&llc_reject_state_trans_3,      // Local busy
+	&llc_reject_state_trans_4,
+	&llc_common_state_trans_n,
+	&llc_reject_state_trans_17,     // Initiate PF cycle
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_11a,    // Timer
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_reject_state_trans_18,
+	&llc_reject_state_trans_19,
+	&llc_reject_state_trans_20a,
+	&llc_reject_state_trans_20b,
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_3,      // Receive frame
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	// &llc_common_state_trans_10,
+	&llc_reject_state_trans_5a,
+	&llc_reject_state_trans_5b,
+	&llc_reject_state_trans_5c,
+	&llc_reject_state_trans_6,
+	&llc_reject_state_trans_7a,
+	&llc_reject_state_trans_7b,
+	&llc_reject_state_trans_8a,
+	&llc_reject_state_trans_8b,
+	&llc_reject_state_trans_9,
+	&llc_reject_state_trans_10a,
+	&llc_reject_state_trans_10b,
+	&llc_reject_state_trans_10c,
+	&llc_reject_state_trans_11,
+	&llc_reject_state_trans_12a,
+	&llc_reject_state_trans_12b,
+	&llc_reject_state_trans_12c,
+	&llc_reject_state_trans_13,
+	&llc_reject_state_trans_14a,
+	&llc_reject_state_trans_14b,
+	&llc_reject_state_trans_15a,
+	&llc_reject_state_trans_15b,
+	&llc_reject_state_trans_16,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_AWAIT transitions ------------------- */
+/* State transitions for LLC_CONN_EV_DATA_REQ event */
+static llc_conn_ev_qfyr_t llc_await_ev_qfyrs_1_0[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_await_actions_1_0[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_1_0 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_AWAIT,
+	llc_await_ev_qfyrs_1_0,
+	llc_await_actions_1_0
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_action_t llc_await_actions_1[] = {
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_1 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_actions_2[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_2 = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_actions_3a[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_3a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_3a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_actions_3b[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_3b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_3b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_actions_4[] = {
+	llc_conn_ac_send_rej_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_start_rej_timer,
+	llc_conn_ac_start_p_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_4 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_5[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_resend_i_xxx_x_set_0_or_send_rr,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_5 = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_6a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_6a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_6a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_6b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_6b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_6b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_7[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_7 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_8a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_8a = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_8a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_8b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_8b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_8b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_9a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_9a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_9a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_9b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_9b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_9b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_9c[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_9c = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_9c
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_9d[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_9d = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_9d
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_10a[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_10a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_10a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_10b[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_10b = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_10b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_11[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_11 = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_11
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_12a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_12a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_12a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_actions_12b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_12b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_12b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_actions_13[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_13 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_actions_13
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_await_ev_qfyrs_14[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_await_actions_14[] = {
+	llc_conn_ac_send_rr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_state_trans_14 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT,
+	llc_await_ev_qfyrs_14,
+	llc_await_actions_14
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_await_state_transitions[] = {
+	&llc_common_state_trans_1,      // Request
+	&llc_common_state_trans_2,
+	&llc_await_state_trans_1_0,
+	&llc_common_state_trans_n,
+	&llc_await_state_trans_1,       // Local busy
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,      // Initiate PF Cycle
+	&llc_common_state_trans_11a,    // Timer
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_await_state_trans_14,
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_3,      // Receive frame
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	// &llc_common_state_trans_10,
+	&llc_await_state_trans_2,
+	&llc_await_state_trans_3a,
+	&llc_await_state_trans_3b,
+	&llc_await_state_trans_4,
+	&llc_await_state_trans_5,
+	&llc_await_state_trans_6a,
+	&llc_await_state_trans_6b,
+	&llc_await_state_trans_7,
+	&llc_await_state_trans_8a,
+	&llc_await_state_trans_8b,
+	&llc_await_state_trans_9a,
+	&llc_await_state_trans_9b,
+	&llc_await_state_trans_9c,
+	&llc_await_state_trans_9d,
+	&llc_await_state_trans_10a,
+	&llc_await_state_trans_10b,
+	&llc_await_state_trans_11,
+	&llc_await_state_trans_12a,
+	&llc_await_state_trans_12b,
+	&llc_await_state_trans_13,
+	&llc_common_state_trans_n
+};
+
+/* ------------------ LLC_CONN_STATE_AWAIT_BUSY transitions ---------------- */
+/* State transitions for LLC_CONN_EV_DATA_CONN_REQ event */
+static llc_conn_ev_qfyr_t llc_await_busy_ev_qfyrs_1_0[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_await_busy_actions_1_0[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_1_0 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_await_busy_ev_qfyrs_1_0,
+	llc_await_busy_actions_1_0
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_await_busy_ev_qfyrs_1[] = {
+	llc_conn_ev_qlfy_data_flag_eq_1,
+	NULL
+};
+
+static llc_conn_action_t llc_await_busy_actions_1[] = {
+	llc_conn_ac_send_rej_xxx_x_set_0,
+	llc_conn_ac_start_rej_timer,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_1 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_await_busy_ev_qfyrs_1,
+	llc_await_busy_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_await_busy_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_data_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_await_busy_actions_2[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_2 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_AWAIT,
+	llc_await_busy_ev_qfyrs_2,
+	llc_await_busy_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_CLEARED event */
+static llc_conn_ev_qfyr_t llc_await_busy_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_data_flag_eq_2,
+	NULL
+};
+
+static llc_conn_action_t llc_await_busy_actions_3[] = {
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_3 = {
+	llc_conn_ev_local_busy_cleared,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_await_busy_ev_qfyrs_3,
+	llc_await_busy_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_busy_actions_4[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_set_data_flag_1,
+	llc_conn_ac_clear_remote_busy,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_4 = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_busy_actions_5a[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_5a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_5a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_busy_actions_5b[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_5b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_5b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_busy_actions_6[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_6 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_7[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_0,
+	llc_conn_ac_clear_remote_busy,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_7 = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_8a[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_8a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_8a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_8b[] = {
+	llc_conn_ac_opt_send_rnr_xxx_x_set_0,
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_8b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_8b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_9[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_data_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_9 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_9
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_10a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_10a = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_10a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_10b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_10b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_10b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_11a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_11a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_11a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_11b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_11b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_11b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_11c[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_11c = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_11c
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_11d[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_11d = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_11d
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_12a[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_12a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_12a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_12b[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_12b = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_12b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_13[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_13 = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_13
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_14a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_14a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_14a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_busy_actions_14b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_14b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_14b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_busy_actions_15[] = {
+	llc_conn_ac_send_rnr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_15 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_busy_actions_15
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_await_busy_ev_qfyrs_16[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_await_busy_actions_16[] = {
+	llc_conn_ac_send_rnr_cmd_p_set_1,
+	llc_conn_ac_start_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_busy_state_trans_16 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	llc_await_busy_ev_qfyrs_16,
+	llc_await_busy_actions_16
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_await_busy_state_transitions[] = {
+	&llc_common_state_trans_1,          // Request
+	&llc_common_state_trans_2,
+	&llc_await_busy_state_trans_1_0,
+	&llc_common_state_trans_n,
+	&llc_await_busy_state_trans_1,      // Local busy
+	&llc_await_busy_state_trans_2,
+	&llc_await_busy_state_trans_3,
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,          // Initiate PF cycle
+	&llc_common_state_trans_11a,        // Timer
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_await_busy_state_trans_16,
+	&llc_common_state_trans_n,
+	&llc_await_busy_state_trans_4,      // Receive frame
+	&llc_await_busy_state_trans_5a,
+	&llc_await_busy_state_trans_5b,
+	&llc_await_busy_state_trans_6,
+	&llc_await_busy_state_trans_7,
+	&llc_await_busy_state_trans_8a,
+	&llc_await_busy_state_trans_8b,
+	&llc_await_busy_state_trans_9,
+	&llc_await_busy_state_trans_10a,
+	&llc_await_busy_state_trans_10b,
+	&llc_await_busy_state_trans_11a,
+	&llc_await_busy_state_trans_11b,
+	&llc_await_busy_state_trans_11c,
+	&llc_await_busy_state_trans_11d,
+	&llc_await_busy_state_trans_12a,
+	&llc_await_busy_state_trans_12b,
+	&llc_await_busy_state_trans_13,
+	&llc_await_busy_state_trans_14a,
+	&llc_await_busy_state_trans_14b,
+	&llc_await_busy_state_trans_15,
+	&llc_common_state_trans_3,
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	// &llc_common_state_trans_10,
+	&llc_common_state_trans_n
+};
+
+/* ----------------- LLC_CONN_STATE_AWAIT_REJECT transitions --------------- */
+/* State transitions for LLC_CONN_EV_DATA_CONN_REQ event */
+static llc_conn_ev_qfyr_t llc_await_reject_ev_qfyrs_1_0[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_await_reject_actions_1_0[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_reject_state_trans_1_0 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_await_reject_ev_qfyrs_1_0,
+	llc_await_reject_actions_1_0
+};
+
+/* State transitions for LLC_CONN_EV_LOCAL_BUSY_DETECTED event */
+static llc_conn_action_t llc_await_rejct_actions_1[] = {
+	llc_conn_ac_send_rnr_xxx_x_set_0,
+	llc_conn_ac_set_data_flag_2,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_1 = {
+	llc_conn_ev_local_busy_detected,
+	LLC_CONN_STATE_AWAIT_BUSY,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_rejct_actions_2a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_2a = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_2a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_rejct_actions_2b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_2b = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_2b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_rejct_actions_3[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_3 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_4[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_stop_rej_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_resend_i_xxx_x_set_0_or_send_rr,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_4 = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_5a[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	llc_conn_ac_stop_rej_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_5a = {
+	llc_conn_ev_rx_i_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_5a
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_5b[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_xxx_x_set_0,
+	llc_conn_ac_stop_rej_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_5b = {
+	llc_conn_ev_rx_i_cmd_pbit_set_0,     LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,             llc_await_rejct_actions_5b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_6[] = {
+	llc_conn_ac_inc_vr_by_1,
+	llc_conn_ac_data_ind,
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_stop_rej_timer,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_6 = {
+	llc_conn_ev_rx_i_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_7a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_7a = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_7a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_7b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_7b = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_7b
+};
+
+/* State transitions for LLC_CONN_EV_RX_I_RSP_Fbit_SET_1_UNEXPD_Ns event */
+static llc_conn_action_t llc_await_rejct_actions_7c[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_resend_i_xxx_x_set_0,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_7c = {
+	llc_conn_ev_rx_i_rsp_fbit_set_1_unexpd_ns,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_7c
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_8a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_8a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_8a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_8b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_8b = {
+	llc_conn_ev_rx_rr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_8b
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_8c[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_8c = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_8c
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_8d[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_8d = {
+	llc_conn_ev_rx_rej_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_8d
+};
+
+/* State transitions for LLC_CONN_EV_RX_RR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_9a[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_9a = {
+	llc_conn_ev_rx_rr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_9a
+};
+
+/* State transitions for LLC_CONN_EV_RX_REJ_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_9b[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_clear_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_9b = {
+	llc_conn_ev_rx_rej_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_9b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_10[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_10 = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_1,
+	LLC_CONN_STATE_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_10
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_11a[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_11a = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_11a
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_RSP_Fbit_SET_0 event */
+static llc_conn_action_t llc_await_rejct_actions_11b[] = {
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_11b = {
+	llc_conn_ev_rx_rnr_rsp_fbit_set_0,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_11b
+};
+
+/* State transitions for LLC_CONN_EV_RX_RNR_CMD_Pbit_SET_1 event */
+static llc_conn_action_t llc_await_rejct_actions_12[] = {
+	llc_conn_ac_send_rr_rsp_f_set_1,
+	llc_conn_ac_upd_nr_received,
+	llc_conn_ac_upd_vs,
+	llc_conn_ac_set_remote_busy,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_12 = {
+	llc_conn_ev_rx_rnr_cmd_pbit_set_1,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_await_rejct_actions_12
+};
+
+/* State transitions for LLC_CONN_EV_P_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_await_rejct_ev_qfyrs_13[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_await_rejct_actions_13[] = {
+	llc_conn_ac_send_rej_cmd_p_set_1,
+	llc_conn_ac_stop_p_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_await_rejct_state_trans_13 = {
+	llc_conn_ev_p_tmr_exp,
+	LLC_CONN_STATE_AWAIT_REJECT,
+	llc_await_rejct_ev_qfyrs_13,
+	llc_await_rejct_actions_13
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_await_rejct_state_transitions[] = {
+	&llc_await_reject_state_trans_1_0,
+	&llc_common_state_trans_1,          // requests
+	&llc_common_state_trans_2,
+	&llc_common_state_trans_n,
+	&llc_await_rejct_state_trans_1,     // local busy
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,          // Initiate PF cycle
+	&llc_await_rejct_state_trans_13,    // timers
+	&llc_common_state_trans_11a,
+	&llc_common_state_trans_11b,
+	&llc_common_state_trans_11c,
+	&llc_common_state_trans_11d,
+	&llc_common_state_trans_n,
+	&llc_await_rejct_state_trans_2a,    // receive frames
+	&llc_await_rejct_state_trans_2b,
+	&llc_await_rejct_state_trans_3,
+	&llc_await_rejct_state_trans_4,
+	&llc_await_rejct_state_trans_5a,
+	&llc_await_rejct_state_trans_5b,
+	&llc_await_rejct_state_trans_6,
+	&llc_await_rejct_state_trans_7a,
+	&llc_await_rejct_state_trans_7b,
+	&llc_await_rejct_state_trans_7c,
+	&llc_await_rejct_state_trans_8a,
+	&llc_await_rejct_state_trans_8b,
+	&llc_await_rejct_state_trans_8c,
+	&llc_await_rejct_state_trans_8d,
+	&llc_await_rejct_state_trans_9a,
+	&llc_await_rejct_state_trans_9b,
+	&llc_await_rejct_state_trans_10,
+	&llc_await_rejct_state_trans_11a,
+	&llc_await_rejct_state_trans_11b,
+	&llc_await_rejct_state_trans_12,
+	&llc_common_state_trans_3,
+	&llc_common_state_trans_4,
+	&llc_common_state_trans_5,
+	&llc_common_state_trans_6,
+	&llc_common_state_trans_7a,
+	&llc_common_state_trans_7b,
+	&llc_common_state_trans_8a,
+	&llc_common_state_trans_8b,
+	&llc_common_state_trans_8c,
+	&llc_common_state_trans_9,
+	// &llc_common_state_trans_10,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_D_CONN transitions ------------------ */
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_1[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_conflict,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_1[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_disc_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_1 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_1,
+	llc_d_conn_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event,
+ * cause_flag = 0
+ */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_1_1[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_conflict,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_1_1[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_1_1 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_1_1,
+	llc_d_conn_actions_1_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_2[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_disc_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_2 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_2,
+	llc_d_conn_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event,
+ * cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_2_1[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_2_1[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_2_1 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_2_1,
+	llc_d_conn_actions_2_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_d_conn_actions_3[] = {
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_3 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_D_CONN,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_d_conn_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_4[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_disc_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_4 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_4,
+	llc_d_conn_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event,
+ * cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_4_1[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_4_1[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_4_1 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_4_1,
+	llc_d_conn_actions_4_1
+};
+
+/*
+ * State transition for
+ * LLC_CONN_EV_DATA_CONN_REQ event
+ */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_5[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_5[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_5 = {
+	llc_conn_ev_data_req, LLC_CONN_STATE_D_CONN,
+	llc_d_conn_ev_qfyrs_5, llc_d_conn_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_6[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_6[] = {
+	llc_conn_ac_send_disc_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_6 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_D_CONN,
+	llc_d_conn_ev_qfyrs_6,
+	llc_d_conn_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event, cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_7[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_failed,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_7[] = {
+	llc_conn_ac_disc_confirm,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_7 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_7,
+	llc_d_conn_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event, cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_d_conn_ev_qfyrs_8[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2, 	
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_failed,
+	NULL
+};
+
+static llc_conn_action_t llc_d_conn_actions_8[] = {
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_d_conn_state_trans_8 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ADM,
+	llc_d_conn_ev_qfyrs_8,
+	llc_d_conn_actions_8
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_d_conn_state_transitions[] = {
+	&llc_d_conn_state_trans_5,      // Request
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,      // Local busy
+	&llc_common_state_trans_n,      // Initiate PF cycle
+	&llc_d_conn_state_trans_6,      // Timer
+	&llc_d_conn_state_trans_7,
+	&llc_d_conn_state_trans_8,
+	&llc_common_state_trans_n,
+	&llc_d_conn_state_trans_1,      // Receive frame
+	&llc_d_conn_state_trans_1_1,
+	&llc_d_conn_state_trans_2,
+	&llc_d_conn_state_trans_2_1,
+	&llc_d_conn_state_trans_3,
+	&llc_d_conn_state_trans_4,
+	&llc_d_conn_state_trans_4_1,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_RESET transitions ------------------- */
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_rst_actions_1[] = {
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_set_s_flag_1,
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_1 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_RESET,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_rst_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_2[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_conn,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_2[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_rst_confirm,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_reset,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_2 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_rst_ev_qfyrs_2,
+	llc_rst_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_UA_RSP_Fbit_SET_X event,
+ * cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_2_1[] = {
+	llc_conn_ev_qlfy_p_flag_eq_f,
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_rst_done,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_2_1[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_upd_p_flag,
+	llc_conn_ac_rst_confirm,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_reset,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_2_1 = {
+	llc_conn_ev_rx_ua_rsp_fbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	llc_rst_ev_qfyrs_2_1,
+	llc_rst_actions_2_1
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_3[] = {
+	llc_conn_ev_qlfy_s_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_rst_done,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_3[] = {
+	llc_conn_ac_set_p_flag_0,
+	llc_conn_ac_set_remote_busy_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_3 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_NORMAL,
+	llc_rst_ev_qfyrs_3,
+	llc_rst_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_4[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+static llc_conn_action_t llc_rst_actions_4[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_ac_disc_ind,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_4 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_4,
+	llc_rst_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event,
+ * cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_4_1[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_4_1[] = {
+	llc_conn_ac_send_dm_rsp_f_set_p,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_4_1 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_4_1,
+	llc_rst_actions_4_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event,
+ * cause_flag = 1 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_5[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_disc,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_5[] = {
+	llc_conn_ac_disc_ind,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_5 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_5,
+	llc_rst_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event,
+ * cause_flag = 0 */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_5_1[] = {
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_5_1[] = {
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_5_1 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_5_1,
+	llc_rst_actions_5_1
+};
+
+/* State transitions for DATA_CONN_REQ event */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_6[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_6[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_6 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_RESET,
+	llc_rst_ev_qfyrs_6,
+	llc_rst_actions_6
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_7[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	llc_conn_ev_qlfy_s_flag_eq_0,
+	NULL
+};
+
+static llc_conn_action_t llc_rst_actions_7[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_7 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_rst_ev_qfyrs_7,
+	llc_rst_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_8[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	llc_conn_ev_qlfy_s_flag_eq_0,
+	llc_conn_ev_qlfy_cause_flag_eq_1,
+	llc_conn_ev_qlfy_set_status_failed,
+	NULL
+};
+static llc_conn_action_t llc_rst_actions_8[] = {
+	llc_conn_ac_disc_ind,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_8 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_8,
+	llc_rst_actions_8
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_rst_ev_qfyrs_8_1[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	llc_conn_ev_qlfy_s_flag_eq_0,
+	llc_conn_ev_qlfy_cause_flag_eq_0,
+	llc_conn_ev_qlfy_set_status_failed,
+	NULL
+};
+static llc_conn_action_t llc_rst_actions_8_1[] = {
+	llc_conn_ac_disc_ind,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_rst_state_trans_8_1 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ADM,
+	llc_rst_ev_qfyrs_8_1,
+	llc_rst_actions_8_1
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_rst_state_transitions[] = {
+	&llc_rst_state_trans_6,       // Request
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,      // Local busy
+	&llc_common_state_trans_n,      // Initiate PF cycle
+	&llc_rst_state_trans_3,       // Timer
+	&llc_rst_state_trans_7,
+	&llc_rst_state_trans_8,
+	&llc_rst_state_trans_8_1,
+	&llc_common_state_trans_n,
+	&llc_rst_state_trans_1,       // Receive frame
+	&llc_rst_state_trans_2,
+	&llc_rst_state_trans_2_1,
+	&llc_rst_state_trans_4,
+	&llc_rst_state_trans_4_1,
+	&llc_rst_state_trans_5,
+	&llc_rst_state_trans_5_1,
+	&llc_common_state_trans_n
+};
+
+/* -------------------- LLC_CONN_STATE_ERROR transitions ------------------- */
+/* State transitions for LLC_CONN_EV_RX_SABME_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_error_actions_1[] = {
+	llc_conn_ac_set_vs_0,
+	llc_conn_ac_set_vr_0,
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_rst_ind,
+	llc_conn_ac_set_p_flag_0,
+	llc_conn_ac_set_remote_busy_0,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_reset,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_1 = {
+	llc_conn_ev_rx_sabme_cmd_pbit_set_x,
+	LLC_CONN_STATE_NORMAL,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_error_actions_1
+};
+
+/* State transitions for LLC_CONN_EV_RX_DISC_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_error_actions_2[] = {
+	llc_conn_ac_send_ua_rsp_f_set_p,
+	llc_conn_ac_disc_ind,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_2 = {
+	llc_conn_ev_rx_disc_cmd_pbit_set_x,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_error_actions_2
+};
+
+/* State transitions for LLC_CONN_EV_RX_DM_RSP_Fbit_SET_X event */
+static llc_conn_action_t llc_error_actions_3[] = {
+	llc_conn_ac_disc_ind,
+	llc_conn_ac_stop_ack_timer,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_3 = {
+	llc_conn_ev_rx_dm_rsp_fbit_set_x,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_error_actions_3
+};
+
+/* State transitions for LLC_CONN_EV_RX_FRMR_RSP_Fbit_SET_X event */
+static llc_conn_action_t llc_error_actions_4[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_4 = {
+	llc_conn_ev_rx_frmr_rsp_fbit_set_x,
+	LLC_CONN_STATE_RESET,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_error_actions_4
+};
+
+/* State transitions for LLC_CONN_EV_RX_XXX_CMD_Pbit_SET_X event */
+static llc_conn_action_t llc_error_actions_5[] = {
+	llc_conn_ac_resend_frmr_rsp_f_set_p,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_5 = {
+	llc_conn_ev_rx_xxx_cmd_pbit_set_x,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_error_actions_5
+};
+
+/* State transitions for LLC_CONN_EV_RX_XXX_RSP_Fbit_SET_X event */
+static struct llc_conn_state_trans llc_error_state_trans_6 = {
+	llc_conn_ev_rx_xxx_rsp_fbit_set_x,
+	LLC_CONN_STATE_ERROR,
+	LLC_NO_EVENT_QUALIFIERS,
+	LLC_NO_TRANSITION_ACTIONS
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_error_ev_qfyrs_7[] = {
+	llc_conn_ev_qlfy_retry_cnt_lt_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_error_actions_7[] = {
+	llc_conn_ac_resend_frmr_rsp_f_set_0,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_inc_retry_cnt_by_1,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_7 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_ERROR,
+	llc_error_ev_qfyrs_7,
+	llc_error_actions_7
+};
+
+/* State transitions for LLC_CONN_EV_ACK_TMR_EXP event */
+static llc_conn_ev_qfyr_t llc_error_ev_qfyrs_8[] = {
+	llc_conn_ev_qlfy_retry_cnt_gte_n2,
+	NULL
+};
+
+static llc_conn_action_t llc_error_actions_8[] = {
+	llc_conn_ac_send_sabme_cmd_p_set_x,
+	llc_conn_ac_set_s_flag_0,
+	llc_conn_ac_start_ack_timer,
+	llc_conn_ac_set_retry_cnt_0,
+	llc_conn_ac_set_cause_flag_0,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_8 = {
+	llc_conn_ev_ack_tmr_exp,
+	LLC_CONN_STATE_RESET,
+	llc_error_ev_qfyrs_8,
+	llc_error_actions_8
+};
+
+/* State transitions for LLC_CONN_EV_DATA_CONN_REQ event */
+static llc_conn_ev_qfyr_t llc_error_ev_qfyrs_9[] = {
+	llc_conn_ev_qlfy_set_status_refuse,
+	NULL
+};
+
+static llc_conn_action_t llc_error_actions_9[] = {
+	NULL
+};
+
+static struct llc_conn_state_trans llc_error_state_trans_9 = {
+	llc_conn_ev_data_req,
+	LLC_CONN_STATE_ERROR,
+	llc_error_ev_qfyrs_9,
+	llc_error_actions_9
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_error_state_transitions[] = {
+	&llc_error_state_trans_9,       // Request
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,      // Local busy
+	&llc_common_state_trans_n,      // Initiate PF cycle
+	&llc_error_state_trans_7,       // Timer
+	&llc_error_state_trans_8,
+	&llc_common_state_trans_n,
+	&llc_error_state_trans_1,       // Receive frame
+	&llc_error_state_trans_2,
+	&llc_error_state_trans_3,
+	&llc_error_state_trans_4,
+	&llc_error_state_trans_5,
+	&llc_error_state_trans_6,
+	&llc_common_state_trans_n
+};
+
+/* ------------------- LLC_CONN_STATE_TEMP transitions ----------------- */
+/* State transitions for LLC_CONN_EV_DISC_REQ event */
+static llc_conn_action_t llc_temp_actions_1[] = {
+	llc_conn_ac_stop_all_timers,
+	llc_conn_ac_send_disc_cmd_p_set_x,
+	llc_conn_disc,
+	NULL
+};
+
+static struct llc_conn_state_trans llc_temp_state_trans_1 = {
+	llc_conn_ev_disc_req,
+	LLC_CONN_STATE_ADM,
+	LLC_NO_EVENT_QUALIFIERS,
+	llc_temp_actions_1
+};
+
+/*
+ * Array of pointers;
+ * one to each transition
+ */
+static struct llc_conn_state_trans *llc_temp_state_transitions[] = {
+	&llc_temp_state_trans_1,        /* requests */
+	&llc_common_state_trans_n,
+	&llc_common_state_trans_n,      /* local busy */
+	&llc_common_state_trans_n,      /* init_pf_cycle */
+	&llc_common_state_trans_n,      /* timer */
+	&llc_common_state_trans_n       /* recieve */
+};
+
+/* Connection State Transition Table */
+struct llc_conn_state llc_conn_state_table[] = {
+	{ LLC_CONN_STATE_ADM,		llc_adm_state_transitions },
+	{ LLC_CONN_STATE_SETUP,		llc_setup_state_transitions },
+	{ LLC_CONN_STATE_NORMAL,	llc_normal_state_transitions },
+	{ LLC_CONN_STATE_BUSY,		llc_busy_state_transitions },
+	{ LLC_CONN_STATE_REJECT,	llc_reject_state_transitions },
+	{ LLC_CONN_STATE_AWAIT,		llc_await_state_transitions },
+	{ LLC_CONN_STATE_AWAIT_BUSY,	llc_await_busy_state_transitions },
+	{ LLC_CONN_STATE_AWAIT_REJECT,	llc_await_rejct_state_transitions },
+	{ LLC_CONN_STATE_D_CONN,	llc_d_conn_state_transitions },
+	{ LLC_CONN_STATE_RESET,		llc_rst_state_transitions },
+	{ LLC_CONN_STATE_ERROR,		llc_error_state_transitions },
+	{ LLC_CONN_STATE_TEMP,		llc_temp_state_transitions }
+};
diff -ruN linux-2.4.18-clean/net/llc/llc_conn.c linux/net/llc/llc_conn.c
--- linux-2.4.18-clean/net/llc/llc_conn.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_conn.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,520 @@
+/*
+ * llc_conn.c - Driver routines for connection component.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_conn.h>
+#include <net/sock.h>
+#include <net/llc_main.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_c_ac.h>
+#include <net/llc_c_st.h>
+#include <net/llc_mac.h>
+#include <net/llc_pdu.h>
+#include <net/llc_s_ev.h>
+
+static int llc_find_offset(int state, int ev_type);
+static void llc_conn_send_pdus(struct sock *sk);
+static int llc_conn_service(struct sock *sk, struct llc_conn_state_ev *ev);
+static int llc_exec_conn_trans_actions(struct sock *sk,
+				       struct llc_conn_state_trans *trans,
+				       struct llc_conn_state_ev *ev);
+static struct llc_conn_state_trans *
+	     llc_qualify_conn_ev(struct sock *sk, struct llc_conn_state_ev *ev);
+
+/* Offset table on connection states transition diagram */
+static int llc_offset_table[NBR_CONN_STATES][NBR_CONN_EV];
+
+/**
+ *	llc_conn_alloc_event: allocates an event
+ *	@sk: socket that event is associated
+ *
+ *	Returns pointer to allocated connection on success, %NULL on failure.
+ */
+struct llc_conn_state_ev *llc_conn_alloc_ev(struct sock *sk)
+{
+	struct llc_conn_state_ev *ev = NULL;
+
+	/* verify connection is valid, active and open */
+	if (LLC_SK(sk)->state != LLC_CONN_OUT_OF_SVC) {
+		/* get event structure to build a station event */
+		ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+		if (ev)
+			memset(ev, 0, sizeof(*ev));
+	}
+	return ev;
+}
+
+/**
+ *	llc_conn_send_event - sends event to connection state machine
+ *	@sk: connection
+ *	@ev: occurred event
+ *
+ *	Sends an event to connection state machine. after processing event
+ *	(executing it's actions and changing state), upper layer will be
+ *	indicated or confirmed, if needed. Returns 0 for success, 1 for
+ *	failure. The socket lock has to be held before calling this function.
+ */
+int llc_conn_send_ev(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	/* sending event to state machine */
+	int rc = llc_conn_service(sk, ev);
+	struct llc_opt *llc = LLC_SK(sk);
+	u8 flag = ev->flag;
+	struct llc_prim_if_block *ind_prim = ev->ind_prim;
+	struct llc_prim_if_block *cfm_prim = ev->cfm_prim;
+
+	llc_conn_free_ev(ev);
+#ifdef THIS_BREAKS_DISCONNECT_NOTIFICATION_BADLY
+	/* check if the connection was freed by the state machine by
+	 * means of llc_conn_disc */
+	if (rc == 2) {
+		printk(KERN_INFO __FUNCTION__ ": rc == 2\n");
+		rc = -ECONNABORTED;
+		goto out;
+	}
+#endif	/* THIS_BREAKS_DISCONNECT_NOTIFICATION_BADLY */
+	if (!flag)   /* indicate or confirm not required */
+		goto out;
+	rc = 0;
+	if (ind_prim) /* indication required */
+		llc->sap->ind(ind_prim);
+	if (!cfm_prim)  /* confirmation not required */
+		goto out;
+	/* data confirm has preconditions */
+	if (cfm_prim->prim != LLC_DATA_PRIM) {
+		llc->sap->conf(cfm_prim);
+		goto out;
+	}
+	if (!llc_data_accept_state(llc->state)) {
+		/* In this state, we can send I pdu */
+		/* FIXME: check if we don't need to see if sk->lock.users != 0
+		 * is needed here */
+		rc = llc->sap->conf(cfm_prim);
+		if (rc) /* confirmation didn't accept by upper layer */
+			llc->failed_data_req = 1;
+	} else
+		llc->failed_data_req = 1;
+out:	return rc;
+}
+
+void llc_conn_send_pdu(struct sock *sk, struct sk_buff *skb)
+{
+	llc_sock_assert(sk);
+	/* queue PDU to send to MAC layer */
+	skb_queue_tail(&sk->write_queue, skb);
+	llc_conn_send_pdus(sk);
+}
+
+/**
+ *	llc_conn_rtn_pdu - sends received data pdu to upper layer
+ *	@sk: Active connection
+ *	@skb: Received data frame
+ *	@ev: Occurred event
+ *
+ *	Sends received data pdu to upper layer (by using indicate function).
+ *	Prepares service parameters (prim and prim_data). calling indication
+ *	function will be done in llc_conn_send_ev.
+ */
+void llc_conn_rtn_pdu(struct sock *sk, struct sk_buff *skb,
+		      struct llc_conn_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = &llc_ind_prim;
+	union llc_u_prim_data *prim_data = llc_ind_prim.data;
+
+	prim_data->data.sk   = sk;
+	prim_data->data.pri  = 0;
+	prim_data->data.skb  = skb;
+	prim_data->data.link = LLC_SK(sk)->link;
+	prim->data	     = prim_data;
+	prim->prim	     = LLC_DATA_PRIM;
+	prim->sap	     = LLC_SK(sk)->sap;
+	ev->flag	     = 1;
+	/* saving prepd prim in event for future use in llc_conn_send_ev */
+	ev->ind_prim	     = prim;
+}
+
+/**
+ *	llc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs
+ *	@sk: active connection
+ *	@nr: NR
+ *	@first_p_bit: p_bit value of first pdu
+ *
+ *	Resend all unacknowledged I PDUs, starting with the NR; send first as
+ *	command PDU with P bit equal first_p_bit; if more than one send
+ *	subsequent as command PDUs with P bit equal zero (0).
+ */
+void llc_conn_resend_i_pdu_as_cmd(struct sock *sk, u8 nr, u8 first_p_bit)
+{
+	struct sk_buff *skb;
+	pdu_sn_t *pdu;
+	u16 nbr_unack_pdus;
+	u8 howmany_resend = 0;
+
+	llc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);
+	if (!nbr_unack_pdus)
+		goto out;
+	/* process unack PDUs only if unack queue is not empty; remove
+	 * appropriate PDUs, fix them up, and put them on mac_pdu_q. */
+	while ((skb = skb_dequeue(&LLC_SK(sk)->pdu_unack_q)) != NULL) {
+		pdu = (pdu_sn_t *)skb->nh.raw;
+		llc_pdu_set_cmd_rsp(skb, LLC_PDU_CMD);
+		llc_pdu_set_pf_bit(skb, first_p_bit);
+		skb_queue_tail(&sk->write_queue, skb);
+		first_p_bit = 0;
+		LLC_SK(sk)->vS = LLC_I_GET_NS(pdu);
+		howmany_resend++;
+	}
+	if (howmany_resend > 0)
+		LLC_SK(sk)->vS = (LLC_SK(sk)->vS + 1) % LLC_2_SEQ_NBR_MODULO;
+	/* any PDUs to re-send are queued up; start sending to MAC */
+	llc_conn_send_pdus(sk);
+out:;
+}
+
+/**
+ *	llc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs
+ *	@sk: active connection.
+ *	@nr: NR
+ *	@first_f_bit: f_bit value of first pdu.
+ *
+ *	Resend all unacknowledged I PDUs, starting with the NR; send first as
+ *	response PDU with F bit equal first_f_bit; if more than one send
+ *	subsequent as response PDUs with F bit equal zero (0).
+ */
+void llc_conn_resend_i_pdu_as_rsp(struct sock *sk, u8 nr, u8 first_f_bit)
+{
+	struct sk_buff *skb;
+	pdu_sn_t *pdu;
+	u16 nbr_unack_pdus;
+	u8 howmany_resend = 0;
+
+	llc_conn_remove_acked_pdus(sk, nr, &nbr_unack_pdus);
+	if (!nbr_unack_pdus)
+		goto out;
+	/* process unack PDUs only if unack queue is not empty; remove
+	 * appropriate PDUs, fix them up, and put them on mac_pdu_q */
+	while ((skb = skb_dequeue(&LLC_SK(sk)->pdu_unack_q)) != NULL) {
+		pdu = (pdu_sn_t *)skb->nh.raw;
+		llc_pdu_set_cmd_rsp(skb, LLC_PDU_RSP);
+		llc_pdu_set_pf_bit(skb, first_f_bit);
+		skb_queue_tail(&sk->write_queue, skb);
+		first_f_bit = 0;
+		LLC_SK(sk)->vS = LLC_I_GET_NS(pdu);
+		howmany_resend++;
+	}
+	if (howmany_resend > 0)
+		LLC_SK(sk)->vS = (LLC_SK(sk)->vS + 1) % LLC_2_SEQ_NBR_MODULO;
+	/* any PDUs to re-send are queued up; start sending to MAC */
+	llc_conn_send_pdus(sk);
+out:;
+}
+
+/**
+ *	llc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue
+ *	@sk: active connection
+ *	nr: NR
+ *	how_many_unacked: size of pdu_unack_q after removing acked pdus
+ *
+ *	Removes acknowledged pdus from transmit queue (pdu_unack_q). Returns
+ *	the number of pdus that removed from queue.
+ */
+int llc_conn_remove_acked_pdus(struct sock *sk, u8 nr, u16 *how_many_unacked)
+{
+	int pdu_pos, i;
+	struct sk_buff *skb;
+	pdu_sn_t *pdu;
+	int nbr_acked = 0;
+	int q_len = skb_queue_len(&LLC_SK(sk)->pdu_unack_q);
+
+	if (!q_len)
+		goto out;
+	skb = skb_peek(&LLC_SK(sk)->pdu_unack_q);
+	pdu = (pdu_sn_t *)skb->nh.raw;
+
+        /* finding position of last acked pdu in queue */
+	pdu_pos = ((int)LLC_2_SEQ_NBR_MODULO + (int)nr -
+			(int)LLC_I_GET_NS(pdu)) % LLC_2_SEQ_NBR_MODULO;
+
+	for (i = 0; i < pdu_pos && i < q_len; i++) {
+		skb = skb_dequeue(&LLC_SK(sk)->pdu_unack_q);
+		if (skb)
+			kfree_skb(skb);
+		nbr_acked++;
+	}
+out:	*how_many_unacked = skb_queue_len(&LLC_SK(sk)->pdu_unack_q);
+	return nbr_acked;
+}
+
+/**
+ *	llc_conn_send_pdus - Sends queued PDUs
+ *	@sk: active connection
+ *
+ *	Sends queued pdus to MAC layer for transmition.
+ */
+static void llc_conn_send_pdus(struct sock *sk)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&sk->write_queue)) != NULL) {
+		pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+		if (!LLC_PDU_TYPE_IS_I(pdu) &&
+		    !(skb->dev->flags & IFF_LOOPBACK))
+			skb_queue_tail(&LLC_SK(sk)->pdu_unack_q, skb);
+		mac_send_pdu(skb);
+		if (LLC_PDU_TYPE_IS_I(pdu) ||
+		    (skb->dev && skb->dev->flags & IFF_LOOPBACK))
+			kfree_skb(skb);
+	}
+}
+
+/**
+ *	llc_conn_free_ev - free event
+ *	@ev: event to free
+ *
+ *	Free allocated event.
+ */
+void llc_conn_free_ev(struct llc_conn_state_ev *ev)
+{
+	if (ev->type == LLC_CONN_EV_TYPE_PDU) {
+		/* free the frame that binded to this event */
+		pdu_sn_t *pdu = (pdu_sn_t *)ev->data.pdu.skb->nh.raw;
+
+		if (LLC_PDU_TYPE_IS_I(pdu) || !ev->flag || !ev->ind_prim)
+			kfree_skb(ev->data.pdu.skb);
+	}
+	/* free event structure to free list of the same */
+	kfree(ev);
+}
+
+/**
+ *	llc_conn_service - finds transition and changes state of connection
+ *	@sk: connection
+ *	@ev: happened event
+ *
+ *	This function finds transition that matches with happened event, then
+ *	executes related actions and finally changes state of connection.
+ *	Returns 0 for success, 1 for failure.
+ */
+static int llc_conn_service(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	int rc = 1;
+	struct llc_conn_state_trans *trans;
+
+	if (LLC_SK(sk)->state > NBR_CONN_STATES)
+		goto out;
+	rc = 0;
+	trans = llc_qualify_conn_ev(sk, ev);
+	if (trans) {
+		rc = llc_exec_conn_trans_actions(sk, trans, ev);
+		if (!rc && trans->next_state != NO_STATE_CHANGE)
+			LLC_SK(sk)->state = trans->next_state;
+	}
+out:	return rc;
+}
+
+/**
+ *	llc_qualify_conn_ev - finds transition for event
+ *	@sk: connection
+ *	@ev: happened event
+ *
+ *	This function finds transition that matches with happened event.
+ *	Returns pointer to found transition on success, %NULL otherwise.
+ */
+static struct llc_conn_state_trans *
+	     llc_qualify_conn_ev(struct sock *sk, struct llc_conn_state_ev *ev)
+{
+	struct llc_conn_state_trans **next_trans;
+	llc_conn_ev_qfyr_t *next_qualifier;
+	struct llc_conn_state *curr_state =
+				&llc_conn_state_table[LLC_SK(sk)->state - 1];
+
+	/* search thru events for this state until list exhausted or until
+	   no more */
+	for (next_trans = curr_state->transitions +
+		llc_find_offset(LLC_SK(sk)->state - 1, ev->type);
+	     (*next_trans)->ev; next_trans++) {
+		if (!((*next_trans)->ev)(sk, ev)) {
+			/* got POSSIBLE event match; the event may require
+			 * qualification based on the values of a number of
+			 * state flags; if all qualifications are met (i.e.,
+			 * if all qualifying functions return success, or 0,
+			 * then this is THE event we're looking for */
+			for (next_qualifier =
+					   (*next_trans)->ev_qualifiers;
+			     next_qualifier && *next_qualifier &&
+				!(*next_qualifier)(sk, ev);
+                             next_qualifier++);
+			if (!next_qualifier || !*next_qualifier)
+				/* all qualifiers executed successfully; this is
+				 * our transition; return it so we can perform
+				 * the associated actions & change the state */
+				return *next_trans;
+		}
+	}
+	return NULL;
+}
+
+/**
+ *	llc_exec_conn_trans_actions - executes related actions
+ *	@sk: connection
+ *	@trans: transition that it's actions must be performed
+ *	@ev: happened event
+ *
+ *	Executes actions that is related to happened event. Returns 0 for
+ *	success, 1 to indicate failure of at least one action or 2 if the
+ *	connection was freed (llc_conn_disc was called)
+ */
+static int llc_exec_conn_trans_actions(struct sock *sk,
+				       struct llc_conn_state_trans *trans,
+				       struct llc_conn_state_ev *ev)
+{
+	int rc = 0;
+	llc_conn_action_t *next_action;
+
+	for (next_action = trans->ev_actions;
+	     next_action && *next_action; next_action++) {
+		int rc2 = (*next_action)(sk, ev);
+
+		if (rc2 == 2) {
+			rc = rc2;
+			break;
+		} else if (rc2)
+			rc = 1;
+	}
+	return rc;
+}
+
+/**
+ *	llc_find_conn - Finds connection in sap for the remote/local sap/mac
+ *	@sap: SAP
+ *	@remote_addr: address of remote LLC (MAC + SAP)
+ *	@local_addr: address of local LLC (MAC + SAP)
+ *
+ *	Search connection list of the SAP and finds connection using the remote
+ *	mac, remote sap, local mac, and local sap. Returns pointer for
+ *	connection found, %NULL otherwise.
+ */
+struct sock *llc_find_conn(struct llc_sap *sap, struct llc_addr *remote_addr,
+			   struct llc_addr *local_addr)
+{
+	struct sock *rc = NULL;
+	struct list_head *entry;
+
+	spin_lock_bh(&sap->sk_list.lock);
+	if (list_empty(&sap->sk_list.list))
+		goto out;
+	list_for_each(entry, &sap->sk_list.list) {
+		struct llc_opt *llc = list_entry(entry, struct llc_opt, node);
+
+		if (!memcmp(llc->laddr.mac, local_addr->mac, MAC_ADDR_LEN) &&
+		    !memcmp(llc->daddr.mac, remote_addr->mac, MAC_ADDR_LEN) &&
+		    llc->daddr.lsap == remote_addr->lsap) {
+			rc = sock_list_entry(entry, struct llc_opt, node);
+			break;
+		}
+	}
+	if (rc)
+		sock_hold(rc);
+out:	spin_unlock_bh(&sap->sk_list.lock);
+	return rc;
+}
+
+/**
+ *	llc_data_accept_state - designates if in this state data can be sent.
+ *	@state: state of connection.
+ *
+ *	Returns 0 if data can be sent, 1 otherwise.
+ */
+u8 llc_data_accept_state(u8 state)
+{
+	if (state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&
+	    state != LLC_CONN_STATE_REJECT)
+		return 1; /* data_conn_refuse */
+	return 0;
+}
+
+/**
+ *	find_next_offset - finds offset for next category of transitions
+ *	@state: state table.
+ *	@offset: start offset.
+ *
+ *	Finds offset of next category of transitions in transition table.
+ *	Returns the start index of next category.
+ */
+u16 find_next_offset(struct llc_conn_state *state, u16 offset)
+{
+	u16 cnt = 0;
+	struct llc_conn_state_trans **next_trans;
+
+	for (next_trans = state->transitions + offset;
+	     (*next_trans)->ev; next_trans++)
+		++cnt;
+	return cnt;
+}
+
+/**
+ *	llc_build_offset_table - builds offset table of connection
+ *
+ *	Fills offset table of connection state transition table
+ *	(llc_offset_table).
+ */
+void __init llc_build_offset_table(void)
+{
+	struct llc_conn_state *curr_state;
+	int state, ev_type, next_offset;
+
+	memset(llc_offset_table, 0, sizeof(llc_offset_table));
+	for (state = 0; state < NBR_CONN_STATES; state++) {
+		curr_state = &llc_conn_state_table[state];
+		next_offset = 0;
+		for (ev_type = 0; ev_type < NBR_CONN_EV; ev_type++) {
+			llc_offset_table[state][ev_type] = next_offset;
+			next_offset += find_next_offset(curr_state,
+							next_offset) + 1;
+		}
+	}
+}
+
+/**
+ *	llc_find_offset - finds start offset of category of transitions
+ *	@state: state of connection
+ *	@ev_type: type of happened event
+ *
+ *	Finds start offset of desired category of transitions. Returns the
+ *	desired start offset.
+ */
+static int llc_find_offset(int state, int ev_type)
+{
+	int rc = 0;
+	/* at this stage, llc_offset_table[..][2] is not important. it is for
+	 * init_pf_cycle and I don't know what is it. */
+	switch (ev_type) {
+		case LLC_CONN_EV_TYPE_PRIM:
+			rc = llc_offset_table[state][0]; break;
+		case LLC_CONN_EV_TYPE_PDU:
+			rc = llc_offset_table[state][4]; break;
+		case LLC_CONN_EV_TYPE_SIMPLE:
+			rc = llc_offset_table[state][1]; break;
+		case LLC_CONN_EV_TYPE_P_TMR:
+		case LLC_CONN_EV_TYPE_ACK_TMR:
+		case LLC_CONN_EV_TYPE_REJ_TMR:
+		case LLC_CONN_EV_TYPE_BUSY_TMR:
+			rc = llc_offset_table[state][3]; break;
+	}
+	return rc;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_evnt.c linux/net/llc/llc_evnt.c
--- linux-2.4.18-clean/net/llc/llc_evnt.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_evnt.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,111 @@
+/*
+ * llc_evnt.c - LLC station component event match functions
+ * Description :
+ *   Functions in this module are implementation of station component events.
+ *   Details of events can be found in IEEE-802.2 standard document.
+ *   All functions have one station and one event as input argument. All of
+ *   them return 0 On success and 1 otherwise.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <net/llc_main.h>
+#include <net/llc_evnt.h>
+#include <net/llc_pdu.h>
+
+int llc_stat_ev_enable_with_dup_addr_check(struct llc_station *station,
+				       struct llc_station_state_ev *ev)
+{
+	return ev->type == LLC_STATION_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev ==
+	       		      LLC_STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK ? 0 : 1;
+}
+
+int llc_stat_ev_enable_without_dup_addr_check(struct llc_station *station,
+					  struct llc_station_state_ev *ev)
+{
+	return ev->type == LLC_STATION_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev ==
+			LLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK ? 0 : 1;
+}
+
+int llc_stat_ev_ack_tmr_exp_lt_retry_cnt_max_retry(struct llc_station *station,
+						struct llc_station_state_ev *ev)
+{
+	return ev->type == LLC_STATION_EV_TYPE_ACK_TMR &&
+	       station->retry_count < station->maximum_retry ? 0 : 1;
+}
+
+int llc_stat_ev_ack_tmr_exp_eq_retry_cnt_max_retry(struct llc_station *station,
+						struct llc_station_state_ev *ev)
+{
+	return ev->type == LLC_STATION_EV_TYPE_ACK_TMR &&
+		station->retry_count == station->maximum_retry ? 0 : 1;
+}
+
+int llc_stat_ev_rx_null_dsap_xid_c(struct llc_station *station,
+			       struct llc_station_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_STATION_EV_TYPE_PDU &&
+	       !LLC_PDU_IS_CMD(pdu) &&			/* command PDU */
+	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_XID &&
+	       !pdu->dsap ? 0 : 1;			/* NULL DSAP value */
+}
+
+int llc_stat_ev_rx_null_dsap_0_xid_r_xid_r_cnt_eq(struct llc_station *station,
+					      struct llc_station_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_STATION_EV_TYPE_PDU &&
+	       !LLC_PDU_IS_RSP(pdu) &&			/* response PDU */
+	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&
+	       !pdu->dsap &&				/* NULL DSAP value */
+	       !station->xid_r_count ? 0 : 1;
+}
+
+int llc_stat_ev_rx_null_dsap_1_xid_r_xid_r_cnt_eq(struct llc_station *station,
+					      struct llc_station_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_STATION_EV_TYPE_PDU &&
+	       !LLC_PDU_IS_RSP(pdu) &&			/* response PDU */
+	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&
+	       !pdu->dsap &&				/* NULL DSAP value */
+	       station->xid_r_count == 1 ? 0 : 1;
+}
+
+int llc_stat_ev_rx_null_dsap_test_c(struct llc_station *station,
+			        struct llc_station_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_STATION_EV_TYPE_PDU &&
+	       !LLC_PDU_IS_CMD(pdu) &&			/* command PDU */
+	       !LLC_PDU_TYPE_IS_U(pdu) &&		/* U type PDU */
+	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_TEST &&
+	       !pdu->dsap ? 0 : 1;			/* NULL DSAP */
+}
+
+int llc_stat_ev_disable_req(struct llc_station *station,
+			    struct llc_station_state_ev *ev)
+{
+	return ev->type == LLC_STATION_EV_TYPE_PRIM &&
+	       ev->data.prim.prim == LLC_DISABLE_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_if.c linux/net/llc/llc_if.c
--- linux-2.4.18-clean/net/llc/llc_if.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_if.c	Sat Jun  8 13:33:11 2002
@@ -0,0 +1,493 @@
+/*
+ * llc_if.c - Defines LLC interface to upper layer
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <asm/errno.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_conn.h>
+#include <net/sock.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_c_ac.h>
+#include <net/llc_c_st.h>
+#include <net/llc_main.h>
+#include <net/llc_mac.h>
+
+static int llc_sap_req(struct llc_prim_if_block *prim);
+static int llc_unitdata_req_handler(struct llc_prim_if_block *prim);
+static int llc_test_req_handler(struct llc_prim_if_block *prim);
+static int llc_xid_req_handler(struct llc_prim_if_block *prim);
+static int llc_data_req_handler(struct llc_prim_if_block *prim);
+static int llc_conn_req_handler(struct llc_prim_if_block *prim);
+static int llc_disc_req_handler(struct llc_prim_if_block *prim);
+static int llc_rst_req_handler(struct llc_prim_if_block *prim);
+static int llc_flowcontrol_req_handler(struct llc_prim_if_block *prim);
+static int llc_sap_resp(struct llc_prim_if_block *prim);
+static int llc_conn_rsp_handler(struct llc_prim_if_block *prim);
+static int llc_rst_rsp_handler(struct llc_prim_if_block *prim);
+static int llc_no_rsp_handler(struct llc_prim_if_block *prim);
+
+extern void llc_register_sap(unsigned char sap,
+			     int (*rcvfunc)(struct sk_buff *skb,
+					    struct net_device *dev,
+					    struct packet_type *pt));
+extern void llc_unregister_sap(unsigned char sap);
+
+/* table of request handler functions */
+static llc_prim_call_t llc_req_prim[LLC_NBR_PRIMITIVES] = {
+	llc_unitdata_req_handler,	/* order of functions must not change */
+	llc_conn_req_handler,
+	llc_data_req_handler,
+	llc_disc_req_handler,
+	llc_rst_req_handler,
+	llc_flowcontrol_req_handler,
+	NULL,
+	llc_xid_req_handler,
+	llc_test_req_handler,
+};
+
+/* table of response handler functions */
+static llc_prim_call_t llc_resp_prim[LLC_NBR_PRIMITIVES] = {
+	llc_no_rsp_handler,     /* order of functions must not change */
+	llc_conn_rsp_handler,
+	llc_no_rsp_handler,
+	llc_no_rsp_handler,
+	llc_rst_rsp_handler,
+	llc_no_rsp_handler,
+};
+
+/**
+ *	llc_sap_open - open interface to the upper layers.
+ *	@nw_indicate: pointer to indicate function of upper layer.
+ *	@nw_confirm: pointer to confirm function of upper layer.
+ *	@local_sap: SAP number.
+ *	@sap: pointer to allocated SAP (output argument).
+ *
+ *	Interface function to upper layer. each one who wants to get a SAP
+ *	(for example NetBEUI) should call this function. Returns 0 for
+ *	success, 1 for failure.
+ */
+struct llc_sap *llc_sap_open(llc_prim_call_t nw_indicate,
+			     llc_prim_call_t nw_confirm, u8 local_sap)
+{
+	/* verify this SAP is not already open; if so, return error */
+	struct llc_sap *sap;
+
+	MOD_INC_USE_COUNT;
+	sap = llc_sap_find(local_sap);
+	if (sap) { /* SAP already exists */
+		sap = NULL;
+		goto err;
+	}
+	/* sap requested does not yet exist */
+	sap = llc_sap_alloc();
+	if (!sap)
+		goto err;
+	/* allocated a SAP; initialize it and clear out its memory pool */
+	sap->laddr.lsap = local_sap;
+	sap->req = llc_sap_req;
+	sap->resp = llc_sap_resp;
+	sap->ind = nw_indicate;
+	sap->conf = nw_confirm;
+	sap->parent_station = llc_station_get();
+	/* initialized SAP; add it to list of SAPs this station manages */
+	llc_sap_save(sap);
+	llc_register_sap(local_sap, mac_indicate);
+out:	return sap;
+err:	MOD_DEC_USE_COUNT;
+	goto out;
+}
+
+/**
+ *	llc_sap_close - close interface for upper layers.
+ *	@sap: SAP to be closed.
+ *
+ *	Close interface function to upper layer. each one who wants to
+ *	close an open SAP (for example NetBEUI) should call this function.
+ */
+void llc_sap_close(struct llc_sap *sap)
+{
+	llc_unregister_sap(sap->laddr.lsap);
+	llc_free_sap(sap);
+	MOD_DEC_USE_COUNT;
+}
+
+/**
+ *	llc_sap_req - Request interface for upper layers
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	Request interface function to upper layer. each one who wants to
+ *	request a service from LLC, must call this function. details of
+ *	requested service is defined in input argument(prim).  Returns 0 for
+ *	success, 1 otherwise.
+ */
+static int llc_sap_req(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+
+	if (prim->prim > 8 || prim->prim == 6) {
+		printk(KERN_ERR __FUNCTION__ ": invalid primitive %d\n",
+			prim->prim);
+		goto out;
+	}
+	/* receive REQUEST primitive from network layer; call the appropriate
+	 * primitive handler which then packages it up as an event and sends it
+	 * to the SAP or CONNECTION event handler */
+	if (prim->prim < LLC_NBR_PRIMITIVES)
+	       /* valid primitive; call the function to handle it */
+		rc = llc_req_prim[prim->prim](prim);
+out:	return rc;
+}
+
+/**
+ *	llc_unitdata_req_handler - unitdata request interface for upper layers
+ *	@prim: pointer to structure that contains service parameters
+ *
+ *	Upper layers calls this function when upper layer wants to send data
+ *	using connection-less mode communication (UI pdu). Returns 0 for
+ *	success, 1 otherwise.
+ */
+static int llc_unitdata_req_handler(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+	struct llc_sap_state_ev *ev;
+	/* accept data frame from network layer to be sent using connection-
+	 * less mode communication; timeout/retries handled by network layer;
+	 * package primitive as an event and send to SAP event handler */
+	struct llc_sap *sap = llc_sap_find(prim->data->udata.saddr.lsap);
+
+	if (!sap)
+		goto out;
+	ev = llc_sap_alloc_ev(sap);
+	if (!ev)
+		goto out;
+	ev->type	   = LLC_SAP_EV_TYPE_PRIM;
+	ev->data.prim.prim = LLC_DATAUNIT_PRIM;
+	ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+	ev->data.prim.data = prim;
+	rc = llc_sap_send_ev(sap, ev);
+out:	return rc;
+}
+
+/**
+ *	llc_test_req_handler - TEST interface for upper layers.
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	This function is called when upper layer wants to send a TEST pdu.
+ *	Returns 0 for success, 1 otherwise.
+ */
+static int llc_test_req_handler(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+	struct llc_sap_state_ev *ev;
+	/* package primitive as an event and send to SAP event handler */
+	struct llc_sap *sap = llc_sap_find(prim->data->udata.saddr.lsap);
+	if (!sap)
+		goto out;
+	ev = llc_sap_alloc_ev(sap);
+	if (!ev)
+		goto out;
+	ev->type	   = LLC_SAP_EV_TYPE_PRIM;
+	ev->data.prim.prim = LLC_TEST_PRIM;
+	if (prim->type)
+		ev->data.prim.type = prim->type;
+	else
+		ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+	ev->data.prim.data = prim;
+	rc = llc_sap_send_ev(sap, ev);
+out:	return rc;
+}
+
+/**
+ *	llc_xid_req_handler - XID interface for upper layers
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	This function is called when upper layer wants to send a XID pdu.
+ *	Returns 0 for success, 1 otherwise.
+ */
+static int llc_xid_req_handler(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+	struct llc_sap_state_ev *ev;
+	/* package primitive as an event and send to SAP event handler */
+	struct llc_sap *sap = llc_sap_find(prim->data->udata.saddr.lsap);
+
+	if (!sap) 
+		goto out;
+	ev = llc_sap_alloc_ev(sap);
+	if (!ev)
+		goto out;
+	ev->type	   = LLC_SAP_EV_TYPE_PRIM;
+	ev->data.prim.prim = LLC_XID_PRIM;
+	if (prim->type)
+                ev->data.prim.type = prim->type;
+        else
+                ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+	ev->data.prim.data = prim;
+	rc = llc_sap_send_ev(sap, ev);
+out:	return rc;
+}
+
+/**
+ *	llc_data_req_handler - Connection data sending for upper layers.
+ *	@prim: pointer to structure that contains service parameters
+ *
+ *	This function is called when upper layer wants to send data using
+ *	connection oriented communication mode. during sending data, connection
+ *	will be locked and received frames and expired timers will be queued.
+ *	Returns 0 for success, -ECONNABORTED when the connection already
+ *	closed. and -EBUSY when sending data is not permitted in this state or
+ *	LLC has send an I pdu with p bit set to 1 and is waiting for it's
+ *	response.
+ */
+static int llc_data_req_handler(struct llc_prim_if_block *prim)
+{
+	struct llc_conn_state_ev *ev;
+	int rc = -ECONNABORTED;
+	/* accept data frame from network layer to be sent using connection
+	 * mode communication; timeout/retries handled by this layer;
+	 * package primitive as an event and send to connection event handler */
+	struct sock *sk = prim->data->data.sk;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (llc->state == LLC_CONN_STATE_ADM)
+		goto out;
+	rc = -EBUSY;
+	if (llc_data_accept_state(llc->state)) {
+		/* data_conn_refuse */
+		llc->failed_data_req = 1;
+		goto out;
+	}
+	if (llc->p_flag) {
+		llc->failed_data_req = 1;
+		goto out;
+	}
+	rc = -ENOMEM;
+	ev = llc_conn_alloc_ev(sk);
+	if (ev) {
+		ev->type	   = LLC_CONN_EV_TYPE_PRIM;
+		ev->data.prim.prim = LLC_DATA_PRIM;
+		ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+		ev->data.prim.data = prim;
+		rc = llc_conn_send_ev(sk, ev);
+	}
+out:	return rc;
+}
+
+/**
+ *	confirm_impossible - Informs upper layer about failed connection
+ *	@prim: pointer to structure that contains confirmation data.
+ *
+ *	Informs upper layer about failing in connection establishment. This
+ *	function is called by llc_conn_req_handler.
+ */
+static void confirm_impossible(struct llc_prim_if_block *prim)
+{
+	prim->data->conn.status = LLC_STATUS_IMPOSSIBLE;
+	prim->sap->conf(prim);
+}
+
+/**
+ *	llc_conn_req_handler - Called by upper layer to establish a conn
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	Upper layer calls this to establish an LLC connection with a remote
+ *	machine. this function packages a proper event and sends it connection
+ *	component state machine.  Success or failure of connection
+ *	establishment will inform to upper layer via calling it's confirm
+ *	function and passing proper information.
+ */
+static int llc_conn_req_handler(struct llc_prim_if_block *prim)
+{
+	int rc = -EBUSY;
+	struct llc_opt *llc;
+	struct llc_sap *sap = prim->sap;
+	struct llc_conn_state_ev *ev;
+	/* network layer supplies addressing required to establish connection;
+	 * package as an event and send it to the connection event handler */
+	struct sock *sk = llc_find_conn(sap, &prim->data->conn.daddr,
+					&prim->data->conn.saddr);
+	if (sk) {
+		confirm_impossible(prim);
+		goto out;
+	}
+	if (prim->data->conn.sk) {
+		sk = prim->data->conn.sk;
+		llc_sock_init(sk);
+	} else {
+		sk = llc_sock_alloc();
+		rc = -ENOMEM;
+		if (!sk) {
+			confirm_impossible(prim);
+			goto out;
+		}
+		prim->data->conn.sk = sk;
+	}
+	sock_hold(sk);
+	/* assign new connection to it's SAP */
+	llc_sap_assign_sock(sap, sk);
+	llc = LLC_SK(sk);
+	memcpy(&llc->daddr, &prim->data->conn.daddr, sizeof(llc->daddr));
+	memcpy(&llc->laddr, &prim->data->conn.saddr, sizeof(llc->laddr));
+	llc->dev  = prim->data->conn.dev;
+	llc->link = prim->data->conn.link;
+	ev = llc_conn_alloc_ev(sk);
+	rc = -ENOMEM;
+	if (ev) {
+		ev->type	   = LLC_CONN_EV_TYPE_PRIM;
+		ev->data.prim.prim = LLC_CONN_PRIM;
+		ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+		ev->data.prim.data = prim;
+		rc = llc_conn_send_ev(sk, ev);
+	}
+	if (rc) {
+		llc_sap_unassign_sock(sap, sk);
+		llc_sock_free(sk);
+		confirm_impossible(prim);
+	}
+out:	sock_put(sk);
+	return rc;
+}
+
+/**
+ *	llc_disc_req_handler - Called by upper layer to close a connection
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	Upper layer calls this when it wants to close an established LLC
+ *	connection with a remote machine. this function packages a proper event
+ *	and sends it to connection component state machine. Returns 0 for
+ *	success, 1 otherwise.
+ */
+static int llc_disc_req_handler(struct llc_prim_if_block *prim)
+{
+	u16 rc = 1;
+	struct llc_conn_state_ev *ev;
+	struct sock* sk = prim->data->disc.sk;
+
+	if (LLC_SK(sk)->state == LLC_CONN_STATE_ADM ||
+	    LLC_SK(sk)->state == LLC_CONN_OUT_OF_SVC)
+		goto out;
+	/* postpone unassigning the connection from its SAP and returning the
+	 * connection until all ACTIONs have been completely executed */
+	ev = llc_conn_alloc_ev(sk);
+	if (!ev)
+		goto out;
+	ev->type = LLC_CONN_EV_TYPE_PRIM;
+	ev->data.prim.prim = LLC_DISC_PRIM;
+	ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+	ev->data.prim.data = prim;
+	rc = llc_conn_send_ev(sk, ev);
+out:	return rc;
+}
+
+/**
+ *	llc_rst_req_handler - Resets an established LLC connection
+ *	@prim: pointer to structure that contains service parameters.
+ *
+ *	Called when upper layer wants to reset an established LLC connection
+ *	with a remote machine. this function packages a proper event and sends
+ *	it to connection component state machine. Returns 0 for success, 1
+ *	otherwise.
+ */
+static int llc_rst_req_handler(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+	struct sock *sk = prim->data->res.sk;
+	struct llc_conn_state_ev *ev = llc_conn_alloc_ev(sk);
+
+	if (ev) {
+		ev->type = LLC_CONN_EV_TYPE_PRIM;
+		ev->data.prim.prim = LLC_RESET_PRIM;
+		ev->data.prim.type = LLC_PRIM_TYPE_REQ;
+		ev->data.prim.data = prim;
+		rc = llc_conn_send_ev(sk, ev);
+	}
+	return rc;
+}
+
+/* We don't support flow control. The original code from procom has
+ * some bits, but for now I'm cleaning this */
+static int llc_flowcontrol_req_handler(struct llc_prim_if_block *prim)
+{
+	return 1;
+}
+
+/**
+ *	llc_sap_resp - Sends response to peer
+ *	@prim: pointer to structure that contains service parameters
+ *
+ *	This function is a interface function to upper layer. each one who
+ *	wants to response to an indicate can call this function via calling
+ *	sap_resp with proper service parameters. Returns 0 for success, 1
+ *	otherwise.
+ */
+static int llc_sap_resp(struct llc_prim_if_block *prim)
+{
+	u16 rc = 1;
+	/* network layer RESPONSE primitive received; package primitive
+	 * as an event and send it to the connection event handler */
+	if (prim->prim < LLC_NBR_PRIMITIVES)
+	       /* valid primitive; call the function to handle it */
+		rc = llc_resp_prim[prim->prim](prim);
+	return rc;
+}
+
+/**
+ *	llc_conn_rsp_handler - Response to connect indication
+ *	@prim: pointer to structure that contains response info.
+ *
+ *	Response to connect indication.
+ */
+static int llc_conn_rsp_handler(struct llc_prim_if_block *prim)
+{
+	struct sock *sk = prim->data->conn.sk;
+
+	LLC_SK(sk)->link = prim->data->conn.link;
+	return 0;
+}
+
+/**
+ *	llc_rst_rsp_handler - Response to RESET indication
+ *	@prim: pointer to structure that contains response info
+ *
+ *	Returns 0 for success, 1 otherwise
+ */
+static int llc_rst_rsp_handler(struct llc_prim_if_block *prim)
+{
+	int rc = 1;
+	/* network layer supplies connection handle; map it to a connection;
+	 * package as event and send it to connection event handler */
+	struct sock *sk = prim->data->res.sk;
+	struct llc_conn_state_ev *ev = llc_conn_alloc_ev(sk);
+
+	if (ev) {
+		ev->type	   = LLC_CONN_EV_TYPE_PRIM;
+		ev->data.prim.prim = LLC_RESET_PRIM;
+		ev->data.prim.type = LLC_PRIM_TYPE_RESP;
+		ev->data.prim.data = prim;
+		rc = llc_conn_send_ev(sk, ev);
+	}
+	return rc;
+}
+
+static int llc_no_rsp_handler(struct llc_prim_if_block *prim)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(llc_sap_open);
+EXPORT_SYMBOL(llc_sap_close);
diff -ruN linux-2.4.18-clean/net/llc/llc_mac.c linux/net/llc/llc_mac.c
--- linux-2.4.18-clean/net/llc/llc_mac.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_mac.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,281 @@
+/*
+ * llc_mac.c - Manages interface between LLC and MAC
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#ifdef CONFIG_TR
+#include <linux/if_tr.h>
+#include <linux/trdevice.h>
+#endif
+#include <net/llc_if.h>
+#include <net/llc_mac.h>
+#include <net/llc_pdu.h>
+#include <net/llc_sap.h>
+#include <net/llc_conn.h>
+#include <net/sock.h>
+#include <net/llc_main.h>
+#include <net/llc_evnt.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_s_ev.h>
+
+/* function prototypes */
+static void fix_up_incoming_skb(struct sk_buff *skb);
+
+/**
+ *	mac_send_pdu - Sends PDU to specific device.
+ *	@skb: pdu which must be sent
+ *
+ *	If module is not initialized then returns failure, else figures out
+ *	where to direct this PDU. Sends PDU to specific device, at this point a
+ *	device must has been assigned to the PDU; If not, can't transmit the
+ *	PDU. PDU sent to MAC layer, is free to re-send at a later time. Returns
+ *	0 on success, 1 for failure.
+ */
+u16 mac_send_pdu(struct sk_buff *skb)
+{
+	struct sk_buff *skb2;
+	int pri = GFP_ATOMIC;
+
+	if (!skb->dev) {
+		printk(KERN_ERR __FUNCTION__ ": skb->dev == NULL!");
+		return -1;
+	}
+	if (skb->sk)
+		pri = (int)skb->sk->priority;
+	skb2 = skb_clone(skb, pri);
+	if (!skb2)
+		return -1;
+	dev_queue_xmit(skb2);
+	return 0;
+}
+
+/**
+ *	mac_indicate - 802.2 entry point from net lower layers
+ *	@skb: received pdu
+ *	@dev: device that receive pdu
+ *	@pt: packet type
+ *
+ *	When the system receives a 802.2 frame this function is called. It
+ *	checks SAP and connection of received pdu and passes frame to
+ *	llc_pdu_router for sending to proper state machine. If frame is
+ *	related to a busy connection (a connection is sending data now),
+ *	function queues this frame in connection's backlog.
+ */
+int mac_indicate(struct sk_buff *skb, struct net_device *dev,
+		 struct packet_type *pt)
+{
+	struct llc_sap *sap;
+	pdu_sn_t *pdu;
+	u8 dest;
+
+	/* When the interface is in promisc. mode, drop all the crap that it
+	   receives, do not try to analyse it. */
+	if (skb->pkt_type == PACKET_OTHERHOST)
+		goto drop;
+        skb = skb_share_check(skb, GFP_ATOMIC);
+        if (!skb)
+		goto out;
+	fix_up_incoming_skb(skb);
+	pdu = (pdu_sn_t *)skb->nh.raw;
+	if (!pdu->dsap) { /* NULL DSAP, refer to station */
+		llc_pdu_router(NULL, NULL, skb, 0);
+		goto out;
+	}
+	sap = llc_sap_find(pdu->dsap);
+	if (!sap) /* unknown SAP */
+		goto drop;
+	llc_decode_pdu_type(skb, &dest);
+	if (dest == LLC_DEST_SAP) /* type 1 services */
+		llc_pdu_router(sap, NULL, skb, LLC_TYPE_1);
+	else if (dest == LLC_DEST_CONN) {
+		struct llc_addr saddr, daddr;
+		struct sock *sk;
+
+		llc_pdu_decode_sa(skb, saddr.mac);
+		llc_pdu_decode_ssap(skb, &saddr.lsap);
+		llc_pdu_decode_da(skb, daddr.mac);
+		llc_pdu_decode_dsap(skb, &daddr.lsap);
+
+		sk = llc_find_conn(sap, &saddr, &daddr);
+		if (!sk) { /* didn't find an active connection; allocate a
+			      connection to use; associate it with this SAP */
+			sk = llc_sock_alloc();
+			if (!sk)
+				goto drop;
+			memcpy(&LLC_SK(sk)->daddr, &saddr, sizeof(saddr));
+			llc_sap_assign_sock(sap, sk);
+			sock_hold(sk);
+		}
+		bh_lock_sock(sk);
+		if (!sk->lock.users) {
+			/* FIXME: with the current code one cannot call
+			 * llc_pdu_router with the socket lock held, cause
+			 * it'll route the pdu to the upper layers and it can
+			 * reenter 802.2 and in Request_primitives will try to
+			 * grab the same lock, maybe we should use
+			 * spin_trylock_bh in the Request_primitives
+			 * (data_req_handler, etc) and add the request to the
+			 * backlog, well see... */
+			bh_unlock_sock(sk);
+			llc_pdu_router(LLC_SK(sk)->sap, sk, skb, LLC_TYPE_2);
+		} else {
+			skb->cb[0] = LLC_PACKET;
+			sk_add_backlog(sk, skb);
+			bh_unlock_sock(sk);
+		}
+		sock_put(sk);
+	} else /* unknown or not supported pdu */
+ 		goto drop;
+out:	return 0;
+drop:	kfree_skb(skb);
+	goto out;
+}
+
+/**
+ *	fix_up_incoming_skb - initializes skb pointers
+ *	@skb: This argument points to incoming skb
+ *
+ *	Initializes internal skb pointer to start of network layer by deriving
+ *	length of LLC header; finds length of LLC control field in LLC header
+ *	by looking at the two lowest-order bits of the first control field
+ *	byte; field is either 3 or 4 bytes long.
+ */
+static void fix_up_incoming_skb(struct sk_buff *skb)
+{
+	u8 llc_len = 2;
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->data;
+
+	if ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) == LLC_PDU_TYPE_U)
+		llc_len = 1;
+	llc_len += 2;
+	skb_pull(skb, llc_len);
+	if (skb->protocol == htons(ETH_P_802_2)) {
+		u16 pdulen = ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->lpdu_len,
+		    data_size = ntohs(pdulen) - llc_len;
+
+		skb_trim(skb, data_size);
+	}	
+}
+
+/**
+ *	llc_pdu_router - routes received pdus to the upper layers
+ *	@sap: current sap component structure.
+ *	@sk: current connection structure.
+ *	@frame: received frame.
+ *	@type: type of received frame, that is LLC_TYPE_1 or LLC_TYPE_2
+ *
+ *	Queues received PDUs from LLC_MAC PDU receive queue until queue is
+ *	empty; examines LLC header to determine the destination of PDU, if DSAP
+ *	is NULL then data unit destined for station else frame destined for SAP
+ *	or connection; finds a matching open SAP, if one, forwards the packet
+ *	to it; if no matching SAP, drops the packet. Returns 0 or the return of
+ *	llc_conn_send_ev (that may well result in the connection being
+ *	destroyed)
+ */
+int llc_pdu_router(struct llc_sap *sap, struct sock* sk,
+		   struct sk_buff *skb, u8 type)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+	int rc = 0;
+
+	if (!pdu->dsap) {
+		struct llc_station *station = llc_station_get();
+		struct llc_station_state_ev *stat_ev =
+						  llc_station_alloc_ev(station);
+		if (stat_ev) {
+			stat_ev->type = LLC_STATION_EV_TYPE_PDU;
+			stat_ev->data.pdu.skb = skb;
+			stat_ev->data.pdu.reason = 0;
+			llc_station_send_ev(station, stat_ev);
+		}
+	} else if (type == LLC_TYPE_1) {
+		struct llc_sap_state_ev *sap_ev = llc_sap_alloc_ev(sap);
+
+		if (sap_ev) {
+			sap_ev->type = LLC_SAP_EV_TYPE_PDU;
+			sap_ev->data.pdu.skb = skb;
+			sap_ev->data.pdu.reason = 0;
+			llc_sap_send_ev(sap, sap_ev);
+		}
+	} else if (type == LLC_TYPE_2) {
+		struct llc_conn_state_ev *conn_ev = llc_conn_alloc_ev(sk);
+
+		if (!LLC_SK(sk)->dev)
+			LLC_SK(sk)->dev = skb->dev;
+		if (conn_ev) {
+			conn_ev->type = LLC_CONN_EV_TYPE_PDU;
+			conn_ev->data.pdu.skb = skb;
+			conn_ev->data.pdu.reason = 0;
+			rc = llc_conn_send_ev(sk, conn_ev);
+		}
+	}
+	return rc;
+}
+
+/**
+ *	lan_hdrs_init - fills MAC header fields
+ *	@skb: Address of the frame to initialize its MAC header
+ *	@sa: The MAC source address
+ *	@da: The MAC destination address
+ *
+ *	Fills MAC header fields, depending on MAC type. Returns 0, If MAC type
+ *	is a valid type and initialization completes correctly 1, otherwise.
+ */
+u16 lan_hdrs_init(struct sk_buff *skb, u8 *sa, u8 *da)
+{
+	u8 *saddr;
+	u8 *daddr;
+	u16 rc = 0;
+	u16 lpdu_len;
+
+	switch (skb->dev->type) {
+#ifdef CONFIG_TR
+		case ARPHRD_IEEE802: {
+			token_ring_mac_hdr_t *trh = (token_ring_mac_hdr_t *)
+						    skb_push(skb, sizeof(*trh));
+			struct net_device *dev = skb->dev;
+
+			trh->ac = AC;
+			trh->fc = LLC_FRAME;
+			if (sa)
+				memcpy(trh->sa, sa, dev->addr_len);
+			else
+				memset(trh->sa, 0, dev->addr_len);
+			if (da) {
+				memcpy(trh->da, da, dev->addr_len);
+				tr_source_route(skb, (struct trh_hdr *)trh, dev);
+			}
+			skb->mac.raw = skb->data;
+			break;
+		}
+#endif
+		case ARPHRD_ETHER :
+		case ARPHRD_LOOPBACK :
+			lpdu_len = skb->len;
+			skb->mac.raw = skb_push(skb,
+						sizeof(ieee_802_3_mac_hdr_t));
+			memset(skb->mac.raw, 0, sizeof(ieee_802_3_mac_hdr_t));
+			((ieee_802_3_mac_hdr_t *)skb->mac.raw)->lpdu_len =
+				htons(lpdu_len);
+			daddr = ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->da;
+			saddr = ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->sa;
+			memcpy(daddr, da, MAC_ADDR_LEN);
+			memcpy(saddr, sa, MAC_ADDR_LEN);
+			break;
+		default:
+			printk(KERN_WARNING "Unknown DEVICE type : %d\n",
+			       skb->dev->type);
+			rc = 1;
+	}
+	return rc;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_main.c linux/net/llc/llc_main.c
--- linux-2.4.18-clean/net/llc/llc_main.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_main.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,607 @@
+/*
+ * llc_main.c - This module contains main functions to manage station, saps
+ * 	and connections of the LLC.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <net/sock.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_conn.h>
+#include <net/llc_main.h>
+#include <net/llc_evnt.h>
+#include <net/llc_actn.h>
+#include <net/llc_stat.h>
+#include <net/llc_c_ac.h>
+#include <net/llc_s_ac.h>
+#include <net/llc_c_ev.h>
+#include <net/llc_c_st.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_s_st.h>
+#include <net/llc_mac.h>
+#include <linux/llc.h>
+
+/* static function prototypes */
+static void llc_station_service_events(struct llc_station *station);
+static void llc_station_free_ev(struct llc_station *station,
+				struct llc_station_state_ev *ev);
+static void llc_station_send_pdus(struct llc_station *station);
+static u16 llc_station_next_state(struct llc_station *station,
+			      struct llc_station_state_ev *ev);
+static u16 llc_exec_station_trans_actions(struct llc_station *station,
+					  struct llc_station_state_trans *trans,
+					  struct llc_station_state_ev *ev);
+static struct llc_station_state_trans *
+			     llc_find_station_trans(struct llc_station *station,
+					       struct llc_station_state_ev *ev);
+static int llc_rtn_all_conns(struct llc_sap *sap);
+
+extern void llc_register_sap(unsigned char sap,
+                             int (*rcvfunc)(struct sk_buff *,
+                                            struct net_device *,
+                                            struct packet_type *));
+extern void llc_unregister_sap(unsigned char sap);
+
+static struct llc_station llc_main_station;	/* only one of its kind */
+struct llc_prim_if_block llc_ind_prim, llc_cfm_prim;
+static union llc_u_prim_data llc_ind_data_prim, llc_cfm_data_prim;
+
+/**
+ *	llc_sap_alloc - allocates and initializes sap.
+ *
+ *	Allocates and initializes sap.
+ */
+struct llc_sap *llc_sap_alloc(void)
+{
+	struct llc_sap *sap = kmalloc(sizeof(*sap), GFP_ATOMIC);
+
+	if (sap) {
+		memset(sap, 0, sizeof(*sap));
+		sap->state = LLC_SAP_STATE_ACTIVE;
+		memcpy(sap->laddr.mac, llc_main_station.mac_sa, MAC_ADDR_LEN);
+		spin_lock_init(&sap->sk_list.lock);
+		INIT_LIST_HEAD(&sap->sk_list.list);
+		skb_queue_head_init(&sap->mac_pdu_q);
+	}
+	return sap;
+}
+
+/**
+ *	llc_free_sap - frees a sap
+ *	@sap: Address of the sap
+ *
+ * 	Frees all associated connections (if any), removes this sap from
+ * 	the list of saps in te station and them frees the memory for this sap.
+ */
+void llc_free_sap(struct llc_sap *sap)
+{
+	struct llc_station *station = sap->parent_station;
+
+	llc_rtn_all_conns(sap);
+	spin_lock_bh(&station->sap_list.lock);
+	list_del(&sap->node);
+	spin_unlock_bh(&station->sap_list.lock);
+	kfree(sap);
+}
+
+/**
+ *	llc_sap_save - add sap to station list
+ *	@sap: Address of the sap
+ *
+ *	Adds a sap to the LLC's station sap list.
+ */
+void llc_sap_save(struct llc_sap *sap)
+{
+	spin_lock_bh(&llc_main_station.sap_list.lock);
+	list_add_tail(&sap->node, &llc_main_station.sap_list.list);
+	spin_unlock_bh(&llc_main_station.sap_list.lock);
+}
+
+/**
+ *	llc_sap_find - searchs a SAP in station
+ *	@sap_value: sap to be found
+ *
+ *	Searchs for a sap in the sap list of the LLC's station upon the sap ID.
+ *	Returns the sap or %NULL if not found.
+ */
+struct llc_sap *llc_sap_find(u8 sap_value)
+{
+	struct llc_sap* sap = NULL;
+	struct list_head *entry;
+
+	spin_lock_bh(&llc_main_station.sap_list.lock);
+	list_for_each(entry, &llc_main_station.sap_list.list) {
+		sap = list_entry(entry, struct llc_sap, node);
+		if (sap->laddr.lsap == sap_value)
+			break;
+	}
+        if (entry == &llc_main_station.sap_list.list) /* not found */
+		sap = NULL;
+	spin_unlock_bh(&llc_main_station.sap_list.lock);
+	return sap;
+}
+
+/**
+ *	llc_backlog_rcv - Processes rx frames and expired timers.
+ *	@sk: LLC sock (p8022 connection)
+ *	@skb: queued rx frame or event
+ *
+ *	This function processes frames that has received and timers that has
+ *	expired during sending an I pdu (refer to data_req_handler).  frames
+ *	queue by mac_indicate function (llc_mac.c) and timers queue by timer
+ *	callback functions(llc_c_ac.c).
+ */
+static int llc_backlog_rcv(struct sock *sk, struct sk_buff *skb)
+{
+	int rc = 0;
+	struct llc_opt *llc = LLC_SK(sk);
+
+	if (skb->cb[0] == LLC_PACKET) {
+		if (llc->state > 1) /* not closed */
+			rc = llc_pdu_router(llc->sap, sk, skb, LLC_TYPE_2);
+		else 
+			kfree_skb(skb);
+	} else if (skb->cb[0] == LLC_EVENT) {
+		struct llc_conn_state_ev *ev =
+					(struct llc_conn_state_ev *)skb->data;
+		/* timer expiration event */
+		if (llc->state > 1)  /* not closed */
+			rc = llc_conn_send_ev(sk, ev);
+		else
+			llc_conn_free_ev(ev);
+		kfree_skb(skb);
+	}
+	return rc;
+}
+/**
+ *     llc_sock_init - Initialize a socket with default llc values.
+ *     @sk: socket to intiailize.
+ */
+
+void llc_sock_init(struct sock* sk)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->state	= LLC_CONN_STATE_ADM;
+	llc->inc_cntr	= llc->dec_cntr = 2;
+	llc->dec_step	= llc->connect_step = 1;
+	llc->ack_timer.expire	      = LLC_ACK_TIME;
+	llc->pf_cycle_timer.expire    = LLC_P_TIME;
+	llc->rej_sent_timer.expire    = LLC_REJ_TIME;
+	llc->busy_state_timer.expire  = LLC_BUSY_TIME;
+	llc->n2	= 2;	/* max retransmit */
+	llc->k	= 2;	/* tx window size, will adjust dynam */
+	llc->rw	= 128;	/* rx window size (optional and equal to tx_window
+			   of remote LLC) */
+	skb_queue_head_init(&llc->pdu_unack_q);
+	sk->backlog_rcv = llc_backlog_rcv;
+}
+
+/**
+ *	__llc_sock_alloc - Allocates LLC sock
+ *
+ *	Allocates a LLC sock and initializes it. Returns the new LLC sock
+ *	or %NULL if there's no memory available for one
+ */
+struct sock *__llc_sock_alloc(void)
+{
+	struct sock *sk = sk_alloc(PF_LLC, GFP_ATOMIC, 1);
+
+	if (!sk)
+		goto out;
+	sock_init_data(NULL, sk);
+	llc_sock_init(sk);
+out:	return sk;
+}
+
+/**
+ *	__llc_sock_free - Frees a LLC socket
+ *	@sk - socket to free
+ *
+ *	Frees a LLC socket
+ */
+void __llc_sock_free(struct sock *sk, u8 free)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc->state = LLC_CONN_OUT_OF_SVC;
+	/* stop all (possibly) running timers */
+	llc_conn_ac_stop_all_timers(sk, NULL);
+	/* handle return of frames on lists */
+	skb_queue_purge(&sk->write_queue);
+	skb_queue_purge(&llc->pdu_unack_q);
+	if (free)
+		sock_put(sk);
+}
+
+/**
+ *	llc_sock_reset - resets a connection
+ *	@sk: LLC socket to reset
+ *
+ *	Resets a connection to the out of service state. Stops its timers
+ *	and frees any frames in the queues of the connection.
+ */
+void llc_sock_reset(struct sock *sk)
+{
+	struct llc_opt *llc = LLC_SK(sk);
+
+	llc_conn_ac_stop_all_timers(sk, NULL);
+	skb_queue_purge(&sk->write_queue);
+	skb_queue_purge(&llc->pdu_unack_q);
+	llc->remote_busy_flag	= 0;
+	llc->cause_flag		= 0;
+	llc->retry_count	= 0;
+	llc->p_flag		= 0;
+	llc->f_flag		= 0;
+	llc->s_flag		= 0;
+	llc->ack_pf		= 0;
+	llc->first_pdu_Ns	= 0;
+	llc->ack_must_be_send	= 0;
+	llc->dec_step		= 1;
+	llc->inc_cntr		= 2;
+	llc->dec_cntr		= 2;
+	llc->X			= 0;
+	llc->failed_data_req	= 0 ;
+	llc->last_nr		= 0;
+}
+
+/**
+ *	llc_rtn_all_conns - Closes all connections of a sap
+ *	@sap: sap to close its connections
+ *
+ *	Closes all connections of a sap. Returns 0 if all actions complete
+ *	successfully, nonzero otherwise
+ */
+static int llc_rtn_all_conns(struct llc_sap *sap)
+{
+	int rc = 0;
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+	struct list_head *entry, *tmp;
+
+	spin_lock_bh(&sap->sk_list.lock);
+	if (list_empty(&sap->sk_list.list))
+		goto out;
+	list_for_each_safe(entry, tmp, &sap->sk_list.list) {
+		struct sock *sk = sock_list_entry(entry, struct llc_opt, node);
+
+		prim.sap = sap;
+		prim_data.disc.sk = sk;
+		prim.prim = LLC_DISC_PRIM;
+		prim.data = &prim_data;
+		LLC_SK(sk)->state = LLC_CONN_STATE_TEMP;
+		if (sap->req(&prim))
+			rc = 1;
+	}
+out:	spin_unlock_bh(&sap->sk_list.lock);
+	return rc;
+}
+
+/**
+ *	llc_station_get - get addr of global station.
+ *
+ *	Returns address of a place to copy the global station to it.
+ */
+struct llc_station *llc_station_get(void)
+{
+	return &llc_main_station;
+}
+
+/**
+ *	llc_station_alloc_ev - allocates an event
+ *	@station: Address of the station
+ *
+ *	Allocates an event in this station. Returns the allocated event on
+ *	success, %NULL otherwise.
+ */
+struct llc_station_state_ev *llc_station_alloc_ev(struct llc_station *station)
+{
+	struct llc_station_state_ev *ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+
+	if (ev)
+		memset(ev, 0, sizeof(*ev));
+	return ev;
+}
+
+/**
+ *	llc_station_send_ev: queue event and try to process queue.
+ *	@station: Address of the station
+ *	@ev: Address of the event
+ *
+ *	Queues an event (on the station event queue) for handling by the
+ *	station state machine and attempts to process any queued-up events.
+ */
+void llc_station_send_ev(struct llc_station *station,
+			 struct llc_station_state_ev *ev)
+{
+	spin_lock_bh(&station->ev_q.lock);
+	list_add_tail(&ev->node, &station->ev_q.list);
+	llc_station_service_events(station);
+	spin_unlock_bh(&station->ev_q.lock);
+}
+
+/**
+ *	llc_station_send_pdu - queues PDU to send
+ *	@station: Address of the station
+ *	@skb: Address of the PDU
+ *
+ *	Queues a PDU to send to the MAC layer.
+ */
+void llc_station_send_pdu(struct llc_station *station, struct sk_buff *skb)
+{
+	skb_queue_tail(&station->mac_pdu_q, skb);
+	llc_station_send_pdus(station);
+}
+
+/**
+ *	llc_station_send_pdus - tries to send queued PDUs
+ *	@station: Address of the station
+ *
+ *	Tries to send any PDUs queued in the station mac_pdu_q to the MAC
+ *	layer.
+ */
+static void llc_station_send_pdus(struct llc_station *station)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&station->mac_pdu_q)) != NULL) {
+		int rc = mac_send_pdu(skb);
+
+		kfree_skb(skb);
+		if (rc)
+			break;
+	}
+}
+
+/**
+ *	llc_station_free_ev - frees an event
+ *	@station: Address of the station
+ *	@event: Address of the event
+ *
+ *	Frees an event.
+ */
+static void llc_station_free_ev(struct llc_station *station,
+			        struct llc_station_state_ev *ev)
+{
+	struct sk_buff *skb = ev->data.pdu.skb;
+
+	if (ev->type == LLC_STATION_EV_TYPE_PDU)
+		kfree_skb(skb);
+	kfree(ev);
+}
+
+/**
+ *	llc_station_service_events - service events in the queue
+ *	@station: Address of the station
+ *
+ *	Get an event from the station event queue (if any); attempt to service
+ *	the event; if event serviced, get the next event (if any) on the event
+ *	queue; if event not service, re-queue the event on the event queue and
+ *	attempt to service the next event; when serviced all events in queue,
+ *	finished; if don't transition to different state, just service all
+ *	events once; if transition to new state, service all events again.
+ *	Caller must hold station->ev_q.lock.
+ */
+static void llc_station_service_events(struct llc_station *station)
+{
+	struct llc_station_state_ev *ev;
+	struct list_head *entry, *tmp;
+
+	list_for_each_safe(entry, tmp, &station->ev_q.list) {
+		ev = list_entry(entry, struct llc_station_state_ev, node);
+		list_del(&ev->node);
+		llc_station_next_state(station, ev);
+	}
+}
+
+/**
+ *	llc_station_next_state - processes event and goes to the next state
+ *	@station: Address of the station
+ *	@ev: Address of the event
+ *
+ *	Processes an event, executes any transitions related to that event and
+ *	updates the state of the station.
+ */
+static u16 llc_station_next_state(struct llc_station *station,
+			      struct llc_station_state_ev *ev)
+{
+	u16 rc = 1;
+	struct llc_station_state_trans *trans;
+
+	if (station->state > LLC_NBR_STATION_STATES)
+		goto out;
+	trans = llc_find_station_trans(station, ev);
+	if (trans) {
+		/* got the state to which we next transition; perform the
+		 * actions associated with this transition before actually
+		 * transitioning to the next state */
+		rc = llc_exec_station_trans_actions(station, trans, ev);
+		if (!rc)
+			/* transition station to next state if all actions
+			 * execute successfully; done; wait for next event */
+			station->state = trans->next_state;
+	} else
+		/* event not recognized in current state; re-queue it for
+		 * processing again at a later time; return failure */
+		rc = 0;
+out:	llc_station_free_ev(station, ev);
+	return rc;
+}
+
+/**
+ *	llc_find_station_trans - finds transition for this event
+ *	@station: Address of the station
+ *	@ev: Address of the event
+ *
+ *	Search thru events of the current state of the station until list
+ *	exhausted or it's obvious that the event is not valid for the current
+ *	state. Returns the address of the transition if cound, %NULL otherwise.
+ */
+static struct llc_station_state_trans *
+	llc_find_station_trans(struct llc_station *station,
+				struct llc_station_state_ev *ev)
+{
+	u16 i;
+	struct llc_station_state_trans **next_trans;
+	struct llc_station_state *curr_state =
+				&llc_station_state_table[station->state - 1];
+
+	for (i = 0, next_trans = curr_state->transitions;
+	     next_trans[i]->ev; i++)
+		if (!next_trans[i]->ev(station, ev))
+			return next_trans[i];
+	return NULL;
+}
+
+/**
+ *	llc_exec_station_trans_actions - executes actions for transition
+ *	@station: Address of the station
+ *	@trans: Address of the transition
+ *	@ev: Address of the event that caused the transition
+ *
+ *	Executes actions of a transition of the station state machine. Returns
+ *	0 if all actions complete successfully, nonzero otherwise.
+ */
+static u16 llc_exec_station_trans_actions(struct llc_station *station,
+					  struct llc_station_state_trans *trans,
+					  struct llc_station_state_ev *ev)
+{
+	u16 rc = 0;
+	llc_station_action_t *next_action;
+
+	for (next_action = trans->ev_actions;
+	     next_action && *next_action; next_action++)
+		if ((*next_action)(station, ev))
+			rc = 1;
+	return rc;
+}
+
+/**
+ *	llc_alloc_frame - allocates sk_buff for frame
+ *
+ *	Allocates an sk_buff for frame and initializes sk_buff fields.
+ *	Returns allocated skb or %NULL when out of memory.
+ */
+struct sk_buff *llc_alloc_frame(void)
+{
+	struct sk_buff *skb = alloc_skb(128, GFP_ATOMIC);
+
+	if (skb) {
+		skb_reserve(skb, 50);
+		skb->nh.raw   = skb->h.raw = skb->data;
+		skb->protocol = htons(ETH_P_802_2);
+		skb->dev      = dev_base->next;
+		skb->mac.raw  = skb->head;
+	}
+	return skb;
+}
+
+static int llc_proc_get_info(char *bf, char **start, off_t offset, int length)
+{
+	struct llc_opt *llc;
+	struct list_head *sap_entry, *llc_entry;
+	off_t begin = 0, pos = 0;
+	int len = 0;
+
+	spin_lock_bh(&llc_main_station.sap_list.lock);
+	list_for_each(sap_entry, &llc_main_station.sap_list.list) {
+		struct llc_sap *sap = list_entry(sap_entry, struct llc_sap,
+						 node);
+
+		len += sprintf(bf + len, "lsap=%d\n", sap->laddr.lsap);
+		spin_lock_bh(&sap->sk_list.lock);
+		if (list_empty(&sap->sk_list.list)) {
+			len += sprintf(bf + len, "no connections\n");
+			goto unlock;
+		}
+		len += sprintf(bf + len,
+				"connection list:\nstate  retries\n");
+		list_for_each(llc_entry, &sap->sk_list.list) {
+			llc = list_entry(llc_entry, struct llc_opt, node);
+			len += sprintf(bf + len, "  %-5d%-8d\n",
+					llc->state, llc->retry_count);
+		}
+unlock:		spin_unlock_bh(&sap->sk_list.lock);
+                pos = begin + len;
+                if (pos < offset) {
+                        len = 0; /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length) /* We have dumped enough */
+                        break;
+	}
+	spin_unlock_bh(&llc_main_station.sap_list.lock);
+
+	/* The data in question runs from begin to begin + len */
+	*start = bf + (offset - begin); /* Start of wanted data */
+	len -= (offset - begin); /* Remove unwanted header data from length */
+	return len;
+}
+
+const char banner[] __initdata =
+		KERN_INFO "LLC 2.0 by Procom, 1997, Arnaldo C. Melo, 2001\n"
+		KERN_INFO "NET4.0 IEEE 802.2 extended support\n";
+const char err_llc[] __initdata = KERN_ERR "LLC installation NOT successful.\n";
+
+static int __init llc_init(void)
+{
+	u16 rc = 0;
+	struct llc_station_state_ev *ev;
+
+	printk(banner);
+	INIT_LIST_HEAD(&llc_main_station.ev_q.list);
+	spin_lock_init(&llc_main_station.ev_q.lock);
+	INIT_LIST_HEAD(&llc_main_station.sap_list.list);
+	spin_lock_init(&llc_main_station.sap_list.lock);
+	skb_queue_head_init(&llc_main_station.mac_pdu_q);
+	ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+	if (!ev)
+		goto err;
+	memset(ev, 0, sizeof(*ev));
+	memcpy(llc_main_station.mac_sa, dev_base->next->dev_addr, MAC_ADDR_LEN);
+	llc_main_station.ack_timer.expires = jiffies + 3 * HZ;
+	/* initialize the station component */
+	llc_register_sap(0, mac_indicate);
+	llc_main_station.maximum_retry = 1;
+	llc_main_station.state = LLC_STATION_STATE_DOWN;
+	ev->type = LLC_STATION_EV_TYPE_SIMPLE;
+	ev->data.a.ev = LLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK;
+	rc = llc_station_next_state(&llc_main_station, ev);
+	llc_build_offset_table();
+	llc_ind_prim.data = &llc_ind_data_prim;
+	llc_cfm_prim.data = &llc_cfm_data_prim;
+	proc_net_create("802.2", 0, llc_proc_get_info);
+#ifdef CONFIG_LLC_UI
+	llc_ui_init();
+#endif
+out:	return rc;
+err:	printk(err_llc);
+	rc = 1;
+	goto out;
+}
+
+static void __exit llc_exit(void)
+{
+#ifdef CONFIG_LLC_UI
+	llc_ui_exit();
+#endif
+	llc_unregister_sap(0);
+	proc_net_remove("802.2");
+}
+
+module_init(llc_init);
+module_exit(llc_exit);
diff -ruN linux-2.4.18-clean/net/llc/llc_pdu.c linux/net/llc/llc_pdu.c
--- linux-2.4.18-clean/net/llc/llc_pdu.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_pdu.c	Sat Jun  8 01:54:08 2002
@@ -0,0 +1,648 @@
+/*
+ * llc_pdu.c - access to PDU internals
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <net/llc_pdu.h>
+#include <net/llc_if.h>
+#include <net/llc_mac.h>
+#include <net/llc_main.h>
+
+static int llc_pdu_decode_pdu_type(struct sk_buff *skb, u8 *type);
+static int llc_get_llc_hdr_length(u8 pdu_type);
+static u8 llc_pdu_get_pf_bit(pdu_sn_t *pdu);
+
+/**
+ *	llc_pdu_header_init - initializes pdu header
+ *	@skb: input skb that header must be set into it.
+ *	@pdu_type: type of PDU (U, I or S).
+ *	@ssap: source sap.
+ *	@dsap: destination sap.
+ *	@cr: command/response bit (0 or 1).
+ *
+ *	This function sets DSAP, SSAP and command/Response bit in LLC header.
+ */
+void llc_pdu_header_init(struct sk_buff *skb, u8 pdu_type, u8 ssap,
+			 u8 dsap, u8 cr)
+{
+	pdu_un_t *p;
+
+	skb->nh.raw = skb_push(skb, llc_get_llc_hdr_length(pdu_type));
+	p = (pdu_un_t *)skb->nh.raw;
+	p->dsap = dsap;
+	p->ssap = ssap;
+	p->ssap |= cr;
+}
+
+void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 pdu_type)
+{
+	((pdu_un_t *)skb->nh.raw)->ssap |= pdu_type;
+}
+
+/**
+ *	pdu_set_pf_bit - sets poll/final bit in LLC header
+ *	@pdu_frame: input frame that p/f bit must be set into it.
+ *	@bit_value: poll/final bit (0 or 1).
+ *
+ *	This function sets poll/final bit in LLC header (based on type of PDU).
+ *	in I or S pdus, p/f bit is right bit of fourth byte in header. in U
+ *	pdus p/f bit is fifth bit of third byte.
+ */
+void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value)
+{
+	u8 pdu_type;
+
+	if (llc_pdu_decode_pdu_type(skb, &pdu_type))
+		goto out;
+	switch (pdu_type) {
+		case LLC_PDU_TYPE_I:
+		case LLC_PDU_TYPE_S:
+			((pdu_sn_t *)skb->nh.raw)->ctrl_2 =
+				(((pdu_sn_t *)skb->nh.raw)->ctrl_2 & 0xFE) |
+				bit_value;
+			break;
+		case LLC_PDU_TYPE_U:
+			((pdu_un_t *)skb->nh.raw)->ctrl_1 |=
+				(((pdu_un_t *)skb->nh.raw)->ctrl_1 & 0xEF) |
+				(bit_value << 4);
+			break;
+	}
+out:;
+}
+
+/**
+ *	llc_pdu_decode_pf_bit - extracs poll/final bit from LLC header
+ *	@skb: input skb that p/f bit must be extracted from it
+ *	@pf_bit: poll/final bit (0 or 1)
+ *
+ *	This function extracts poll/final bit from LLC header (based on type of
+ *	PDU). In I or S pdus, p/f bit is right bit of fourth byte in header. In
+ *	U pdus p/f bit is fifth bit of third byte.
+ */
+int llc_pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit)
+{
+	u8 pdu_type;
+	int rc = llc_pdu_decode_pdu_type(skb, &pdu_type);
+
+	if (rc)
+		goto out;
+	switch (pdu_type) {
+		case LLC_PDU_TYPE_I:
+		case LLC_PDU_TYPE_S:
+			*pf_bit = ((pdu_sn_t *)skb->nh.raw)->ctrl_2 &
+				  LLC_S_PF_BIT_MASK;
+			break;
+		case LLC_PDU_TYPE_U:
+			*pf_bit = (((pdu_un_t *)skb->nh.raw)->ctrl_1 &
+				  LLC_U_PF_BIT_MASK) >> 4;
+			break;
+	}
+out:	return 0;
+}
+
+/**
+ *	llc_pdu_decode_cr_bit - extracs command response bit from LLC header
+ *	@skb: input skb that c/r bit must be extracted from it.
+ *	@cr_bit: command/response bit (0 or 1).
+ *
+ *	This function extracts command/response bit from LLC header. this bit
+ *	is right bit of source SAP.
+ */
+int llc_pdu_decode_cr_bit(struct sk_buff *skb, u8 *cr_bit)
+{
+	*cr_bit = ((pdu_un_t *)skb->nh.raw)->ssap & LLC_PDU_CMD_RSP_MASK;
+	return 0;
+}
+
+/**
+ *	llc_pdu_decode_sa - extracs source address (MAC) of input frame
+ *	@skb: input skb that source address must be extracted from it.
+ *	@sa: pointer to source address (6 byte array).
+ *
+ *	This function extracts source address(MAC) of input frame.
+ */
+int llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
+{
+	if (skb->protocol == ntohs(ETH_P_802_2))
+		memcpy(sa, ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->sa,
+		       MAC_ADDR_LEN);
+	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+		memcpy(sa, ((token_ring_mac_hdr_t *)skb->mac.raw)->sa,
+		       MAC_ADDR_LEN);
+	return 0;
+}
+
+/**
+ *	llc_pdu_decode_da - extracts dest address of input frame
+ *	@skb: input skb that destination address must be extracted from it
+ *	@sa: pointer to destination address (6 byte array).
+ *
+ *	This function extracts destination address(MAC) of input frame.
+ */
+int llc_pdu_decode_da(struct sk_buff *skb, u8 *da)
+{
+	if (skb->protocol == ntohs(ETH_P_802_2))
+		memcpy(da, ((ieee_802_3_mac_hdr_t *)skb->mac.raw)->da,
+		       MAC_ADDR_LEN);
+	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+		memcpy(da, ((token_ring_mac_hdr_t *)skb->mac.raw)->da,
+		       MAC_ADDR_LEN);
+	return 0;
+}
+
+/**
+ *	llc_pdu_decode_dsap - extracts dest SAP of input frame
+ *	@skb: input skb that destination SAP must be extracted from it.
+ *	@dsap: destination SAP (output argument).
+ *
+ *	This function extracts destination SAP of input frame. right bit of
+ *	DSAP designates individual/group SAP.
+ */
+int llc_pdu_decode_dsap(struct sk_buff *skb, u8 *dsap)
+{
+	*dsap = ((pdu_un_t *)skb->nh.raw)->dsap & 0xFE;
+	return 0;
+}
+
+/**
+ *	llc_pdu_decode_ssap - extracts source SAP of input frame
+ *	@skb: input skb that source SAP must be extracted from it.
+ *	@ssap: source SAP (output argument).
+ *
+ *	This function extracts source SAP of input frame. right bit of SSAP is
+ *	command/response bit.
+ */
+int llc_pdu_decode_ssap(struct sk_buff *skb, u8 *ssap)
+{
+	*ssap = ((pdu_un_t *)skb->nh.raw)->ssap & 0xFE;
+	return 0;
+}
+
+/**
+ *	llc_pdu_init_as_ui_cmd - sets LLC header as UI PDU
+ *	@skb: input skb that header must be set into it.
+ *
+ *	This function sets third byte of LLC header as a UI PDU.
+ */
+int llc_pdu_init_as_ui_cmd(struct sk_buff *skb)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_UI;
+	return 0;
+}
+
+/**
+ *	llc_pdu_init_as_xid_cmd - sets bytes 3, 4 & 5 of LLC header as XID
+ *	@skb: input skb that header must be set into it.
+ *
+ *	This function sets third,fourth,fifth and sixth bytes of LLC header as
+ *	a XID PDU.
+ */
+int llc_pdu_init_as_xid_cmd(struct sk_buff *skb, u8 svcs_supported,
+			    u8 rx_window)
+{
+	xid_info_t *xid_info;
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_XID;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+	xid_info = (xid_info_t *)(((u8 *)&pdu->ctrl_1) + 1);
+	xid_info->fmt_id = XID_FMT_ID;    /* 0x81*/
+	xid_info->type = svcs_supported;
+	xid_info->rw = (rx_window << 1);  /* size of recieve window */
+	return 0;
+}
+
+/**
+ *	llc_pdu_init_as_test_cmd - sets PDU as TEST
+ *	@skb - Address of the skb to build
+ *
+ * 	Sets a PDU as TEST
+ */
+int llc_pdu_init_as_test_cmd(struct sk_buff *skb)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+	return 0;
+}
+
+/**
+ *	llc_pdu_init_as_disc_cmd - Builds DISC PDU
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *
+ *	Builds a pdu frame as a DISC command.
+ */
+int llc_pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_2_PDU_CMD_DISC;
+	pdu->ctrl_1 |= (((p_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+	return 0;
+}
+
+/**
+ *	pdu_init_as_i_cmd - builds I pdu
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *	@ns: The sequence number of the data PDU
+ *	@nr: The seq. number of the expected I PDU from the remote
+ *
+ *	Builds a pdu frame as an I command.
+ */
+int llc_pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_I;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (p_bit & LLC_I_PF_BIT_MASK); /* p/f bit */
+	pdu->ctrl_1 |= ((ns << 1) & 0xFE);   /* set N(S) in bits 2..8 */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE);   /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rej_cmd - builds REJ PDU
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *	@nr: The seq. number of the expected I PDU from the remote
+ *
+ *	Builds a pdu frame as a REJ command.
+ */
+int llc_pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_CMD_REJ;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (p_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE); /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rnr_cmd - builds RNR pdu
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *	@nr: The seq. number of the expected I PDU from the remote
+ *
+ *	Builds a pdu frame as an RNR command.
+ */
+int llc_pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_CMD_RNR;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (p_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE); /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rr_cmd - Builds RR pdu
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *	@nr: The seq. number of the expected I PDU from the remote
+ *
+ *	Builds a pdu frame as an RR command.
+ */
+int llc_pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_CMD_RR;
+	pdu->ctrl_2 = (p_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE); /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_sabme_cmd - builds SABME pdu
+ *	@skb: Address of the skb to build
+ *	@p_bit: The P bit to set in the PDU
+ *
+ *	Builds a pdu frame as an SABME command.
+ */
+int llc_pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_2_PDU_CMD_SABME;
+	pdu->ctrl_1 |= (((p_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+	return 0;
+}
+
+/**
+ *	pdu_init_as_dm_rsp - builds DM response pdu
+ *	@skb: Address of the skb to build
+ *	@f_bit: The F bit to set in the PDU
+ *
+ *	Builds a pdu frame as a DM response.
+ */
+int llc_pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_DM;
+	pdu->ctrl_1 |= (((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+	return 0;
+}
+
+/**
+ *	pdu_init_as_xid_rsp - builds XID response PDU
+ *	@skb: Address of the skb to build
+ *	@svcs_supported: The class of the LLC (I or II)
+ *	@rx_window: The size of the receive window of the LLC
+ *
+ *	Builds a pdu frame as an XID response.
+ */
+int llc_pdu_init_as_xid_rsp(struct sk_buff *skb, u8 svcs_supported, u8 rx_window)
+{
+	xid_info_t *xid_info;
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_XID;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+
+	xid_info = (xid_info_t *)(((u8 *)&pdu->ctrl_1) + 1);
+	xid_info->fmt_id = XID_FMT_ID;
+	xid_info->type = svcs_supported;
+	xid_info->rw = rx_window << 1;
+	return 0;
+}
+
+/**
+ *	pdu_init_as_test_rsp - build TEST response PDU
+ *	@skb: Address of the skb to build
+ *
+ *	Builds a pdu frame as a TEST response.
+ */
+int llc_pdu_init_as_test_rsp(struct sk_buff *skb)
+{
+	int data_size = 0;
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+	return 0;
+}
+
+/**
+ *	pdu_init_as_frmr_rsp - builds FRMR response PDU
+ *	@pdu_frame: Address of the frame to build
+ *	@prev_pdu: The rejected PDU frame
+ *	@f_bit: The F bit to set in the PDU
+ *	@vs: tx state vari value for the data link conn at the rejecting LLC
+ *	@vr: rx state var value for the data link conn at the rejecting LLC
+ *	@vzyxw: completely described in the IEEE Std 802.2 document (Pg 55)
+ *
+ *	Builds a pdu frame as a FRMR response.
+ */
+int llc_pdu_init_as_frmr_rsp(struct sk_buff *skb, pdu_sn_t *prev_pdu, u8 f_bit,
+			 u8 vs, u8 vr, u8 vzyxw)
+{
+	frmr_info_t *frmr_info;
+	u8 prev_pf = 0;
+	u8 *ctrl;
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_FRMR;
+	pdu->ctrl_1 |= ((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK;
+
+	frmr_info = (frmr_info_t *)&pdu->ctrl_2;
+	ctrl = (u8 *)&prev_pdu->ctrl_1;
+	FRMR_INFO_SET_REJ_CNTRL(frmr_info,ctrl);
+	FRMR_INFO_SET_Vs(frmr_info, vs);
+	FRMR_INFO_SET_Vr(frmr_info, vr);
+	prev_pf = llc_pdu_get_pf_bit(prev_pdu);
+	FRMR_INFO_SET_C_R_BIT(frmr_info, prev_pf);
+	FRMR_INFO_SET_INVALID_PDU_CTRL_IND(frmr_info, vzyxw);
+	FRMR_INFO_SET_INVALID_PDU_INFO_IND(frmr_info, vzyxw);
+	FRMR_INFO_SET_PDU_INFO_2LONG_IND(frmr_info, vzyxw);
+	FRMR_INFO_SET_PDU_INVALID_Nr_IND(frmr_info, vzyxw);
+	FRMR_INFO_SET_PDU_INVALID_Ns_IND(frmr_info, vzyxw);
+	skb_put(skb, 5);
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rr_rsp - builds RR response pdu
+ *	@skb: Address of the skb to build
+ *	@f_bit: The F bit to set in the PDU
+ *	@nr: The seq. number of the expected data PDU from the remote
+ *
+ *	Builds a pdu frame as an RR response.
+ */
+int llc_pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_RR;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rej_rsp - builds REJ response pdu
+ *	@skb: Address of the skb to build
+ *	@f_bit: The F bit to set in the PDU
+ *	@nr: The seq. number of the expected data PDU from the remote
+ *
+ *	Builds a pdu frame as a REJ response.
+ */
+int llc_pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_REJ;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_rnr_rsp - builds RNR response pdu
+ *	@pdu_frame: Address of the frame to build
+ *	@f_bit: The F bit to set in the PDU
+ *	@nr: The seq. number of the expected data PDU from the remote
+ *
+ *	Builds a pdu frame as an RNR response.
+ */
+int llc_pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr)
+{
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_S;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_RNR;
+	pdu->ctrl_2 = 0;
+	pdu->ctrl_2 |= (f_bit & LLC_S_PF_BIT_MASK);
+	pdu->ctrl_1 &= 0x0F;    /* setting bits 5..8 to zero(reserved) */
+	pdu->ctrl_2 |= ((nr << 1) & 0xFE);  /* set N(R) in bits 10..16 */
+	return 0;
+}
+
+/**
+ *	pdu_init_as_ua_rsp - builds UA response pdu
+ *	@skb: Address of the frame to build
+ *	@f_bit: The F bit to set in the PDU
+ *	
+ *	Builds a pdu frame as a UA response.
+ */
+int llc_pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	pdu->ctrl_1 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_2_PDU_RSP_UA;
+	pdu->ctrl_1 |= (((f_bit & 1) << 4) & LLC_U_PF_BIT_MASK);
+	return 0;
+}
+
+/**
+ *	llc_pdu_decode_pdu_type - designates PDU type
+ *	@skb: input skb that type of it must be designated.
+ *	@type: type of PDU (output argument).
+ *
+ *	This function designates type of PDU (I,S or U).
+ */
+static int llc_pdu_decode_pdu_type(struct sk_buff *skb, u8 *type)
+{
+	pdu_un_t *pdu = (pdu_un_t *)skb->nh.raw;
+
+	if (pdu->ctrl_1 & 1) {
+		if ((pdu->ctrl_1 & LLC_PDU_TYPE_U) == LLC_PDU_TYPE_U)
+			*type = LLC_PDU_TYPE_U;
+		else
+			*type = LLC_PDU_TYPE_S;
+	} else
+		*type = LLC_PDU_TYPE_I;
+	return 0;
+}
+
+/**
+ *	llc_decode_pdu_type - designates component LLC must handle for PDU
+ *	@skb: input skb
+ *	@dest: destination component
+ *
+ *	This function designates which component of LLC must handle this PDU.
+ */
+int llc_decode_pdu_type(struct sk_buff *skb, u8 *dest)
+{
+	u8 type = LLC_DEST_CONN; /* I-PDU or S-PDU type */
+	pdu_sn_t *pdu = (pdu_sn_t *)skb->nh.raw;
+
+	if ((pdu->ctrl_1 & LLC_PDU_TYPE_MASK) != LLC_PDU_TYPE_U)
+		goto out;
+	switch (LLC_U_PDU_CMD(pdu)) {
+		case LLC_1_PDU_CMD_XID:
+		case LLC_1_PDU_CMD_UI:
+		case LLC_1_PDU_CMD_TEST:
+			type = LLC_DEST_SAP;
+			break;
+		case LLC_2_PDU_CMD_SABME:
+		case LLC_2_PDU_CMD_DISC:
+		case LLC_2_PDU_RSP_UA:
+		case LLC_2_PDU_RSP_DM:
+		case LLC_2_PDU_RSP_FRMR:
+			break;
+		default:
+			type = LLC_DEST_INVALID;
+			break;
+	}
+out:	*dest = type;
+	return 0;
+}
+
+/**
+ *	get_llc_hdr_len - designates LLC header length
+ *	@pdu_type: type of PDU.
+ *
+ *	This function designates LLC header length of PDU. header length for I
+ *	and S PDU is 4 and for U is 3 bytes. Returns the length of header.
+ */
+static int llc_get_llc_hdr_length(u8 pdu_type)
+{
+	int rtn_val = 0;
+
+	switch (pdu_type) {
+		case LLC_PDU_TYPE_I:
+		case LLC_PDU_TYPE_S:
+			rtn_val = 4;
+			break;
+		case LLC_PDU_TYPE_U:
+			rtn_val = 3;
+			break;
+		case LLC_PDU_TYPE_XID:
+			rtn_val = 6;
+			break;
+	}
+	return rtn_val;
+}
+
+/**
+ *	llc_pdu_get_pf_bit - extracts p/f bit of input PDU
+ *	@pdu: pointer to LLC header.
+ *
+ *	This function extracts p/f bit of input PDU. at first examines type of
+ *	PDU and then extracts p/f bit. Returns the p/f bit.
+ */
+static u8 llc_pdu_get_pf_bit(pdu_sn_t *pdu)
+{
+	u8 pdu_type;
+	u8 pf_bit = 0;
+
+	if (pdu->ctrl_1 & 1) {
+		if ((pdu->ctrl_1 & LLC_PDU_TYPE_U) == LLC_PDU_TYPE_U)
+			pdu_type = LLC_PDU_TYPE_U;
+		else
+			pdu_type = LLC_PDU_TYPE_S;
+	} else
+		pdu_type = LLC_PDU_TYPE_I;
+	switch (pdu_type) {
+		case LLC_PDU_TYPE_I:
+		case LLC_PDU_TYPE_S:
+			pf_bit = pdu->ctrl_2 & LLC_S_PF_BIT_MASK;
+			break;
+		case LLC_PDU_TYPE_U:
+			pf_bit = (pdu->ctrl_1 & LLC_U_PF_BIT_MASK) >> 4;
+			break;
+	}
+	return pf_bit;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_s_ac.c linux/net/llc/llc_s_ac.c
--- linux-2.4.18-clean/net/llc/llc_s_ac.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_s_ac.c	Fri Jun  7 17:27:50 2002
@@ -0,0 +1,262 @@
+/*
+ * llc_s_ac.c - actions performed during sap state transition.
+ *
+ * Description :
+ *   Functions in this module are implementation of sap component actions.
+ *   Details of actions can be found in IEEE-802.2 standard document.
+ *   All functions have one sap and one event as input argument. All of
+ *   them return 0 On success and 1 otherwise.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netdevice.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_main.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_pdu.h>
+#include <net/llc_mac.h>
+
+/**
+ *	llc_sap_action_unit_data_ind - forward UI PDU to network layer
+ *	@sap: SAP
+ *	@ev: the event to forward
+ *
+ *	Received a UI PDU from MAC layer; forward to network layer as a
+ *	UNITDATA INDICATION; verify our event is the kind we expect
+ */
+int llc_sap_action_unitdata_ind(struct llc_sap *sap,
+				struct llc_sap_state_ev *ev)
+{
+	llc_sap_rtn_pdu(sap, ev->data.pdu.skb, ev);
+	return 0;
+}
+
+/**
+ *	llc_sap_action_send_ui - sends UI PDU resp to UNITDATA REQ to MAC layer
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Sends a UI PDU to the MAC layer in response to a UNITDATA REQUEST
+ *	primitive from the network layer. Verifies event is a primitive type of
+ *	event. Verify the primitive is a UNITDATA REQUEST.
+ */
+int llc_sap_action_send_ui(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = ev->data.prim.data;
+	struct llc_prim_unit_data *prim_data = &prim->data->udata;
+	struct sk_buff *skb = prim->data->udata.skb;
+	int rc;
+	
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, prim_data->saddr.lsap,
+			    prim_data->daddr.lsap, LLC_PDU_CMD);
+	rc = llc_pdu_init_as_ui_cmd(skb);
+	if (rc)
+		goto out;
+	rc = lan_hdrs_init(skb, prim_data->saddr.mac, prim_data->daddr.mac);
+	if (!rc)
+		llc_sap_send_pdu(sap, skb);
+out:	return rc;
+}
+
+/**
+ *	llc_sap_action_send_xid_c - send XID PDU as response to XID REQ
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Send a XID command PDU to MAC layer in response to a XID REQUEST
+ *	primitive from the network layer. Verify event is a primitive type
+ *	event. Verify the primitive is a XID REQUEST.
+ */
+int llc_sap_action_send_xid_c(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = ev->data.prim.data;
+	struct llc_prim_xid *prim_data = &prim->data->xid;
+	struct sk_buff *skb = prim_data->skb;
+	int rc;
+	
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_XID, prim_data->saddr.lsap,
+			    prim_data->daddr.lsap, LLC_PDU_CMD);
+	rc = llc_pdu_init_as_xid_cmd(skb, XID_NULL_CLASS_2, 0);
+	if (rc)
+		goto out;
+	rc = lan_hdrs_init(skb, prim_data->saddr.mac, prim_data->daddr.mac);
+	if (!rc)
+		llc_sap_send_pdu(sap, skb);
+out:	return rc;
+}
+
+/**
+ *	llc_sap_action_send_xid_r - send XID PDU resp to MAC for received XID
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Send XID response PDU to MAC in response to an earlier received XID
+ *	command PDU. Verify event is a PDU type event
+ */
+int llc_sap_action_send_xid_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+        struct llc_prim_if_block *prim = ev->data.prim.data;
+        struct llc_prim_xid *prim_data = &prim->data->xid;
+        struct sk_buff *skb = prim_data->skb;
+        int rc;
+
+        llc_pdu_header_init(skb, LLC_PDU_TYPE_XID, prim_data->saddr.lsap,
+                            prim_data->daddr.lsap, LLC_PDU_RSP);
+        rc = llc_pdu_init_as_xid_rsp(skb, XID_NULL_CLASS_2, 0);
+        if (rc)
+                goto out;
+        rc = lan_hdrs_init(skb, prim_data->saddr.mac, prim_data->daddr.mac);
+        if (!rc)
+                llc_sap_send_pdu(sap, skb);
+out:    return rc;
+}
+
+#ifdef OLD
+int llc_sap_action_send_xid_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	u8 mac_da[MAC_ADDR_LEN], mac_sa[MAC_ADDR_LEN], dsap;
+	int rc = 1;
+	struct sk_buff *ev_skb = ev->data.pdu.skb;
+	struct sk_buff *skb;
+
+	llc_pdu_decode_sa(ev_skb, mac_da);
+	llc_pdu_decode_da(ev_skb, mac_sa);
+	llc_pdu_decode_ssap(ev_skb, &dsap);
+	skb = llc_alloc_frame();
+	if (!skb)
+		goto out;
+	skb->dev = ev_skb->dev;
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap, dsap,
+			    LLC_PDU_RSP);
+	rc = llc_pdu_init_as_xid_rsp(skb, XID_NULL_CLASS_2, 0);
+	if (rc)
+		goto out;
+	rc = lan_hdrs_init(skb, mac_sa, mac_da);
+	if (!rc)
+		llc_sap_send_pdu(sap, skb);
+out:	return rc;
+}
+#endif
+
+/**
+ *	llc_sap_action_send_test_c - send TEST PDU to MAC in resp to TEST REQ
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Send a TEST command PDU to the MAC layer in response to a TEST REQUEST
+ *	primitive from the network layer. Verify event is a primitive type
+ *	event; verify the primitive is a TEST REQUEST.
+ */
+int llc_sap_action_send_test_c(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = ev->data.prim.data;
+	struct llc_prim_test *prim_data = &prim->data->test;
+	struct sk_buff *skb = prim_data->skb;
+	int rc;
+	
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, prim_data->saddr.lsap,
+			    prim_data->daddr.lsap, LLC_PDU_CMD);
+	rc = llc_pdu_init_as_test_cmd(skb);
+	if (rc)
+		goto out;
+	rc = lan_hdrs_init(skb, prim_data->saddr.mac, prim_data->daddr.mac);
+	if (!rc)
+		llc_sap_send_pdu(sap, skb);
+out:	return rc;
+}
+
+int llc_sap_action_send_test_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	struct llc_prim_if_block *prim = ev->data.prim.data;
+        struct llc_prim_test *prim_data = &prim->data->test;
+        struct sk_buff *skb = prim_data->skb;
+        int rc;
+
+        llc_pdu_header_init(skb, LLC_PDU_TYPE_U, prim_data->saddr.lsap,
+                            prim_data->daddr.lsap, LLC_PDU_RSP);
+        rc = llc_pdu_init_as_test_rsp(skb);
+        if (rc)
+                goto out;
+        rc = lan_hdrs_init(skb, prim_data->saddr.mac, prim_data->daddr.mac);
+        if (!rc)
+                llc_sap_send_pdu(sap, skb);
+out:    return rc;
+}
+
+#ifdef OLD
+int llc_sap_action_send_test_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	u8 mac_da[MAC_ADDR_LEN], mac_sa[MAC_ADDR_LEN], dsap;
+	int rc = 1;
+	struct sk_buff *ev_skb = ev->data.pdu.skb;
+	struct sk_buff *skb;
+
+	llc_pdu_decode_sa(ev_skb, mac_da);
+	llc_pdu_decode_da(ev_skb, mac_sa);
+	llc_pdu_decode_ssap(ev_skb, &dsap);
+	skb = llc_alloc_frame();
+	if (!skb)
+		goto out;
+	skb->dev = ev_skb->dev;
+	llc_pdu_header_init(skb, LLC_PDU_TYPE_U, sap->laddr.lsap, dsap,
+			    LLC_PDU_RSP);
+	rc = llc_pdu_init_as_test_rsp(skb, ev_skb);
+	if (rc)
+		goto out;
+	rc = lan_hdrs_init(skb, mac_sa, mac_da);
+	if (!rc)
+		llc_sap_send_pdu(sap, skb);
+out:	return rc;
+}
+#endif
+
+/**
+ *	llc_sap_action_report_status - report data link status to layer mgmt
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Report data link status to layer management. Verify our event is the
+ *	kind we expect.
+ */
+int llc_sap_action_report_status(struct llc_sap *sap,
+				 struct llc_sap_state_ev *ev)
+{
+	return 0;
+}
+
+/**
+ *	llc_sap_action_xid_ind - send XID PDU resp to net layer via XID IND
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Send a XID response PDU to the network layer via a XID INDICATION
+ *	primitive.
+ */
+int llc_sap_action_xid_ind(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	llc_sap_rtn_pdu(sap, ev->data.pdu.skb, ev);
+	return 0;
+}
+
+/**
+ *	llc_sap_action_test_ind - send TEST PDU to net layer via TEST IND
+ *	@sap: SAP
+ *	@ev: the event to send
+ *
+ *	Send a TEST response PDU to the network layer via a TEST INDICATION
+ *	primitive. Verify our event is a PDU type event.
+ */
+int llc_sap_action_test_ind(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	llc_sap_rtn_pdu(sap, ev->data.pdu.skb, ev);
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_s_ev.c linux/net/llc/llc_s_ev.c
--- linux-2.4.18-clean/net/llc/llc_s_ev.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_s_ev.c	Sat Jun  8 01:51:36 2002
@@ -0,0 +1,114 @@
+/*
+ * llc_s_ev.c - Defines SAP component events
+ *
+ * The followed event functions are SAP component events which are described
+ * in 802.2 LLC protocol standard document.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_pdu.h>
+
+int llc_sap_ev_activation_req(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	return ev->type == LLC_SAP_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev == LLC_SAP_EV_ACTIVATION_REQ ? 0 : 1;
+}
+
+int llc_sap_ev_rx_ui(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+	       !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_UI ? 0 : 1;
+}
+
+int llc_sap_ev_unitdata_req(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	return ev->type == LLC_SAP_EV_TYPE_PRIM &&
+	       ev->data.prim.prim == LLC_DATAUNIT_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+
+}
+
+int llc_sap_ev_xid_req(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	return ev->type == LLC_SAP_EV_TYPE_PRIM &&
+	       ev->data.prim.prim == LLC_XID_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_sap_ev_xid_rsp(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+        return ev->type == LLC_SAP_EV_TYPE_PRIM &&
+               ev->data.prim.prim == LLC_XID_PRIM &&
+               ev->data.prim.type == LLC_PRIM_TYPE_RESP ? 0 : 1;
+}
+
+int llc_sap_ev_rx_xid_c(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+	       !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_XID ? 0 : 1;
+}
+
+int llc_sap_ev_rx_xid_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_SAP_EV_TYPE_PDU && !LLC_PDU_IS_RSP(pdu) &&
+	       !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID ? 0 : 1;
+}
+
+int llc_sap_ev_test_req(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	return ev->type == LLC_SAP_EV_TYPE_PRIM &&
+	       ev->data.prim.prim == LLC_TEST_PRIM &&
+	       ev->data.prim.type == LLC_PRIM_TYPE_REQ ? 0 : 1;
+}
+
+int llc_sap_ev_test_rsp(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+        return ev->type == LLC_SAP_EV_TYPE_PRIM &&
+               ev->data.prim.prim == LLC_TEST_PRIM &&
+               ev->data.prim.type == LLC_PRIM_TYPE_RESP ? 0 : 1;
+}
+
+int llc_sap_ev_rx_test_c(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_SAP_EV_TYPE_PDU && !LLC_PDU_IS_CMD(pdu) &&
+	       !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_TEST ? 0 : 1;
+}
+
+int llc_sap_ev_rx_test_r(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+	return ev->type == LLC_SAP_EV_TYPE_PDU && !LLC_PDU_IS_RSP(pdu) &&
+	       !LLC_PDU_TYPE_IS_U(pdu) &&
+	       LLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_TEST ? 0 : 1;
+}
+
+int llc_sap_ev_deactivation_req(struct llc_sap *sap,
+				struct llc_sap_state_ev *ev)
+{
+	return ev->type == LLC_SAP_EV_TYPE_SIMPLE &&
+	       ev->data.a.ev == LLC_SAP_EV_DEACTIVATION_REQ ? 0 : 1;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_s_st.c linux/net/llc/llc_s_st.c
--- linux-2.4.18-clean/net/llc/llc_s_st.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_s_st.c	Fri Jun  7 17:32:26 2002
@@ -0,0 +1,189 @@
+/*
+ * llc_s_st.c - Defines SAP component state machine transitions.
+ *
+ * The followed transitions are SAP component state machine transitions
+ * which are described in 802.2 LLC protocol standard document.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/types.h>
+#include <net/llc_if.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_s_ac.h>
+#include <net/llc_s_st.h>
+
+/* dummy last-transition indicator; common to all state transition groups */
+static struct llc_sap_state_trans llc_sap_state_trans_n = {
+	NULL, 0, NULL	/* last entry for this state */
+};
+
+/* state LLC_SAP_STATE_INACTIVE transition for LLC_SAP_EV_ACTIVATION_REQ event */
+static llc_sap_action_t llc_sap_inactive_state_actions_1[] = {
+	llc_sap_action_report_status,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_inactive_state_trans_1 = {
+	llc_sap_ev_activation_req,	LLC_SAP_STATE_ACTIVE,
+					llc_sap_inactive_state_actions_1
+};
+
+/* array of pointers; one to each transition */
+static struct llc_sap_state_trans *llc_sap_inactive_state_transitions[] = {
+	&llc_sap_inactive_state_trans_1,
+	&llc_sap_state_trans_n
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_RX_UI event */
+static llc_sap_action_t llc_sap_active_state_actions_1[] = {
+	llc_sap_action_unitdata_ind,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_1 = {
+	llc_sap_ev_rx_ui,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_1
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_UNITDATA_REQ event */
+static llc_sap_action_t llc_sap_active_state_actions_2[] = {
+	llc_sap_action_send_ui,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_2 = {
+	llc_sap_ev_unitdata_req,	LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_2
+};
+
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_XID_REQ event */
+static llc_sap_action_t llc_sap_active_state_actions_3[] = {
+	llc_sap_action_send_xid_c,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_3 = {
+	llc_sap_ev_xid_req,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_3
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_XID_RSP event */
+static llc_sap_action_t llc_sap_active_state_actions_4[] = {
+        llc_sap_action_send_xid_r,
+        NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_4 = {
+        llc_sap_ev_xid_rsp,             LLC_SAP_STATE_ACTIVE,
+                                        llc_sap_active_state_actions_4
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_RX_XID_C event */
+static llc_sap_action_t llc_sap_active_state_actions_5[] = {
+//	llc_sap_action_send_xid_r,
+	llc_sap_action_xid_ind,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_5 = {
+	llc_sap_ev_rx_xid_c,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_5
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_RX_XID_R event */
+static llc_sap_action_t llc_sap_active_state_actions_6[] = {
+	llc_sap_action_xid_ind,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_6 = {
+	llc_sap_ev_rx_xid_r,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_6
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_TEST_REQ event */
+static llc_sap_action_t llc_sap_active_state_actions_7[] = {
+	llc_sap_action_send_test_c,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_7 = {
+	llc_sap_ev_test_req,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_7
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_TEST_RSP event */
+static llc_sap_action_t llc_sap_active_state_actions_8[] = {
+        llc_sap_action_send_test_r,
+        NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_8 = {
+        llc_sap_ev_test_rsp,            LLC_SAP_STATE_ACTIVE,
+                                        llc_sap_active_state_actions_8
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_RX_TEST_C event */
+static llc_sap_action_t llc_sap_active_state_actions_9[] = {
+//	llc_sap_action_send_test_r,
+	llc_sap_action_test_ind,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_9 = {
+	llc_sap_ev_rx_test_c,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_9
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_RX_TEST_R event */
+static llc_sap_action_t llc_sap_active_state_actions_10[] = {
+	llc_sap_action_test_ind,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_10 = {
+	llc_sap_ev_rx_test_r,		LLC_SAP_STATE_ACTIVE,
+					llc_sap_active_state_actions_10
+};
+
+/* state LLC_SAP_STATE_ACTIVE transition for LLC_SAP_EV_DEACTIVATION_REQ event */
+static llc_sap_action_t llc_sap_active_state_actions_11[] = {
+	llc_sap_action_report_status,
+	NULL
+};
+
+static struct llc_sap_state_trans llc_sap_active_state_trans_11 = {
+	llc_sap_ev_deactivation_req,	LLC_SAP_STATE_INACTIVE,
+					llc_sap_active_state_actions_11
+};
+
+/* array of pointers; one to each transition */
+static struct llc_sap_state_trans *llc_sap_active_state_transitions[] = {
+	&llc_sap_active_state_trans_2,
+	&llc_sap_active_state_trans_1,
+	&llc_sap_active_state_trans_3,
+	&llc_sap_active_state_trans_4,
+	&llc_sap_active_state_trans_5,
+	&llc_sap_active_state_trans_6,
+	&llc_sap_active_state_trans_7,
+	&llc_sap_active_state_trans_8,
+	&llc_sap_active_state_trans_9,
+	&llc_sap_active_state_trans_10,
+	&llc_sap_active_state_trans_11,
+	&llc_sap_state_trans_n
+};
+
+/* SAP state transition table */
+struct llc_sap_state llc_sap_state_table[] = {
+	{ LLC_SAP_STATE_INACTIVE, llc_sap_inactive_state_transitions },
+	{ LLC_SAP_STATE_ACTIVE,	  llc_sap_active_state_transitions   }
+};
diff -ruN linux-2.4.18-clean/net/llc/llc_sap.c linux/net/llc/llc_sap.c
--- linux-2.4.18-clean/net/llc/llc_sap.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_sap.c	Sat Jun  8 11:13:10 2002
@@ -0,0 +1,262 @@
+/*
+ * llc_sap.c - driver routines for SAP component.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/types.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_s_ev.h>
+#include <net/llc_s_ac.h>
+#include <net/llc_s_st.h>
+#include <net/sock.h>
+#include <net/llc_main.h>
+#include <net/llc_mac.h>
+#include <net/llc_pdu.h>
+
+static void llc_sap_free_ev(struct llc_sap *sap, struct llc_sap_state_ev *ev);
+static int llc_sap_next_state(struct llc_sap *sap, struct llc_sap_state_ev *ev);
+static int llc_exec_sap_trans_actions(struct llc_sap *sap,
+				      struct llc_sap_state_trans *trans,
+				      struct llc_sap_state_ev *ev);
+static struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,
+						  struct llc_sap_state_ev *ev);
+
+/**
+ *	llc_sap_assign_sock - adds a connection to a SAP
+ *	@sap: pointer to SAP.
+ *	@conn: pointer to connection.
+ *
+ *	This function adds a connection to connection_list of a SAP.
+ */
+void llc_sap_assign_sock(struct llc_sap *sap, struct sock *sk)
+{
+	spin_lock_bh(&sap->sk_list.lock);
+	LLC_SK(sk)->sap = sap;
+	list_add_tail(&LLC_SK(sk)->node, &sap->sk_list.list);
+	spin_unlock_bh(&sap->sk_list.lock);
+}
+
+/**
+ *	llc_sap_unassign_sock - removes a connection from SAP
+ *	@sap: SAP
+ *	@sk: pointer to connection
+ *
+ *	This function removes a connection from connection_list of a SAP.
+ *	List locking is performed by caller (rtn_all_conns).
+ */
+void llc_sap_unassign_sock(struct llc_sap *sap, struct sock *sk)
+{
+	list_del(&LLC_SK(sk)->node);
+}
+
+/**
+ *	llc_sap_alloc_ev - allocates sap event
+ *	@sap: pointer to SAP
+ *	@ev: allocated event (output argument)
+ *
+ *	Returns the allocated sap event or %NULL when out of memory.
+ */
+struct llc_sap_state_ev *llc_sap_alloc_ev(struct llc_sap *sap)
+{
+	struct llc_sap_state_ev *ev = kmalloc(sizeof(*ev), GFP_ATOMIC);
+
+        if (ev)
+		memset(ev, 0, sizeof(*ev));
+	return ev;
+}
+
+/**
+ *	llc_sap_send_ev - sends event to SAP state machine
+ *	@sap: pointer to SAP
+ *	@ev: pointer to occurred event
+ *
+ *	After executing actions of the event, upper layer will be indicated
+ *	if needed(on receiving an UI frame).
+ */
+int llc_sap_send_ev(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	struct llc_prim_if_block *prim;
+	u8 flag;
+
+	llc_sap_next_state(sap, ev);
+	flag = ev->ind_cfm_flag;
+	prim = ev->prim;
+	if (flag == LLC_IND) {
+		skb_get(ev->data.pdu.skb);
+		sap->ind(prim);
+	}
+	llc_sap_free_ev(sap, ev);
+	return 0;
+}
+
+/**
+ *	llc_sap_rtn_pdu - Informs upper layer on rx of an UI, XID or TEST pdu.
+ *	@sap: pointer to SAP
+ *	@skb: received pdu
+ *	@ev: pointer to occurred event
+ */
+void llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb,
+		     struct llc_sap_state_ev *ev)
+{
+	pdu_un_t *pdu;
+	struct llc_prim_if_block *prim = &llc_ind_prim;
+	union llc_u_prim_data *prim_data = llc_ind_prim.data;
+	u8 lfb;
+
+	llc_pdu_decode_sa(skb, prim_data->udata.saddr.mac);
+	llc_pdu_decode_da(skb, prim_data->udata.daddr.mac);
+	llc_pdu_decode_dsap(skb, &prim_data->udata.daddr.lsap);
+	llc_pdu_decode_ssap(skb, &prim_data->udata.saddr.lsap);
+	prim_data->udata.pri = 0;
+	prim_data->udata.skb = skb;
+	pdu = (pdu_un_t *)skb->nh.raw;
+	switch (LLC_U_PDU_RSP(pdu)) {
+		case LLC_1_PDU_CMD_TEST:
+			prim->prim = LLC_TEST_PRIM;
+			if (!LLC_PDU_IS_CMD(pdu))
+				prim_data->udata.pri = LLC_PRIM_TYPE_REQ;
+			else
+				prim_data->udata.pri = LLC_PRIM_TYPE_RESP;
+			break;
+		case LLC_1_PDU_CMD_XID:
+			prim->prim = LLC_XID_PRIM;
+			if (!LLC_PDU_IS_CMD(pdu))
+                                prim_data->udata.pri = LLC_PRIM_TYPE_REQ;
+                        else
+                                prim_data->udata.pri = LLC_PRIM_TYPE_RESP;
+			break;
+		case LLC_1_PDU_CMD_UI:
+			if (skb->protocol == ntohs(ETH_P_TR_802_2)) {
+				if (((token_ring_mac_hdr_t *)
+							skb->mac.raw)->rcf) {
+					lfb = ntohs(((token_ring_mac_hdr_t *)
+						    skb->mac.raw)->rcf) &
+						    0x0070;
+					prim_data->udata.lfb = lfb >> 4;
+				} else {
+					lfb = 0xFF;
+					prim_data->udata.lfb = 0xFF;
+				}
+			}
+			prim->prim = LLC_DATAUNIT_PRIM;
+			break;
+	}
+	prim->data = prim_data;
+	prim->sap = sap;
+	ev->ind_cfm_flag = LLC_IND;
+	ev->prim = prim;
+}
+
+/**
+ *	llc_sap_send_pdu - Sends a frame to MAC layer for transmition
+ *	@sap: pointer to SAP
+ *	@skb: pdu that must be sent
+ */
+void llc_sap_send_pdu(struct llc_sap *sap, struct sk_buff *skb)
+{
+	mac_send_pdu(skb);
+	kfree_skb(skb);
+}
+
+/**
+ *	llc_sap_free_ev - frees an sap event
+ *	@sap: pointer to SAP
+ *	@ev: released event
+ */
+static void llc_sap_free_ev(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	if (ev->type == LLC_SAP_EV_TYPE_PDU) {
+		pdu_un_t *pdu = (pdu_un_t *)ev->data.pdu.skb->nh.raw;
+
+		if (LLC_U_PDU_CMD(pdu) != LLC_1_PDU_CMD_UI)
+			kfree_skb(ev->data.pdu.skb);
+	}
+	kfree(ev);
+}
+
+/**
+ *	llc_sap_next_state - finds transition, execs actions & change SAP state
+ *	@sap: pointer to SAP
+ *	@ev: happened event
+ *
+ *	This function finds transition that matches with happened event, then
+ *	executes related actions and finally changes state of SAP. It returns
+ *	0 on success and 1 for failure.
+ */
+static int llc_sap_next_state(struct llc_sap *sap, struct llc_sap_state_ev *ev)
+{
+	int rc = 1;
+	struct llc_sap_state_trans *trans;
+
+	if (sap->state <= LLC_NBR_SAP_STATES) {
+		trans = llc_find_sap_trans(sap, ev);
+		if (trans) {
+			/* got the state to which we next transition; perform
+			 * the actions associated with this transition before
+			 * actually transitioning to the next state */
+			rc = llc_exec_sap_trans_actions(sap, trans, ev);
+			if (!rc)
+               			/* transition SAP to next state if all actions
+               			   execute successfully */
+				sap->state = trans->next_state;
+		}
+	}
+	return rc;
+}
+
+/**
+ *	llc_find_sap_trans - finds transition for event
+ *	@sap: pointer to SAP
+ *	@ev: happened event
+ *
+ *	This function finds transition that matches with happened event.
+ *	Returns the pointer to found transition on success or %NULL for
+ *	failure.
+ */
+static struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,
+						  struct llc_sap_state_ev* ev)
+{
+	int i;
+	struct llc_sap_state_trans **next_trans;
+	struct llc_sap_state *curr_state = &llc_sap_state_table[sap->state - 1];
+	/* search thru events for this state until list exhausted or until
+	 * its obvious the event is not valid for the current state */
+	for (i = 0, next_trans = curr_state->transitions;
+	     next_trans [i]->ev; i++)
+		if (!next_trans[i]->ev(sap, ev))
+			/* got event match; return it */
+			return next_trans[i];
+	return NULL;
+}
+
+/**
+ *	llc_exec_sap_trans_actions - execute actions related to event
+ *	@sap: pointer to SAP
+ *	@trans: pointer to transition that it's actions must be performed
+ *	@ev: happened event.
+ *
+ *	This function executes actions that is related to happened event.
+ *	Returns 0 for success and 1 for failure of at least one action.
+ */
+static int llc_exec_sap_trans_actions(struct llc_sap *sap,
+				      struct llc_sap_state_trans *trans,
+				      struct llc_sap_state_ev *ev)
+{
+	int rc = 0;
+	llc_sap_action_t *next_action;
+
+	for (next_action = trans->ev_actions;
+	     next_action && *next_action; next_action++)
+		if ((*next_action)(sap, ev))
+			rc = 1;
+	return rc;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_sock.c linux/net/llc/llc_sock.c
--- linux-2.4.18-clean/net/llc/llc_sock.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_sock.c	Sat Jun  8 09:14:06 2002
@@ -0,0 +1,1779 @@
+/*
+ * llc_sock.c - LLC User Interface SAPs
+ * Description:
+ *   Functions in this module are implementation of socket based llc
+ *   communications for the Linux operating system. Support of llc class
+ *   one and class two is provided via SOCK_DGRAM and SOCK_STREAM
+ *   respectively.
+ *
+ *   An llc2 connection is (mac + sap), only one llc2 sap connection
+ *   is allowed per mac. Though one sap may have multiple mac + sap
+ *   connections.
+ *
+ * Copyright (c) 2001 by Jay Schulist <jschlst@samba.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <asm/uaccess.h>
+#include <asm/ioctls.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/errno.h>
+#include <net/sock.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/init.h>
+
+static u16 llc_ui_sap_last_autoport;
+static u16 llc_ui_sap_link_no_max[256];
+static u8 llc_ui_addrany[IFHWADDRLEN]; 		/* zeroed because its in .bss */
+static struct sockaddr_llc llc_ui_addrnull;	/* zeroed because its in .bss */
+static struct sock *llc_ui_sockets;
+static struct proto_ops llc_ui_ops;
+static rwlock_t llc_ui_sockets_lock = RW_LOCK_UNLOCKED;
+
+static int llc_ui_indicate(struct llc_prim_if_block *prim);
+static int llc_ui_confirm(struct llc_prim_if_block *prim);
+static int llc_ui_wait_for_conn(struct sock *sk, int seconds);
+static int llc_ui_wait_for_disc(struct sock *sk, int seconds);
+
+/**
+ *	llc_ui_next_link_no - return the next unused link number for a sap
+ *	@sap: Address of sap to get link number from.
+ *
+ *	Return the next unused link number for a given sap.
+ */
+static inline u16 llc_ui_next_link_no(int sap)
+{
+	return llc_ui_sap_link_no_max[sap]++;
+}
+
+/**
+ *	llc_ui_mac_match - determines if two mac addresses are the same
+ *	@mac1: First mac address to compare.
+ *	@mac2: Second mac address to compare.
+ *
+ *	Determines if two given mac address are the same.  Returns 0 if there
+ *	is not a complete match upto len, 1 if a complete match upto len is
+ *	found.
+ */
+static inline u8 llc_ui_mac_match(u8 *mac1, u8 *mac2)
+{
+	return !memcmp(mac1, mac2, IFHWADDRLEN);
+}
+
+/**
+ *	llc_ui_mac_null - determines if a address is a NULL mac address
+ *	@mac: Mac address to test if NULL.
+ *
+ *	Determines if a given address is a NULL mac address.  Returns 0 if the
+ *	address is not a NULL mac, 1 if the address is a NULL mac.
+ */
+static inline u8 llc_ui_mac_null(u8 *mac)
+{
+	return !memcmp(mac, llc_ui_addrany, IFHWADDRLEN);
+}
+
+/**
+ *	llc_ui_addr_null - determines if a address structure is NULL
+ *	@addr: Address to test if NULL.
+ */	
+static inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)
+{
+	return !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));
+}
+
+/**
+ *	llc_ui_protocol_type - return eth protocol for ARP header type
+ *	@arphrd: ARP header type.
+ *
+ *	Given an ARP header type return the corresponding ethernet protocol.
+ *	Returns  0 if ARP header type not supported or the corresponding
+ *	ethernet protocol type.
+ */
+static inline u16 llc_ui_protocol_type(u16 arphrd)
+{
+	u16 rc = htons(ETH_P_802_2);
+
+	if (arphrd == ARPHRD_IEEE802)
+		rc = htons(ETH_P_TR_802_2);
+	return rc;
+}
+
+/**
+ *	llc_ui_header_len - return lenght of llc header based on operation
+ *	@sk: Socket which contains a valid llc socket type.
+ *	@addr: Complete sockaddr_llc structure received from the user.
+ *
+ *	Provide the length of the llc header depending on what kind of
+ *	operation the user would like to perform and the type of socket.
+ *	Returns the correct llc header length.
+ */
+static inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)
+{
+	u8 rc = LLC_PDU_LEN_U;
+
+	if (addr->sllc_test || addr->sllc_xid) {
+		rc = LLC_PDU_LEN_U;
+		if (addr->sllc_xid)
+			rc += 3;
+	} else if (sk->type == SOCK_STREAM)
+		rc = LLC_PDU_LEN_I;
+	return rc;
+}
+
+/**
+ *	llc_ui_send_conn - send connect command for new llc2 connection
+ *	@sap : Sap the socket is bound to.
+ *	@addr: Source and destination fields provided by the user.
+ *	@dev : Device which this connection should use.
+ *	@link: Link number to assign to this connection.
+ *
+ *	Send a connect command to the llc layer for a new llc2 connection.
+ *	Returns 0 upon success, non-zero if action didn't succeed.
+ */
+static int llc_ui_send_conn(struct sock *sk, struct llc_sap *sap,
+			    struct sockaddr_llc *addr,
+			    struct net_device *dev, int link)
+{
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+
+	prim.data	    = &prim_data;
+	prim.sap	    = sap;
+	prim.prim	    = LLC_CONN_PRIM;
+	prim_data.conn.dev  = dev;
+	prim_data.conn.link = link;
+	prim_data.conn.sk   = NULL;
+	prim_data.conn.pri  = 0;
+	prim_data.conn.saddr.lsap = LLC_UI_SK(sk)->addr.sllc_ssap;
+	prim_data.conn.daddr.lsap = addr->sllc_dsap;
+	memcpy(prim_data.conn.saddr.mac, dev->dev_addr, IFHWADDRLEN);
+	memcpy(prim_data.conn.daddr.mac, addr->sllc_dmac, IFHWADDRLEN);
+	return sap->req(&prim);
+}
+
+/**
+ *	llc_ui_send_disc - send disc command to llc layer
+ *	@sk: Socket with valid llc information.
+ *
+ *	Send a disconnect command to the llc layer for an established
+ *	llc2 connection.
+ *	Returns 0 upon success, non-zero if action did not succeed.
+ */
+static int llc_ui_send_disc(struct sock *sk)
+{
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+	int rc = 0;
+
+	if (sk->type != SOCK_STREAM || sk->state != TCP_ESTABLISHED)
+		goto out;
+	sk->state	    = TCP_CLOSING;
+	prim.data	    = &prim_data;
+	prim.sap	    = llc->sap;
+	prim.prim	    = LLC_DISC_PRIM;
+	prim_data.disc.sk   = llc->core_sk;
+	prim_data.disc.link = llc->link;
+	rc = llc->sap->req(&prim);
+out:	return rc;
+}
+
+/**
+ *	llc_ui_send_data - send data via reliable llc2 connection
+ *	@sap: Sap the socket is bound to.
+ *	@sk: Connection the socket is using.
+ *	@skb: Data the user wishes to send.
+ *	@addr: Source and destination fields provided by the user.
+ *
+ *	Send data via reliable llc2 connection.
+ *	Returns 0 upon success,  non-zero if action did not succeed.
+ */
+static int llc_ui_send_data(struct llc_sap *sap, struct sock *sk,
+			    struct sk_buff *skb, struct sockaddr_llc *addr)
+{
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+	struct sock *core_sk = LLC_UI_SK(sk)->core_sk;
+	int rc;
+	
+	prim.data	   = &prim_data;
+	prim.sap	   = sap;
+	prim.prim	   = LLC_DATA_PRIM;
+	prim_data.data.skb = skb;
+	prim_data.data.pri = 0;
+	prim_data.data.sk  = core_sk;
+	skb->protocol	   = llc_ui_protocol_type(addr->sllc_arphrd);
+	rc = wait_event_interruptible(sk->socket->wait, 
+		!LLC_SK(core_sk)->failed_data_req);
+	if (rc < 0)
+		goto out;
+	rc = sap->req(&prim);
+out:	return rc;
+}
+
+/**
+ *	llc_ui_send_llc1 - send llc1 prim data block to llc layer.
+ *	@sap      : Sap the socket is bound to.
+ *	@skb      : Data the user wishes to send.
+ *	@addr     : Source and destination fields provided by the user.
+ *	@primitive: Action the llc layer should perform.
+ *
+ *	Send an llc1 primitive data block to the llc layer for processing.
+ *	This function is used for test, xid and unit_data messages.
+ *	Returns 0 upon success, non-zero if action did not succeed.
+ */
+static int llc_ui_send_llc1(struct llc_sap *sap, struct sk_buff *skb,
+			    struct sockaddr_llc *addr, int primitive)
+{
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+
+	prim.data 		  = &prim_data;
+	prim.sap 		  = sap;
+	prim.prim		  = primitive;
+	prim.type		  = 0;
+	prim_data.test.skb 	  = skb;
+	prim_data.test.saddr.lsap = sap->laddr.lsap;
+	prim_data.test.daddr.lsap = addr->sllc_dsap;
+	skb->protocol = llc_ui_protocol_type(addr->sllc_arphrd);
+	memcpy(prim_data.test.saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);
+	memcpy(prim_data.test.daddr.mac, addr->sllc_dmac, IFHWADDRLEN);
+	return sap->req(&prim);
+}
+
+/**
+ *	llc_ui_find_sap - returns sap struct that matches sap number specified
+ *	@sap: Sap number to search for.
+ *
+ *	Search the local socket list and return the first instance of the sap
+ *	structure which matches the sap number the user specified.
+ *	Returns llc_sap upon match, %NULL otherwise.
+ */
+static inline struct llc_sap *llc_ui_find_sap(u8 sap)
+{
+	struct sock *sk;
+	struct llc_sap *s = NULL;
+
+	read_lock_bh(&llc_ui_sockets_lock);
+	for (sk = llc_ui_sockets; sk; sk = sk->next) {
+		struct llc_ui_opt *llc = LLC_UI_SK(sk);
+
+		if (!llc->sap)
+			continue;
+		if (llc->sap->laddr.lsap == sap) {
+			s = llc->sap;
+			break;
+		}
+	}
+	read_unlock_bh(&llc_ui_sockets_lock);
+	return s;
+}
+
+/**
+ *	llc_ui_find_sk_by_link_no - return socket matching sap and link_no
+ *	@sap: Sap to search for.
+ *	@link: link number of connection to match.
+ *
+ *	Search the local socket list and return the socket which has a matching
+ *	sap and link_no. This search only works on connected sockets.
+ *	Returns sock upon match, %NULL otherwise.
+ */
+static struct sock *llc_ui_find_sk_by_link_no(struct llc_sap *sap, u16 link)
+{
+	struct sock *sk;
+
+	read_lock(&llc_ui_sockets_lock);
+	for (sk = llc_ui_sockets; sk; sk = sk->next) {
+		struct llc_ui_opt *llc = LLC_UI_SK(sk);
+
+		if (llc->sap && llc->sap->laddr.lsap == sap->laddr.lsap &&
+		    llc->core_sk &&    /* if no core_sk, link_no is invalid */
+		    llc->link == link)
+			break; /* exact mac + sap match. */
+	}
+	if (sk)
+		sock_hold(sk);
+	read_unlock(&llc_ui_sockets_lock);
+	return sk;
+}
+
+static struct sock *__llc_ui_find_sk_by_exact(struct llc_addr *laddr,
+					      struct llc_addr *daddr)
+{
+	struct sock *sk;
+
+	for (sk = llc_ui_sockets; sk; sk = sk->next) {
+		struct llc_ui_opt *llc = LLC_UI_SK(sk);
+		if (llc_ui_mac_null(llc->addr.sllc_mmac) &&
+		    llc_ui_mac_match(llc->addr.sllc_smac, laddr->mac) &&
+		    llc_ui_mac_match(llc->addr.sllc_dmac, daddr->mac) &&
+		    llc->addr.sllc_ssap == laddr->lsap &&
+		    llc->addr.sllc_dsap == daddr->lsap)
+			break;
+	}
+	return sk;
+}
+
+/**
+ *	__llc_ui_find_sk_by_addr - return socket matching local mac + sap.
+ *	@addr: Local address to match.
+ *
+ *	Search the local socket list and return the socket which has a matching
+ *	local (mac + sap) address (allows null mac). This search will work on
+ *	unconnected and connected sockets, though find_by_link_no is recommend
+ *	for connected sockets.
+ *	Returns sock upon match, %NULL otherwise.
+ */
+static struct sock *__llc_ui_find_sk_by_addr(struct llc_addr *laddr,
+			struct llc_addr *daddr, struct net_device *dev)
+{
+	struct sock *sk, *tmp_sk;
+
+	for (sk = llc_ui_sockets; sk; sk = sk->next) {
+		struct llc_ui_opt *llc = LLC_UI_SK(sk);
+
+		if (llc->addr.sllc_ssap != laddr->lsap)
+			continue;
+		if (llc_ui_mac_null(llc->addr.sllc_smac)) {
+			if (!llc_ui_mac_null(llc->addr.sllc_mmac) &&
+			    !llc_ui_mac_match(llc->addr.sllc_mmac, laddr->mac))
+				continue;
+			break;
+		}
+		if (dev && !llc_ui_mac_null(llc->addr.sllc_mmac) &&
+		    llc_ui_mac_match(llc->addr.sllc_mmac, laddr->mac) &&
+		    llc_ui_mac_match(llc->addr.sllc_smac, dev->dev_addr))
+			break;
+		if (llc_ui_mac_match(llc->addr.sllc_smac, laddr->mac)) {
+			tmp_sk = __llc_ui_find_sk_by_exact(laddr, daddr);
+			if (tmp_sk) {
+				sk = tmp_sk;
+				break;
+			}
+			if (llc_ui_mac_null(llc->addr.sllc_dmac))
+				break;
+		}
+	}
+	return sk;
+}
+
+static struct sock *llc_ui_find_sk_by_addr(struct llc_addr *addr,
+			struct llc_addr *daddr, struct net_device *dev)
+{
+	struct sock *sk;
+	read_lock(&llc_ui_sockets_lock);
+	sk = __llc_ui_find_sk_by_addr(addr, daddr, dev);
+	if (sk)
+		sock_hold(sk);
+	read_unlock(&llc_ui_sockets_lock);
+	return sk;
+}
+
+static struct sock *llc_ui_bh_find_sk_by_addr(struct llc_addr *addr,
+			struct llc_addr *daddr, struct net_device *dev)
+{
+	struct sock *sk;
+	read_lock_bh(&llc_ui_sockets_lock);
+	sk = __llc_ui_find_sk_by_addr(addr, daddr, dev);
+	if (sk)
+		sock_hold(sk);
+	read_unlock_bh(&llc_ui_sockets_lock);
+	return sk;
+}
+
+/**
+ *	llc_ui_insert_socket - insert socket into list
+ *	@sk: Socket to insert.
+ *
+ *	Insert a socket into the local llc socket list.
+ */
+static inline void llc_ui_insert_socket(struct sock *sk)
+{
+	write_lock_bh(&llc_ui_sockets_lock);
+	sk->next = llc_ui_sockets;
+	if (sk->next)
+		llc_ui_sockets->pprev = &sk->next;
+	llc_ui_sockets = sk;
+	sk->pprev = &llc_ui_sockets;
+	sock_hold(sk);
+	write_unlock_bh(&llc_ui_sockets_lock);
+}
+
+/**
+ *	llc_ui_remove_socket - remove socket from list
+ *	@sk: Socket to remove.
+ *
+ *	Remove a socket from the local llc socket list.
+ */
+static inline void llc_ui_remove_socket(struct sock *sk)
+{
+	write_lock_bh(&llc_ui_sockets_lock);
+	if (sk->pprev) {
+		if (sk->next)
+			sk->next->pprev = sk->pprev;
+		*sk->pprev = sk->next;
+		sk->pprev = NULL;
+		/* this only makes sense if the socket was inserted on the
+		 * list, if sk->pprev is NULL it wasn't */
+		sock_put(sk);
+	}
+	write_unlock_bh(&llc_ui_sockets_lock);
+}
+
+/**
+ *	llc_ui_destroy_timer - try to destroy socket again
+ *	@data: Socket which is to be destroyed.
+ *
+ *	Attempt to destroy a socket which was previously destroyed but
+ *	was still in use at the time.
+ */
+static void llc_ui_destroy_timer(unsigned long data)
+{
+	struct sock *sk = (struct sock *)data;
+
+	skb_queue_purge(&sk->receive_queue);
+	skb_queue_purge(&sk->write_queue);
+	if (!atomic_read(&sk->wmem_alloc) &&
+	    !atomic_read(&sk->rmem_alloc) && sk->dead)
+		MOD_DEC_USE_COUNT;
+	else {
+		sk->timer.expires = jiffies + SOCK_DESTROY_TIME;
+		add_timer(&sk->timer);
+	}
+}
+
+/**
+ *	llc_ui_create - alloc and init a new llc_ui socket
+ *	@sock: Socket to initialize and attach allocated sk to.
+ *	@protocol: Unused.
+ *
+ *	Allocate and initialize a new llc_ui socket, validate the user wants a
+ *	socket type we have available.
+ *	Returns 0 upon success, negative upon failure.
+ */
+static int llc_ui_create(struct socket *sock, int protocol)
+{
+	struct proto_ops *prot;
+	struct sock *sk;
+	int rc = -ESOCKTNOSUPPORT;
+
+	MOD_INC_USE_COUNT;
+	switch (sock->type) {
+		case SOCK_DGRAM:	/* llc1 */
+		case SOCK_STREAM:	/* llc2 */
+			prot = &llc_ui_ops;
+			break;
+		case SOCK_SEQPACKET:	/* llc3, not supported */
+		case SOCK_RAW:		/* not supported */
+		default:
+			goto decmod;
+	}
+	rc = -ENOMEM;
+	sk = sk_alloc(PF_LLC, GFP_KERNEL, 1);
+	if (!sk)
+		goto decmod;
+	rc = 0;
+	sock_init_data(sock, sk);
+	sock->ops = prot;
+out:	return rc;
+decmod:	MOD_DEC_USE_COUNT;
+	goto out;
+}
+
+/**
+ *	llc_ui_release - shutdown socket
+ *	@sock: Socket to release.
+ *
+ *	Shutdown and deallocate an existing socket.
+ */
+static int llc_ui_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc;
+
+	if (!sk)
+		goto out;
+	llc_ui_remove_socket(sk);
+	llc = LLC_UI_SK(sk);
+	if (llc->core_sk)
+		llc_ui_send_disc(sk);
+	if (llc->sap && !llc_ui_find_sap(llc->sap->laddr.lsap))
+		llc_sap_close(llc->sap);
+	skb_queue_purge(&sk->receive_queue);
+	skb_queue_purge(&sk->write_queue);
+	sock_orphan(sk);
+	sock->sk = NULL;
+	if (!atomic_read(&sk->wmem_alloc) &&
+	    !atomic_read(&sk->rmem_alloc) && sk->dead)
+		MOD_DEC_USE_COUNT;
+	else {
+		init_timer(&sk->timer);
+		sk->timer.expires = jiffies + SOCK_DESTROY_TIME;
+		sk->timer.function = llc_ui_destroy_timer;
+		sk->timer.data = (unsigned long)sk;
+		add_timer(&sk->timer);
+	}
+out:	return 0;
+}
+
+/**
+ *	llc_ui_autoport - provide dynamicly allocate SAP number
+ *
+ *	Provide the caller with a dynamicly allocated SAP number according
+ *	to the rules that are set in this function. Returns: 0, upon failure,
+ *	SAP number otherwise.
+ */
+static int llc_ui_autoport(void)
+{
+	struct llc_sap *sap;
+	int i, tries = 0;
+
+	while (tries < LLC_SAP_DYN_TRIES) {
+		for (i = llc_ui_sap_last_autoport;
+		     i < LLC_SAP_DYN_STOP; i += 2) {
+			sap = llc_ui_find_sap(i);
+			if (!sap) {
+				llc_ui_sap_last_autoport = i + 2;
+				goto out;
+			}
+		}
+		llc_ui_sap_last_autoport = LLC_SAP_DYN_START;
+		tries++;
+	}
+	i = 0;
+out:	return i;
+}
+
+/**
+ *	llc_ui_autobind - Bind a socket to a specific address.
+ *	@sk: Socket to bind an address to.
+ *	@addr: Address the user wants the socket bound to.
+ *
+ *	Bind a socket to a specific address. For llc a user is able to bind to
+ *	a specific sap only or mac + sap. If the user only specifies a sap and
+ *	a null dmac (all zeros) the user is attempting to bind to an entire
+ *	sap. This will stop anyone else on the local system from using that
+ *	sap.  If someone else has a mac + sap open the bind to null + sap will
+ *	fail.
+ *	If the user desires to bind to a specific mac + sap, it is possible to
+ *	have multiple sap connections via multiple macs.
+ *	Bind and autobind for that matter must enforce the correct sap usage
+ *	otherwise all hell will break loose.
+ *	Returns: 0 upon success, negative otherwise.
+ */
+static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)
+{
+	struct sock *sk = sock->sk;
+	struct llc_sap *sap;
+	struct net_device *dev = NULL;
+	int rc = -EINVAL;
+
+	if (!sk->zapped)
+		goto out;
+	/* bind to a specific mac, optional. */
+	if (!llc_ui_mac_null(addr->sllc_smac)) {
+		rtnl_lock();
+		dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+		rtnl_unlock();
+		rc = -ENETUNREACH;
+		if (!dev)
+			goto out;
+		LLC_UI_SK(sk)->dev = dev;
+	}
+	/* bind to a specific sap, optional. */
+	if (!addr->sllc_ssap) {
+		rc = -EUSERS;
+		addr->sllc_ssap = llc_ui_autoport();
+		if (!addr->sllc_ssap)
+			goto out;
+	}
+	sap = llc_ui_find_sap(addr->sllc_ssap);
+	if (!sap) {
+		sap = llc_sap_open(llc_ui_indicate, llc_ui_confirm,
+				   addr->sllc_ssap);
+		rc = -EBUSY; /* some other network layer is using the sap */
+		if (!sap)
+			goto out;
+	} else {
+		struct llc_addr local_addr, remote_addr;
+		struct sock *ask;
+
+		rc = -EUSERS; /* can't get exclusive use of sap */
+		if (!dev && llc_ui_mac_null(addr->sllc_mmac))
+			goto out;
+		memset(&local_addr, 0, sizeof(local_addr));
+		memset(&remote_addr, 0, sizeof(remote_addr));
+		if (!llc_ui_mac_null(addr->sllc_mmac)) {
+			if (sk->type != SOCK_DGRAM) {
+				rc = -EOPNOTSUPP;
+				goto out;
+			}
+			memcpy(local_addr.mac, addr->sllc_mmac, IFHWADDRLEN);
+		} else
+			memcpy(local_addr.mac, addr->sllc_smac, IFHWADDRLEN);
+		local_addr.lsap = addr->sllc_ssap;
+		rc = -EADDRINUSE;   /* mac + sap clash. */
+		ask = llc_ui_bh_find_sk_by_addr(&local_addr, &remote_addr, dev);
+		if (ask) {
+			sock_put(ask);
+			goto out;
+		}
+	}
+	memcpy(&LLC_UI_SK(sk)->addr, addr, sizeof(*addr));
+	LLC_UI_SK(sk)->sap = sap;
+	rc = sk->zapped = 0;
+	llc_ui_insert_socket(sk);
+out:	return rc;
+}
+
+/**
+ *	llc_ui_bind - bind a socket to a specific address.
+ *	@sock: Socket to bind an address to.
+ *	@uaddr: Address the user wants the socket bound to.
+ *	@addr_len: Length of the uaddr structure.
+ *
+ *	Bind a socket to a specific address. For llc a user is able to bind to
+ *	a specific sap only or mac + sap. If the user only specifies a sap and
+ *	a null dmac (all zeros) the user is attempting to bind to an entire
+ *	sap. This will stop anyone else on the local system from using that
+ *	sap. If someone else has a mac + sap open the bind to null + sap will
+ *	fail.
+ *	If the user desires to bind to a specific mac + sap, it is possible to
+ *	have multiple sap connections via multiple macs.
+ *	Bind and autobind for that matter must enforce the correct sap usage
+ *	otherwise all hell will break loose.
+ *	Returns: 0 upon success, negative otherwise.
+ */
+static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr,
+		       int addr_len)
+{
+	struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+	struct sock *sk = sock->sk;
+	int rc = -EINVAL;
+
+	if (!sk->zapped || addr_len != sizeof(*addr))
+		goto out;
+	rc = -EAFNOSUPPORT;
+	if (addr->sllc_family != AF_LLC)
+		goto out;
+	/* use autobind, to avoid code replication. */
+	rc = llc_ui_autobind(sock, addr);
+out:	return rc;
+}
+
+/**
+ *	llc_ui_shutdown - shutdown a connect llc2 socket.
+ *	@sock: Socket to shutdown.
+ *	@how: What part of the socket to shutdown.
+ *
+ *	Shutdown a connected llc2 socket. Currently this function only supports
+ *	shutting down both sends and receives (2), we could probably make this
+ *	function such that a user can shutdown only half the connection but not
+ *	right now.
+ *	Returns: 0 upon success, negative otherwise.
+ */
+static int llc_ui_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+	int rc = -ENOTCONN;
+
+	lock_sock(sk);
+	if (sk->state != TCP_ESTABLISHED)
+		goto out;
+	rc = -EINVAL;
+	if (how != 2)
+		goto out;
+	rc = llc_ui_send_disc(sk);
+	if (!rc)
+	        llc_ui_wait_for_disc(sk, 255);
+	/* Wake up anyone sleeping in poll */
+	sk->state_change(sk);
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_connect - Connect to a remote llc2 mac + sap.
+ *	@sock: Socket which will be connected to the remote destination.
+ *	@uaddr: Remote and possibly the local address of the new connection.
+ *	@addr_len: Size of uaddr structure.
+ *	@flags: Operational flags specified by the user.
+ *
+ *	Connect to a remote llc2 mac + sap. The caller must specify the
+ *	destination mac and address to connect to. If the user previously
+ *	called bind(2) with a smac the user does not need to specify the source
+ *	address and mac.
+ *	This function will autobind if user did not previously call bind.
+ *	Returns: 0 upon success, negative otherwise.
+ */
+static int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,
+			  int addr_len, int flags)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+	struct net_device *dev;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (addr_len != sizeof(*addr))
+		goto out;
+	rc = -EAFNOSUPPORT;
+	if (addr->sllc_family != AF_LLC)
+		goto out;
+	/* bind connection to sap if user hasn't done it. */
+	if (sk->zapped) {
+		/* bind to sap with null dev, exclusive */
+		rc = llc_ui_autobind(sock, addr);
+		if (rc)
+			goto out;
+	}
+	if (!llc->dev) {
+		rtnl_lock();
+		dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+		rtnl_unlock();
+		if (!dev)
+			goto out;
+	} else
+		dev = llc->dev;
+	if (sk->type != SOCK_STREAM)
+		goto out;
+	rc = -EALREADY;
+	if (sock->state == SS_CONNECTING)
+		goto out;
+	sock->state = SS_CONNECTING;
+	sk->state   = TCP_SYN_SENT;
+	llc->link = llc_ui_next_link_no(llc->sap->laddr.lsap);
+	rc = llc_ui_send_conn(sk, llc->sap, addr, dev, llc->link);
+	if (rc) {
+		sock->state = SS_UNCONNECTED;
+		sk->state   = TCP_CLOSE;
+		goto out;
+	}
+	rc = llc_ui_wait_for_conn(sk, 255);
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_listen - allow a normal socket to accept incoming connections
+ *	@sock: Socket to allow incomming connections on.
+ *	@backlog: Number of connections to queue.
+ *
+ *	Allow a normal socket to accept incoming connections.
+ *	Returns 0 upon success, negative otherwise.
+ */
+static int llc_ui_listen(struct socket *sock, int backlog)
+{
+	struct sock *sk = sock->sk;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (sock->state != SS_UNCONNECTED)
+		goto out;
+	rc = -EOPNOTSUPP;
+	if (sk->type != SOCK_STREAM && sk->type != SOCK_SEQPACKET)
+		goto out;
+	rc = -EAGAIN;
+	if (sk->zapped)
+		goto out;
+	rc = 0;
+	if (!(unsigned)backlog)     /* BSDism */
+		backlog = 1;
+	if ((unsigned)backlog > SOMAXCONN)
+		backlog = SOMAXCONN;
+	sk->max_ack_backlog = backlog;
+	if (sk->state != TCP_LISTEN) {
+		sk->ack_backlog = 0;
+		sk->state = TCP_LISTEN;
+	}
+	sk->socket->flags |= __SO_ACCEPTCON;
+out:	release_sock(sk);
+	return rc;
+}
+
+static int llc_ui_wait_for_disc(struct sock *sk, int seconds)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int rc, timeout = seconds * HZ;
+
+	add_wait_queue_exclusive(sk->sleep, &wait);
+	for (;;) {
+		__set_current_state(TASK_INTERRUPTIBLE);
+		rc = 0;
+		if (sk->state != TCP_CLOSE)
+		timeout = schedule_timeout(timeout);
+		else
+			break;
+		rc = -ERESTARTSYS;
+		if (signal_pending(current))
+			break;
+		rc = -EAGAIN;
+		if (!timeout)
+			break;
+	}
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(sk->sleep, &wait);
+	return rc;
+}
+
+static int llc_ui_wait_for_conn(struct sock *sk, int seconds)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int rc, timeout = seconds * HZ;
+
+	add_wait_queue_exclusive(sk->sleep, &wait);
+	for (;;) {
+		__set_current_state(TASK_INTERRUPTIBLE);
+		rc = 0;
+		if (sk->state != TCP_ESTABLISHED)
+			timeout = schedule_timeout(timeout);
+		if (sk->state == TCP_ESTABLISHED) {
+			if (!LLC_UI_SK(sk)->core_sk)
+				rc = -EAGAIN;
+			break;
+		}
+		rc = -EAGAIN;
+		if (sk->state == TCP_CLOSE)
+			break;
+		rc = -ERESTARTSYS;
+		if (signal_pending(current))
+			break;
+		rc = -EAGAIN;
+		if (!timeout)
+			break;
+	}
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(sk->sleep, &wait);
+	return rc;
+}
+
+/**
+ *	llc_ui_accept - accept a new incoming connection.
+ *	@sock: Socket which connections arrive on.
+ *	@newsock: Socket to move incomming connection to.
+ *	@flags: User specified operational flags.
+ *
+ *	Accept a new incoming connection.
+ *	Returns 0 upon success, negative otherwise.
+ */
+static int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	struct sock *sk = sock->sk, *newsk;
+	struct sk_buff *skb;
+	int rc = -EOPNOTSUPP;
+
+	lock_sock(sk);
+	if (sk->type != SOCK_SEQPACKET && sk->type != SOCK_STREAM)
+		goto out;
+	rc = -EINVAL;
+	if (sock->state != SS_UNCONNECTED || sk->state != TCP_LISTEN)
+		goto out;
+	/* wait for a connection to arrive. */
+	do {
+		skb = skb_dequeue(&sk->receive_queue);
+		if (!skb) {
+			rc = -EWOULDBLOCK;
+			if (flags & O_NONBLOCK)
+				goto out;
+			interruptible_sleep_on(sk->sleep);
+			rc = -ERESTARTSYS;
+			if (signal_pending(current))
+				goto out;
+		}
+	} while (!skb);
+
+	rc = -EINVAL;
+	if(!skb->sk)
+		goto frees;
+	/* attach connection to a new socket. */
+	rc = llc_ui_create(newsock, sk->protocol);
+	if (rc)
+		goto frees;
+	rc = 0;
+	newsk		    = newsock->sk;
+	newsk->pair	    = NULL;
+	newsk->socket	    = newsock;
+	newsk->sleep	    = &newsock->wait;
+	newsk->zapped	    = 0;
+	newsk->state	    = TCP_ESTABLISHED;
+	newsock->state	    = SS_CONNECTED;
+	LLC_UI_SK(newsk)->sap	  = LLC_UI_SK(sk)->sap;
+	LLC_UI_SK(newsk)->dev     = LLC_UI_SK(sk)->dev;
+	LLC_UI_SK(newsk)->link    = LLC_SK(skb->sk)->link;
+	LLC_UI_SK(newsk)->core_sk = skb->sk;
+	memcpy(&LLC_UI_SK(newsk)->addr, &LLC_UI_SK(sk)->addr,
+	       sizeof(LLC_UI_SK(sk)->addr));
+	memcpy(LLC_UI_SK(newsk)->addr.sllc_dmac, LLC_SK(skb->sk)->daddr.mac,
+                IFHWADDRLEN);
+        LLC_UI_SK(newsk)->addr.sllc_dsap = LLC_SK(skb->sk)->daddr.lsap;
+	/* put orignal socket back into a clean listen state. */
+	sk->state		  = TCP_LISTEN;
+	sk->ack_backlog--;
+	llc_ui_insert_socket(newsk);
+	skb->sk = NULL;
+frees:	kfree_skb(skb);
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_recvmsg - copy received data to the socket user.
+ *	@sock: Socket to copy data from.
+ *	@msg: Various user space related information.
+ *	@size: Size of user buffer.
+ *	@flags: User specified flags.
+ *	@scm: Unknown.
+ *
+ *	Copy received data to the socket user.
+ *	Returns non-negative upon success, negative otherwise.
+ */
+static int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+			  int flags, struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;
+	struct sockaddr_llc saddr;
+	struct sk_buff *skb;
+	int rc = -ENOMEM, copied = 0;
+	int noblock = flags & MSG_DONTWAIT;
+
+	lock_sock(sk);
+	skb = skb_recv_datagram(sk, flags, noblock, &rc);
+	if (!skb)
+		goto out;
+	rc = -EPROTO;
+	if (skb->len < sizeof(saddr))
+		goto dgram_free;
+	/* remove saved sllc header. */
+	memcpy(&saddr, skb->head, sizeof(saddr));
+	skb_pull(skb, sizeof(saddr));
+	copied = skb->len;
+	if (copied > size) {
+		copied = size;
+		msg->msg_flags |= MSG_TRUNC;
+	}
+	rc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
+	if (rc)
+		goto dgram_free;
+	if (uaddr)
+		memcpy(uaddr, &saddr, sizeof(*uaddr));
+	msg->msg_namelen = sizeof(*uaddr);
+dgram_free:
+	skb_free_datagram(sk, skb); /* Free the datagram. */
+out:	release_sock(sk);
+	return rc ? : copied;
+}
+
+/**
+ *	llc_ui_sendmsg - Transmit data provided by the socket user.
+ *	@sock: Socket to transmit data from.
+ *	@msg: Various user related information.
+ *	@len: Length of data to transmit.
+ *	@scm: Unknown.
+ *
+ *	Transmit data provided by the socket user.
+ *	Returns non-negative upon success, negative otherwise.
+ */
+static int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, int len,
+			  struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	struct sockaddr_llc *addr = (struct sockaddr_llc *)msg->msg_name;
+	int flags = msg->msg_flags;
+	struct net_device *dev;
+	struct sk_buff *skb;
+	int rc = -EOPNOTSUPP, size = 0;
+
+	lock_sock(sk);
+	if (flags & ~MSG_DONTWAIT)
+		goto release;
+	rc = -EINVAL;
+	if (addr && msg->msg_namelen < sizeof(*addr))
+		goto release;
+	if (!addr && llc_ui_addr_null(&llc->addr))
+		goto release;
+	if (!addr)
+		addr = &llc->addr;
+	/* must bind connection to sap if user hasn't done it. */
+	if (sk->zapped) {
+		/* bind to sap with null dev, exclusive. */
+		rc = llc_ui_autobind(sock, addr);
+		if (rc)
+			goto release;
+	}
+	if (!llc->dev) {
+		rtnl_lock();
+		dev = dev_getbyhwaddr(addr->sllc_arphrd, addr->sllc_smac);
+		rtnl_unlock();
+		rc = -ENETUNREACH;
+		if (!dev)
+			goto release;
+	} else
+		dev = llc->dev;
+	size = dev->hard_header_len + len + llc_ui_header_len(sk, addr);
+	rc = -EMSGSIZE;
+	if (size > dev->mtu)
+		goto release;
+	skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &rc);
+	if (!skb)
+		goto release;
+	skb->sk  = sk;
+	skb->dev = dev;
+	skb_reserve(skb, dev->hard_header_len + llc_ui_header_len(sk, addr));
+	rc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	if (rc)
+		goto release;
+	if (addr->sllc_test) {
+		rc = llc_ui_send_llc1(llc->sap, skb, addr, LLC_TEST_PRIM);
+		goto out;
+	}
+	if (addr->sllc_xid) {
+		rc = llc_ui_send_llc1(llc->sap, skb, addr, LLC_XID_PRIM);
+		goto out;
+	}
+	if (sk->type == SOCK_DGRAM || addr->sllc_ua) {
+		rc = llc_ui_send_llc1(llc->sap, skb, addr, LLC_DATAUNIT_PRIM);
+		goto out;
+	}
+	rc = -ENOPROTOOPT;
+	if (!(sk->type == SOCK_STREAM && !addr->sllc_ua))
+		goto out;
+	rc = -ENOTCONN;
+	if (!llc->core_sk)
+		goto out;
+	rc = llc_ui_send_data(llc->sap, sk, skb, addr);
+out:	if (rc)
+		skb_free_datagram(sk, skb);
+release:
+	release_sock(sk);
+	return rc ? : len;
+}
+
+/**
+ *	llc_ui_getname - return the address info of a socket
+ *	@sock: Socket to get address of.
+ *	@uaddr: Address structure to return information.
+ *	@uaddr_len: Length of address structure.
+ *	@peer: Does user want local or remote address information.
+ *
+ *	Return the address information of a socket.
+ */
+static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
+			  int *uaddr_len, int peer)
+{
+	struct sockaddr_llc sllc;
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	int rc = 0;
+
+	lock_sock(sk);
+	if (sk->zapped)
+		goto out;
+	*uaddr_len = sizeof(sllc);
+	memset(uaddr, 0, *uaddr_len);
+	if (peer) {
+		rc = -ENOTCONN;
+		if (sk->state != TCP_ESTABLISHED)
+			goto out;
+		if(llc->dev)
+			sllc.sllc_arphrd = llc->dev->type;
+		sllc.sllc_dsap = LLC_SK(llc->core_sk)->daddr.lsap;
+		memcpy(&sllc.sllc_dmac, &LLC_SK(llc->core_sk)->daddr.mac,
+		       IFHWADDRLEN);
+	} else {
+		rc = -EINVAL;
+		if (!llc->sap)
+			goto out;
+		sllc.sllc_ssap = llc->sap->laddr.lsap;
+
+		if (llc->dev) {
+			sllc.sllc_arphrd = llc->dev->type;
+			memcpy(&sllc.sllc_smac, &llc->dev->dev_addr,
+			       IFHWADDRLEN);
+		}
+	}
+	rc = 0;
+	sllc.sllc_family = AF_LLC;
+	memcpy(uaddr, &sllc, sizeof(sllc));
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_ioctl - io controls for PF_LLC
+ *	@sock: Socket to get/set info
+ *	@cmd: command
+ *	@arg: optional argument for cmd
+ *
+ *	get/set info on llc sockets
+ */
+static int llc_ui_ioctl(struct socket *sock, unsigned int cmd,
+			unsigned long arg)
+{
+	return dev_ioctl(cmd, (void *)arg);
+}
+
+/**
+ *	llc_ui_setsockopt - set various connection specific parameters.
+ *	@sock: Socket to set options on.
+ *	@level: Socket level user is requesting operations on.
+ *	@optname: Operation name.
+ *	@optval User provided operation data.
+ *	@optlen: Length of optval.
+ *
+ *	Set various connection specific parameters.
+ */
+static int llc_ui_setsockopt(struct socket *sock, int level, int optname,
+			     char *optval, int optlen)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	int rc = -EINVAL, opt;
+
+	lock_sock(sk);
+	if (level != SOL_LLC || optlen != sizeof(int))
+		goto out;
+	rc = -ENOTCONN;
+	if (!llc->core_sk)
+		goto out;
+	rc = get_user(opt, (int *)optval);
+	if (rc)
+		goto out;
+	rc = -EINVAL;
+	switch (optname) {
+		case LLC_OPT_RETRY:
+			if (opt > LLC_OPT_MAX_RETRY)
+				goto out;
+			LLC_SK(llc->core_sk)->n2 = opt;
+			break;
+		case LLC_OPT_SIZE:
+			if (opt > LLC_OPT_MAX_SIZE)
+				goto out;
+			LLC_SK(llc->core_sk)->n1 = opt;
+			break;
+		case LLC_OPT_ACK_TMR_EXP:
+			if (opt > LLC_OPT_MAX_ACK_TMR_EXP)
+				goto out;
+			LLC_SK(llc->core_sk)->ack_timer.expire = opt;
+			break;
+		case LLC_OPT_P_TMR_EXP:
+			if (opt > LLC_OPT_MAX_P_TMR_EXP)
+				goto out;
+			LLC_SK(llc->core_sk)->pf_cycle_timer.expire = opt;
+			break;
+		case LLC_OPT_REJ_TMR_EXP:
+			if (opt > LLC_OPT_MAX_REJ_TMR_EXP)
+				goto out;
+			LLC_SK(llc->core_sk)->rej_sent_timer.expire = opt;
+			break;
+		case LLC_OPT_BUSY_TMR_EXP:
+			if (opt > LLC_OPT_MAX_BUSY_TMR_EXP)
+				goto out;
+			LLC_SK(llc->core_sk)->busy_state_timer.expire = opt;
+			break;
+		case LLC_OPT_TX_WIN:
+			if (opt > LLC_OPT_MAX_WIN)
+				goto out;
+			LLC_SK(llc->core_sk)->k = opt;
+			break;
+		case LLC_OPT_RX_WIN:
+			if (opt > LLC_OPT_MAX_WIN)
+				goto out;
+			LLC_SK(llc->core_sk)->rw = opt;
+			break;
+		default:
+			rc = -ENOPROTOOPT;
+			goto out;
+	}
+	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_getsockopt - get connection specific socket info
+ *	@sock: Socket to get information from.
+ *	@level: Socket level user is requesting operations on.
+ *	@optname: Operation name.
+ *	@optval: Variable to return operation data in.
+ *	@optlen: Length of optval.
+ *
+ *	Get connection specific socket information.
+ */
+static int llc_ui_getsockopt(struct socket *sock, int level, int optname,
+			     char *optval, int *optlen)
+{
+	struct sock *sk = sock->sk;
+	struct llc_ui_opt *llc = LLC_UI_SK(sk);
+	int val = 0, len = 0, rc = -EINVAL;
+
+	lock_sock(sk);
+	if (level != SOL_LLC)
+		goto out;
+	rc = -ENOTCONN;
+	if (!llc->core_sk)
+		goto out;
+	rc = get_user(len, optlen);
+	if (rc)
+		goto out;
+	rc = -EINVAL;
+	if (len != sizeof(int))
+		goto out;
+	switch (optname) {
+		case LLC_OPT_RETRY:
+			val = LLC_SK(llc->core_sk)->n2;
+			break;
+		case LLC_OPT_SIZE:
+			val = LLC_SK(llc->core_sk)->n1;
+			break;
+		case LLC_OPT_ACK_TMR_EXP:
+			val = LLC_SK(llc->core_sk)->ack_timer.expire;
+			break;
+		case LLC_OPT_P_TMR_EXP:
+			val = LLC_SK(llc->core_sk)->pf_cycle_timer.expire;
+			break;
+		case LLC_OPT_REJ_TMR_EXP:
+			val = LLC_SK(llc->core_sk)->rej_sent_timer.expire;
+			break;
+		case LLC_OPT_BUSY_TMR_EXP:
+			val = LLC_SK(llc->core_sk)->busy_state_timer.expire;
+			break;
+		case LLC_OPT_TX_WIN:
+			val = LLC_SK(llc->core_sk)->k;
+			break;
+		case LLC_OPT_RX_WIN:
+			val = LLC_SK(llc->core_sk)->rw;
+			break;
+		default:
+			rc = -ENOPROTOOPT;
+			goto out;
+	}
+	rc = 0;
+	if (put_user(len, optlen) || copy_to_user(optval, &val, len))
+		rc = -EFAULT;
+out:	release_sock(sk);
+	return rc;
+}
+
+/**
+ *	llc_ui_ind_test - handle TEST indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle TEST indication.
+ */
+static void llc_ui_ind_test(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_test *prim_data = &prim->data->test;
+	struct sockaddr_llc *llc;
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sock *sk = llc_ui_find_sk_by_addr(&prim_data->daddr, 
+		&prim_data->saddr, skb->dev);
+
+	if (!sk)
+		goto out;
+	if (sk->state == TCP_LISTEN)
+		goto out_put;
+	skb2 = skb_copy_expand(skb, sizeof(*llc), 0, GFP_ATOMIC);
+	if (!skb2)
+		goto out_put;
+	/* save primitive for use by the user. (pulled in recvmsg) */
+	llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(*llc));
+	llc->sllc_family = AF_LLC;
+	llc->sllc_arphrd = skb->dev->type;
+	llc->sllc_test   = 1;
+	llc->sllc_xid    = 0;
+	llc->sllc_ua     = 0;
+	llc->sllc_dsap = prim_data->daddr.lsap;
+	memcpy(llc->sllc_dmac, prim_data->daddr.mac, IFHWADDRLEN);
+	llc->sllc_ssap = prim_data->saddr.lsap;
+	memcpy(llc->sllc_smac, prim_data->saddr.mac, IFHWADDRLEN);
+	/* queue skb to the user. */
+	if (sock_queue_rcv_skb(sk, skb2) < 0)
+		kfree_skb(skb2);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_ind_xid - handle XID indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle XID indication.
+ */
+static void llc_ui_ind_xid(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_xid *prim_data = &prim->data->xid;
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sockaddr_llc *llc;
+	struct sock *sk = llc_ui_find_sk_by_addr(&prim_data->daddr, 
+		&prim_data->saddr, skb->dev);
+
+	if (!sk)
+		goto out;
+	if (sk->state == TCP_LISTEN)
+		goto out_put;
+	skb2 = skb_copy_expand(skb, sizeof(*llc), 0, GFP_ATOMIC);
+	if (!skb2)
+		goto out_put;
+	/* save primitive for use by the user. (pulled in
+	 * recvmsg) */
+	llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(*llc));
+	llc->sllc_family = AF_LLC;
+	llc->sllc_arphrd = 0;
+	llc->sllc_test   = 0;
+	llc->sllc_xid    = 1;
+	llc->sllc_ua     = 0;
+	llc->sllc_dsap = prim_data->daddr.lsap;
+	memcpy(llc->sllc_dmac, prim_data->daddr.mac, IFHWADDRLEN);
+	llc->sllc_ssap = prim_data->saddr.lsap;
+	memcpy(llc->sllc_smac, prim_data->saddr.mac, IFHWADDRLEN);
+	/* queue skb to the user. */
+	if (sock_queue_rcv_skb(sk, skb2) < 0)
+		kfree_skb(skb2);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_ind_dataunit - handle DATAUNIT indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle DATAUNIT indication.
+ */
+static void llc_ui_ind_dataunit(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_unit_data *prim_data = &prim->data->udata;
+	struct sockaddr_llc *llc;
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sock *sk = llc_ui_find_sk_by_addr(&prim_data->daddr, 
+		&prim_data->saddr, skb->dev);
+
+	if (!sk)
+		goto out;
+	if (sk->state == TCP_LISTEN)
+		goto out_put;
+	skb2 = skb_copy_expand(skb, sizeof(*llc), 0, GFP_ATOMIC);
+	if (!skb2)
+		goto out_put;
+	/* save primitive for use by the user. (pulled in
+	 * recvmsg) */
+	llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(*llc));
+	llc->sllc_family = AF_LLC;
+	llc->sllc_arphrd = skb->dev->type;
+	llc->sllc_test   = 0;
+	llc->sllc_xid    = 0;
+	llc->sllc_ua     = 1;
+	llc->sllc_dsap = prim_data->daddr.lsap;
+	memcpy(llc->sllc_dmac, prim_data->daddr.mac, IFHWADDRLEN);
+	llc->sllc_ssap = prim_data->saddr.lsap;
+	memcpy(llc->sllc_smac, prim_data->saddr.mac, IFHWADDRLEN);
+	/* queue skb to the user. */
+	if (sock_queue_rcv_skb(sk, skb2) < 0)
+		kfree_skb(skb2);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_ind_conn - handle CONNECT indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle CONNECT indication.
+ */
+static void llc_ui_ind_conn(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_conn *prim_data = &prim->data->conn;
+	struct sock* sk;
+	struct sk_buff *skb2;
+
+	LLC_SK(prim_data->sk)->laddr.lsap = prim->sap->laddr.lsap;
+	sk = llc_ui_find_sk_by_addr(&LLC_SK(prim_data->sk)->laddr,
+				    &prim_data->saddr,
+				    prim_data->dev);
+	if (!sk)
+		goto out;
+	if (sk->type != SOCK_STREAM || sk->state != TCP_LISTEN)
+		goto out_put;
+	if (prim->data->conn.status)
+		goto out_put; /* bad status. */
+	/* give this connection a link number. */
+	LLC_SK(prim_data->sk)->link =
+		llc_ui_next_link_no(LLC_SK(prim_data->sk)->laddr.lsap);
+	skb2 = alloc_skb(0, GFP_ATOMIC);
+	if (!skb2)
+		goto out_put;
+	skb2->sk = prim_data->sk;
+	skb_queue_tail(&sk->receive_queue, skb2);
+	sk->state_change(sk);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_ind_data - handle DATA indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle CONNECT indication.
+ */
+static void llc_ui_ind_data(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_data *prim_data = &prim->data->data;
+	struct sockaddr_llc *llc;
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sock *sk = llc_ui_find_sk_by_link_no(prim->sap, prim_data->link);
+
+	if (!sk)
+		goto out;
+	if (sk->type != SOCK_STREAM || sk->state != TCP_ESTABLISHED)
+		goto out_put;
+	skb2 = skb_copy_expand(skb, sizeof(*llc), 0, GFP_ATOMIC);
+	if (!skb2)
+		goto out_put;
+	/* save primitive for use by the user. (pulled in recvmsg) */
+	llc = (struct sockaddr_llc *)skb_push(skb2, sizeof(*llc));
+	llc->sllc_family = AF_LLC;
+	llc->sllc_arphrd = skb->dev->type;
+	llc->sllc_test   = 0;
+	llc->sllc_xid    = 0;
+	llc->sllc_ua     = 0;
+	llc->sllc_dsap	 = LLC_UI_SK(sk)->sap->laddr.lsap;
+	memcpy(llc->sllc_dmac, LLC_SK(prim_data->sk)->laddr.mac, IFHWADDRLEN);
+	llc->sllc_ssap = LLC_SK(prim_data->sk)->daddr.lsap;
+	memcpy(llc->sllc_smac, LLC_SK(prim_data->sk)->daddr.mac, IFHWADDRLEN);
+	/* queue skb to the user. */
+	if (sock_queue_rcv_skb(sk, skb2))
+		kfree_skb(skb2);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_ind_disc - handle DISC indication
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle DISC indication.
+ */
+static void llc_ui_ind_disc(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_disc *prim_data = &prim->data->disc;
+	struct sock *sk = llc_ui_find_sk_by_link_no(prim->sap, prim_data->link);
+
+	if (!sk)
+		goto out;
+	if (sk->type != SOCK_STREAM || sk->state != TCP_ESTABLISHED)
+		goto out_put;
+	LLC_UI_SK(sk)->core_sk = NULL;
+	sk->socket->state  = SS_UNCONNECTED;
+	sk->state	   = TCP_CLOSE;
+	if (!sk->dead) {
+		sk->state_change(sk);
+		sk->dead = 1;
+	}
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_indicate - LLC user interface hook into the LLC layer.
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	LLC user interface hook into the LLC layer, every llc_ui sap references
+ *	this function as its indicate handler.
+ *	Always returns 0 to indicate reception of primitive.
+ */
+static int llc_ui_indicate(struct llc_prim_if_block *prim)
+{
+	switch (prim->prim) {
+		case LLC_TEST_PRIM:
+			llc_ui_ind_test(prim);		break;
+		case LLC_XID_PRIM:
+			llc_ui_ind_xid(prim);		break;
+		case LLC_DATAUNIT_PRIM:
+			llc_ui_ind_dataunit(prim);	break;
+		case LLC_CONN_PRIM:
+			llc_ui_ind_conn(prim);		break;
+		case LLC_DATA_PRIM:
+			llc_ui_ind_data(prim);		break;
+		case LLC_DISC_PRIM:
+			llc_ui_ind_disc(prim);		break;
+		case LLC_RESET_PRIM:
+		case LLC_FLOWCONTROL_PRIM:
+		default:				break;
+	}
+	return 0;
+}
+
+/**
+ *	llc_ui_conf_conn - handle CONN confirm.
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle CONN confirm.
+ */
+static void llc_ui_conf_conn(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_conn *prim_data = &prim->data->conn;
+	struct sock *sk = llc_ui_find_sk_by_addr(&LLC_SK(prim_data->sk)->laddr,
+						 &LLC_SK(prim_data->sk)->daddr,
+						 prim_data->dev);
+
+	if (!sk)
+		goto out;
+	if (sk->type != SOCK_STREAM || sk->state != TCP_SYN_SENT)
+		goto out_put;
+	if (!prim->data->conn.status) {
+		sk->socket->state      = SS_CONNECTED;
+		sk->state	       = TCP_ESTABLISHED;
+		LLC_UI_SK(sk)->core_sk = prim_data->sk;
+	} else {
+		sk->socket->state      = SS_UNCONNECTED;
+		sk->state	       = TCP_CLOSE;
+		LLC_UI_SK(sk)->core_sk = NULL;
+	}
+	sk->state_change(sk);
+	wake_up_interruptible(sk->sleep);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_conf_data - handle DATA confirm.
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle DATA confirm.
+ */
+static void llc_ui_conf_data(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_data *prim_data = &prim->data->data;
+	struct sock *sk = llc_ui_find_sk_by_link_no(prim->sap, prim_data->link);
+
+	if (sk) {
+		wake_up(sk->sleep);
+		sock_put(sk);
+	}
+}
+
+/**
+ *	llc_ui_conf_disc - handle DISC confirm.
+ *	@prim: Primitive block provided by the llc layer.
+ *
+ *	handle DISC confirm.
+ */
+static void llc_ui_conf_disc(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_disc *prim_data = &prim->data->disc;
+	struct sock *sk = llc_ui_find_sk_by_link_no(prim->sap, prim_data->link);
+
+	if (!sk)
+		goto out;
+	if (sk->type != SOCK_STREAM || sk->state != TCP_CLOSING)
+		goto out_put;
+	LLC_UI_SK(sk)->core_sk = NULL;
+	sk->socket->state      = SS_UNCONNECTED;
+	sk->state	       = TCP_CLOSE;
+	sk->state_change(sk);
+	wake_up_interruptible(sk->sleep);
+out_put:
+	sock_put(sk);
+out:;
+}
+
+/**
+ *	llc_ui_confirm - LLC user interface hook into the LLC layer
+ *	@prim: Primative block provided by the llc layer.
+ *
+ *	LLC user interface hook into the LLC layer, every llc_ui sap references
+ *	this function as its confirm handler.
+ *	Always returns 0 to indicate reception of primitive.
+ */
+static int llc_ui_confirm(struct llc_prim_if_block *prim)
+{
+	switch (prim->prim) {
+		case LLC_CONN_PRIM:
+			llc_ui_conf_conn(prim);		break;
+		case LLC_DATA_PRIM:
+			llc_ui_conf_data(prim);		break;
+		case LLC_DISC_PRIM:
+			llc_ui_conf_disc(prim);		break;
+		case LLC_RESET_PRIM:			break;
+		default:
+			printk(KERN_ERR __FUNCTION__ ": unknown prim %d\n",
+			       prim->prim);
+			break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+/**
+ *	llc_ui_get_info - return info to procfs
+ *	@buffer: where to put the formatted output
+ *	@start: starting from
+ *	@offset: offset into buffer.
+ *	@length: size of the buffer
+ *
+ *	Get the output of the local llc ui socket list to the caller.
+ *	Returns the length of data wrote to buffer.
+ */
+static int llc_ui_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	off_t pos = 0;
+	off_t begin = 0;
+	struct sock *s;
+	int len = sprintf(buffer, "SocketID SKt Mc local_mac_sap          "
+				  "remote_mac_sap         tx_queue "
+				  "rx_queue st uid link_no\n");
+
+	/* Output the LLC socket data for the /proc filesystem */
+	read_lock_bh(&llc_ui_sockets_lock);
+	for (s = llc_ui_sockets; s; s = s->next) {
+		struct llc_ui_opt *llc = LLC_UI_SK(s);
+		len += sprintf(buffer + len, "%p ", s);
+		len += sprintf(buffer + len, "%02X  ", s->type);
+		len += sprintf(buffer + len, "%02X ",
+			       !llc_ui_mac_null(llc->addr.sllc_mmac));
+		if (llc->sap) {
+			if (llc->dev && llc_ui_mac_null(llc->addr.sllc_mmac))
+				len += sprintf(buffer + len,
+					"%02X:%02X:%02X:%02X:%02X:%02X",
+					llc->dev->dev_addr[0],
+					llc->dev->dev_addr[1],
+					llc->dev->dev_addr[2],
+					llc->dev->dev_addr[3],
+					llc->dev->dev_addr[4],
+					llc->dev->dev_addr[5]);
+			else {
+				if (!llc_ui_mac_null(llc->addr.sllc_mmac))
+					len += sprintf(buffer + len,
+						"%02X:%02X:%02X:%02X:%02X:%02X",
+						llc->addr.sllc_mmac[0],
+						llc->addr.sllc_mmac[1],
+						llc->addr.sllc_mmac[2],
+						llc->addr.sllc_mmac[3],
+						llc->addr.sllc_mmac[4],
+						llc->addr.sllc_mmac[5]);
+				else
+					len += sprintf(buffer + len,
+						"%02X:%02X:%02X:%02X:%02X:%02X",
+						0, 0, 0, 0, 0, 0);
+			}
+			len += sprintf(buffer + len, "@0x%02X ",
+					llc->sap->laddr.lsap);
+		} else
+			len += sprintf(buffer + len,
+				"%02X:%02X:%02X:%02X:%02X:%02X@0x%02X ",
+				0, 0, 0, 0, 0, 0, 0);
+		len += sprintf(buffer + len,
+			"%02X:%02X:%02X:%02X:%02X:%02X@0x%02X ",
+			llc->addr.sllc_dmac[0], llc->addr.sllc_dmac[1],
+			llc->addr.sllc_dmac[2], llc->addr.sllc_dmac[3],
+			llc->addr.sllc_dmac[4], llc->addr.sllc_dmac[5],
+			llc->addr.sllc_dsap);
+		len += sprintf(buffer + len, "%08X:%08X ",
+				atomic_read(&s->wmem_alloc),
+				atomic_read(&s->rmem_alloc));
+		len += sprintf(buffer + len,"%02X %-3d ", s->state,
+				SOCK_INODE(s->socket)->i_uid);
+		if (llc->core_sk)
+			len += sprintf(buffer + len, "%-7d\n",
+					LLC_SK(llc->core_sk)->link);
+		else
+			len += sprintf(buffer + len, "no_link\n");
+		/* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+
+		if (pos < offset) {
+			len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+		}
+		if (pos > offset + length)      /* We have dumped enough */
+			break;
+	}
+	read_unlock_bh(&llc_ui_sockets_lock);
+
+	/* The data in question runs from begin to begin + len */
+	*start = buffer + offset - begin;       /* Start of wanted data */
+	len -= offset - begin;	/* Remove unwanted header data from length */
+	if (len > length)
+		len = length;	/* Remove unwanted tail data from length */
+	return len;
+}
+#endif /* CONFIG_PROC_FS */
+
+static struct net_proto_family llc_ui_family_ops = {
+	family:	PF_LLC,
+	create:	llc_ui_create,
+};
+
+static struct proto_ops SOCKOPS_WRAPPED(llc_ui_ops) = {
+	family:		PF_LLC,
+	release:	llc_ui_release,
+	bind:		llc_ui_bind,
+	connect:	llc_ui_connect,
+	socketpair:	sock_no_socketpair,
+	accept:		llc_ui_accept,
+	getname:	llc_ui_getname,
+	poll:		datagram_poll,
+	ioctl:		llc_ui_ioctl,
+	listen:		llc_ui_listen,
+	shutdown:	llc_ui_shutdown,
+	setsockopt:	llc_ui_setsockopt,
+	getsockopt:	llc_ui_getsockopt,
+	sendmsg:	llc_ui_sendmsg,
+	recvmsg:	llc_ui_recvmsg,
+	mmap:		sock_no_mmap,
+	sendpage:	sock_no_sendpage,
+};
+
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(llc_ui, PF_LLC);
+
+int llc_ui_init(void)
+{
+	int i;
+
+	for (i = 0; i < 256; i++)
+		llc_ui_sap_link_no_max[i] = 0;
+	llc_ui_sap_last_autoport = LLC_SAP_DYN_START;
+	(void)sock_register(&llc_ui_family_ops);
+	proc_net_create("llc", 0, llc_ui_get_info);
+	printk(KERN_INFO "NET4.0 IEEE 802.2 User Interface SAPs, "
+			 "Jay Schulist, 2001\n");
+	return 0;
+}
+
+void llc_ui_exit(void)
+{
+	proc_net_remove("llc");
+	sock_unregister(PF_LLC);
+	return;
+}
diff -ruN linux-2.4.18-clean/net/llc/llc_stat.c linux/net/llc/llc_stat.c
--- linux-2.4.18-clean/net/llc/llc_stat.c	Wed Dec 31 19:00:00 1969
+++ linux/net/llc/llc_stat.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,207 @@
+/*
+ * llc_stat.c - Implementation of LLC station component state machine
+ * 		transitions
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/types.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_evnt.h>
+#include <net/llc_actn.h>
+#include <net/llc_stat.h>
+
+/* ------------------- COMMON STATION STATE transitions ------------------ */
+
+/* dummy last-transition indicator; common to all state transition groups */
+static struct llc_station_state_trans llc_stat_state_trans_n = {
+	NULL, 0, NULL			/* last entry for this state */
+};
+
+/* ------------------------ DOWN STATE transitions ----------------------- */
+
+/* state transition for LLC_STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK event */
+static llc_station_action_t llc_stat_down_state_actions_1[] = {
+	llc_station_ac_start_ack_timer,
+	llc_station_ac_set_retry_cnt_0,
+	llc_station_ac_set_xid_r_cnt_0,
+	llc_station_ac_send_null_dsap_xid_c,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_down_state_trans_1 = {
+	llc_stat_ev_enable_with_dup_addr_check,
+					LLC_STATION_STATE_DUP_ADDR_CHK,
+					llc_stat_down_state_actions_1
+};
+
+/* state transition for LLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK event */
+static llc_station_action_t llc_stat_down_state_actions_2[] = {
+	llc_station_ac_report_status,	/* STATION UP */
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_down_state_trans_2 = {
+	llc_stat_ev_enable_without_dup_addr_check,
+					LLC_STATION_STATE_UP,
+					llc_stat_down_state_actions_2
+};
+
+/* array of pointers; one to each transition */
+static struct llc_station_state_trans *llc_stat_dwn_state_trans[] = {
+	&llc_stat_down_state_trans_1,
+	&llc_stat_down_state_trans_2,
+	&llc_stat_state_trans_n
+};
+
+/* ------------------------- UP STATE transitions ------------------------ */
+/* state transition for LLC_STATION_EV_DISABLE_REQ event */
+static llc_station_action_t llc_stat_up_state_actions_1[] = {
+	llc_station_ac_report_status,	/* STATION DOWN */
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_up_state_trans_1 = {
+	llc_stat_ev_disable_req,	LLC_STATION_STATE_DOWN,
+					llc_stat_up_state_actions_1
+};
+
+/* state transition for LLC_STATION_EV_RX_NULL_DSAP_XID_C event */
+static llc_station_action_t llc_stat_up_state_actions_2[] = {
+	llc_station_ac_send_xid_r,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_up_state_trans_2 = {
+	llc_stat_ev_rx_null_dsap_xid_c,	LLC_STATION_STATE_UP,
+					llc_stat_up_state_actions_2
+};
+
+/* state transition for LLC_STATION_EV_RX_NULL_DSAP_TEST_C event */
+static llc_station_action_t llc_stat_up_state_actions_3[] = {
+	llc_station_ac_send_test_r,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_up_state_trans_3 = {
+	llc_stat_ev_rx_null_dsap_test_c,	LLC_STATION_STATE_UP,
+					llc_stat_up_state_actions_3
+};
+
+/* array of pointers; one to each transition */
+static struct llc_station_state_trans *llc_stat_up_state_trans [] = {
+	&llc_stat_up_state_trans_1,
+	&llc_stat_up_state_trans_2,
+	&llc_stat_up_state_trans_3,
+	&llc_stat_state_trans_n
+};
+
+/* ---------------------- DUP ADDR CHK STATE transitions ----------------- */
+/*
+ * state transition for LLC_STATION_EV_RX_NULL_DSAP_0_XID_R_XID_R_CNT_EQ
+ * event
+ */
+static llc_station_action_t llc_stat_dupaddr_state_actions_1[] = {
+	llc_station_ac_inc_xid_r_cnt_by_1,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_1 = {
+	llc_stat_ev_rx_null_dsap_0_xid_r_xid_r_cnt_eq,
+					LLC_STATION_STATE_DUP_ADDR_CHK,
+					llc_stat_dupaddr_state_actions_1
+};
+
+/*
+ * state transition for LLC_STATION_EV_RX_NULL_DSAP_1_XID_R_XID_R_CNT_EQ
+ * event
+ */
+static llc_station_action_t llc_stat_dupaddr_state_actions_2[] = {
+	llc_station_ac_report_status,	/* DUPLICATE ADDRESS FOUND */
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_2 = {
+	llc_stat_ev_rx_null_dsap_1_xid_r_xid_r_cnt_eq,
+					LLC_STATION_STATE_DOWN,
+					llc_stat_dupaddr_state_actions_2
+};
+
+/* state transition for LLC_STATION_EV_RX_NULL_DSAP_XID_C event */
+static llc_station_action_t llc_stat_dupaddr_state_actions_3[] = {
+	llc_station_ac_send_xid_r,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_3 = {
+	llc_stat_ev_rx_null_dsap_xid_c,	LLC_STATION_STATE_DUP_ADDR_CHK,
+					llc_stat_dupaddr_state_actions_3
+};
+
+/*
+ * state transition for LLC_STATION_EV_ACK_TMR_EXP_LT_RETRY_CNT_MAX_RETRY
+ * event
+ */
+static llc_station_action_t llc_stat_dupaddr_state_actions_4[] = {
+	llc_station_ac_start_ack_timer,
+	llc_station_ac_inc_retry_cnt_by_1,
+	llc_station_ac_set_xid_r_cnt_0,
+	llc_station_ac_send_null_dsap_xid_c,
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_4 = {
+	llc_stat_ev_ack_tmr_exp_lt_retry_cnt_max_retry,
+					LLC_STATION_STATE_DUP_ADDR_CHK,
+					llc_stat_dupaddr_state_actions_4
+};
+
+/*
+ * state transition for LLC_STATION_EV_ACK_TMR_EXP_EQ_RETRY_CNT_MAX_RETRY
+ * event
+ */
+static llc_station_action_t llc_stat_dupaddr_state_actions_5[] = {
+	llc_station_ac_report_status,	/* STATION UP */
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_5 = {
+	llc_stat_ev_ack_tmr_exp_eq_retry_cnt_max_retry,
+					LLC_STATION_STATE_UP,
+					llc_stat_dupaddr_state_actions_5
+};
+
+/* state transition for LLC_STATION_EV_DISABLE_REQ event */
+static llc_station_action_t llc_stat_dupaddr_state_actions_6[] = {
+	llc_station_ac_report_status,	/* STATION DOWN */
+	NULL
+};
+
+static struct llc_station_state_trans llc_stat_dupaddr_state_trans_6 = {
+	llc_stat_ev_disable_req,	LLC_STATION_STATE_DOWN,
+					llc_stat_dupaddr_state_actions_6
+};
+
+/* array of pointers; one to each transition */
+static struct llc_station_state_trans *llc_stat_dupaddr_state_trans[] = {
+	&llc_stat_dupaddr_state_trans_6,	// Request
+	&llc_stat_dupaddr_state_trans_4,	// Timer
+	&llc_stat_dupaddr_state_trans_5,
+	&llc_stat_dupaddr_state_trans_1,	// Receive frame
+	&llc_stat_dupaddr_state_trans_2,
+	&llc_stat_dupaddr_state_trans_3,
+	&llc_stat_state_trans_n
+};
+
+struct llc_station_state llc_station_state_table[LLC_NBR_STATION_STATES] = {
+	{ LLC_STATION_STATE_DOWN,	  llc_stat_dwn_state_trans },
+	{ LLC_STATION_STATE_DUP_ADDR_CHK, llc_stat_dupaddr_state_trans },
+	{ LLC_STATION_STATE_UP,		  llc_stat_up_state_trans }
+};
diff -ruN linux-2.4.18-clean/net/netbeui/Makefile linux/net/netbeui/Makefile
--- linux-2.4.18-clean/net/netbeui/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/Makefile	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,22 @@
+#
+# Makefile for the Linux NETBEUI layer.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+# We only get in/to here if CONFIG_NETBEUI = 'y' or 'm'
+
+O_TARGET := netbeui.o
+
+obj-y	:= llc_supp.o af_netb.o config.o dextab.o dgram_serve.o \
+	   name_serve.o nb_common.o proc.o query_serve.o session_serve.o \
+	   sock_dgram.o sock_name.o sock_session.o status_serve.o
+
+ifeq ($(CONFIG_NETBEUI),m)
+  obj-m += $(O_TARGET)
+endif
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.18-clean/net/netbeui/af_netb.c linux/net/netbeui/af_netb.c
--- linux-2.4.18-clean/net/netbeui/af_netb.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/af_netb.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,119 @@
+/*
+ * af_netb.c - Contains functions that supply socket system calls for NetBEUI
+ *             protocol stack which their names has a 'netbeui_' prefix, and
+ *             also some utility functions that their names has a 'nbso_'
+ *             prefix.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/uio.h>
+#include <linux/skbuff.h>
+#include <linux/netbeui.h>
+#include <net/sock.h>
+
+extern struct proto_ops nbso_name_proto_ops;
+extern struct proto_ops nbso_dgram_proto_ops;
+extern struct proto_ops nbso_session_proto_ops;
+
+/* Socket System Calls */
+/*
+ * Function: netbeui_create
+ *	Creates a NetBEUI socket.
+ * Parameters:
+ *	sock    : pointer to 'struct socket' that created by system before call
+ *	          of this function.
+ *	protocol: an integer that have protocol specific meaning and we do not
+ *	          use it.
+ * Returns: int
+ *	0       : if socket has been created successfully.
+ *	negative: if a fault occurs.
+ *                 -ESOCKTNOSUPPORT: Specified socket type NOT supported.
+ *                 -ENOMEM         : Out of memory condition.
+ */
+static int netbeui_create(struct socket *sock, int protocol)
+{
+	struct proto_ops *prot;
+	struct sock *sk;
+	int rc = 0;
+
+	MOD_INC_USE_COUNT;
+	switch (sock->type) {
+		case SOCK_STREAM:
+			prot = &nbso_session_proto_ops;
+			break;
+		case SOCK_DGRAM:
+			prot = &nbso_dgram_proto_ops;
+			break;
+		case SOCK_RAW:
+			prot = &nbso_name_proto_ops;
+			break;
+		case SOCK_SEQPACKET:
+		default:
+			rc = -ESOCKTNOSUPPORT;
+			goto err_notsupport;
+	}
+	sk = sk_alloc(PF_NETBEUI, GFP_KERNEL, 1);
+	if (!sk)
+		goto err_sk;
+	memset(NB_SK(sk), 0, sizeof(*NB_SK(sk)));
+	sock_init_data(sock, sk);
+	sock->ops = prot;
+	sk->state = NBSO_INIT;
+out:	return rc;
+err_sk: rc = -ENOMEM;
+err_notsupport:
+	MOD_DEC_USE_COUNT;
+	goto out;
+}
+
+/* Socket family declarations */
+static struct net_proto_family netbeui_family_ops = {
+        family:         PF_NETBEUI,
+        create:         netbeui_create,
+};
+
+/*
+ * Function: nbso_init
+ *	Initializes socket interface for servicing. This function is called
+ *	in start of NetBEUI module installation in kernel memory.
+ * Parameters: None
+ * Returns: int
+ *	0       : if operation is performed successfully.
+ *	negative: if a fault occurs.
+ */
+int nbso_init(void)
+{
+	return sock_register(&netbeui_family_ops);
+}
+
+/*
+ * Function: nbso_exit
+ *	Prepares socket interface for termination of NetBEUI module operation.
+ * Parameters: none
+ * Returns: int
+ *	0       : if operation is performed successfully.
+ *	negative: if a fault occurs.
+ */
+int nbso_exit(void)
+{
+	return sock_unregister(netbeui_family_ops.family);
+}
diff -ruN linux-2.4.18-clean/net/netbeui/config.c linux/net/netbeui/config.c
--- linux-2.4.18-clean/net/netbeui/config.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/config.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,408 @@
+/*
+ * config.c - Contains functions that configure or query NetBEUI parameters
+ *	      from API tools such as ioctl/setsockopt/getsockopt.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/errno.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+#include <linux/netbeui.h>
+
+/* Holds NetBIOS configurable parameters */
+config_t netbios_config = {
+	NETBEUI_DFLT_LINK_INACT_TMOUT,
+	NETBEUI_DFLT_TX_TMOUT,
+	NETBEUI_DFLT_TX_COUNT,
+	NETBEUI_DFLT_RSRC_TMOUT,
+	NETBEUI_DFLT_DATA_ACK_TMOUT
+};
+
+/*
+ * Function: nbcs_update_netbios_config
+ *	Updates NetBIOS parameters with new values while considers special
+ *	cases.
+ * Parameters:
+ *	newcfg: pointer to config_t which contains new values for NetBIOS
+ *	  	parameters.
+ * Returns: none
+ * Notes:
+ *	- Since most NetBIOS parameters are tuned automatically both in LLC
+ *	  and NetBEUI, this implementation contains only a subset.
+ *	- Setting value of parameter to zero means using NetBIOS defaults
+ *	- Two parameters "resource_timeout" and "data_ack_timeout" are added
+ *	  by this implementation.
+ */
+static void nbcs_update_netbios_config(config_t *newcfg)
+{
+	/* Setting INACT TMOUT */
+	if (!newcfg->inactivity_timeout)
+		netbios_config.inactivity_timeout =
+						NETBEUI_DFLT_LINK_INACT_TMOUT;
+	else if (newcfg->inactivity_timeout > NETBEUI_MAX_LINK_INACT_TMOUT)
+		netbios_config.inactivity_timeout =
+						NETBEUI_MAX_LINK_INACT_TMOUT;
+	else
+		netbios_config.inactivity_timeout = newcfg->inactivity_timeout;
+
+	/* Setting TX TMOUT */
+	if (!newcfg->transmit_timeout)
+		netbios_config.transmit_timeout = NETBEUI_DFLT_TX_TMOUT;
+	else if (newcfg->transmit_timeout > NETBEUI_MAX_TX_TMOUT)
+		netbios_config.transmit_timeout = NETBEUI_MAX_TX_TMOUT;
+	else
+		netbios_config.transmit_timeout = newcfg->transmit_timeout;
+
+	/* Setting TX COUNT */
+	if (!newcfg->transmit_count)
+		netbios_config.transmit_count = NETBEUI_DFLT_TX_COUNT;
+	else if (newcfg->transmit_count > NETBEUI_MAX_TX_COUNT)
+		netbios_config.transmit_count = NETBEUI_MAX_TX_COUNT;
+	else
+		netbios_config.transmit_count = newcfg->transmit_count;
+
+	/* Setting RSRC TMOUT */
+	if (!newcfg->resource_timeout)
+		netbios_config.resource_timeout = NETBEUI_DFLT_RSRC_TMOUT;
+	else if (newcfg->resource_timeout > NETBEUI_MAX_RSRC_TMOUT)
+		netbios_config.resource_timeout = NETBEUI_MAX_RSRC_TMOUT;
+	else
+		netbios_config.resource_timeout = newcfg->resource_timeout;
+
+	/* Setting DATA ACK TMOUT */
+	if (!newcfg->data_ack_timeout)
+		netbios_config.data_ack_timeout = NETBEUI_DFLT_DATA_ACK_TMOUT;
+	else if (newcfg->data_ack_timeout > NETBEUI_MAX_DATA_ACK_TMOUT)
+		netbios_config.data_ack_timeout = NETBEUI_MAX_DATA_ACK_TMOUT;
+	else
+		netbios_config.data_ack_timeout = newcfg->data_ack_timeout;
+}
+
+/*
+ * Function: nbcs_setsockopt
+ *	Sets SOL_NETBEUI layer options provided by setsockopt system call.
+ * Parameters:
+ *	sock   : pointer to socket structure
+ *	optname: option code
+ *	optval : pointer to new value of parameter (option)
+ *	optlen : length of option value in bytes.
+ * Returns:
+ *	0	     : if new value for option set successfully
+ *	-EOPNOTSUPP  : if option is not supported on socket type
+ *	-ENOTPROTOOPT: if NetBEUI layer does not support the option.
+ * Notes:
+ *	- Refer to Implementation documents for a complete description of
+ *	  NetBEUI layer options accessible from setsockopt.
+ *	- user buffer is checked in upper layer.
+ */
+int nbcs_setsockopt(struct socket *sock, int optname, void *optval, int optlen)
+{
+	struct sock *sk = sock->sk;
+	int rc = -ENOPROTOOPT;
+
+	if (optname == SO_URGENTACK) {
+		rc = -ENOTCONN;
+		if (NB_SK(sk)->u.st.session) {
+			__u8 urg_ack;
+
+			rc = -EFAULT;
+			if (get_user(urg_ack, (__u8 *)optval))
+				goto out;
+			rc = 0;
+			NB_SK(sk)->u.st.session->urgent_ack = urg_ack;
+		}
+	} else if (optname == SO_NBPARAM) {
+		config_t tmp_config;
+
+		rc = -EINVAL;
+		if (optlen != sizeof(netbios_config))
+			goto out;
+		rc = -EFAULT;
+		if (copy_from_user((void *)&tmp_config, optval, optlen))
+			goto out;
+		rc = 0;
+		nbcs_update_netbios_config(&tmp_config);
+	}
+out:	return rc;
+}
+
+/*
+ * Function: nbcs_getsockopt
+ *	Gets SOL_NETBEUI layer options requested by getsockopt system call.
+ * Parameters:
+ *	sock   : pointer to socket structure
+ *	optname: option code
+ *	optval : (VRP) pointer to buffer to save value of parameter (option)
+ *	optlen : (VRP) pointer length of option value in bytes.
+ * Returns:
+ *	0	     : if value of option is moved to optval successfully
+ *	-EOPNOTSUPP  : if option is not supported on socket type
+ *	-ENOTPROTOOPT: if NetBEUI layer does not support the option.
+ * Notes:
+ *	- Refer to Implementation documents for a complete description of
+ *	  NetBEUI layer options accessible from setsockopt.
+ *	- user buffer is checked in upper layer.
+ */
+int nbcs_getsockopt(struct socket *sock, int optname, void *optval, int *optlen)
+{
+	struct sock *sk = sock->sk;
+	int len, rc = -EFAULT;
+
+	if (get_user(len, (int *)optlen))
+		goto out;
+	if (optname == SO_URGENTACK) {
+		rc = -EOPNOTSUPP;
+		if (!NB_SK(sk)->u.st.session)
+			goto out;
+		len = MIN(len, sizeof(NB_SK(sk)->u.st.session->urgent_ack));
+		rc = -EFAULT;
+		if (copy_to_user(optval,
+				 (void *)&NB_SK(sk)->u.st.session->urgent_ack,
+		   		 len) || put_user(len, (int *)optlen))
+			goto out;
+		rc = 0;
+	} else if (optname == SO_NBPARAM) {
+		len = MIN(len, sizeof(netbios_config));
+		rc = -EFAULT;
+		if (copy_to_user(optval, (void *)&netbios_config, len) ||
+		    put_user(len, (int *)optlen))
+			goto out;
+		rc = 0;
+	} else
+		rc = -ENOPROTOOPT;
+out:	return rc;
+}
+
+/*
+ * Function: nbcs_purge_links
+ *	Disconnects links on a specific network device (if exist).
+ * Parameters:
+ *	dev : pointer to device that links on it must be disconnect.
+ *	flag: type of unbinding that specified by user. The
+ *	      NETBEUI_UNBIND_FLAG_SAFE flag means that protocol stack unbinds
+ *	      from the device only no links exist on it.
+ * Returns: int
+ *	zero    : if command be performed successfully.
+ *	negative: if command fails. error codes that bubble to user are
+ *	          dependent to cmd.
+ *	          -EISCONN: the device has some links as yet, but the
+ *	                    NETBEUI_UNBIND_FLAG_SAFE flag is specified.
+ */
+static int nbcs_purge_links(struct net_device *dev, unsigned char flag)
+{
+	int i, count, rc = 0;
+	dextab_t *ltbl = nbll_get_link_table();
+
+	spin_lock_bh(&ltbl->lock);
+	count = ltbl->count;
+	for (i = ltbl->reserved; count; i++, count--) {
+		link_t *nb_link = ltbl->addr[i];
+
+		if (nb_link->dev == dev) {
+			if (flag == NETBEUI_UNBIND_FLAG_DROP)
+				nbll_drop_link(nb_link->link);
+			else { /* NETBEUI_UNBIND_FLAG_SAFE */
+				rc = -EISCONN;
+				goto out;
+			}
+		}
+	}
+out:	spin_unlock_bh(&ltbl->lock);
+	return rc;
+}
+
+static int nbcs_config_bind(struct netbeui_cfg *usp)
+{
+	char name[IFNAMSIZ];
+	struct net_device *dev;
+	unsigned char reserved;
+	int i, rc = -EFAULT;
+
+	if (get_user(reserved, &usp->reserved))
+		goto out;
+	rc = -EINVAL;
+	if (reserved)
+		goto out;
+	rc = -EFAULT;
+	if (copy_from_user(name, usp->nif_name, IFNAMSIZ))
+		goto out;
+	rc = -ENOSPC;
+	write_lock_bh(&netbeui_adapters.lock);
+	if (netbeui_adapters.count == NETBEUI_MAX_ADAPTERS)
+		goto unlock_adapters;
+	rc = 0;
+	for (i = 0; i < netbeui_adapters.count; i++)
+		if (!strcmp(netbeui_adapters.dev[i]->name, name))
+			goto unlock_adapters; /* It binds already */
+	read_lock_bh(&dev_base_lock);
+	for (dev = dev_base; dev; dev = dev->next) {
+		if (strcmp(dev->name, name))
+			continue;
+		if (nbcm_apt_dev(dev)) {
+			dev_hold(dev);
+			netbeui_adapters.dev[netbeui_adapters.count] = dev;
+			netbeui_adapters.count++;
+			dev_mc_add(dev, netbeui_funcaddr(dev),
+			           dev->addr_len, 0);
+			goto unlock_dev_base;
+		} else {
+			rc = -EOPNOTSUPP;
+			goto unlock_dev_base;
+		}
+	}
+	rc = -ENODEV;
+unlock_dev_base:
+	read_unlock_bh(&dev_base_lock);
+unlock_adapters:
+	write_unlock_bh(&netbeui_adapters.lock);
+out:	return rc;
+}
+
+static int nbcs_config_unbind(struct netbeui_cfg *usp)
+{
+	char name[IFNAMSIZ];
+	unsigned char reserved, flag;
+	int i, rc = -EFAULT;
+
+	if (get_user(reserved, &usp->reserved))
+		goto out;
+	rc = -EINVAL;
+	if (reserved)
+		goto out;
+	rc = -EFAULT;
+	if (copy_from_user(name, usp->nif_name, IFNAMSIZ) ||
+	    get_user(flag, &usp->flag))
+		goto out;
+	write_lock_bh(&netbeui_adapters.lock);
+	for (i = 0; i < netbeui_adapters.count; i++) {
+		if (strcmp(netbeui_adapters.dev[i]->name, name))
+			continue;
+		rc = nbcs_purge_links(netbeui_adapters.dev[i], flag);
+		if (rc)
+			goto unlock;
+		dev_mc_delete(netbeui_adapters.dev[i],
+			      netbeui_funcaddr(netbeui_adapters.dev[i]),
+		              netbeui_adapters.dev[i]->addr_len, 0);
+		dev_put(netbeui_adapters.dev[i]);
+		netbeui_adapters.count--;
+		if (i < netbeui_adapters.count)
+			netbeui_adapters.dev[i] =
+				  netbeui_adapters.dev[netbeui_adapters.count];
+		netbeui_adapters.dev[netbeui_adapters.count] = NULL;
+		rc = 0;
+		goto unlock;
+	}
+	rc = -ENODEV;
+unlock:	write_unlock_bh(&netbeui_adapters.lock);
+out:	return rc;
+}
+
+/*
+ * Function: nbcs_config
+ *	Performs configuration actions on the NetBEUI via NBIOCCONFIG ioctl
+ *	command.
+ * Parameters:
+ *	usp: pointer to 'struct netbeui_cfg' that contains command and its
+ *	     arguments.
+ * Returns: int
+ *	zero    : if command is performed successfully.
+ *	negative: if command fails. error codes that bubble to user are
+ *	          dependent to usp->command.
+ *	          -EOPNOTSUPP: the command is not valid.
+ */
+static int nbcs_config(struct netbeui_cfg *usp)
+{
+	unsigned short command;
+	int lnn, snn, rc = -EFAULT;
+
+	if (get_user(command, &usp->command))
+		goto out;
+	switch (command) {
+		case NETBEUI_CFGCMD_NIF_UNBIND:
+			rc = nbcs_config_unbind(usp);
+			break;
+		case NETBEUI_CFGCMD_NIF_BIND:
+			rc = nbcs_config_bind(usp);
+			break;
+		case NETBEUI_CFGCMD_DROP_SESS:
+			if (get_user(lnn, &usp->ln_num) ||
+			    get_user(snn, &usp->sn_num))
+				break;
+			rc = -EINVAL;
+			if (lnn < 0 || lnn >= NETBEUI_MAX_LINKS ||
+			    snn < 1 || snn >= NETBEUI_MAX_SESSIONS)
+				break;
+			rc = nbss_drop_session(lnn, snn);
+			break;
+		case NETBEUI_CFGCMD_DROP_LINK:
+			if (get_user(lnn, &usp->ln_num))
+				break;
+			rc = -EINVAL;
+			if (lnn < 0 || lnn >= NETBEUI_MAX_LINKS)
+				break;
+			rc = nbll_drop_link(lnn);
+			break;
+		default:
+			rc = -EOPNOTSUPP;
+			break;
+	}
+out:	return rc;
+}
+
+/*
+ * Function: nbcs_ioctl
+ *	Provides NetBEUI level requests of ioctl() system call.
+ * Parameters:
+ *	cmd: code of command that must perform.
+ *	arg: pointer to appropriate data structure, related to command.
+ * Returns: int
+ *	zero    : if command be performed successfully.
+ *	negative: if command fails. error codes that bubble to user are
+ *	          dependent to cmd.
+ *	          -EOPNOTSUPP: the command is not valid.
+ */
+int nbcs_ioctl(unsigned int cmd, void *arg)
+{
+	int len, rc = -EOPNOTSUPP;
+
+	switch (cmd) {
+                case NBIOCGSTATUS: {
+			struct netbeui_status *usp = arg;
+
+			rc = -EFAULT;
+			if (get_user(len, &usp->buff_len))
+				break;
+			rc = -EINVAL;
+			if (len < NETBEUI_MIN_STATUS_BUFF_LEN)
+				break;
+			rc = nbst_obtain_status(usp->called_name,
+						usp->status_buff,
+						&usp->buff_len);
+			break;
+		}
+		case NBIOCCONFIG: {
+			struct netbeui_cfg *usp = arg;
+
+			rc = -EACCES;
+			if (!capable(CAP_NET_ADMIN))
+				break;
+			rc = nbcs_config(usp);
+			break;
+		}
+	}
+	return rc;
+}
diff -ruN linux-2.4.18-clean/net/netbeui/dextab.c linux/net/netbeui/dextab.c
--- linux-2.4.18-clean/net/netbeui/dextab.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/dextab.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,244 @@
+/*
+ * dextab.c - Contains functions that implement a dynamically expandable table.
+ * 	      The abstraction includes a data structure with a table of
+ * 	      addresses which expands in order of two. The table never shrinks.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/netbeui.h>
+
+/*
+ * Function: dextab_init
+ *	Initializes dextab_t structure
+ * Parameters:
+ *	tbl	: pointer to dextab_t to be initialized
+ *	reserved: number of entries to reserve from head of dextab. This value
+ *		  instructs other functions not to use those entries.
+ *	max_size: maximum number of entries the <tbl> can hold.
+ * Returns: none
+ * Note:
+ *	- There are two ways to initialize a dextab:
+ *		1- Staticly initializating when defining dextab_t
+ *		2- calling dextab_init
+ */
+void dextab_init(dextab_t *tbl, int reserved, int max_size)
+{
+	tbl->addr	= NULL;
+	tbl->size	= 0;
+	tbl->reserved	= reserved;
+	tbl->max_size	= max_size;
+	tbl->count	= 0;
+	spin_lock_init(&tbl->lock);
+}
+
+/*
+ * Function: dextab_expand
+ *	Expands table array of pointers in order of two. The old entries
+ *	contents are safely kept in their place.
+ * Parameters:
+ *	tbl	: pointer to dextab_t to be expanded
+ * Returns:
+ *	0	: If table expanded successfully.
+ *	non-zero: if table entry count has reached maximum size determined
+ *		  in initialization steps and if memory allocation failed.
+ *	Don't grab tbl->lock, dextab_add_insert_entry already does this
+ */
+static int dextab_expand(dextab_t *tbl)
+{
+	int new_size;
+	void **new_addr;
+	int rc = -1;
+
+	new_size = !tbl->size ? 16 : (tbl->size * 2);
+	/* Table size should not exceed maximum table size */
+	if (new_size > tbl->max_size) {
+		if (tbl->size < tbl->max_size)
+			new_size = tbl->max_size;
+		else
+			goto out;
+	}
+	new_addr = kmalloc(new_size * sizeof(void *), GFP_ATOMIC);
+	if (!new_addr)
+		goto out;
+	/* Copy previous data from old area to new one */
+	memset(new_addr, 0, new_size * sizeof(void *));
+	if (tbl->addr) {
+		memcpy(new_addr, tbl->addr, tbl->size * sizeof(void *));
+		kfree(tbl->addr);
+	}
+	tbl->addr = new_addr;
+	tbl->size = new_size;
+	rc = 0;
+out:	return rc;
+}
+
+/*
+ * Function: dextab_add_insert_entry
+ *	This is a back-end function which depending on its arguments creates
+ *	an entry or puts a pre-allocated entry into dextab. The front ends
+ *	are macros defined in header files.
+ * Parameters:
+ *	tbl	  : pointer to dextab_t to insert element into
+ *	entry_size: size of entry to add. if non-zero value passed, the memory
+ *		    is allocated with entry_size bytes.
+ *	entry	  : address of entry to insert into table
+ * Returns:
+ *	>=0	  : uopn successfull insertion into table, this is the index
+ *		    of entry in table.
+ * 	<0	  : unsuccessful insertion
+ * Note:
+ *	- The entry_size and entry are exclusive arguments and entry_size
+ *	  precedes entry in decisions.
+ *	- Add means allocate and insert entry, which is usually indicated by
+ *	  setting entry_size to non-zero value.
+ *	- Insert means insert a pre-allocated entry, which is usually indicated
+ *	  by setting entry_size to zero and passing an address in entry.
+ */
+int __dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry)
+{
+	int index, rc = -1;
+
+	/* If you can find a free slot in table add entry there */
+	for (index = tbl->reserved; index < tbl->size; index++) {
+		if (tbl->addr[index])
+			continue;
+		tbl->addr[index] = entry_size > 0 ?
+		                   kmalloc(entry_size, GFP_ATOMIC) : entry;
+		if (tbl->addr[index]) {
+			tbl->count++;
+			rc = index;
+		}
+		goto out;
+	}
+	/* Try to expand table then retry again */
+	if (!dextab_expand(tbl)) {
+		rc = __dextab_add_insert_entry(tbl, entry_size, entry);
+		goto out;
+	}
+	/* Could not expand table return error */
+	rc = -1;
+out:	return rc;
+}
+
+int dextab_add_insert_entry(dextab_t *tbl, int entry_size, void *entry)
+{
+	int rc = -1;
+
+	spin_lock_bh(&tbl->lock);
+	rc = __dextab_add_insert_entry(tbl, entry_size, entry);
+	spin_unlock_bh(&tbl->lock);
+	return rc;
+}
+
+/*
+ * Function: dextab_remove_delete_index
+ *	This is a back-end function which depending on its arguments removes
+ *	destructs an entry from dextab. The front ends are macros defined in
+ *	header files.
+ * Parameters:
+ *	tbl	   : pointer to dextab_t to remove element from
+ *	entry_index: index of entry in table
+ *	flag	   : removal or deletion flag. Values are:
+ *			- DEXTAB_FREE_ENTRY
+ *			- DEXTAB_NOFREE_ENTRY (otherwise)
+ * Returns: none
+ * Note:
+ *	- The flag value is checked against DEXTAB_FREE_ENTRY
+ *	- Remove means delete entry from table and free its memory, This is
+ *	  indicated by setting qflag DEXTAB_FREE_ENTRY
+ *	- Delete means delete entry from memory, this is indicated by setting
+ *	  qflag to everything other than DEXTAB_FREE_ENTRY usually
+ *	  DEXTAB_NOFREE_ENTRY
+ */
+void __dextab_remove_delete_index(dextab_t *tbl, int entry_index, int flag)
+{
+	if (entry_index < tbl->size && entry_index >= tbl->reserved)
+		if (tbl->addr[entry_index]) {
+			if (flag == DEXTAB_FREE_ENTRY)
+				kfree(tbl->addr[entry_index]);
+			tbl->addr[entry_index] = NULL;
+			tbl->count--;
+		}
+}
+
+void dextab_remove_delete_index(dextab_t *tbl, int entry_index, int flag)
+{
+	spin_lock_bh(&tbl->lock);
+	__dextab_remove_delete_index(tbl, entry_index, flag);
+	spin_unlock_bh(&tbl->lock);
+}
+
+/*
+ * Function: dextab_entry_index
+ *	Returns index of an entry in table using its address.
+ * Parameters:
+ *	tbl  : pointer to dextab_t to find entry in
+ *	entry: address of entry to find in table
+ * Returns:
+ *	>= 0: index of entry found in table
+ *	< 0 : if entry not found in table
+ */
+int dextab_entry_index(dextab_t *tbl, void *entry)
+{
+	int index;
+
+	spin_lock_bh(&tbl->lock);
+	for (index = tbl->reserved; index < tbl->size; index++)
+		if (tbl->addr[index] == entry)
+			break;
+	if (index >= tbl->size)
+		index = -1;
+	spin_unlock_bh(&tbl->lock);
+	return index;
+}
+
+/*
+ * Function: dextab_count_entries
+ *	returns count of entries in dextab
+ * Parameters:
+ *	tbl	   : pointer to dextab_t to count its entries
+ * Returns:
+ *	>0	   : count of entries in table
+ */
+inline int __dextab_count_entries(dextab_t *tbl)
+{
+	return tbl->count;
+}
+
+inline int dextab_count_entries(dextab_t *tbl)
+{
+	int rc;
+
+	spin_lock_bh(&tbl->lock);
+	rc = __dextab_count_entries(tbl);
+	spin_unlock_bh(&tbl->lock);
+	return rc;
+}
+
+/*
+ * Function: dextab_destruct
+ *	housekeep a dextab, deallocates memories, ....
+ * Parameters:
+ *	tbl: pointer to dextab_t to destruct
+ * Returns: none
+ */
+void dextab_destruct(dextab_t *tbl)
+{
+	spin_lock_bh(&tbl->lock);
+	if (tbl->addr)
+		kfree(tbl->addr);
+	spin_unlock_bh(&tbl->lock);
+	dextab_init(tbl, tbl->reserved, tbl->max_size);
+}
diff -ruN linux-2.4.18-clean/net/netbeui/dgram_serve.c linux/net/netbeui/dgram_serve.c
--- linux-2.4.18-clean/net/netbeui/dgram_serve.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/dgram_serve.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,601 @@
+/*
+ * dgram_serve.c - Contains functions that supply DATAGRAM service for NetBEUI
+ *                 protocol stack, and also some utility functions.
+ *
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/string.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <net/sock.h>
+#include <linux/slab.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/netbeui.h>
+
+#ifndef spin_trylock_bh
+#define spin_trylock_bh(lock)   ({ int __r; local_bh_disable(); \
+                                   __r = spin_trylock(lock);    \
+                                   if (!__r) local_bh_enable(); \
+                                   __r; })
+#endif
+
+unsigned int dgbc_mtu;  /* DataGram BroadCast Maximum Transfer Unit */
+
+static struct {
+	spinlock_t	 lock;
+	name_dgrms_t	*obc;	/* One Behind Cache */
+	name_dgrms_t	*normal_list;
+	name_dgrms_t	*star_list;
+} nbdg_names = {
+	lock:	SPIN_LOCK_UNLOCKED,
+};
+
+/* Internal NBDG functions */
+/*
+ * Function: nbdg_find_name
+ *	Finds sightly name_dgrms structure address depend on its name in the
+ *	normal_list.
+ *
+ * Parameters:
+ *	name : pointer to name that must find its structure address.
+ *
+ * Returns: name_dgrms_t *
+ *	non NULL : address of related name_dgrms structure.
+ *	NULL     : means requested name not exist in normal_list.
+ */
+static inline name_dgrms_t *nbdg_find_name (char *name)
+{
+	name_dgrms_t *curr;
+
+	for (curr = nbdg_names.normal_list; curr; curr = curr->next)
+		if (!memcmp(curr->name, name, NETBEUI_NAME_LEN))
+			break;
+	return curr;
+}
+
+/*
+ * Function: nbdg_find_such_frame
+ *	Finds another frame in 'frameq' that has same "frame type" and
+ *	"source name" with 'skb'.
+ *
+ * Parameters:
+ *	skb : pointer to sk_buff that contains sightly frame.
+ *
+ * Returns: struct sk_buff *
+ *	non NULL : address of appropriate sk_buff.
+ *	NULL     : if no such frame exist in frameq.
+ */
+static struct sk_buff *nbdg_find_such_frame(struct sk_buff *skb)
+{
+	char source_name[NETBEUI_NAME_LEN];
+	dgram_t *hdrp = (dgram_t *)skb->data;
+	int frame_type = hdrp->command;
+	struct sk_buff_head *frameq = skb->list;
+
+	memcpy(source_name, hdrp->source_name, NETBEUI_NAME_LEN);
+	skb = skb->next;
+	while (skb != (struct sk_buff *)frameq) {
+		hdrp = (dgram_t *)skb->data;
+
+		if (hdrp->command == frame_type)
+			if (!memcmp(hdrp->source_name, source_name,
+			    NETBEUI_NAME_LEN))
+				return skb;
+		skb = skb->next;
+	}
+	return NULL;
+}
+
+/*
+ * Function: nbdg_enqueue_name
+ *	Enqueues a name_dgrms structure at begin of 'list' queue. it guards
+ *	code from race conditions by Lock/UnLock 'nbdg_names' structure.
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that must be inserted into
+ *	        the list.
+ *	list  : pointer to a pointer that points to first member of list.
+ *
+ * Returns: none
+ */
+static void nbdg_enqueue_name(name_dgrms_t *namep, name_dgrms_t **list)
+{
+	spin_lock_bh(&nbdg_names.lock);
+	namep->prev = NULL;
+	namep->next = *list;
+	*list = namep;
+	if (namep->next)
+		namep->next->prev = namep;
+	namep->list = list;
+	spin_unlock_bh(&nbdg_names.lock);
+}
+
+/*
+ * Function: nbdg_dequeue_name
+ *	Dequeues a name_dgrms structure from 'list' queue. it guards code
+ *	from race conditions by Lock/UnLock 'nbdg_names' structure.
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that must be removed from
+ *	        its list.
+ *
+ * Returns: none
+ */
+static void nbdg_dequeue_name(name_dgrms_t *namep)
+{
+	spin_lock_bh(&nbdg_names.lock);
+	if (namep->next)
+		namep->next->prev = namep->prev;
+	if (namep->prev)
+		namep->prev->next = namep->next;
+	else
+		*namep->list = namep->next;
+	spin_unlock_bh(&nbdg_names.lock);
+}
+
+/*
+ * Exported  NBDG  functions
+ */
+/*
+ * Function: nbdg_set_dgbc_mtu
+ *	Tunes the 'dgbc_mtu' global variable up to correct value. this function
+ *	is called at begin of protocol stack installation in kernel space, and
+ *	also must be called each time 'netbeui_adapters.dev[]' array altered.
+ *
+ * Parameters: none
+ *
+ * Returns: none
+ */
+void nbdg_set_dgbc_mtu(void)
+{
+	int i, tmp;
+
+	read_lock(&netbeui_adapters.lock);
+	if (!netbeui_adapters.dev[0])
+		goto out;
+	tmp = netbeui_adapters.dev[0]->mtu;
+	for (i = 1; i < NETBEUI_MAX_ADAPTERS && netbeui_adapters.dev[i]; i++)
+		tmp = MIN(tmp, netbeui_adapters.dev[i]->mtu);
+	dgbc_mtu = tmp - LLCMAC_UIB_HEADLEN() - NETBEUI_UILEN;
+out:	read_unlock(&netbeui_adapters.lock);
+}
+
+/*
+ * Function: nbdg_remove_unwanted_dgf
+ *	Removes frames in frame queue that contain up to 'len' bytes of data.
+ *	user program can uses this function by call ioctl() with SIOCRUWDGF
+ *	command. because we have not any mechanism in NetBEUI to recognize
+ *	message boundaries, this is user (program) that recognizes them and
+ *	announce us that Maximum 'len' bytes of remainder data is not
+ *	beneficial and can be removed. 'len' == 0 means that we must remove all
+ *	of such frames from queue.
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that operation perform on its
+ *	        frameq.
+ *	len   : maximum length which upper layer knows that is not usable.
+ *
+ * Returns: int
+ *	0 : this function always succeed.
+ */
+int nbdg_remove_unwanted_dgf(name_dgrms_t *namep, int len)
+{
+	struct sk_buff *skb = namep->curr_skb,
+	               *such_skb;
+	if (!skb)
+		return 0;  /* We are at begin of a message boundary now */
+	namep->curr_skb = NULL;
+	if (len) {
+		len -= skb->len;
+		while (len > 0) {
+			such_skb = nbdg_find_such_frame(skb);
+			skb_unlink(skb);
+			kfree_skb(skb);
+			if (!such_skb)
+				return 0;
+			skb = such_skb;
+			len -= skb->len;
+		}
+	} else /* Remove all of such frames */
+		while ((such_skb = nbdg_find_such_frame(skb))) {
+			skb_unlink(skb);
+			kfree_skb(skb);
+			skb = such_skb;
+		}
+	skb_unlink(skb);
+	kfree_skb(skb);
+	return 0;
+}
+
+/*
+ * Function: nbdg_register_peername
+ *	Registers a remote name for a local name. it causes that received
+ *	frames only from specified remote name be acceptable. broadcasted frames
+ *	will be accepted only if 'remote_name[0]' is equal to '*'.
+ *
+ * Parameters:
+ *	namep       : pointer to name_dgrms structure that remote name registers
+ *	              for it.
+ *	remote_name : pointer to remote name that must be registered.
+ *
+ * Returns: none
+ */
+void nbdg_register_peername(name_dgrms_t *namep, char *remote_name)
+{
+	if (remote_name[0] == '*') {
+		if (namep->list != &nbdg_names.star_list) {
+			nbdg_dequeue_name(namep);
+			nbdg_enqueue_name(namep, &nbdg_names.star_list);
+		}
+	} else
+		if (namep->list != &nbdg_names.normal_list) {
+			nbdg_dequeue_name(namep);
+			nbdg_enqueue_name(namep, &nbdg_names.normal_list);
+		}
+	namep->conn_name = remote_name;
+	namep->connected = 1;
+}
+
+/*
+ * Function: nbdg_deregister_peername
+ *	Deregisters a registered name for a local name. it causes that received
+ *	frames which are broadcasted or have our name in dest_name field of
+ *	their NetBIOS header, be acceptable.
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that must deregister its
+ *	        attached name.
+ *
+ * Returns: none
+ */
+void nbdg_deregister_peername(name_dgrms_t *namep)
+{
+	if (namep->conn_name[0] == '*') {
+		nbdg_dequeue_name(namep);
+		nbdg_enqueue_name(namep, &nbdg_names.normal_list);
+	}
+	namep->connected = 0;
+}
+
+/*
+ * Function: nbdg_add_name
+ *	Creates a name_dgrms structure and adds it to normal_list.
+ *
+ * Parameters:
+ *	local_name : pointer to name that must add its structure to normal_list.
+ *	wq         : pointer to a pointer that points to dependent wait_queue.
+ *	namep      : (VRP) pointer to a pointer buffer that in successful return
+ *	             contains address of related name_dgrms structure in list.
+ *
+ * Returns: int
+ *	0        : if operation is performed successfully.
+ *	negative : if a fault occurs.
+ *                  -ENOMEM : Out of memory condition.
+ */
+int nbdg_add_name(char *local_name, wait_queue_head_t *wq, name_dgrms_t **namep)
+{
+	name_dgrms_t *new = kmalloc(sizeof(name_dgrms_t), GFP_KERNEL);
+
+	if (!new)
+		return -ENOMEM;
+	memset(new, 0, sizeof(*new));
+	skb_queue_head_init(&new->frameq);
+	memcpy(new->name, local_name, NETBEUI_NAME_LEN);
+	new->waitq = wq;
+	init_waitqueue_head(new->waitq);
+	nbdg_enqueue_name(new, &nbdg_names.normal_list);
+	*namep = new;
+	return 0;
+}
+
+/*
+ * Function: nbdg_del_name
+ *	Removes a name_dgrms structure from its list.
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that must deleted.
+ *
+ * Returns: none
+ */
+void nbdg_del_name(name_dgrms_t *namep)
+{
+	spin_lock_bh(&nbdg_names.lock);
+	if (nbdg_names.obc == namep)
+		nbdg_names.obc = NULL;
+	spin_unlock_bh(&nbdg_names.lock);
+	nbdg_dequeue_name(namep);
+	skb_queue_purge(&namep->frameq);
+	kfree(namep);
+}
+
+/*
+ * Function: nbdg_receive_ready
+ *	Answers to the question "Do in transport layer exist any queued
+ *	received data for this name ?"
+ *
+ * Parameters:
+ *	namep : pointer to name_dgrms structure that question is about it.
+ *
+ * Returns: int
+ *	0  : means "OK, exist some data".
+ *	-1 : means "NO, not exist any queued received data as yet".
+ */
+int nbdg_receive_ready(name_dgrms_t *namep)
+{
+	return skb_queue_empty(&namep->frameq) ? -1 : 0 /* OK! */;
+}
+
+/*
+ * Function: nbdg_send
+ *	Sends datagrams to the sightly destination(s).
+ *
+ * Parameters:
+ *	local_name : pointer to name that must copied to source_name field of
+ *	             NetBIOS header of all sent frames.
+ *	dest_name  : pointer to name that must copied to dest_name field of
+ *	             NetBIOS header of all sent frames (target name).
+ *	dest_type  : type of destination of frames.
+ *	buff       : pointer to buffer that contains data that must be sent.
+ *	bufflen    : length of data buffer.
+ *
+ * Returns: int
+ *	positive : number of bytes that was sent.
+ *	negative : if a fault occurs.
+ *	           -ENOMEM       : Out of memory condition.
+ */
+int nbdg_send(struct sock *sk, char *local_name, char *dest_name,
+	      name_type_t dest_type, struct iovec *iov, int len, int noblock)
+{
+	int rc,
+	    fskbl,
+	    offset = 0,
+	    bytes_put = 0;
+	dgram_t hdr;
+	struct sk_buff *skb;
+	unsigned char *datap;
+
+	if (dest_name[0] == '*')
+		hdr.command = NETBEUI_DATAGRAM_BROADCAST;
+	else {
+		hdr.command = NETBEUI_DATAGRAM;
+		memcpy(hdr.dest_name, dest_name, NETBEUI_NAME_LEN);
+	}
+	hdr.length = NETBEUI_UILEN;
+	hdr.delimiter = NETBEUI_DELIMITER;
+	memcpy(hdr.source_name, local_name, NETBEUI_NAME_LEN);
+	fskbl = CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN, dgbc_mtu + NETBEUI_UILEN);
+	skb = sock_alloc_send_skb(sk, fskbl, noblock, &rc);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, LLCMAC_UIB_HEADLEN());
+	memcpy(skb_put(skb, sizeof(hdr)), &hdr, sizeof(hdr));
+
+	if (len > dgbc_mtu) {
+		datap = skb_put(skb, dgbc_mtu);
+		do {
+			rc = memcpy_fromiovecend(datap, iov, offset, dgbc_mtu);
+			if (rc)
+				goto out;
+			offset += dgbc_mtu;
+			bytes_put += dgbc_mtu;
+			len -= dgbc_mtu;
+			rc = nbll_uisend(NULL, skb);
+			if (rc)
+				goto out;
+		} while (len > dgbc_mtu); /* FIXME: > or >= ? */
+	}
+	if (len) {
+		skb_trim(skb, sizeof(hdr));
+		rc = memcpy_fromiovecend(skb_put(skb, len), iov, offset, len);
+		if (rc)
+			goto out;
+		bytes_put += len;
+
+		rc = nbll_uisend(NULL, skb);
+		if (rc)
+			goto out;
+	}
+	rc = bytes_put;
+out:	kfree_skb(skb);
+	return rc;
+}
+
+/*
+ * Function: nbdg_receive
+ *	Copies data that received and queued into user data buffer.
+ *
+ * Parameters:
+ *	namep       : pointer to name_dgrms that we want receive data that
+ *	              queued for it.
+ *	source_name : (VRP) pointer to a name buffer. if this parameter is not
+ *	              NULL at return the name buffer will be filled with message
+ *	              sender name.
+ *	dest_name   : (VRP) pointer to a name buffer. if this parameter is not
+ *	              NULL at return the name buffer will be filled with message
+ *	              destination name.
+ *	buff        : (VRP) pointer to data buffer. at return this buffer
+ *	              contains data that received.
+ *	bufflen     : indicates Maximum no of bytes that user wants to receive.
+ *	nonblock    : an integer that if be set to non-zero value means that
+ *	              no waiting (sleeping, blocking & ...) acceptable during
+ *	              operation.
+ *
+ * Returns: int
+ *	positive : no of bytes that was received.
+ *	negative : if a fault occurs.
+ *	           -EWOULDBLOCK : user requests non-blocking operation, but
+ *	                            operation would block.
+ *	           -ERESTARTSYS : interrupted system call.
+ */
+int nbdg_receive(name_dgrms_t *namep, char *source_name, char *dest_name,
+		 char *buff, int bufflen, int nonblock)
+{
+	int bytes_gotten = 0;
+	char *datap;
+	dgram_t *hdrp;
+	struct sk_buff *skb;
+
+	while (skb_queue_empty(&namep->frameq))
+		if (nonblock)
+			return -EWOULDBLOCK;
+		else {
+			interruptible_sleep_on(namep->waitq);
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		}
+	skb = namep->curr_skb;
+	if (!skb) {
+		skb = namep->curr_skb = skb_peek(&namep->frameq);
+		skb->len -= sizeof(dgram_t);
+	}
+	hdrp = (dgram_t *)skb->data;
+	datap = (char *)(skb->tail - skb->len);
+	if (source_name)
+		memcpy(source_name, hdrp->source_name, NETBEUI_NAME_LEN);
+	if (dest_name) {
+		if (hdrp->command == NETBEUI_DATAGRAM) {
+			if (copy_to_user(dest_name, hdrp->dest_name,
+						NETBEUI_NAME_LEN))
+				return -EFAULT;
+		} else
+			if (put_user('*', dest_name))
+				return -EFAULT;
+	}
+	while (bufflen) {
+		int len = MIN(bufflen, skb->len);
+
+		if (copy_to_user(buff, datap, len))
+			return -EFAULT;
+		buff += len;
+		bufflen -= len;
+		datap += len;
+		skb->len -= len;
+		bytes_gotten += len;
+
+		if (!skb->len) {  /* sk_buff copied completely */
+			struct sk_buff *such_skb = nbdg_find_such_frame(skb);
+
+			skb_unlink(skb);
+			kfree_skb(skb);
+			namep->curr_skb = such_skb;
+			if (!such_skb)  /* No any such frame */
+				return bytes_gotten;
+			skb = such_skb;
+			hdrp = (dgram_t *)skb->data;
+			skb->len -= sizeof(dgram_t);
+			datap = (char *)(hdrp + sizeof(dgram_t));
+		}
+	}
+	return bytes_gotten;
+}
+
+/*
+ * Function: nbdg_get_datagram
+ *	Takes a NETBEUI_DATAGRAM frame from 'llc supplementary' and place it on
+ *	appropriate frame queues.
+ *
+ * Parameters:
+ *	skb        : pointer to sk_buff that contains NETBEUI_DATAGRAM frame.
+ *
+ * Returns: none
+ */
+void nbdg_get_datagram(struct sk_buff *skb)
+{
+	dgram_t *hdrp;
+	name_dgrms_t *namep;
+
+	if (!spin_trylock_bh(&nbdg_names.lock))
+		goto drop;
+	/* Place a copy of the skb in frame queue of all star_list's members */
+	for (namep = nbdg_names.star_list; namep; namep = namep->next) {
+		struct sk_buff *new_skb = skb_clone(skb, GFP_ATOMIC);
+
+		if (!new_skb)
+			continue;
+		skb_queue_tail(&namep->frameq, new_skb);
+		wake_up_interruptible(namep->waitq);
+	}
+	hdrp = (dgram_t *)skb->data;
+
+	if (nbdg_names.obc && /* If One Behind Cache is not empty and ... */
+	    !memcmp(nbdg_names.obc->name, hdrp->dest_name, NETBEUI_NAME_LEN))
+		namep = nbdg_names.obc;
+	else {
+		namep = nbdg_find_name(hdrp->dest_name);
+		if (!namep)  /* No registered name for this sk_buff */
+			goto unlock_drop;
+		nbdg_names.obc = namep;
+	}
+	if (namep->connected)
+		/* To force short circuiting by compiler */
+		if (!memcmp(namep->conn_name, hdrp->source_name,
+			    NETBEUI_NAME_LEN))
+			/* Not connected to this source_name */
+			goto unlock_drop;
+	/* Now we find the apposite name */
+	skb_queue_tail(&namep->frameq, skb);
+	spin_unlock_bh(&nbdg_names.lock);
+	wake_up_interruptible(namep->waitq);
+out:	return;
+unlock_drop:
+	spin_unlock_bh(&nbdg_names.lock);
+drop:	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbdg_get_datagram_broadcast
+ *	Takes a NETBEUI_DATAGRAM_BROADCAST frame from 'llc supplementary' and
+ *	place it on appropriate frame queues.
+ *
+ * Parameters:
+ *	skb        : pointer to sk_buff that contains
+ *		     NETBEUI_DATAGRAM_BROADCAST frame.
+ *
+ * Returns: none
+ */
+void nbdg_get_datagram_broadcast(struct sk_buff *skb)
+{
+	name_dgrms_t *namep;
+	struct sk_buff *new_skb;
+
+	barrier();
+	if (!spin_trylock_bh(&nbdg_names.lock))
+		goto drop;
+	/* Place a copy of skb in frame queue of all star_list's members */
+	for (namep = nbdg_names.star_list; namep; namep = namep->next) {
+		new_skb = skb_clone(skb, GFP_ATOMIC);
+		if (!new_skb)
+			continue;
+		skb_queue_tail(&namep->frameq, new_skb);
+		wake_up_interruptible(namep->waitq);
+	}
+	for (namep = nbdg_names.normal_list; namep; namep = namep->next) {
+		if (namep->connected)
+			/* To force short circuiting by compiler */
+			if (memcmp(namep->conn_name,
+			           ((dgram_t *)skb->data)->source_name,
+			           NETBEUI_NAME_LEN))
+				/* Not connected to this source_name */
+				continue;
+		new_skb = skb_clone(skb, GFP_ATOMIC);
+		if (!new_skb)
+			continue;
+		skb_queue_tail(&namep->frameq, new_skb);
+		wake_up_interruptible(namep->waitq);
+	}
+	spin_unlock_bh(&nbdg_names.lock);
+drop:	kfree_skb(skb);
+}
diff -ruN linux-2.4.18-clean/net/netbeui/llc_supp.c linux/net/netbeui/llc_supp.c
--- linux-2.4.18-clean/net/netbeui/llc_supp.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/llc_supp.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,1461 @@
+/*
+ * llc_supp.c - Contains three category of functions
+ * 			1- functions that implement Link Service State Machine
+ * 			2- functions that simplify LLC interface layer services
+ *			3- dispatching functions
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/errno.h>
+#define __KERNEL_SYSCALLS__
+#include <linux/unistd.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <linux/init.h>
+#include <linux/llc.h>
+#include <linux/netbeui.h>
+
+static void nbll_timer_function(unsigned long input);
+/* These functions are Link State Transition handlers */
+static int nbll_conn_indicate_in_initial(link_t *nb_link);
+static int nbll_conn_request_in_connwait(link_t *nb_link);
+static int nbll_dummy_conn_in_initial(link_t *nb_link);
+static int nbll_conn_confirm_in_connwait(link_t *nb_link);
+static int nbll_conn_indicate_in_connwait(link_t *nb_link);
+static int nbll_conn_reject_in_connwait(link_t *nb_link);
+static int nbll_disc_request_in_connwait(link_t *nb_link);
+static int nbll_reset_indicate_in_up(link_t *nb_link);
+static int nbll_session_alive_in_up(link_t *nb_link);
+static int nbll_disc_request_in_up(link_t *nb_link);
+static int nbll_disc_indicate_in_up(link_t *nb_link);
+
+static int autobind;
+MODULE_PARM(autobind, "i");
+MODULE_PARM_DESC(autobind, "Autobinds all multicast interfaces");
+
+/* Contains hardcoded NetBIOS Frame Header length */
+u8 nb_cmd_hdr_len[] = {
+	0x2C, 0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x00, 0x2C,
+	0x2C, 0x2C, 0x2C, 0x00, 0x00, 0x2C, 0x2C, 0x2C,
+	0x00, 0x00, 0x00, 0x2C, 0x0E, 0x0E, 0x0E, 0x0E,
+	0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x00, 0x00, 0x0E
+};
+
+/*
+ * LLC is not re-entrant service to upper layer (NetBEUI)
+ * This flag, set upon entering LLC code, prevents NetBEUI to re-enter the
+ * code when its timers fire.
+ */
+volatile int llc_in_progress = 0;
+
+/* This is the communication medium between LLC and NetBEUI */
+static struct llc_sap *netbeui_sap;
+
+/* This is a list of adapters NetBEUI is bound to. */
+struct nb_adapters netbeui_adapters = {
+	lock:	RW_LOCK_UNLOCKED,
+};
+
+/* LLC links to other network nodes */
+static dextab_t link_table = {
+	max_size:	NETBEUI_MAX_LINKS,
+	lock:		SPIN_LOCK_UNLOCKED
+};
+
+#define link_table_entry(i)  ((link_t *)link_table.addr[i])
+
+/* Link service state machine definition */
+typedef int (*link_event_handler_t)(link_t *);
+
+struct event_struct {
+	link_state_t  next_state;
+	link_event_handler_t event_handler;
+};
+
+static struct event_struct link_state_table[3][9] = {
+			/* NETBEUI_LINK_INITIAL  */
+{
+{ NETBEUI_LINK_UP,
+	nbll_conn_indicate_in_initial }, /* NETBEUI_LINK_CONN_INDICATE  */
+{ -1, NULL },				 /* NETBEUI_LINK_CONN_REQUEST   */
+{ NETBEUI_LINK_CONNWAIT,
+	nbll_dummy_conn_in_initial },	 /* NETBEUI_LINK_DUMMY_CONN     */
+{ -1, NULL },				 /* NETBEUI_LINK_CONN_CONFIRM   */
+{ -1, NULL },				 /* NETBEUI_LINK_CONN_REJECT    */
+{ -1, NULL },				 /* NETBEUI_LINK_RESET_INDICATE */
+{ -1, NULL }, 				 /* NETBEUI_LINK_SESSION_ALIVE  */
+{ -1, NULL },				 /* NETBEUI_LINK_DISC_REQUEST   */
+{ -1, NULL }				 /* NETBEUI_LINK_DISC_INDICATE  */
+},
+			/* NETBEUI_LINK_CONNWAIT */
+{
+{ NETBEUI_LINK_UP,
+	nbll_conn_indicate_in_connwait }, /* NETBEUI_LINK_CONN_INDICATE  */
+{ NETBEUI_LINK_CONNWAIT,
+	nbll_conn_request_in_connwait },  /* NETBEUI_LINK_CONN_REQUEST   */
+{ -1, NULL },				  /* NETBEUI_LINK_DUMMY_CONN     */
+{ NETBEUI_LINK_UP,
+	nbll_conn_confirm_in_connwait },  /* NETBEUI_LINK_CONN_CONFIRM   */
+{ NETBEUI_LINK_INITIAL,
+	nbll_conn_reject_in_connwait },	  /* NETBEUI_LINK_CONN_REJECT    */
+{ -1, NULL },				  /* NETBEUI_LINK_RESET_INDICATE */
+{ -1, NULL }, 				  /* NETBEUI_LINK_SESSION_ALIVE  */
+{ NETBEUI_LINK_INITIAL,
+	nbll_disc_request_in_connwait },  /* NETBEUI_LINK_DISC_REQUEST   */
+{ -1, NULL }				  /* NETBEUI_LINK_DISC_INDICATE  */
+},
+			  /* NETBEUI_LINK_UP */
+{
+{ -1, NULL },				  /* NETBEUI_LINK_CONN_INDICATE  */
+{ -1, NULL },				  /* NETBEUI_LINK_CONN_REQUEST   */
+{ -1, NULL },				  /* NETBEUI_LINK_DUMMY_CONN     */
+{ -1, NULL },				  /* NETBEUI_LINK_CONN_CONFIRM   */
+{ -1, NULL },				  /* NETBEUI_LINK_CONN_REJECT    */
+{ NETBEUI_LINK_UP,
+	nbll_reset_indicate_in_up },	  /* NETBEUI_LINK_RESET_INDICATE */
+{ NETBEUI_LINK_UP,
+	nbll_session_alive_in_up },	  /* NETBEUI_LINK_SESSION_ALIVE  */
+{ NETBEUI_LINK_INITIAL,
+	nbll_disc_request_in_up },	  /* NETBEUI_LINK_DISC_REQUEST   */
+{ NETBEUI_LINK_INITIAL,
+	nbll_disc_indicate_in_up }	  /* NETBEUI_LINK_DISC_INDICATE  */
+}
+};
+/*
+ * LLC interface functions
+ * Data-out functions
+ */
+/*
+ * Function: nbll_isend_link
+ *	This is the lowest level LLC interface function in sending and I-Frame
+ *	It prepares a LLC frame structure, considers LLC re-entrancy problems
+ *	and decides on LLC return value to handle many special cases.
+ * Parameters:
+ *	rdev	  : pointer to struct net_device or adapter the frame is sent to
+ *		    This parameter is designed to minimize critical regions
+ *	llc_handle: LLC handle of remote machine (is a pointer to LLC data)
+ *	skb	  : the pointer to sk_buff containing data to send
+ *	qflag	  : queuing flag. NetBEUI links control flow of data to LLC
+ *		    layer using a skb queue. Depending on the situation we
+ *		    are in, an unsuccessful try in delivering frame to LLC
+ *		    should queue the frame for later trials. This flag controls
+ *		    how this function should queue the skb.
+ *			0    : queue unsuccessful skb in tail and return 0
+ *			other: queue unsuccessful skb in head and return
+ *			       non-zero
+ * Returns:
+ *	0	  : if LLC accepts the frame or frame is queue in Link for
+ *		    later trial
+ *	qflag<> 0 : if queues frame for later trial
+ *	non-zero  : any other error value returned by LLC
+ * Notes:
+ *	- Any modification to this function highly affects the whole system
+ *
+ *	- A special race condition is an interrupt occurred when LLC returns
+ *	  from sap_request to NetBEUI. To cover it a critical region is created
+ *	  before LLC return statement in LLC code and is destroyed after
+ *	  sap_request statement in NetBEUI code. This is why you may see
+ *	  wonderful save and restore flag calls in the code.
+ *
+ *	  acme: with all the locking changes I think that this race is gone
+ *	  so, for now I'll get rid of all this 'wonderful' save and restore
+ */
+static int nbll_isend_link(struct net_device *rdev, struct sock *llc_handle,
+			   struct sk_buff *skb, unsigned char link,
+			   int qflag)
+{
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+	int rc;
+
+	prim.data = &prim_data;
+	skb->protocol = htons(ETH_P_802_2);
+	if (!memcmp(rdev->name, "tr", 2))
+		skb->protocol = htons(ETH_P_TR_802_2);
+	skb->dev	   = rdev;
+	skb->mac.raw	   = skb->head;
+	prim_data.data.pri = 0;
+	prim_data.data.sk  = llc_handle;
+	prim_data.data.skb = skb;
+	prim.sap	   = netbeui_sap;
+	prim.prim	   = LLC_DATA_PRIM;
+restart:
+	llc_in_progress = 1;
+	barrier();
+	rc = netbeui_sap->req(&prim);
+	llc_in_progress = 0;
+	barrier();
+	switch (rc) {
+		case 0:
+			goto out;
+		case -ERESTART:
+			goto restart;
+		case -EBUSY: {
+			link_t *nb_link = link_table_entry(link);
+
+			if (!nb_link) {
+				kfree_skb(skb);
+				rc = -ECONNABORTED;
+				goto out;
+			}
+			nb_link->llc_busy = 1;
+			if (!qflag)
+				__skb_queue_tail(&nb_link->skbq, skb);
+			else
+				__skb_queue_head(&nb_link->skbq, skb);
+			rc = qflag;
+			goto out;
+		}
+	}
+	kfree_skb(skb);
+out:	return rc;
+}
+
+/*
+ * Function: nbll_free_link
+ *	Does a complete housekeeping for a link including queue/table/...
+ * Parameters:
+ *	nb_link	: pointer to link_t to destruct
+ * Returns: none
+ */
+static inline void nbll_free_link(link_t *nb_link)
+{
+	skb_queue_purge(&nb_link->skbq);
+	dextab_destruct(&nb_link->session_table);
+	kfree(nb_link);
+}
+
+/* used by session_serve.c as well, so cannot be static */
+inline void nbll_link_put(link_t *nb_link)
+{
+	if (atomic_dec_and_test(&nb_link->refcnt))
+		nbll_free_link(nb_link);
+}
+
+static inline void nbll_link_hold(link_t *nb_link)
+{
+	atomic_inc(&nb_link->refcnt);
+}
+
+/**
+ *	nbll_isend - sends I-Frames on a LLC connection
+ *	@link: An integer containing link number in link table
+ *	@skb: pointer to sk_buff containing data to send
+ *
+ *	This is the interface routine that actually tries to send I-Frames
+ *	on an LLC connection.
+ *	Returns:
+ *	0: if LLC accepts frame or it is queued for later trial
+ *	-ECONNABORTED: If connection is aborted by remote peer
+ *	-ENOMEM	: If cannot allocate a skb
+ *	non-zero: any other error value returned by LLC
+ *	Notes:
+ *	- Since I intended to call this function freely in upper layer codes,
+ *	  it contains a critical region checking LINK consistency
+ */
+int nbll_isend(int link, struct sk_buff *skb)
+{
+	link_t *nb_link = NULL;
+	struct net_device *link_dev;
+	struct sock *link_llc_handle;
+	int rc = -EINVAL;
+
+	spin_lock_bh(&link_table.lock);
+	if (link > link_table.count) {
+		spin_unlock_bh(&link_table.lock);
+		goto freeskb;
+	}
+	nb_link = link_table_entry(link);
+	rc = -ECONNABORTED;
+	if (!nb_link) {
+		spin_unlock(&link_table.lock);
+		goto freeskb;
+	}
+	nbll_link_hold(nb_link);
+	spin_unlock_bh(&link_table.lock);
+	rc = 0;
+	if (nb_link->llc_busy == 1) {
+		__skb_queue_tail(&nb_link->skbq, skb);
+		goto out;
+	}
+	nb_link->iactivity++;
+	link_dev = nb_link->dev;
+	link_llc_handle = nb_link->llc_handle;
+	rc = nbll_isend_link(link_dev, link_llc_handle, skb, link, 0);
+out:	nbll_link_put(nb_link);
+	return rc;
+freeskb:
+	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbll_uisend_mac
+ *	This is the lowest level LLC interface function in sending and UI-Frame
+ * Parameters:
+ *	remote_mac: pointer to MAC address of destination node or NetBIOS
+ *		    functional address of device the frame is sent to.
+ *	skb	  : pointer to sk_buff containing data to send
+ * Returns:
+ *	0	: if LLC accepts frame
+ *	-ENOMEM	: If cannot allocate a skb
+ *	non-zero: any other error value returned by LLC
+ */
+static int nbll_uisend_mac(unsigned char *remote_mac, struct sk_buff *skb)
+{
+	union llc_u_prim_data prim_data;
+	struct llc_prim_if_block prim;
+
+	prim.data = &prim_data;
+	skb->protocol = htons(ETH_P_802_2);
+	if (!memcmp(skb->dev->name, "tr", 2))
+		skb->protocol = htons(ETH_P_TR_802_2);
+
+	prim_data.udata.saddr.lsap = LLC_SAP_NETBEUI;
+	memcpy(prim_data.udata.saddr.mac, skb->dev->dev_addr,
+	       skb->dev->addr_len);
+	prim_data.udata.daddr.lsap = LLC_SAP_NETBEUI;
+	memcpy(prim_data.udata.daddr.mac, remote_mac, skb->dev->addr_len);
+	prim_data.udata.skb = skb;
+	prim.sap	= netbeui_sap;
+	prim.prim	= LLC_DATAUNIT_PRIM;
+	return netbeui_sap->req(&prim);
+}
+
+/*
+ * Function: nbll_uisend
+ *	This is the interface routine that actually tries to send UI-Frames
+ *	on an LLC connection.
+ * Parameters:
+ *	remote_mac: pointer to MAC address of destination system or NULL
+ *		    to indicate broadcast to all NICs NetBEUI is bound to
+ *	skb	  : pointer to sk_buff containing data to send
+ * Returns:
+ *	0	: if LLC accepts frame
+ *	-ENOMEM	: If cannot allocate a skb
+ *		  or cannot create a copy from skb.
+ *	non-zero: any other error value returned by LLC
+ */
+int nbll_uisend(unsigned char *remote_mac, struct sk_buff *skb)
+{
+	int i, rc = -ENOMEM;
+
+	/* If datagram has a destination */
+	if (remote_mac) {
+		rc = nbll_uisend_mac(remote_mac, skb);
+		goto out;
+	}
+	/* Datagram is to be broadcasted to all interfaces */
+	read_lock(&netbeui_adapters.lock);
+	for (i = 0; i < NETBEUI_MAX_ADAPTERS && netbeui_adapters.dev[i]; i++) {
+		struct sk_buff *skb2 = skb_copy(skb, GFP_ATOMIC);
+
+		if (!skb2)
+			goto out;
+		skb2->dev = netbeui_adapters.dev[i];
+		nbll_uisend_mac(netbeui_funcaddr(skb2->dev), skb2);
+	}
+	rc = 0;
+out:	read_unlock(&netbeui_adapters.lock);
+	return rc;
+}
+
+/*
+ * Link service state machine functions
+ * Implementing general functions
+ */
+/*
+ * Function: nbll_alloc_link
+ *	Allocates and Initializes a link_t structure
+ * Parameters: none
+ * Returns:
+ *	NULL	: if can not allocate link_t structure
+ *	non-NULL: if link_t is allocated and initialized
+ * Note:
+ *	- Link timer is initialized but not started
+ *	- The call to memset does implicitly initialize all fields. Those
+ *	  fields that need explicit non-zero initialization are manipulated
+ *	  afterwards.
+ */
+static link_t *nbll_alloc_link(void)
+{
+	link_t *nb_link = kmalloc(sizeof(*nb_link), GFP_ATOMIC);
+
+	if (!nb_link)
+		goto out;
+	/* Implicitly initialize all fields */
+	memset(nb_link, 0, sizeof(*nb_link));
+	nb_link->state = NETBEUI_LINK_INITIAL;
+	nb_link->link  = -1;
+	dextab_init(&nb_link->session_table, 1, NETBEUI_MAX_SESSIONS);
+	skb_queue_head_init(&nb_link->skbq);
+	init_waitqueue_head(&nb_link->waitq);
+	init_timer(&nb_link->timer);
+	nb_link->timer.data	= (unsigned long)nb_link;
+	nb_link->timer.function	= nbll_timer_function;
+	atomic_set(&nb_link->refcnt, 1);
+out:	return nb_link;
+}
+
+/*
+ * Function: nbll_insert_link_into_table
+ *	Inserts a previously allocated/initialized link into system link table
+ * Parameters:
+ *	nb_link	: pointer to link_t to insert
+ * Returns: none
+ *	0	: if nb_link is inserted into system link_table
+ *	-ENOSPC : if link_table is full
+ */
+static int nbll_insert_link_into_table(link_t *nb_link)
+{
+	int link;
+	int rc = 0;
+
+	nbll_link_hold(nb_link);
+	link = dextab_insert_entry(&link_table, nb_link);
+	if (link < 0)
+		rc = -ENOSPC;
+	else
+		nb_link->link = link;
+	nbll_link_put(nb_link);
+	return rc;
+}
+
+/*
+ * Function: nbll_delete_link_from_table
+ *	Deletes a link from system link table
+ * Parameters:
+ *	nb_link	: pointer to link_t to delete
+ * Returns: none
+ */
+static void nbll_delete_link_from_table(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	dextab_delete_index(&link_table, nb_link->link);
+	nb_link->link = -1;
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_find_link
+ *	Finds a link in system link table to a remote node from its mac and
+ *	the device we are connected via
+ * Parameters:
+ *	dev	  : pointer to struct net_device we are connected to remote
+ *		    node via
+ *	remote_mac: pointer to MAC address of remote node we are connected to
+ * Returns:
+ *	NULL	  : if a corresponding link is not found
+ *	non-NULL  : the link_t address of corresponding link
+ */
+static link_t *nbll_find_link(struct net_device *dev, unsigned char *remote_mac)
+{
+	int index;
+	link_t *nb_link = NULL;
+
+	spin_lock(&link_table.lock);
+	for (index = link_table.reserved; index < link_table.size; index++) {
+		nb_link = link_table_entry(index);
+		if (nb_link && nb_link->dev == dev &&
+		    !memcmp(nb_link->remote_mac, remote_mac, dev->addr_len))
+			break;
+	}
+	if (nb_link)
+		nbll_link_hold(nb_link);
+	spin_unlock(&link_table.lock);
+	return nb_link;
+}
+
+/*
+ * Function: nbll_request_llc_connect
+ *	Prepares and sends a connection request to LLC layer.
+ * Parameters:
+ *	nb_link	: pointer to link_t structure prepared for this new connection
+ *		  A NetBEUI link_t is the counterpart of LLC connection struct.
+ * Returns:
+ *	0	: LLC accepted connection request
+ *	non-zero: LLC rejected connection request
+ */
+static int nbll_request_llc_connect(link_t *nb_link)
+{
+	struct net_device *dev;
+	struct llc_prim_if_block prim;
+	union llc_u_prim_data prim_data;
+	int rc;
+
+	nbll_link_hold(nb_link);
+	dev = nb_link->dev;
+	prim.data			= &prim_data;
+	prim_data.conn.saddr.lsap	= LLC_SAP_NETBEUI;
+	memcpy(prim_data.conn.saddr.mac, dev->dev_addr, dev->addr_len);
+	prim_data.conn.daddr.lsap	= LLC_SAP_NETBEUI;
+	memcpy(prim_data.conn.daddr.mac, nb_link->remote_mac,
+	       dev->addr_len);
+	prim_data.conn.dev  = dev;
+	prim_data.conn.link = nb_link->link;
+	prim_data.conn.sk   = NULL;
+	prim_data.conn.pri  = 0;
+	prim.prim	    = LLC_CONN_PRIM;
+	prim.sap	    = netbeui_sap;
+	rc = netbeui_sap->req(&prim);
+	nbll_link_put(nb_link);
+	return rc;
+}
+
+/*
+ * Function: nbll_request_llc_disconnect
+ *	Prepares and sends a disconnection request to LLC layer.
+ * Parameters:
+ *	nb_link	: pointer to link_t structure responsible for this connection
+ *		  A NetBEUI link_t is the counterpart of LLC connection struct.
+ * Returns:
+ *	0	: LLC accepted disconnection request
+ *	non-zero: LLC rejected disconnection request
+ * Note:
+ *	- Currently LLC always accepts disconnection request.
+ */
+static int nbll_request_llc_disconnect(link_t *nb_link)
+{
+	struct llc_prim_if_block prim;
+	union llc_u_prim_data prim_data;
+	int rc;
+
+	nbll_link_hold(nb_link);
+	prim.data	  = &prim_data;
+	prim_data.disc.sk = nb_link->llc_handle;
+	prim.prim	  = LLC_DISC_PRIM;
+	prim.sap	  = netbeui_sap;
+	rc = netbeui_sap->req(&prim);
+	nbll_link_put(nb_link);
+	return rc;
+}
+
+/*
+ * Function: nbll_isend_session_alive
+ *	Prepares a NetBIOS SESSION ALIVE frame and nbll_isends it to link
+ * Parameters:
+ *	nb_link: pointer to link_t structure to send SESSION ALIVE to
+ * Returns: None
+ */
+static void nbll_isend_session_alive(link_t *nb_link)
+{
+	packet_t *hdr;
+	int llcmac_ihl,
+	    session_packet_len = nb_cmd_hdr_len[NETBEUI_SESSION_ALIVE];
+	struct sk_buff *skb;
+
+	nbll_link_hold(nb_link);
+	llcmac_ihl = LLCMAC_I_HEADLEN(nb_link->dev);
+	skb = alloc_skb((session_packet_len + llcmac_ihl), GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	skb_reserve(skb, llcmac_ihl);
+        skb->nh.raw = skb->h.raw = skb->data;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_SESSION_ALIVE;
+	hdr->data1		= 0;
+	hdr->data2		= 0;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= 0;
+	hdr->source_num		= 0;
+	nbll_isend(nb_link->link, skb);
+out:	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_handle_event
+ *	This is the heart of Link Service State Machine, which performs a
+ *	transition from current state of link element to new state based
+ *	on event occurred and link state table contents.
+ * Parameters:
+ *	event	: An integer of NETBEUI_LINK_* family that implies type of event
+ *	nb_link	: pointer to link_t structure which the event occurred on
+ * Returns: none
+ * Notes:
+ *	- The state changes before actions be executed. This is due to
+ *	  non deterministic behavior of actions which may sleep the current
+ *	  process, thus stopping the function in the mid-way.
+ */
+static void nbll_handle_event(link_event_t event, link_t *nb_link)
+{
+	struct event_struct *ev;
+
+	nbll_link_hold(nb_link);
+	ev = &link_state_table[nb_link->state][event];
+	if (ev && ev->event_handler) {
+		link_state_t old_state = nb_link->state;
+
+		nb_link->state = ev->next_state;
+		if (ev->event_handler(nb_link))
+			nb_link->state = old_state;
+	}
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_timer_function
+ *	This is the callback function triggered upon expiration of link
+ *	inactivity timer. It just injects an event into state machine for
+ *	its link.
+ * Parameters:
+ *	input	: pointer to link_t structure whose timer is expired.
+ * Returns: none
+ */
+static void nbll_timer_function(unsigned long input)
+{
+	link_t *nb_link = (link_t *)input;
+
+	nbll_link_hold(nb_link);
+	nbll_handle_event(NETBEUI_LINK_SESSION_ALIVE, nb_link);
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Link service state machine functions
+ * Implementing transition functions
+ */
+/*
+ * Function: nbll_xxxx_in_ssss
+ *	The section below contains functions that implement actions needed
+ *	to  legally transit from one state to another.
+ * Parameters:
+ *	nb_link	: pointer to link_t structure which the actions are to be
+ *		  applied to
+ * Returns:
+ *	0	: if all actions are done successfully
+ *	non-zero: if one of actions failed
+ * Note:
+ *	- For the sake of simplicity, the actions are automatically rollbacked
+ *	  in each function, if an action in transition fails. The design
+ *	  documents do not cover these parts of code.
+ */
+static int nbll_conn_indicate_in_initial(link_t *nb_link)
+{
+	int rc;
+
+	nbll_link_hold(nb_link);
+	nb_link->status = nbll_insert_link_into_table(nb_link);
+	if (!nb_link->status) {
+		nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+		add_timer(&nb_link->timer);
+	}
+	rc = nb_link->status;
+	nbll_link_put(nb_link);
+	return rc;
+}
+
+static int nbll_conn_request_in_connwait(link_t *nb_link)
+{
+	int rc = -1;
+
+	nbll_link_hold(nb_link);
+	if (nbll_request_llc_connect(nb_link))
+		goto out;
+	wait_event(nb_link->waitq, nb_link->state != NETBEUI_LINK_CONNWAIT);
+	rc = 0;
+out:	nbll_link_put(nb_link);
+	return rc;
+}
+
+static int nbll_dummy_conn_in_initial(link_t *nb_link)
+{
+	int rc;
+
+	nbll_link_hold(nb_link);
+	rc = nbll_insert_link_into_table(nb_link);
+	nbll_link_put(nb_link);
+	return rc;
+}
+
+static int nbll_conn_confirm_in_connwait(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+	add_timer(&nb_link->timer);
+	nb_link->status = 0;
+	wake_up(&nb_link->waitq);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_conn_indicate_in_connwait(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	nb_link->timer.expires = jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+	add_timer(&nb_link->timer);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_conn_reject_in_connwait(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	nbll_delete_link_from_table(nb_link);
+	nb_link->status = -ECONNREFUSED;
+	wake_up(&nb_link->waitq);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_disc_request_in_connwait(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	nbll_delete_link_from_table(nb_link);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_reset_indicate_in_up(link_t *nb_link)
+{
+	int index;
+
+	nbll_link_hold(nb_link);
+	for (index = nb_link->session_table.reserved;
+	     index < nb_link->session_table.size; index++) {
+		session_t *session = (session_t *)
+					nb_link->session_table.addr[index];
+		if (session) {
+    			nbss_abort_session(session);
+			dextab_delete_index(&nb_link->session_table,
+					    session->lsn);
+		}
+	}
+	del_timer(&nb_link->timer);
+	nb_link->iactivity	= 0;
+	nb_link->timer.expires	= jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+	add_timer(&nb_link->timer);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_session_alive_in_up(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	if (!nb_link->iactivity)
+		nbll_isend_session_alive(nb_link);
+	nb_link->iactivity	= 0;
+	nb_link->timer.expires	= jiffies + NETBEUI_INACTIVITY_TIMEOUT;
+	add_timer(&nb_link->timer);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_disc_request_in_up(link_t *nb_link)
+{
+	nbll_link_hold(nb_link);
+	del_timer(&nb_link->timer);
+	nbll_request_llc_disconnect(nb_link);
+	nbll_delete_link_from_table(nb_link);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+static int nbll_disc_indicate_in_up(link_t *nb_link)
+{
+	int index;
+
+	nbll_link_hold(nb_link);
+	del_timer(&nb_link->timer);
+
+	for (index = nb_link->session_table.reserved;
+	     index < nb_link->session_table.size; index++) {
+		session_t *session = (session_t *)
+					nb_link->session_table.addr[index];
+		if (session) {
+			nbss_abort_session(session);
+			dextab_delete_index(&nb_link->session_table,
+					    session->lsn);
+		}
+	}
+	dextab_destruct(&nb_link->session_table);
+	nbll_delete_link_from_table(nb_link);
+	nbll_link_put(nb_link);
+	return 0;
+}
+
+/*
+ * Link service state machine functions
+ * Implementing interface functions
+ */
+/*
+ * Function: get_disconnect_indicate
+ *	Accepts a connection indication from LLC layer. If it can establish
+ *	a link anyway, generates an event on link element, otherwise requests
+ *	LLC to disconnect (! this is LLC rule)
+ * Parameters:
+ *	prim: pointer to primary interface block type, the LLC communication
+ *	      data structure. This is a union with different fields with
+ *	      different meaning for different purposes.
+ * Returns: none
+ */
+static void nbll_get_connect_indicate(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_conn *prim_data = &prim->data->conn;
+	link_t *nb_link = nbll_find_link(prim_data->dev, prim_data->saddr.mac);
+
+	if (!nb_link) {
+		nb_link = nbll_alloc_link();
+		if (nb_link)
+			nbll_link_hold(nb_link);
+	}
+	if (nb_link) {
+		nb_link->llc_handle = prim_data->sk;
+		nb_link->dev = prim_data->dev;
+		memcpy(nb_link->remote_mac, prim_data->saddr.mac,
+		       nb_link->dev->addr_len);
+		nbll_handle_event(NETBEUI_LINK_CONN_INDICATE, nb_link);
+	}
+	if (!nb_link || nb_link->state == NETBEUI_LINK_INITIAL) {
+		/* Request link disconnection */
+		prim->data->disc.sk = prim_data->sk;
+		prim->prim = LLC_DISC_PRIM;
+		prim->sap  = netbeui_sap;
+		netbeui_sap->req(prim);
+		if (nb_link)
+			nbll_link_put(nb_link);
+	} else {
+		prim->prim	= LLC_CONN_PRIM;
+		prim->sap	= netbeui_sap;
+		prim_data->link	= nb_link->link;
+		netbeui_sap->resp(prim);
+	}
+	if (nb_link)
+		nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_get_connect_confirm
+ *	Accepts a connection confirm for a previously requested connection from
+ *	LLC layer. The LLC may confirm a connection request positively or
+ *	negatively.
+ * Parameters:
+ *	prim	: pointer to primary interface block type, the LLC communication
+ *		  data structure. This is a union with different fields with
+ *		  different meaning for different purposes.
+ * Returns: none
+ */
+static void nbll_get_connect_confirm(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_conn *prim_data = &prim->data->conn;
+	link_t *nb_link = link_table_entry(prim_data->link);
+
+	nbll_link_hold(nb_link);
+	if (prim_data->status == LLC_STATUS_CONN) {
+		nb_link->llc_handle = prim_data->sk;
+		nbll_handle_event(NETBEUI_LINK_CONN_CONFIRM, nb_link);
+	} else
+		nbll_handle_event(NETBEUI_LINK_CONN_REJECT, nb_link);
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_get_data_confirm
+ *	Accepts a data confirm from LLC layer, according to a -EBUSY return
+ *	value on latest try to send I-Frame to a LLC connection. This primitive
+ *	informs NetBEUI to flush its link queue to LLC connection.
+ * Parameters:
+ *	prim: pointer to primary interface block type, the LLC communication
+ *	      data structure. This is a union with different fields with
+ *	      different meaning for different purposes.
+ * Returns:
+ *	0 	: if all queue contents are flushed successfully.
+ *	non-Zero: if LLC does not accept all entries and queue has more entries
+ *		  to flush.
+ * Note:
+ *	- Since this function is raised via LLC, the return value has special
+ *	  meaning to both NetBEUI and LLC to sync their flags. The llc_busy
+ *	  flag in NetBEUI link demonstrates existence of skbs in link queue
+ *	  ready to send to LLC layer.
+ */
+static int nbll_get_data_confirm(struct llc_prim_if_block *prim)
+{
+	struct llc_prim_data *prim_data = &prim->data->data;
+	link_t *nb_link = link_table_entry(prim_data->link);
+	struct sk_buff *skb;
+	int rc = -EBUSY;
+
+	printk(KERN_INFO __FUNCTION__ ": enter\n");
+	nbll_link_hold(nb_link);
+	while ((skb = __skb_dequeue(&nb_link->skbq)) != NULL)
+		if (nbll_isend_link(nb_link->dev, nb_link->llc_handle,
+				    skb, prim_data->link, 1) == 1)
+			goto out;
+	rc = nb_link->llc_busy = 0;
+out:	nbll_link_put(nb_link);
+	return rc;
+}
+
+/*
+ * Function: nbll_get_disconnect_indicate
+ *	Accepts a disconnection indication for a connection from LLC layer.
+ * Parameters:
+ *	prim: pointer to primary interface block type, the LLC communication
+ *	      data structure. This is a union with different fields with
+ *	      different meaning for different purposes.
+ * Returns: none
+ */
+static void nbll_get_disconnect_indicate(struct llc_prim_if_block *prim)
+{
+	link_t *nb_link = link_table_entry(prim->data->disc.link);
+	nbll_link_hold(nb_link);
+	nbll_handle_event(NETBEUI_LINK_DISC_INDICATE, nb_link);
+	nbll_link_put(nb_link);
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: nbll_get_disconnect_confirm
+ *	Accepts a disconnection confirm for a previous disconnect request, from
+ *	LLC layer.
+ * Parameters:
+ *	prim: pointer to primary interface block type, the LLC communication
+ *	      data structure. This is a union with different fields with
+ *	      different meaning for different purposes.
+ * Returns: none
+ * Note:
+ *	- Currently LLC does not generate a disconnection confirm. Both NetBEUI
+ *	  and LLC assume that a disconnection request is always satisfied.
+ */
+static void nbll_get_disconnect_confirm(struct llc_prim_if_block *prim)
+{
+	/* Nothing to do, we do not wait for disconnection confirmation */
+}
+
+/*
+ * Function: nbll_get_reset_indicate
+ *	Accepts a reset indication for a connection from LLC layer.
+ * Parameters:
+ *	prim: pointer to primary interface block type, the LLC communication
+ *	      data structure. This is a union with different fields with
+ *	      different meaning for different purposes.
+ * Returns: none
+ * Note:
+ *	- LLC reset indication means close all sessions on link and reset
+ *	  link parameters. Just the link itself remains UP and RUNNING.
+ */
+static void nbll_get_reset_indicate(struct llc_prim_if_block *prim)
+{
+	link_t *nb_link = link_table_entry(prim->data->res.link);
+
+	nbll_link_hold(nb_link);
+	nbll_handle_event(NETBEUI_LINK_RESET_INDICATE, nb_link);
+	nb_link->llc_busy  = 0;
+	nb_link->iactivity = 0;
+	skb_queue_purge(&nb_link->skbq);
+	nbll_link_put(nb_link);
+}
+
+/*
+ * Function: get_link_table
+ *	returns a pointer to NetBEUI link table. The proc support code uses
+ *	the link table to map its contents to /proc/sys/netbeui entry.
+ * Parameters: none
+ * Returns:
+ *	non-NULL: pointer to NetBEUI link table
+ */
+dextab_t *nbll_get_link_table(void)
+{
+	return &link_table;
+}
+
+link_t *nbll_get_link(int link)
+{
+	link_t *nb_link = NULL;
+
+	spin_lock(&link_table.lock);
+	if (link <= link_table.size)
+		nb_link = link_table_entry(link);
+	if (nb_link)
+		nbll_link_hold(nb_link);
+	spin_unlock(&link_table.lock);
+	return nb_link;
+}
+
+/*
+ * Function: nbll_attach_session
+ *	This is a sophisticated interface to session service module, which
+ *	attaches (links) a session to a link. Depending on the existence and
+ *	state of the link, it interacts with LLC and manipulates link session
+ *	table to content the request.
+ * Parameters:
+ *	session	  : pointer to session_t structure to add to session table of
+ *		    link
+ *	dev	  : pointer to device structure the link to remote node is on
+ *	remote_mac: pointer to MAC address of remote node the link is to
+ * Returns:
+ *	0	     : if session is successfully added to link session table
+ *	-ENOSPC	     : if link session table has no space to add session
+ *	-ENOMEM	     : if can not allocate memory for creating new link
+ *	-EHOSTUNREACH: if LLC connection request for a new link failed.
+ */
+int nbll_attach_session(session_t *session, struct net_device *dev,
+			unsigned char *remote_mac)
+{
+	link_t *nb_link = nbll_find_link(dev, remote_mac);
+	int session_no;
+	int rc;
+
+	/* If a link exists previously and is up or requested within an
+	   interrupt */
+	if (nb_link) {
+		session_no = dextab_insert_entry(&nb_link->session_table,
+						 session);
+		rc = -ENOSPC;
+		if (session_no < 0)
+			goto plink;
+		session = (session_t *)nb_link->session_table.addr[session_no];
+		session->link = nb_link->link;
+		session->lsn  = session_no;
+		rc = 0;
+		goto plink;
+	}
+	/* Request for link (dummy) */
+	nb_link = nbll_alloc_link();
+	rc = -ENOMEM;
+	if (!nb_link)
+		goto out;
+	nbll_link_hold(nb_link);
+	nb_link->llc_handle = 0;
+	nb_link->dev = dev;
+	memcpy(nb_link->remote_mac, remote_mac, dev->addr_len);
+	nbll_handle_event(NETBEUI_LINK_DUMMY_CONN, nb_link);
+	rc = -EHOSTUNREACH;
+	if (nb_link->state == NETBEUI_LINK_INITIAL) {
+		nbll_link_put(nb_link);
+		goto plink;
+	}
+	rc = nbll_attach_session(session, dev, remote_mac);
+plink:	nbll_link_put(nb_link);
+out:	return rc;
+}
+
+/*
+ * Function: nbll_link_session
+ *	This is a joke !!!!!
+ *	NetBEUI connection request has two steps NAME QUERY and LLC CONNECTION
+ *	establishment. To overcome some traditional limits in total session
+ *	count new implementations add a NAME FIND step before the other two
+ *	steps, thus letting the other two be used interchangeably.
+ *	Unfortunately Microsoft implementations force using NAME QUERY before
+ *	LLC CONNECTION. To overcome the problem we first put a link into
+ *	CONNWAIT, attach a session to it and first issue NAME QUERY then
+ *	request LLC CONNECTION. This function does the actual LLC connection
+ *	request on the dummy link.
+ * Parameters:
+ *	link	  : an integer representing link number in link table
+ * Returns:
+ *	0	     : if dummy link is now established successfully.
+ *	-ECONNRESET  : if dummy link is reset
+ *	-EHOSTUNREACH: if LLC connection establishment failed.
+ */
+int nbll_link_session(int link)
+{
+	link_t *nb_link;
+	int rc = -ECONNRESET;
+
+	spin_lock(&link_table.lock);
+	nb_link = link_table_entry(link);
+	if (!nb_link) {
+		spin_unlock(&link_table.lock);
+		goto out;
+	}
+	nbll_link_hold(nb_link);
+	spin_unlock(&link_table.lock);
+	nbll_handle_event(NETBEUI_LINK_CONN_REQUEST, nb_link);
+	rc = -EHOSTUNREACH;
+	if (nb_link->state == NETBEUI_LINK_INITIAL) {
+		nbll_link_put(nb_link);
+		goto plink;
+	}
+	rc = 0;
+plink:	nbll_link_put(nb_link);
+out:	return rc;
+}
+
+/*
+ * Function: nbll_detach_session
+ *	Detaches a session from its link session table. If the session was the
+ *	last session link, it tries to drop the link to free resources.
+ * Parameters:
+ *	link	  : an integer representing link number in link table
+ *	session_no: an integer representing session number in link session table
+ * Returns: none
+ */
+void nbll_detach_session(int link, unsigned char session_no)
+{
+	session_t *session;
+	link_t *nb_link;
+
+	spin_lock(&link_table.lock);
+	nb_link = link_table_entry(link);
+	if (!nb_link) {
+		spin_unlock(&link_table.lock);
+		goto out;
+	}
+	nbll_link_hold(nb_link);
+	spin_unlock(&link_table.lock);
+	session = (session_t *)nb_link->session_table.addr[session_no];
+	if (session)
+		session->lsn = 0;
+	__dextab_delete_index(&nb_link->session_table, session_no);
+	if (dextab_count_entries(&nb_link->session_table) > 0)
+		goto plink;
+	nbll_handle_event(NETBEUI_LINK_DISC_REQUEST, nb_link);
+	nbll_link_put(nb_link);
+plink:	nbll_link_put(nb_link);
+out:;
+}
+
+/*
+ * Function: nbll_drop_link
+ *	Drops a specified link with its sessions.
+ * Parameters:
+ *	link: an integer representing link number in link table.
+ * Returns: int
+ *	zero    : if the link dropped successfully.
+ *	negative: if operation fails.
+ *	           -EINVAL: the link number is invalid.
+ * Notes:
+ * 	- Only called from user context, in config.c, ioctl path
+ */
+int nbll_drop_link(int link)
+{
+	link_t *nb_link = nbll_get_link(link);
+	dextab_t *sn_tbl;
+	int i, sn_cnt, rc = -EINVAL;
+
+	if (!nb_link) /* Invalid link number */
+		goto out;
+	sn_tbl = &nb_link->session_table;
+	spin_lock_bh(&sn_tbl->lock);
+	rc = 0;
+	sn_cnt = sn_tbl->count;
+	for (i = sn_tbl->reserved; sn_cnt; i++) {
+		session_t *sn = sn_tbl->addr[i];
+
+		if (sn) {
+			nbll_detach_session(link, i);
+			nbss_abort_session(sn);
+			sn_cnt--;
+		}
+	}
+	spin_unlock_bh(&sn_tbl->lock);
+	nbll_link_put(nb_link);
+out:	return rc;
+}
+
+/*
+ * LLC interface functions
+ * Data-in functions
+ */
+/*
+ * Function: nbll_disconnect_all_links
+ *	Generates disconnection event on all NetBEUI links.
+ * Parameters: none
+ * Returns: none
+ */
+static void nbll_disconnect_all_links(void)
+{
+	int index;
+	link_t *nb_link;
+
+	spin_lock(&link_table.lock);
+	for (index = link_table.reserved; index < link_table.size; index++) {
+		nb_link = link_table_entry(index);
+		spin_unlock(&link_table.lock);
+		if (nb_link) {
+			nbll_handle_event(NETBEUI_LINK_DISC_REQUEST, nb_link);
+			nbll_link_put(nb_link);
+		}
+		spin_lock(&link_table.lock);
+	}
+	spin_unlock(&link_table.lock);
+}
+
+/*
+ * Function: nbll_deliver_packet
+ *	While checking input I-Frame consistency, routes frame to session
+ *	service interface. Since manipulating I-Frames is always the
+ *	responsibility of session service, the dispatching mechanism is
+ *	implemented there.
+ * Parameters:
+ *	skb	 : sk_buff which holds actual data
+ *	prim_data: pointer to LLC primitive data description.
+ * Returns: none
+ * Notes:
+ *	- Imagine struct llc_prim_if_block is the function that LLC calls in
+ *	  NetBEUI code and union llc_u_prim_data as argument to this function.
+ *	- This function is a barrier for ill frames with anomalous content.
+ */
+static void nbll_deliver_packet(struct sk_buff *skb,
+				struct llc_prim_data *prim_data)
+{
+	int command = ((packet_t *)(skb->data))->command;
+	link_t *nb_link = link_table_entry(prim_data->link);
+	session_t *session;
+
+	nbll_link_hold(nb_link);
+	/* Sanity check if command length and code is valid, all checks should
+	 * be done! */
+	/* It checks ill netbios headers, and prevents memory faults */
+	if (skb->len < NETBEUI_MIN_COMMAND_LEN ||
+	    command > NETBEUI_MAX_COMMAND_CODE ||
+	    skb->len < nb_cmd_hdr_len[command] ||
+	    ((packet_t *)skb->data)->delimiter != NETBEUI_DELIMITER ||
+	    ((packet_t *)skb->data)->dest_num >= nb_link->session_table.size)
+		goto err;
+	nb_link->iactivity++;
+	session = (session_t *)
+		nb_link->session_table.addr[((packet_t *)skb->data)->dest_num];
+	if (!session || command == NETBEUI_SESSION_ALIVE)
+		goto err;
+	nbss_deliver_frame(session, skb);
+out:	nbll_link_put(nb_link);
+	return;
+err:	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbll_deliver_datagram
+ *	The UI-Frame dispatcher
+ *	While checking input UI-Frame consistency, routes frame to final
+ *	destination in name service, session service and datagram distribution.
+ *	Due to different destinations the dispatching mechanism for UI-Frames is
+ *	implemented here in this function.
+ * Parameters:
+ *	skb	 : sk_buff which holds actual data
+ *	prim_data: pointer to LLC primitive data description.
+ * Returns: none
+ */
+static void nbll_deliver_datagram(struct sk_buff *skb,
+				  struct llc_prim_unit_data *prim_data)
+{
+	int command = ((dgram_t *)(skb->data))->command;
+
+	/* Sanity check if command length and code is valid, all checks
+	 * should be done !!! */
+	/* It checks ill netbios headers, and prevents memory faults */
+	if (skb->len < NETBEUI_MIN_COMMAND_LEN ||
+	    command > NETBEUI_MAX_COMMAND_CODE ||
+	    skb->len < nb_cmd_hdr_len[command] ||
+	    ((dgram_t *)skb->data)->delimiter != NETBEUI_DELIMITER)
+		goto fskb;
+	/* Token Ring support */
+	skb->cb[0] = prim_data->lfb;
+
+	switch (command) {
+		case NETBEUI_ADD_GROUP_NAME_QUERY:
+			nbns_get_add_name_query(skb, prim_data->saddr.mac,
+						NETBEUI_NAME_GROUP);
+			break;
+		case NETBEUI_ADD_NAME_QUERY:
+			nbns_get_add_name_query(skb, prim_data->saddr.mac,
+						NETBEUI_NAME_UNIQUE);
+			break;
+		case NETBEUI_ADD_NAME_RESPONSE:
+			nbns_get_add_name_response(skb, prim_data->saddr.mac);
+			break;
+		case NETBEUI_NAME_IN_CONFLICT:
+			nbns_get_name_conflict(skb);
+			break;
+		case NETBEUI_NAME_QUERY:
+			nbss_get_name_query(skb, prim_data->saddr.mac);
+			break;
+		case NETBEUI_NAME_RECOGNIZED:
+			nbqs_get_name_recognized(skb, prim_data->saddr.mac);
+			break;
+		case NETBEUI_DATAGRAM:
+			nbdg_get_datagram(skb);
+			break;
+		case NETBEUI_DATAGRAM_BROADCAST:
+			nbdg_get_datagram_broadcast(skb);
+			break;
+		case NETBEUI_STATUS_QUERY:
+			nbst_get_status_query(skb, prim_data->saddr.mac);
+			break;
+		case NETBEUI_STATUS_RESPONSE:
+			nbst_get_status_response(skb, prim_data->saddr.mac);
+			break;
+		case NETBEUI_TERMINATE_TRACE:
+		case NETBEUI_TERMINATE_TRACE2:
+			goto fskb;
+	}
+out:	return;
+fskb:	kfree_skb(skb);
+	goto out;
+}
+
+/**
+ *	netbeui_indicate - The callback for LLC indicate primitive dispatching
+ *	@prim: primary interface block type, the LLC comm data structure.
+ *
+ *	It dispatches LLC primitive to Link Service State Machine interfaces.
+ *	Note: LLC flow control indication is not generated. We have used data
+ *	request/confirm to control flow. Think if it is a misconception or is
+ *	accepted anyway.
+ */
+static int netbeui_indicate(struct llc_prim_if_block *prim)
+{
+	struct sk_buff *skb = NULL;
+
+	switch (prim->prim) {
+		case LLC_DATAUNIT_PRIM:
+			skb = prim->data->udata.skb;
+			nbll_deliver_datagram(skb, &prim->data->udata);
+			break;
+		case LLC_CONN_PRIM:
+			nbll_get_connect_indicate(prim);
+			break;
+		case LLC_DATA_PRIM:
+			skb = prim->data->data.skb;
+			nbll_deliver_packet(skb, &prim->data->data);
+			break;
+		case LLC_DISC_PRIM:
+			nbll_get_disconnect_indicate(prim);
+			break;
+		case LLC_RESET_PRIM:
+			nbll_get_reset_indicate(prim);
+			break;
+		case LLC_FLOWCONTROL_PRIM:
+			break;
+	}
+	return 0;
+}
+
+/**
+ *	netbeui_confirm - callback for LLC confirm primitive.
+ *	@prim: primary interface block type, the LLC comm data structure. 
+ *
+ *	The callback for LLC confirm primitive dispatching. It dispatches LLC
+ *	primitive to Link Service State Machine interfaces.
+ *	Note: LLC reset confirm is not generated, since we never generate
+ *	reset request
+ */
+static int netbeui_confirm(struct llc_prim_if_block *prim)
+{
+	int status = 0;
+
+	switch (prim->prim) {
+		case LLC_CONN_PRIM:
+			nbll_get_connect_confirm(prim);		break;
+		case LLC_DATA_PRIM:
+			status = nbll_get_data_confirm(prim);	break;
+		case LLC_DISC_PRIM:
+			nbll_get_disconnect_confirm(prim);	break;
+		case LLC_RESET_PRIM:				break;
+	}
+	return status;
+}
+
+static char banner[] __initdata =
+	KERN_INFO "NetBEUI 2.0 by Procom, 1997, Arnaldo C. Melo, 2001\n";
+static char err_sap[] __initdata =
+	KERN_ERR "Error opening NetBIOS SAP 0x%X on LLC.\n";
+static char err_socket[] __initdata =
+	KERN_ERR "Error registering NetBEUI socket.\n";
+static char err_proc[] __initdata =
+	KERN_INFO "Error registering NetBEUI proc entries.\n";
+
+/**
+ *	netbeui_init - The starting point of NetBEUI module.
+ *
+ *	Since NetBEUI is distributed as a module, netbeui_init does all initial
+ *	steps itself. Returns 0 if module initialized successfully, non-zero
+ *	if a step in initialization failed (mostly opening LLC sap)
+ */
+static int __init netbeui_init(void)
+{
+	int rc = 0;
+
+	printk(banner);
+	netbeui_sap = llc_sap_open(netbeui_indicate, netbeui_confirm,
+				   LLC_SAP_NETBEUI);
+	if (!netbeui_sap) {
+		printk(err_sap);
+		goto err;
+	}
+	write_lock(&netbeui_adapters.lock);
+	netbeui_adapters.autobind = autobind;
+	if (autobind) {
+		int i = 0;
+		struct net_device *dev;
+
+		read_lock(&dev_base_lock);
+		for (dev = dev_base; dev && i < NETBEUI_MAX_ADAPTERS;
+		     dev = dev->next)
+			if (nbcm_apt_dev(dev)) {
+				dev_hold(dev);
+				netbeui_adapters.dev[i++] = dev;
+				dev_mc_add(dev, netbeui_funcaddr(dev),
+					   dev->addr_len, 0);
+			}
+		read_unlock(&dev_base_lock);
+		netbeui_adapters.count = i;
+	}
+	nbns_init_name_number_1(netbeui_adapters.dev);
+	write_unlock(&netbeui_adapters.lock);
+	nbdg_set_dgbc_mtu();
+
+	if (nbso_init()) {
+		printk(err_socket);
+		goto err_sap;
+	}
+	if (netbeui_proc_init()) {
+		printk(err_proc);
+		goto err_nbso;
+	}
+	nbst_init_status();
+out:	return rc;
+err_nbso:
+	nbso_exit();
+err_sap:
+	llc_sap_close(netbeui_sap);
+err:	rc = -1;
+	goto out;
+}
+
+static char err_exit[] __exitdata =
+		KERN_ERR "Error unregistering NetBEUI socket.\n";
+
+/**
+ *	netbeui_exit - The ending point of NetBEUI module.
+ *
+ *	Since NetBEUI is distributed as a module, netbeui_exit does all
+ *	housekeeping steps itself
+ */
+static void __exit netbeui_exit(void)
+{
+	int i;
+
+	nbll_disconnect_all_links();
+	read_lock(&netbeui_adapters.lock);
+	for (i = 0; i < netbeui_adapters.count; i++) {
+		dev_mc_delete(netbeui_adapters.dev[i],
+			      netbeui_funcaddr(netbeui_adapters.dev[i]),
+			      netbeui_adapters.dev[i]->addr_len, 0);
+		dev_put(netbeui_adapters.dev[i]);
+	}
+	read_unlock(&netbeui_adapters.lock);
+	if (nbso_exit())
+		printk(err_exit);
+	netbeui_proc_clean();
+	llc_sap_close(netbeui_sap);
+}
+module_init(netbeui_init);
+module_exit(netbeui_exit);
diff -ruN linux-2.4.18-clean/net/netbeui/name_serve.c linux/net/netbeui/name_serve.c
--- linux-2.4.18-clean/net/netbeui/name_serve.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/name_serve.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,898 @@
+/*
+ * name_serve.c - Contains functions that implement NetBIOS Name Service
+ *
+ * Notes:
+ *	- Two intermixed structures hold local name table a dextab_t that is
+ *	  used for assigning numbers to names and implicit name rule checking
+ *	  and a unidirectional linked list which is used for name search. every
+ *	  name entry may be found in both data structures.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/netbeui.h>
+
+static void nbns_timer_function(unsigned long input);
+
+/* These functions are Name State Transition handlers */
+static int nbns_add_name_in_initial(name_t *nb_name);
+static int nbns_retry_timeout_in_all(name_t *nb_name);
+static int nbns_response_timeout_in_addwait(name_t *nb_name);
+static int nbns_add_name_response1_in_addwait(name_t *nb_name);
+static int nbns_add_name_query_in_addwait(name_t *nb_name);
+static int nbns_response_timeout_in_collided(name_t *nb_name);
+static int nbns_add_name_response2_in_collided(name_t *nb_name);
+static int nbns_add_name_query_in_acquired(name_t *nb_name);
+static int nbns_name_conflict_in_acquired(name_t *nb_name);
+static int nbns_remove_name_in_acquired(name_t *nb_name);
+
+static void nbns_handle_event(name_event_t event, name_t *nb_name);
+static unsigned short int nbns_correlator;
+#define nbns_next_correlator() (++nbns_correlator)
+
+/* We need to have two paths to access names from dextab and linked-list */
+static name_t *name_list;
+static rwlock_t name_list_lock = RW_LOCK_UNLOCKED;
+dextab_t name_table = {
+	reserved:	2,
+	max_size:	NETBEUI_MAX_NAMES,
+	lock:		SPIN_LOCK_UNLOCKED
+};
+static name_t name_number_1;
+
+#define name_table_entry(i)	((name_t *)name_table.addr[i])
+
+/* Name Service State Machine definition */
+typedef int (* name_event_handler_t)(name_t *);
+
+struct event_struct {
+	name_state_t  next_state;
+	name_event_handler_t event_handler;
+};
+static struct event_struct name_state_table[4][8] = {
+			/* NETBEUI_NAME_INITIAL */
+{
+{ NETBEUI_NAME_ADDWAIT,
+	nbns_add_name_in_initial }, /* NETBEUI_NAME_ADD_NAME */
+{ -1, NULL },			    /* NETBEUI_NAME_RETRY_TIMEOUT */
+{ -1, NULL },			    /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+{ -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+{ -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+{ -1, NULL },			    /* NETBEUI_NAME_ADD_NAME_QUERY */
+{ -1, NULL },			    /* NETBEUI_NAME_NAME_CONFLICT */
+{ -1, NULL }			    /* NETBEUI_NAME_REMOVE_NAME */
+},
+			/* NETBEUI_NAME_ADDWAIT  */
+{
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME */
+{ NETBEUI_NAME_ADDWAIT,
+	nbns_retry_timeout_in_all },	   /* NETBEUI_NAME_RETRY_TIMEOUT */
+{ NETBEUI_NAME_ACQUIRED,
+	nbns_response_timeout_in_addwait }, /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+{ NETBEUI_NAME_COLLIDED,
+	nbns_add_name_response1_in_addwait }, /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+{NETBEUI_NAME_ADDWAIT,
+	nbns_add_name_query_in_addwait },  /* NETBEUI_NAME_ADD_NAME_QUERY */
+{ -1, NULL },				   /* NETBEUI_NAME_NAME_CONFLICT */
+{ -1, NULL }				   /* NETBEUI_NAME_REMOVE_NAME */
+},
+			/* NETBEUI_NAME_COLLIDED */
+{
+{ -1, NULL },				     /* NETBEUI_NAME_ADD_NAME */
+{ NETBEUI_NAME_COLLIDED,
+	nbns_retry_timeout_in_all },	     /* NETBEUI_NAME_RETRY_TIMEOUT */
+{ NETBEUI_NAME_INITIAL,
+	nbns_response_timeout_in_collided }, /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+{ NETBEUI_NAME_INITIAL,
+	nbns_add_name_response2_in_collided }, /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+{ -1, NULL },				     /* NETBEUI_NAME_ADD_NAME_QUERY */
+{ -1, NULL },				     /* NETBEUI_NAME_NAME_CONFLICT */
+{ -1, NULL }				     /* NETBEUI_NAME_REMOVE_NAME */
+},
+			/* NETBEUI_NAME_ACQUIRED */
+{
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME */
+{ -1, NULL },				   /* NETBEUI_NAME_RETRY_TIMEOUT */
+{ -1, NULL }, 				   /* NETBEUI_NAME_RESPONSE_TIMEOUT */
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE1 */
+{ -1, NULL },				   /* NETBEUI_NAME_ADD_NAME_RESPONSE2 */
+{ NETBEUI_NAME_ACQUIRED,
+	nbns_add_name_query_in_acquired }, /* NETBEUI_NAME_ADD_NAME_QUERY */
+{ NETBEUI_NAME_ACQUIRED,
+	nbns_name_conflict_in_acquired },  /* NETBEUI_NAME_NAME_CONFLICT */
+{ NETBEUI_NAME_INITIAL,
+	nbns_remove_name_in_acquired },    /* NETBEUI_NAME_REMOVE_NAME */
+}
+};
+
+/* NAME_NUMBER_1 assignment and interface functions */
+/*
+ * Function: nbns_dev_name_number_1
+ *	Returns the name number of built by device MAC address
+ * Parameters:
+ *	dev: pointer to device structure to build its NAME_NUMBER_1
+ * Returns:
+ *	non-NULL: pointer to NAME_NUMBER_1 built by device MAC address
+ * Note:
+ *	NAME_NUMBER_1 is defined as (16-n) bytes zero concatenated by (n)
+ *	bytes of MAC address, where n is size of MAC address in bytes.
+ */
+unsigned char *nbns_dev_name_number_1(struct net_device *dev)
+{
+	static char dev_name_number_1[NETBEUI_NAME_LEN];
+	int zero_count = NETBEUI_NAME_LEN - dev->addr_len;
+
+	memset(dev_name_number_1, 0, zero_count);
+	memcpy(dev_name_number_1 + zero_count, dev->dev_addr, dev->addr_len);
+	return dev_name_number_1;
+}
+
+/*
+ * Function: nbns_validate_name
+ *	Checks a NetBIOS name validity according to NetBIOS name rules.
+ * Parameters:
+ *	name: pointer to NetBIOS name
+ * Returns:
+ *	0	: if name is a valid NetBIOS name
+ *	non-zero: if name is not a valid NetBIOS name
+ */
+int nbns_validate_name(char *name)
+{
+	return (!memcmp(name, "IBM", 3) ||
+		 memchr(name, '\0', NETBEUI_NAME_LEN - 1)) ? -1 : 0;
+}
+
+/*
+ * Function: nbns_init_name_number_1
+ *	Finds a correct value for NAME_NUMBER_1
+ * Parameters:
+ *	adapters: list of adapters the NetBEUI is bound to
+ * Returns: None
+ * Notes:
+ *	- A NetBEUI implementation should provide a unique NAME_NUMBER_1.
+ *	  Since our implementations supports both multiple interface and
+ *	  loopback device, we need to decide on the device that is used
+ *	  for generating NAME_NUMBER_1.
+ */
+void nbns_init_name_number_1(struct net_device *adapters[])
+{
+	name_number_1.type	  = NETBEUI_NAME_UNIQUE;
+	name_number_1.state	  = NETBEUI_NAME_ACQUIRED;
+	name_number_1.name_number = 1;
+
+	if (adapters[0] && !(adapters[0]->flags & IFF_LOOPBACK)) {
+		memcpy(name_number_1.name, nbns_dev_name_number_1(adapters[0]),
+		       NETBEUI_NAME_LEN);
+		goto out;
+	}
+	if (adapters[1]) {
+		memcpy(name_number_1.name, nbns_dev_name_number_1(adapters[1]),
+		       NETBEUI_NAME_LEN);
+		goto out;
+	}
+	if (adapters[0]) {
+		memcpy(name_number_1.name, "LOOPBACK DEVICE   ",
+		       NETBEUI_NAME_LEN);
+		goto out;
+	}
+	name_number_1.name_number = -1;
+out:;
+}
+
+/*
+ * Function: nbns_name_number_1
+ *	The Name Service interface access routine for NAME_NUMBER_1
+ * Parameters: None
+ * Returns:
+ *	non-NULL: pointer to name_t structure that holds NAME_NUMBER_1
+ */
+name_t *nbns_name_number_1(void)
+{
+	return name_number_1.name_number == 1 ? &name_number_1 : NULL;
+}
+
+/*
+ * Name service state machine functions
+ * Implementing general functions
+ */
+/*
+ * Function: nbns_alloc_skb
+ *	allocates a sk_buff that suits Name Service framing needs
+ * Parameters:
+ *	data_len: number of data bytes that the calling routine intends
+ *		  to put in skb
+ * Returns:
+ *	NULL	: if can not allocate memory for skb
+ *	non-NULL: pointer to skb allocated with data_len bytes space for data
+ */
+static struct sk_buff *nbns_alloc_skb(int mac_hlen, int data_len)
+{
+	struct sk_buff *skb = alloc_skb(CALC_DG_SKBLEN(mac_hlen, data_len),
+					GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	skb_reserve(skb, LLCMAC_UI_HEADLEN(mac_hlen));
+	skb->nh.raw = skb->h.raw = skb->data;
+	skb_put(skb, data_len);
+	skb->dev = NULL;
+out:	return skb;
+}
+
+/*
+ * Function: nbns_alloc_name
+ *	Allocates a name_t structure and does completely initialize all fields
+ * Parameters: None
+ * Returns:
+ *	NULL	: if can not allocate memory for name_t or its sk_buff
+ *	non-NULL: pointer to name_t
+ * Notes:
+ *	- An skb is attached to each new name for name registration purposes
+ *	- Name timer is initialized but not started.
+ *	- The call to memset does implicitly initialize all fields. Those fields
+ *	  that need explicit non-zero initialization are manipulated afterwards.
+ */
+static name_t *nbns_alloc_name(void)
+{
+	name_t *nb_name = kmalloc(sizeof(*nb_name), GFP_ATOMIC);
+
+	if (!nb_name)
+		goto out;
+	/* Implicitly initialize all fields */
+	memset(nb_name, 0, sizeof(*nb_name));
+	init_timer(&nb_name->timer);
+	nb_name->timer.data	= (unsigned long)nb_name;
+	nb_name->timer.function	= nbns_timer_function;
+	init_waitqueue_head(&nb_name->waitq);
+	atomic_set(&nb_name->refcnt, 1);
+	/* Allocate name skb */
+	nb_name->skb = nbns_alloc_skb(NETBEUI_MAC_B_HEADLEN,
+				      nb_cmd_hdr_len[NETBEUI_ADD_NAME_QUERY]);
+	if (!nb_name->skb) {
+		kfree(nb_name);
+		nb_name = NULL;
+	}
+out:	return nb_name;
+}
+
+/*
+ * Function: nbns_free_name
+ *	Deallocates memory used for name_t and its sk_buff
+ * Parameters:
+ *	nb_name: pointer to name_t memory to be freed
+ * Returns: None
+ */
+static void __nbns_free_name(name_t *nb_name)
+{
+	kfree_skb(nb_name->skb);
+	kfree(nb_name);
+}
+
+static void nbns_free_name(name_t *nb_name)
+{
+	nbns_handle_event(NETBEUI_NAME_REMOVE_NAME, nb_name);
+	__nbns_free_name(nb_name);
+}
+
+inline void nbns_name_hold(name_t *nb_name)
+{
+	atomic_inc(&nb_name->refcnt);
+}
+
+inline void nbns_name_put(name_t *nb_name)
+{
+	if (atomic_dec_and_test(&nb_name->refcnt))
+		nbns_free_name(nb_name);
+}
+
+/*
+ * Function: nbns_add_name_to_table
+ *	Inserts a previously allocated/initialized name_t into system local name
+ *	table and local name list.
+ * Parameters:
+ *	nb_name: pointer to name_t to insert
+ * Returns:
+ *	0      : if name is successfully inserted into name table
+ *	-ENOSPC: if local name table is full
+ */
+static int nbns_add_name_to_table(name_t *nb_name)
+{
+	/* Allocate a name table entry  */
+	int name_number = dextab_insert_entry(&name_table, nb_name);
+
+	if (name_number <= 1)
+		return -ENOSPC;
+	nb_name->name_number = name_number;
+	/* Add name to name list */
+	write_lock_bh(&name_list_lock);
+	nb_name->next	     = name_list;
+	name_list	     = nb_name;
+	write_unlock_bh(&name_list_lock);
+	return 0;
+}
+
+/*
+ * Function: nbns_remove_name_from_table
+ *	Removes a name from system local name table.
+ * Parameters:
+ *	nb_name: pointer to name_t to remove
+ * Returns: None
+ */
+static void nbns_remove_name_from_table(name_t *nb_name)
+{
+	name_t *entry;
+	name_t *prev_entry = NULL;
+
+	dextab_delete_entry(&name_table, nb_name);
+	write_lock_bh(&name_list_lock);
+	entry = name_list;
+	while (entry) {
+		if (entry == nb_name) {
+			if (prev_entry)
+				prev_entry->next = entry->next;
+			else
+				name_list = entry->next;
+			break;
+		}
+		prev_entry = entry;
+		entry = entry->next;
+	}
+	write_unlock_bh(&name_list_lock);
+}
+
+/*
+ * Function: nbns_find_correlator
+ *	Finds a name in local name list, which has a specific NetBIOS name
+ *	and has transmitted frames with a specific correlator
+ * Parameters:
+ *	correlator: a sixteen bit integer which contains the response
+ *	            correlator of input frame. It should be matched against
+ *		    xmit correlator of frames sent by the element.
+ *	name	  : pointer to NetBIOS name that the requested element should
+ *		    have
+ * Returns:
+ *	NULL	: if no name_t element found with the requested characteristics
+ *	non-NULL: pointer to matching name_t with requested characteristics
+ * Notes:
+ *	- This routine is useful for relating incoming response frames with
+ *	  name elements that have transmitted requests to remote nodes.
+ */
+static name_t *nbns_find_correlator(unsigned short correlator, char *name)
+{
+	name_t *nb_name;
+
+	read_lock_bh(&name_list_lock);
+	nb_name = name_list;
+	while (nb_name)
+		if (nb_name->resp_correlator == correlator &&
+		    nb_name->state != NETBEUI_NAME_ACQUIRED &&
+		    !memcmp(nb_name->name, name, NETBEUI_NAME_LEN))
+			break;
+		else
+			nb_name = nb_name->next;
+	if (nb_name)
+		nbns_name_hold(nb_name);
+	read_unlock_bh(&name_list_lock);
+	return nb_name;
+}
+
+/*
+ * Function: nbns_boradcast_add_name_query
+ *	Prepares a NetBIOS ADD NAME QUERY frame and nbll_uisends it to network
+ * Parameters:
+ *	nb_name: pointer to name_t structure which the frame should be built for
+ * Returns:
+ *	0 	: if frame is successfully broadcasted to network
+ *	non-zero: if frame transmission encountered an error (usually at NDI
+ *		  layer)
+ * Notes:
+ *	- Since ADD NAME QUERY frames are retransmitted in timed intervals, it
+ *	  is considered to build frame once, but transmit it multiple times.
+ *	  having built frames in each retransmission does generate multiple
+ *	  correlators and does frustrate processing responses.
+ */
+static int nbns_broadcast_add_name_query(name_t *nb_name)
+{
+	if (!nb_name->retries) {
+		dgram_t *hdr = (dgram_t *)nb_name->skb->data;
+
+		hdr->length	= nb_cmd_hdr_len[NETBEUI_ADD_NAME_QUERY];
+		hdr->delimiter	= NETBEUI_DELIMITER;
+		hdr->command	= nb_name->type == NETBEUI_NAME_UNIQUE ?
+						   NETBEUI_ADD_NAME_QUERY :
+						   NETBEUI_ADD_GROUP_NAME_QUERY;
+		hdr->data1		= 0;
+		hdr->data2		= 0;
+		hdr->xmit_correlator	= 0;
+		hdr->resp_correlator	= nb_name->resp_correlator =
+							nbns_next_correlator();
+		memset(hdr->dest_name, 0, NETBEUI_NAME_LEN);
+		memcpy(hdr->source_name, nb_name->name, NETBEUI_NAME_LEN);
+	}
+	return nbll_uisend(NULL, nb_name->skb);
+}
+
+/*
+ * Function: nbns_broadcast_name_in_conflict
+ *	Prepares a NetBIOS NAME IN CONFLICT frame and nbll_uisends it to network
+ * Parameters:
+ *	nb_name: pointer to name_t structure which the frame should be built for
+ * Returns:
+ *	0 	: if frame is successfully broadcasted to network
+ *	non-zero: if frame transmission encountered an error (usually at NDI
+ *		  layer)
+ */
+static int nbns_broadcast_name_in_conflict(name_t *nb_name)
+{
+	dgram_t *hdr = (dgram_t *)nb_name->skb->data;
+
+	hdr->length	= nb_cmd_hdr_len[NETBEUI_NAME_IN_CONFLICT];
+	hdr->delimiter	= NETBEUI_DELIMITER;
+	hdr->command	= NETBEUI_NAME_IN_CONFLICT;
+	hdr->data1	= hdr->data2 = 0;
+	hdr->xmit_correlator = hdr->resp_correlator = 0;
+	memcpy(hdr->dest_name, nb_name->name, NETBEUI_NAME_LEN);
+	memcpy(hdr->source_name, nbns_name_number_1()->name, NETBEUI_NAME_LEN);
+	return nbll_uisend(NULL, nb_name->skb);
+}
+
+/*
+ * Function: nbns_unicast_add_name_response
+ *	Prepares a NetBIOS ADD NAME RESPONSE frame and nbll_uisends it to
+ *	network
+ * Parameters:
+ *	nb_name: pointer to name_t structure which the frame should be built for
+ * Returns:
+ *	0 	: if frame is successfully broadcasted to network
+ *	non-zero: if frame transmission encountered an error (usually at NDI
+ *		  layer) or it can not allocate memory for frame.
+ * Note:
+ *	- The lack of memory and inability to send response frame may cause a
+ *	  name to conflict on network. This is simply the case on a heavily
+ *	  loaded server, however since the query is retransmitted multiple times
+ *	  we hope the server would be able to defend its name at least once. In
+ *	  addition if an administrator finds the case he can increase either
+ *	  retransmissions or timeouts for all nodes on network.
+ */
+static int nbns_unicast_add_name_response(name_t *nb_name)
+{
+	dgram_t *hdr;
+	struct sk_buff *skb = nbns_alloc_skb(MAC_HEADLEN(nb_name->dev),
+				     nb_cmd_hdr_len[NETBEUI_ADD_NAME_RESPONSE]);
+	if (!skb)
+		return -ENOMEM;
+	hdr		= (dgram_t *)skb->data;
+	hdr->length	= nb_cmd_hdr_len[NETBEUI_ADD_NAME_RESPONSE];
+	hdr->delimiter	= NETBEUI_DELIMITER;
+	hdr->command	= NETBEUI_ADD_NAME_RESPONSE;
+	hdr->data1	= nb_name->state == NETBEUI_NAME_ACQUIRED ? 0 : 1;
+	hdr->data2	= nb_name->type;
+	hdr->xmit_correlator	= nb_name->xmit_correlator;
+	hdr->resp_correlator	= 0;
+	memcpy(hdr->source_name, nb_name->name, NETBEUI_NAME_LEN);
+	memcpy(hdr->dest_name, nb_name->name, NETBEUI_NAME_LEN);
+	skb->dev	= nb_name->dev;
+	return nbll_uisend(nb_name->remote_mac, skb);
+}
+
+/*
+ * Function: nbns_handle_event
+ *	This is the heart of Name Service State Machine, which performs a
+ *	transition from current state of name element to new state based
+ *	on event occurred and name state table contents.
+ * Parameters:
+ *	event  : An integer of NETBEUI_NAME_* family that implies type of event
+ *	nb_name: pointer to name_t structure which the event occurred on
+ * Returns: None
+ * Notes:
+ *	- The state changes before actions be executed. This is due to
+ *	  non deterministic behavior of actions which may sleep the current
+ *	  process, thus stopping the function in the mid-way.
+ */
+static void nbns_handle_event(name_event_t event, name_t *nb_name)
+{
+	struct event_struct *ev = &name_state_table[nb_name->state][event];
+
+	if (ev && ev->event_handler) {
+		unsigned char old_state = nb_name->state;
+
+		nb_name->state = ev->next_state;
+		if (ev->event_handler(nb_name))
+			nb_name->state = old_state;
+	}
+}
+
+/*
+ * Function: nbns_timer_function
+ *	This is the callback function triggered upon expiration of name
+ *	retransmittion timer. It just injects an event into state machine for
+ *	its link.
+ * Parameters:
+ *	input: pointer to name_t structure whose timer is expired.
+ * Returns: None
+ */
+static void nbns_timer_function(unsigned long input)
+{
+	name_t *nb_name = (name_t *)input;
+
+	if (nb_name->retries < NETBEUI_TRANSMIT_COUNT)
+		nbns_handle_event(NETBEUI_NAME_RETRY_TIMEOUT, nb_name);
+	else
+		nbns_handle_event(NETBEUI_NAME_RESPONSE_TIMEOUT, nb_name);
+}
+
+/*
+ * Name service state machine functions
+ * Implementing transition functions
+ */
+/*
+ * Function: nbns_xxxx_in_ssss
+ *	The section below contains functions that implement actions needed
+ *	to  legally transit from one state to another.
+ * Parameters:
+ *	nb_name: pointer to name_t structure which the actions are to be
+ *		 applied to
+ * Returns:
+ *	0	: if all actions are done successfully
+ *	non-zero: if one of actions failed
+ * Note:
+ *	- For the sake of simplicity, the actions are automatically rollbacked
+ *	  in each function, if an action in transition fails. The design
+ *	  documents do not cover these parts of code.
+ */
+static int nbns_add_name_in_initial(name_t *nb_name)
+{
+	int rc = -1;
+
+	nb_name->retries = 0;
+	nb_name->status  = nbns_broadcast_add_name_query(nb_name);
+	if (nb_name->status)
+		goto out;
+	nb_name->status = nbns_add_name_to_table(nb_name);
+	if (nb_name->status)
+		goto out;
+	rc = 0;
+	nb_name->retries++;
+	nb_name->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_name->timer);
+	sleep_on(&nb_name->waitq);
+out:	return rc;
+}
+
+static int nbns_retry_timeout_in_all(name_t *nb_name)
+{
+	nb_name->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_name->timer);
+
+	if (nbns_broadcast_add_name_query(nb_name))
+		return -1;
+	nb_name->retries++;
+	return 0;
+}
+
+static int nbns_response_timeout_in_addwait(name_t *nb_name)
+{
+	wake_up(&nb_name->waitq);
+	return 0;
+}
+
+static int nbns_add_name_response1_in_addwait(name_t *nb_name)
+{
+	nb_name->status = -EADDRINUSE;
+	return 0;
+}
+
+static int nbns_add_name_query_in_addwait(name_t *nb_name)
+{
+	return nbns_unicast_add_name_response(nb_name) ? -1 : 0;
+}
+
+static int nbns_response_timeout_in_collided(name_t *nb_name)
+{
+	wake_up(&nb_name->waitq);
+	nbns_remove_name_from_table(nb_name);
+	return 0;
+}
+
+static int nbns_add_name_response2_in_collided(name_t *nb_name)
+{
+	nbns_broadcast_name_in_conflict(nb_name);
+	del_timer(&nb_name->timer);
+	wake_up(&nb_name->waitq);
+	nbns_remove_name_from_table(nb_name);
+	return 0;
+}
+
+static int nbns_add_name_query_in_acquired(name_t *nb_name)
+{
+	return nbns_unicast_add_name_response(nb_name) ? -1 : 0;
+}
+
+static int nbns_name_conflict_in_acquired(name_t *nb_name)
+{
+	nb_name->conflicted = 1;
+	return 0;
+}
+
+static int nbns_remove_name_in_acquired(name_t *nb_name)
+{
+	nbns_remove_name_from_table(nb_name);
+	return 0;
+}
+
+/*
+ * Name service state machine functions
+ * Implementing interface functions
+ */
+/*
+ * Function: nbns_add_name
+ *	Adds a name to local name table after checking network (being
+ *	permitted).
+ * Parameters:
+ *	name	: pointer to 16 byte NetBIOS name
+ *	type	: type of NetBIOS name that is NETBEUI_NAME_GROUP,
+ *		  NETBEUI_NAME_UNIQUE
+ *	out_name: pointer to name_t structure built for that name. Since this
+ *		  a result argument, its value depends on function return value
+ *		  if return value specifies successful operation then this
+ *		  argument contains a valid pointer.
+ * Returns:
+ *	0	   : if name successfully registered into local name table
+ *	-EINVAL    : if name is not a valid NetBIOS name
+ *	-EADDRINUSE: if name is registered either in local name table or
+ *		     on another machine in network.
+ *	-ENOMEM	   : if memory allocation for name element name_t fails
+ *	others	   : any other error value reported by LLC or system.
+ */
+int nbns_add_name(char *name, name_type_t type, name_t **out_name)
+{
+	name_t *nb_name;
+	int rc = -EINVAL;
+
+	if (nbns_validate_name(name))
+		goto out;
+	rc = -EADDRINUSE;
+	nb_name = nbns_find_name(name);
+	if (nb_name)
+		goto out_put;
+	nb_name = nbns_alloc_name();
+	rc = -ENOMEM;
+	if (!nb_name)
+		goto out;
+	*out_name = NULL;
+	nb_name->state	= NETBEUI_NAME_INITIAL;
+	nb_name->type	= type;
+	memcpy(nb_name->name, name, NETBEUI_NAME_LEN);
+	nbns_handle_event(NETBEUI_NAME_ADD_NAME, nb_name);
+	if (nb_name->state != NETBEUI_NAME_ACQUIRED) {
+		rc = nb_name->status ? : -1;
+		__nbns_free_name(nb_name);
+		goto out;
+	}
+	rc = 0;
+	*out_name = nb_name;
+	nbns_name_hold(nb_name);
+out:	return rc;
+out_put:
+	nbns_name_put(nb_name);
+	goto out;
+}
+
+/*
+ * Function: nbns_find_name
+ *	Finds a name with a specific 16 bytes NetBIOS name in local name table.
+ * Parameters:
+ *	name: pointer to 16 bytes NetBIOS name to be located in local name table
+ * Returns:
+ *	NULL	: if NetBIOS name not found in local name table
+ *	non-NULL: pointer to name_t element found in local name table.
+ */
+name_t *nbns_find_name(char *name)
+{
+	name_t *nb_name;
+
+	read_lock_bh(&name_list_lock);
+	nb_name = name_list;
+	while (nb_name) {
+		if (!memcmp(nb_name->name, name, NETBEUI_NAME_LEN))
+			break;
+		nb_name = nb_name->next;
+	}
+	if (nb_name)
+		nbns_name_hold(nb_name);
+	read_unlock_bh(&name_list_lock);
+	return nb_name;
+}
+
+/*
+ * Function: nbns_del_name
+ *	Removes a name_t element from local name table and local name list,
+ *	using its NetBIOS name.
+ * Parameters:
+ *	nb_name: pointer to name_t element to remove from local name table
+ * Returns: None
+ * Notes:
+ *	- Removing the name_t is a multi-pass mechanism depending on the value
+ *	  of name use count. A name is actually removed from local name table
+ *	  when its use count reaches zero.
+ */
+void nbns_del_name(name_t *nb_name)
+{
+	if (nb_name->name_number != 1)
+		nbns_name_put(nb_name);
+}
+
+/*
+ * Function: nbns_del_identifier
+ *	Removes a name_t element from local name table and local name list,
+ *	using its identification number.
+ * Parameters:
+ *	id: id or number of the name to remove from local name table
+ * Returns: None
+ * Notes:
+ *	- Refer to notes section of nbns_del_name comment
+ *	- The identification number is a notion used in sock_name. Every
+ *	  SOCK_NAME type socket assigns a unique identifier to all the name
+ *	  it registers, which lets not to keep another table of registered
+ *	  names in socket data structures. The value is simple memory address
+ *	  of socket and is assigned directly from SOCK_NAME codes.
+ *	- Multiple names may have similar identifier.
+ */
+void nbns_del_identifier(unsigned long id)
+{
+	name_t *nb_name;
+	int index;
+
+	for (index = name_table.reserved; index < name_table.size; index++) {
+		nb_name = name_table_entry(index);
+		if (nb_name && nb_name->identifier == id)
+			nbns_del_name(nb_name);
+	}
+}
+
+/*
+ * Function: nbns_get_add_name_query
+ *	Accepts an ADD NAME QUERY frame and generates an event for Name
+ *	Service State Machine.
+ * Parameters:
+ *	skb	  : pointer to sk_buff that holds the frame
+ *	remote_mac: pointer to MAC address of remote node, whom sent the frame
+ *	type	  : the flag indicates the type of query:
+ *			NETBEUI_NAME_GROUP indicates ADD GROUP NAME QUERY
+ *			NETBEUI_NAME_UNIQUE indicates ADD NAME QUERY
+ * Returns: none
+ */
+void nbns_get_add_name_query(struct sk_buff *skb, unsigned char *remote_mac,
+			     int type)
+{
+	dgram_t *hdr = (dgram_t *)skb->data;
+	name_t *nb_name = nbns_find_name(hdr->source_name);
+
+	/* If name not found in name table or both are group names */
+	if (!nb_name)
+	       goto out;
+	if ((skb->dev->flags & IFF_LOOPBACK) ||
+            (nb_name->type == NETBEUI_NAME_GROUP && type == NETBEUI_NAME_GROUP))
+		goto out_put;
+	memcpy(nb_name->remote_mac, remote_mac, skb->dev->addr_len);
+	nb_name->dev = skb->dev;
+	nb_name->xmit_correlator = hdr->resp_correlator;
+	nbns_handle_event(NETBEUI_NAME_ADD_NAME_QUERY, nb_name);
+out_put:
+	nbns_name_put(nb_name);
+out:	kfree_skb(skb);
+}
+
+/*
+ * Function: nbns_get_add_name_response
+ *	Accepts an ADD NAME RESPONSE frame and generates an event for Name
+ *	Service State Machine.
+ * Parameters:
+ *	skb	  : pointer to sk_buff that holds the frame
+ *	remote_mac: pointer to MAC address of remote node, whom sent the frame
+ * Returns: none
+ */
+void nbns_get_add_name_response(struct sk_buff *skb, unsigned char *remote_mac)
+{
+	dgram_t *hdr = (dgram_t *)skb->data;
+	name_t *nb_name = nbns_find_correlator(hdr->xmit_correlator,
+					       hdr->dest_name);
+	/* If it does not match a query */
+	if (!nb_name)
+		goto out;
+	/* The name registration query got a negative response */
+	/* Test if it is a duplicate and already received */
+
+	if (nb_name->dev != skb->dev ||
+	    memcmp(nb_name->remote_mac, remote_mac, skb->dev->addr_len)) {
+		nb_name->dev = skb->dev;
+		memcpy(nb_name->remote_mac, remote_mac, skb->dev->addr_len);
+		nb_name->responses++;
+		if (nb_name->responses == 1)
+			nbns_handle_event(NETBEUI_NAME_ADD_NAME_RESPONSE1,
+					  nb_name);
+		else
+			nbns_handle_event(NETBEUI_NAME_ADD_NAME_RESPONSE2,
+					  nb_name);
+	}
+	nbns_name_put(nb_name);
+out:	kfree_skb(skb);
+}
+
+/*
+ * Function: nbns_get_name_conflict
+ *	Accepts a NAME CONFLICT frame and generates an event for Name
+ *	Service State Machine.
+ * Parameters:
+ *	skb: pointer to sk_buff that holds the frame
+ * Returns: None
+ * Notes:
+ *	- The strategy chosen for manipulating NAME CONFLICT frames is to
+ *	  set a flag in name_t structure, which is available via /proc entry
+ *	  interface.
+ */
+void nbns_get_name_conflict(struct sk_buff *skb)
+{
+	name_t *nb_name = nbns_find_name(((dgram_t *)skb->data)->source_name);
+
+	if (nb_name) {
+		nbns_handle_event(NETBEUI_NAME_NAME_CONFLICT, nb_name);
+		nbns_name_put(nb_name);
+	}
+	kfree_skb(skb);
+}
+
+/*
+ * Function: nbns_get_link_table
+ *	returns a pointer to NetBEUI name table. The proc support code uses
+ *	the name table to map its contents to /proc/sys/netbeui entry.
+ * Parameters: None
+ * Returns:
+ *	non-NULL: pointer to NetBEUI name table
+ */
+dextab_t *nbns_get_name_table(void)
+{
+	return &name_table;
+}
+
+/*
+ * Function: nbns_get_name_list
+ *	returns a pointer to NetBEUI name list. The status module uses
+ *	the name list to prepare its status response.
+ * Parameters: None
+ * Returns:
+ *	NULL	: name list has no entry
+ *	non-NULL: pointer to NetBEUI name list
+ */
+name_t *nbns_get_name_list(void)
+{
+	return name_list;
+}
+
+/*
+ * Function: nbns_count_names
+ *	returns number of entries in name table. The status module uses
+ *	the this number to prepare its status response.
+ * Parameters: None
+ * Returns:
+ *	zero	: name table has no entry
+ *	positive: number of entries in name table
+ */
+int nbns_count_names(void)
+{
+	return name_table.count;
+}
diff -ruN linux-2.4.18-clean/net/netbeui/nb_common.c linux/net/netbeui/nb_common.c
--- linux-2.4.18-clean/net/netbeui/nb_common.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/nb_common.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,134 @@
+/*
+ * nb_common.c - Contains common in use functions for NetBEUI services.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/netbeui.h>
+#include <linux/if_arp.h>
+
+/*
+ * Function: netbeui_funcaddr
+ *	Returns functional address of a network device.
+ * Parameters:
+ *	dev : pointer to device that need to its functional address.
+ * Returns: char *
+ */
+char *netbeui_funcaddr(struct net_device *dev)
+{
+	char* rc = NETBIOS_FUNC_ADDR_4ETH;
+
+	if (dev->type != ARPHRD_ETHER && dev->type != ARPHRD_EETHER &&
+	    dev->type != ARPHRD_LOOPBACK) {
+		if (dev->type == ARPHRD_IEEE802)
+			rc = NETBIOS_FUNC_ADDR_4TR;
+		else
+			rc = "\x00\x00\x00\x00\x00\x00";
+	}
+	return rc;
+}
+
+/*
+ * Function: nbcm_dev_supported
+ *	Indicates that a network device is supported by us or not.
+ * Parameters:
+ *	dev_type : device type that must check it.
+ * Returns: unsigned char
+ *	0 : device not supported by us.
+ *	1 : device supported by us.
+ */
+static unsigned char nbcm_dev_supported(unsigned int dev_type)
+{
+	return dev_type == ARPHRD_ETHER || dev_type == ARPHRD_EETHER ||
+	       dev_type == ARPHRD_IEEE802 || dev_type == ARPHRD_LOOPBACK;
+}
+
+/*
+ * Function: nbcm_apt_dev
+ * Parameters: None
+ * Returns: unsigned char
+ */
+unsigned char nbcm_apt_dev(struct net_device *dev)
+{
+	return (dev->flags & IFF_LOOPBACK) ||
+	       ((dev->flags & IFF_MULTICAST) && nbcm_dev_supported(dev->type));
+}
+
+/*
+ * Function: MAC_HEADLEN
+ *	Calculates the MAC header length of a device.
+ * Parameters:
+ *	dev: pointer to device that we need to its MAC header length.
+ * Returns: int
+ *	Always positive: MAC header length of the device.
+ * Note:
+ *	if we do not recognize device type, the function returns ethernet
+ *	MAC header length.
+ */
+int MAC_HEADLEN(struct net_device *dev)
+{
+	return dev->type == ARPHRD_IEEE802 ? sizeof(struct trh_hdr) :
+					     sizeof(struct ethhdr);
+}
+
+/*
+ * Function: LLCMAC_I_HEADLEN
+ *	Calculates lengths of LLC header and MAC header together for 'I frames'
+ *	on a specific device.
+ * Parameters:
+ *	dev: pointer to device that calculation is performed for it.
+ * Returns: int
+ *       Always positive : I frame's MAC + LLC header length of the device.
+ */
+inline int LLCMAC_I_HEADLEN(struct net_device *dev)
+{
+	return MAC_HEADLEN(dev) + NETBEUI_LLC_I_HEADLEN;
+}
+
+/*
+ * Function: LLCMAC_UI_HEADLEN
+ *	Calculates lengths of LLC header and MAC header together for UI frames.
+ * Parameters:
+ *	mac_hlen : MAC header length for UI frames.
+ * Returns: int
+ *       Always positive: UI frame's MAC + LLC header length of the device.
+ */
+inline int LLCMAC_UI_HEADLEN(int mac_hlen)
+{
+	return mac_hlen + NETBEUI_LLC_UI_HEADLEN;
+}
+
+/*
+ * Function: LLCMAC_UIB_HEADLEN
+ *	Calculates lengths of LLC header and MAC header together for
+ *	broadcasted UI frames.
+ * Parameters: none
+ * Returns: int
+ *       Always positive: broadcasted UI frame's MAC + LLC header length.
+ */
+inline int LLCMAC_UIB_HEADLEN(void)
+{
+	return NETBEUI_MAC_B_HEADLEN + NETBEUI_LLC_UI_HEADLEN;
+}
+
+/*
+ * Function: CALC_DG_SKBLEN
+ *	Calculates appropriate sk_buff length for sending UI frames.
+ * Parameters:
+ *	mac_hlen    : MAC header length.
+ *	user_datalen: length of data that must put into sk_buff after
+ *	              MAC + LLC headers (including NetBIOS header).
+ * Returns: int
+ *       Always positive: appropriate sk_buff length for sending UI frames.
+ */
+inline int CALC_DG_SKBLEN(int mac_hlen, int user_datalen)
+{
+	return LLCMAC_UI_HEADLEN(mac_hlen) + user_datalen;
+}
diff -ruN linux-2.4.18-clean/net/netbeui/proc.c linux/net/netbeui/proc.c
--- linux-2.4.18-clean/net/netbeui/proc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/proc.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,281 @@
+/*
+ * proc.c - Implements directory entries for NETBEUI names , links and
+ *          sessions below proc filesystem in memory.
+ * Notes:
+ *	- Proc file system for NETBEUI is created under /proc/net/netbeui.
+ *      - There are two types of directory entries below netbeui under proc :
+ *	  Static directory entries which are created at module initialization
+ *	  into memory. Dynamic entries which are created at runtime like session
+ *	  entries per link.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+#include <linux/netbeui.h>
+
+#define NETBEUI_PROJECT "Procom, 1997, Arnaldo C. Melo, 2001"
+#define NETBEUI_RELEASE	"2.0"
+
+static struct proc_dir_entry *proc_netbeui;
+
+static const char *netbeui_version = "NetBEUI version " NETBEUI_RELEASE " "
+				     NETBEUI_PROJECT "\n";
+
+static int netbeui_version_proc_get_info(char *buffer, char **start,
+					 off_t offset, int count, int* eof,
+					 void* data)
+{
+	return sprintf(buffer, netbeui_version);
+}
+
+static int netbeui_adapters_proc_get_info(char *buffer, char **start,
+					  off_t offset, int count, int *eof,
+					  void* data)
+{
+	int i, l = 0;
+	int j = 0;
+	char *b;
+
+	read_lock(&netbeui_adapters.lock);
+	for (i = 0, b = buffer; netbeui_adapters.dev[i]; i++, j += l, b += l)
+		l = sprintf(b, "%-*.*s %5u %02X:%02X:%02X:%02X:%02X:%02X\n",
+			IFNAMSIZ, IFNAMSIZ, netbeui_adapters.dev[i]->name,
+			netbeui_adapters.dev[i]->mtu,
+			netbeui_adapters.dev[i]->dev_addr[0],
+			netbeui_adapters.dev[i]->dev_addr[1],
+			netbeui_adapters.dev[i]->dev_addr[2],
+			netbeui_adapters.dev[i]->dev_addr[3],
+			netbeui_adapters.dev[i]->dev_addr[4],
+			netbeui_adapters.dev[i]->dev_addr[5]);
+	read_unlock(&netbeui_adapters.lock);
+	return j;
+}
+
+static int netbeui_names_proc_get_info(char *buffer, char **start, off_t offset,
+				       int count, int* eof, void* data)
+{
+	int i, len = 0;
+	dextab_t *name_table = nbns_get_name_table();
+
+	spin_lock_bh(&name_table->lock);
+	if (!name_table->count)
+		goto out;
+	len += sprintf(buffer,
+			"%-*.*s stt stu conflict nameNr users\n",
+			NETBEUI_NAME_LEN + 5, NETBEUI_NAME_LEN + 5, "name");
+	for (i = name_table->reserved; i < name_table->size; ++i) {
+		unsigned char printable_name[NETBEUI_NAME_LEN + 10];
+		unsigned char name_port;
+		name_t *name = name_table->addr[i];
+
+		if (!name)
+			continue;
+		memcpy(printable_name, name->name, NETBEUI_NAME_LEN + 1);
+		name_port = name->name[NETBEUI_NAME_LEN - 1];
+		if (name_port < 0x20 || name_port >= 0x80)
+			sprintf(printable_name + NETBEUI_NAME_LEN - 1,
+				"<%2x>", name_port);
+		len += sprintf(buffer + len,
+				"%-*.*s %3d %3d %8u %6u %5u\n",
+				NETBEUI_NAME_LEN + 5, NETBEUI_NAME_LEN + 5,
+				printable_name, name->state, name->status,
+				name->conflicted, name->name_number,
+				atomic_read(&name->refcnt));
+	}
+out:	spin_unlock_bh(&name_table->lock);
+        if (offset >= len) {
+                *start = buffer;
+                *eof = 1;
+                len = 0;
+        } else {
+		*start = buffer + offset;
+		if ((len -= offset) > count)
+			len = count;
+		else
+			*eof = 1;
+	}
+	return len;
+}
+
+static int netbeui_sessions_proc_get_info(char *buffer, char **start,
+					  off_t offset, int count, int* eof,
+					  void* data)
+{
+	int i, len = 0;
+	dextab_t *link_table = nbll_get_link_table();
+
+	spin_lock_bh(&link_table->lock);
+	if (!link_table->count)
+		goto out;
+	len += sprintf(buffer,
+			"lk st su %-*.*s%-*.*slsn rsn ver nI "
+			"tr  mtu oTotal   iTotal\n",
+			NETBEUI_NAME_LEN - 1, NETBEUI_NAME_LEN - 1,
+			"localName",
+			NETBEUI_NAME_LEN - 1, NETBEUI_NAME_LEN - 1,
+			"remoteName");
+
+	for (i = link_table->reserved; i < link_table->size; ++i) {
+		int j;
+		link_t *link = link_table->addr[i];
+		dextab_t *session_table;
+
+		if (!link)
+			continue;
+		session_table = &link->session_table;
+		spin_lock_bh(&session_table->lock);
+		if (!session_table->count)
+			goto unlock_session_table;
+		for (j = session_table->reserved;
+		     j < session_table->size; ++j) {
+			struct nb_session *session = session_table->addr[j];
+			char* name = NULL;
+
+			if (!session)
+				continue;
+			if (session->local_name)
+				name = (char *)&session->local_name->name;
+			len += sprintf(buffer + len,
+					"%2u %2d %2d %-*.*s%-*.*s%3u "
+					"%3u %3u %2u %2u %4u %8u %8u\n",
+					session->link,
+					session->state, session->status,
+					NETBEUI_NAME_LEN - 1,
+					NETBEUI_NAME_LEN - 1,
+					name,
+					NETBEUI_NAME_LEN - 1,
+					NETBEUI_NAME_LEN - 1,
+					session->remote_name,
+					session->lsn, session->rsn,
+					session->version,
+					session->nack_indicator,
+					session->tr_frame_lf, session->mtu,
+					session->o_total, session->i_total);
+		}
+unlock_session_table:
+		spin_unlock_bh(&session_table->lock);
+	}
+out:	spin_unlock_bh(&link_table->lock);
+        if (offset >= len) {
+                *start = buffer;
+                *eof = 1;
+                len = 0;
+        } else {
+		*start = buffer + offset;
+		if ((len -= offset) > count)
+			len = count;
+		else
+			*eof = 1;
+	}
+	return len;
+}
+
+static int netbeui_links_proc_get_info(char *buffer, char **start, off_t offset,
+				       int count, int *eof, void *data)
+{
+	int i, len = 0;
+	dextab_t *table = nbll_get_link_table();
+
+	spin_lock_bh(&table->lock);
+	if (table->count)
+		len = sprintf(buffer,
+			       "lk st su %-17.17s %-*.*s llcBusy frames\n",
+			       "remoteMac", IFNAMSIZ, IFNAMSIZ, "remoteDevice");
+	else
+		goto out;
+	for (i = table->reserved; i < table->size; ++i) {
+		link_t *link = table->addr[i];
+		char *name = NULL;
+
+		if (!link)
+			continue;
+		if (link->dev)
+			name = link->dev->name;
+		len += sprintf(buffer + len,
+				"%2u %2d %2d %02X:%02X:%02X:%02X:%02X:%02X "
+				"%-*.*s %7u %6u\n",
+				link->link, link->state, link->status,
+				link->remote_mac[0], link->remote_mac[1],
+				link->remote_mac[2], link->remote_mac[3],
+				link->remote_mac[4], link->remote_mac[5],
+				IFNAMSIZ, IFNAMSIZ, name, link->llc_busy,
+				skb_queue_len(&link->skbq));
+	}
+out:	spin_unlock_bh(&table->lock);
+        if (offset >= len) {
+                *start = buffer;
+                *eof = 1;
+                len = 0;
+        } else {
+		*start = buffer + offset;
+		if ((len -= offset) > count)
+			len = count;
+		else
+			*eof = 1;
+	}
+	return len;
+}
+
+int netbeui_proc_init(void)
+{
+	int rc = 0;
+
+	proc_netbeui = proc_mkdir("netbeui", proc_net);
+	if (!proc_netbeui)
+		goto out_err;
+	if (!create_proc_read_entry("links", 0, proc_netbeui,
+				    netbeui_links_proc_get_info, NULL))
+		goto out_netbeui;
+	if (!create_proc_read_entry("sessions", 0, proc_netbeui,
+				    netbeui_sessions_proc_get_info, NULL))
+		goto out_links;
+	if (!create_proc_read_entry("names", 0, proc_netbeui,
+				    netbeui_names_proc_get_info, NULL))
+		goto out_sessions;
+	if (!create_proc_read_entry("version", 0, proc_netbeui,
+				    netbeui_version_proc_get_info, NULL))
+		goto out_names;
+	if (!create_proc_read_entry("adapters", 0, proc_netbeui,
+				    netbeui_adapters_proc_get_info, NULL))
+		goto out_version;
+out:	return rc;
+out_version:
+	remove_proc_entry("version", proc_netbeui);
+out_names:
+	remove_proc_entry("names", proc_netbeui);
+out_sessions:
+	remove_proc_entry("sessions", proc_netbeui);
+out_links:
+	remove_proc_entry("links", proc_netbeui);
+out_netbeui:
+	remove_proc_entry("netbeui", proc_net);
+out_err:
+	rc = -ENOMEM;
+	goto out;
+}
+
+void netbeui_proc_clean(void)
+{
+	if (proc_netbeui) {
+		remove_proc_entry("links", proc_netbeui);
+		remove_proc_entry("sessions", proc_netbeui);
+		remove_proc_entry("names", proc_netbeui);
+		remove_proc_entry("version", proc_netbeui);
+		remove_proc_entry("adapters", proc_netbeui);
+		remove_proc_entry("netbeui", proc_net);
+	}
+}
diff -ruN linux-2.4.18-clean/net/netbeui/query_serve.c linux/net/netbeui/query_serve.c
--- linux-2.4.18-clean/net/netbeui/query_serve.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/query_serve.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,778 @@
+/*
+ * query_serve.c - Contains functions that implement NetBIOS Query Service.
+ *		   It also implements a remote name cache which is intended
+ * 		   to cache a mapping between NetBIOS name and MAC address.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *	- Remote name cache needs upper layer considerations which makes its
+ *	  impossible or hardly possible in other modules. Up to now only Session
+ * 	  service uses this mechanism to speed-up connection establishment.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/netbeui.h>
+
+static void nbqs_timer_function(unsigned long);
+
+/* These functions are Query State Transition handlers */
+static int nbqs_name_query_in_initial(query_t *nb_query);
+static int nbqs_name_find_in_initial(query_t *nb_query);
+static int nbqs_retry_timeout_in_all(query_t *nb_query);
+static int nbqs_response_timeout_in_all(query_t *nb_query);
+static int nbqs_name_recognized_in_qrywait(query_t *nb_query);
+static int nbqs_name_recognized_in_findwait(query_t *nb_query);
+static int nbqs_end_query_in_name_recognized(query_t *nb_query);
+
+static unsigned short int nbqs_correlator;
+#define nbqs_next_correlator() (++nbqs_correlator)
+
+static query_t *query_list;
+rwlock_t query_list_lock = RW_LOCK_UNLOCKED;
+
+/* Remote name cache definition */
+struct rnc_struct {
+	__u8 name[NETBEUI_NAME_LEN];
+	__u8 mac[6];
+	struct net_device *dev;
+	unsigned long int time_stamp;
+	struct rnc_struct *prev;
+	struct rnc_struct *next;
+};
+typedef struct rnc_struct rnc_t;
+
+static rnc_t *rnc_list;
+static int rnc_count;
+static spinlock_t rnc_list_lock = SPIN_LOCK_UNLOCKED;
+
+/* Query Service State Machine definition */
+typedef int (* query_event_handler_t)(query_t *);
+
+struct event_struct {
+	query_state_t next_state;
+	query_event_handler_t event_handler;
+};
+
+static struct event_struct query_state_table[4][6] = {
+			/* NETBEUI_QUERY_INITIAL */
+{
+{ NETBEUI_QUERY_QRYWAIT,
+	nbqs_name_query_in_initial },	   /* NETBEUI_QUERY_NAME_QUERY */
+{ NETBEUI_QUERY_FINDWAIT,
+	nbqs_name_find_in_initial },	   /* NETBEUI_QUERY_NAME_FIND */
+{ -1, NULL },				   /* NETBEUI_QUERY_RETRY_TIMEOUT */
+{ -1, NULL },				   /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+{ -1, NULL },				   /* NETBEUI_QUERY_NAME_RECOGNIZED */
+{ -1, NULL },				   /* NETBEUI_QUERY_END_QURY */
+},
+			/* NETBEUI_QUERY_QRYWAIT */
+{
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+{ NETBEUI_QUERY_QRYWAIT,
+	nbqs_retry_timeout_in_all },	    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+{ NETBEUI_QUERY_INITIAL,
+	nbqs_response_timeout_in_all },	    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+{ NETBEUI_QUERY_RECOGNIZED,
+	nbqs_name_recognized_in_qrywait },  /* NETBEUI_QUERY_NAME_RECOGNIZED */
+{ -1, NULL },				    /* NETBEUI_QUERY_END_QURY */
+},
+			/* NETBEUI_QUERY_FINDWAIT */
+{
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+{ NETBEUI_QUERY_FINDWAIT,
+	nbqs_retry_timeout_in_all },	    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+{ NETBEUI_QUERY_INITIAL,
+	nbqs_response_timeout_in_all },	    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+{ NETBEUI_QUERY_FINDWAIT,
+	nbqs_name_recognized_in_findwait }, /* NETBEUI_QUERY_NAME_RECOGNIZED */
+{ -1, NULL },				    /* NETBEUI_QUERY_END_QURY */
+},
+			/* NETBEUI_QUERY_RECOGNIZED */
+{
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_QUERY */
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_FIND */
+{ -1, NULL },				    /* NETBEUI_QUERY_RETRY_TIMEOUT */
+{ -1, NULL },				    /* NETBEUI_QUERY_RESPONSE_TIMEOUT */
+{ -1, NULL },				    /* NETBEUI_QUERY_NAME_RECOGNIZED */
+{ NETBEUI_QUERY_INITIAL,
+	nbqs_end_query_in_name_recognized },/* NETBEUI_QUERY_END_QURY */
+}
+};
+/*
+ * Query service state machine functions
+ * Implementing remote name cache
+ */
+/*
+ * Function: nbqs_remove_rnc
+ *	Removes a rnc_t entry from remote name cache list rnc_list
+ *
+ * Parameters:
+ *	nb_rnc	: pointer to rnc_t entry to remove
+ *
+ * Returns: none
+ */
+static void __nbqs_remove_rnc(rnc_t *nb_rnc)
+{
+	if (nb_rnc->next)
+		nb_rnc->next->prev = nb_rnc->prev;
+	if (nb_rnc->prev)
+		nb_rnc->prev->next = nb_rnc->next;
+	else
+		rnc_list = nb_rnc->next;
+}
+
+static inline void nbqs_remove_rnc(rnc_t *nb_rnc)
+{
+	spin_lock(&rnc_list_lock);
+	__nbqs_remove_rnc(nb_rnc);
+	spin_unlock(&rnc_list_lock);
+}
+
+/*
+ * Function: nbqs_find_rnc
+ *	Finds a rnc_t entry in remote name cache list for a specific NetBIOS
+ *	16 byte name.
+ *
+ * Parameters:
+ *	name	: NetBIOS name of remote node to find its rnc_t
+ *
+ * Returns:
+ *	NULL	: if no matching entry found in remote cache name list
+ *	non-NULL: pointer to rnc_t in remote_cache name list
+ */
+static inline rnc_t *__nbqs_find_rnc(char *name)
+{
+	rnc_t *nb_rnc = rnc_list;
+
+	while (nb_rnc) {
+		if (!memcmp(nb_rnc->name, name, NETBEUI_NAME_LEN)) {
+			nb_rnc->time_stamp = jiffies;
+			break;
+		}
+		nb_rnc = nb_rnc->next;
+	}
+	return nb_rnc;
+}
+
+static inline rnc_t *nbqs_find_rnc(char *name)
+{
+	rnc_t *nb_rnc;
+
+	spin_lock(&rnc_list_lock);
+	nb_rnc = __nbqs_find_rnc(name);
+	spin_unlock(&rnc_list_lock);
+	return nb_rnc;
+}
+
+/*
+ * Function: nbqs_cleanup_rnc
+ *	This routine will throw those cache entries who live in cache more
+ *	than a specific time (measured in jiffies) <NETBEUI_QUERY_CACHE_LIVING_TIME>.
+ *
+ * Parameters: none
+ *
+ * Returns: none
+ *
+ * Notes:
+ *	- For the sake of efficiency, remote name cache list wont grow more
+ *	  than a specific size <NETBEUI_QUERY_MAX_CACHE_ENTRIES>. Note that this is
+ *	  just a high water mark. Refer to nbqs_add_rnc
+ */
+static void __nbqs_cleanup_rnc(void)
+{
+	rnc_t *nb_rnc = rnc_list;
+
+	while (nb_rnc) {
+		if (jiffies - nb_rnc->time_stamp > NETBEUI_QUERY_CACHE_LIVING_TIME) {
+			rnc_t *tmp_rnc = nb_rnc;
+
+			nb_rnc = nb_rnc->next;
+			nbqs_remove_rnc(tmp_rnc);
+			kfree(tmp_rnc);
+		} else {
+			rnc_count++;
+			nb_rnc = nb_rnc->next;
+		}
+	}
+}
+
+static inline void nbqs_cleanup_rnc(void)
+{
+	spin_lock(&rnc_list_lock);
+	__nbqs_cleanup_rnc();
+	spin_unlock(&rnc_list_lock);
+}
+
+/*
+ * Function: nbqs_add_rnc
+ *	Adds/Updates an entry to remote name cache list
+ *
+ * Parameters:
+ *	name	: pointer to NetBIOS name of remote node
+ *	dev	: pointer to device structure node is connected via
+ *	mac	: pointer to MAC address of remote node
+ *
+ * Returns: none
+ *	
+ * Notes:
+ *	- If an rnc_t corresponding to NetBIOS name exists in cache it is
+ *	  updated else a new entry is created.
+ *	- This routine handles cache grow beyond NETBEUI_QUERY_MAX_CACHE_ENTRIES
+ *	  but does not guarantee to preserve the entry count below the value
+ *	- This routine does not guarantee adding memory since it may fail
+ *	  to allocate memory. This does not affect the system consistency.
+ */
+void nbqs_add_rnc(char *name, struct net_device *dev, unsigned char *mac)
+{
+	rnc_t *nb_rnc;
+
+	spin_lock(&rnc_list_lock);
+	nb_rnc = __nbqs_find_rnc(name);
+	if (nb_rnc) {
+		memcpy(nb_rnc->mac, mac, 6);
+		nb_rnc->dev		= dev;
+		nb_rnc->time_stamp	= jiffies;
+	}
+	if (rnc_count >= NETBEUI_QUERY_MAX_CACHE_ENTRIES)
+		__nbqs_cleanup_rnc();
+	nb_rnc = kmalloc(sizeof(rnc_t), GFP_KERNEL);
+	if (!nb_rnc)
+		goto out;
+	rnc_count++;
+	memcpy(nb_rnc->name, name, NETBEUI_NAME_LEN);
+	memcpy(nb_rnc->mac, mac, 6);
+	nb_rnc->dev		= dev;
+	nb_rnc->time_stamp	= jiffies;
+	if (rnc_list) {
+		rnc_list->prev	= nb_rnc;
+		nb_rnc->next	= rnc_list;
+		nb_rnc->prev	= NULL;
+		rnc_list	= nb_rnc;
+	} else {
+		rnc_list	= nb_rnc;
+		nb_rnc->next	= nb_rnc->prev = NULL;
+	}
+out:	spin_unlock(&rnc_list_lock);
+}
+
+/*
+ * Function: nbqs_delete_rnc
+ *	This is a wrapper to nbqs_remove_rnc which both remove entry from
+ *	remote name cache and deallocates memory.
+ *
+ * Parameters:
+ *	name	: NetBIOS name of remote node to remove its rnc_t
+ *
+ * Returns: none
+ */
+void nbqs_delete_rnc(char *name)
+{
+	rnc_t *nb_rnc;
+
+	spin_lock(&rnc_list_lock);
+	nb_rnc = __nbqs_find_rnc(name);
+	if (nb_rnc) {
+		__nbqs_remove_rnc(nb_rnc);
+		kfree(nb_rnc);
+		rnc_count--;
+	}
+	spin_unlock(&rnc_list_lock);
+}
+
+/*
+ * Query service state machine functions
+ * Implementing general functions
+ */
+/*
+ * Function: nbqs_alloc_query
+ *	Allocates a query_t structure and does completely initialize all fields
+ *
+ * Parameters: none
+ *
+ * Returns:
+ *	NULL	: if can not allocate memory for query_t or its sk_buff
+ *	non-NULL: pointer to query_t
+ *	
+ * Notes:
+ *	- An skb is attached to each new query for query processing purposes
+ *	- query timer is initialized but not started.
+ *	- The call to memset does implicitly initialize all fields. Those
+ *	  fields that need explicit non-zero initialization are manipulated
+ *	  afterwards.
+ */
+static query_t *nbqs_alloc_query(void)
+{
+	int name_dgram_len;
+	query_t *nb_query = kmalloc(sizeof(*nb_query), GFP_KERNEL);
+
+	if (!nb_query)
+		goto out;
+	/* Implicitly initialize all fields */
+	memset(nb_query, 0, sizeof(*nb_query));
+	init_timer(&nb_query->timer);
+	nb_query->timer.data	 = (unsigned long)nb_query;
+	nb_query->timer.function = nbqs_timer_function;
+	init_waitqueue_head(&nb_query->waitq);
+
+	/* Allocate query skb */
+	/* All commands use same length */
+	name_dgram_len = nb_cmd_hdr_len[NETBEUI_NAME_QUERY];
+	nb_query->skb = alloc_skb(CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN,
+				  name_dgram_len), GFP_KERNEL);
+	if (!nb_query->skb)
+		goto err;
+	skb_reserve(nb_query->skb, LLCMAC_UIB_HEADLEN());
+	nb_query->skb->nh.raw = nb_query->skb->h.raw = nb_query->skb->data;
+	skb_put(nb_query->skb, name_dgram_len);
+	nb_query->skb->dev = NULL;
+out:	return nb_query;
+err:	kfree(nb_query);
+	nb_query = NULL;
+	goto out;
+}
+
+/*
+ * Function: nbqs_free_query
+ *	Deallocates memory used for a query_t and its sk_buff
+ *
+ * Parameters:
+ *	nb_query : pointer to query_t memory to be freed
+ *
+ * Returns: none
+ */
+static inline void nbqs_free_query(query_t *nb_query)
+{
+	kfree_skb(nb_query->skb);
+	kfree(nb_query);
+}
+
+/*
+ * Function: nbqs_add_query_to_list
+ *	Inserts a previously allocated/initialized query_t into query list
+ *
+ * Parameters:
+ *	nb_query : pointer to query_t to insert
+ *
+ * Returns:
+ *	0 	 : always returns zero
+ */
+static inline int nbqs_add_query_to_list(query_t *nb_query)
+{
+	write_lock(&query_list_lock);
+	nb_query->next	= query_list;
+	query_list	= nb_query;
+	write_unlock(&query_list_lock);
+	return 0;
+}
+
+/*
+ * Function: nbqs_remove_query_from_list
+ *	Removes a query_t from query list
+ *
+ * Parameters:
+ *	nb_query : pointer to query_t to remove
+ *
+ * Returns: none
+ */
+static void nbqs_remove_query_from_list(query_t *nb_query)
+{
+	query_t *entry, *prev_entry = NULL;
+
+	write_lock(&query_list_lock);
+	entry = query_list;
+	while (entry) {
+		if (entry == nb_query) {
+			if (prev_entry)
+				prev_entry->next = entry->next;
+			else
+				query_list = entry->next;
+			break;
+		}
+		prev_entry = entry;
+		entry = entry->next;
+	}
+	write_unlock(&query_list_lock);
+}
+
+/*
+ * Function: nbqs_find_correlator
+ *	finds a query_t in query_list, which has transmitted frames with
+ *	specific correlator.
+ *
+ * Parameters:
+ *	correlator : a sixteen bit integer which contains the response
+ *	             correlator of input frame. It should be matched against
+ *		     xmit correlator of frames sent by the element.
+ *
+ * Returns:
+ *	NULL	   : if no query_t element found with the requested
+ *		     characteristic.
+ *	non-NULL   : pointer to matching query_t with the requested
+ *		     characteristic.
+ */
+static query_t *nbqs_find_correlator(unsigned short correlator)
+{
+	query_t *nb_query;
+	
+	read_lock(&query_list_lock);
+	nb_query = query_list;
+	while (nb_query) {
+		if (nb_query->resp_correlator == correlator)
+			break;
+		nb_query = nb_query->next;
+	}
+	read_unlock(&query_list_lock);
+	return nb_query;
+}
+
+/*
+ * Function: nbqs_boradcast_name_query
+ *	Prepares a NetBIOS NAME QUERY frames and nbll_uisends it to network.
+ *
+ * Parameters:
+ *	nb_query : pointer to query_t element which the frame should be built
+ *		   from
+ *
+ * Returns:
+ *	0 	 : if frame is successfully broadcasted to network
+ *	non-zero : if frame transmission encountered an error (usually at NDI
+ *		   layer)
+ *	
+ * Notes:
+ *	- Since ADD NAME QUERY frames are retransmitted in timed intervals, it
+ *	  is considered to build frame once, but transmit it multiple times.
+ *	  having built frames in each retransmission does generate multiple
+ *	  correlators and does frustrate processing responses.
+ */
+static int nbqs_broadcast_name_query(query_t *nb_query)
+{
+	if (!nb_query->retries) {
+		dgram_t *hdr = (dgram_t *)nb_query->skb->data;
+	
+		hdr->length	= nb_cmd_hdr_len[NETBEUI_NAME_QUERY];
+		hdr->delimiter	= NETBEUI_DELIMITER;
+		hdr->command	= NETBEUI_NAME_QUERY;
+		hdr->data1	= 0;
+		if (nb_query->lsn > 0)
+			hdr->data2 =
+				NETBEUI_CALL_DATA2(nb_query->calling_name->type,
+						   nb_query->lsn);
+		else
+			hdr->data2 = 0;
+		hdr->xmit_correlator = 0;
+		hdr->resp_correlator =
+			nb_query->resp_correlator = nbqs_next_correlator();
+		memcpy(hdr->dest_name, nb_query->called_name, NETBEUI_NAME_LEN);
+		if (nb_query->lsn > 0)
+			memcpy(hdr->source_name, nb_query->calling_name->name,
+			       NETBEUI_NAME_LEN);
+		else
+			memset(hdr->source_name, 0, NETBEUI_NAME_LEN);
+	}
+	return nbll_uisend(NULL, nb_query->skb);
+}
+
+/*
+ * Function: nbqs_handle_event
+ *	This is the heart of Query Service State Machine, which performs a
+ *	transition from current state of query element to new state based
+ *	on event occurred and query state table contents.
+ *
+ * Parameters:
+ *	event	: An integer of NETBEUI_QUERY_* family that implies type of
+ *		  event
+ *	nb_name	: pointer to query_t structure which the event occurred on
+ *
+ * Returns: none
+ *
+ * Notes:
+ *	- The state changes before actions be executed. This is due to
+ *	  non deterministic behavior of actions which may sleep the current
+ *	  process, thus stopping the function in the mid-way.
+ */
+static void nbqs_handle_event(query_event_t event, query_t *nb_query)
+{
+	struct event_struct *ev = &query_state_table[nb_query->state][event];
+
+	if (ev && ev->event_handler) {
+		unsigned char old_state = nb_query->state;
+
+		nb_query->state = ev->next_state;
+		if (ev->event_handler(nb_query))
+			nb_query->state = old_state;
+	}
+}
+
+/*
+ * Function: nbqs_timer_function
+ *	This is the callback function triggered upon expiration of name
+ *	retransmittion timer. It just injects an event into state machine for
+ *	its link.
+ *
+ * Parameters:
+ *	input	: pointer to query_t structure whose timer is expired.
+ *
+ * Returns: none
+ */
+static void nbqs_timer_function(unsigned long input)
+{
+	query_t *nb_query = (query_t *)input;
+
+	if (nb_query->retries < NETBEUI_TRANSMIT_COUNT)
+		nbqs_handle_event(NETBEUI_QUERY_RETRY_TIMEOUT, nb_query);
+	else
+		nbqs_handle_event(NETBEUI_QUERY_RESPONSE_TIMEOUT, nb_query);
+}
+
+/*
+ * Query service state machine functions
+ * Implementing transition actions
+ */
+/*
+ * Function: nbqs_xxxx_in_ssss
+ *	The section below contains functions that implement actions needed
+ *	to  legally transit from one state to another.
+ *
+ * Parameters:
+ *	nb_query: pointer to query_t structure which the actions are to be
+ *		  applied to
+ *
+ * Returns:
+ *	0	: if all actions are done successfully
+ *	non-zero: if one of actions failed
+ *
+ * Note:
+ *	- For the sake of simplicity, the actions are automatically rollbacked
+ *	  in each function, if an action in transition fails. The design
+ *	  documents do not cover these parts of code.
+ */
+static int nbqs_name_query_in_initial(query_t *nb_query)
+{
+	nb_query->retries = nb_query->responses	= 0;
+
+	if (nbqs_broadcast_name_query(nb_query))
+		return -ENOMEM;
+	nb_query->retries++;
+	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_query->timer);
+	nbqs_add_query_to_list(nb_query);
+	sleep_on(&nb_query->waitq);
+	return 0;
+}
+
+static int nbqs_name_find_in_initial(query_t *nb_query)
+{
+	nb_query->retries = nb_query->responses	= nb_query->buff_ofs = 0;
+
+	if (nbqs_broadcast_name_query(nb_query))
+		return -ENOMEM;
+	nb_query->retries++;
+	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_query->timer);
+	nbqs_add_query_to_list(nb_query);
+	sleep_on(&nb_query->waitq);
+	return 0;
+}
+
+static int nbqs_retry_timeout_in_all(query_t *nb_query)
+{
+	nb_query->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_query->timer);
+
+	if (nbqs_broadcast_name_query(nb_query))
+		return -ENOMEM;
+	nb_query->retries++;
+	return 0;
+}
+
+static int nbqs_response_timeout_in_all(query_t *nb_query)
+{
+	wake_up(&nb_query->waitq);
+	nbqs_remove_query_from_list(nb_query);
+	return 0;
+}
+
+static int nbqs_name_recognized_in_qrywait(query_t *nb_query)
+{
+	del_timer(&nb_query->timer);
+	wake_up(&nb_query->waitq);
+	nbqs_remove_query_from_list(nb_query);
+	return 0;
+}
+
+static int nbqs_name_recognized_in_findwait(query_t *nb_query)
+{
+	/* Here we should add the MAC header to buffer, considering
+	 * unicity of resp */
+	int i;
+	struct net_device *dev;
+	char *mac_buff = nb_query->mac_buff;
+
+	for (i = 0; i < nb_query->buff_ofs; i++) {
+		dev = nb_query->dev_buff[i];
+
+		if (nb_query->dev == dev &&
+		    !memcmp(nb_query->remote_mac, mac_buff, dev->addr_len))
+			return 0;
+		mac_buff += dev->addr_len;
+	}
+	if (nb_query->buff_ofs < nb_query->buff_len) {
+		dev = nb_query->dev;
+		nb_query->dev_buff[nb_query->buff_ofs] = dev;
+		memcpy(mac_buff, nb_query->remote_mac, dev->addr_len);
+		nb_query->buff_ofs++;
+	}
+	return 0;
+}
+
+static int nbqs_end_query_in_name_recognized(query_t *nb_query)
+{
+	return 0;
+}
+
+/*
+ * Query service state machine functions
+ * Implementing interface functions
+ */
+/*
+ * Function: nbqs_query_name
+ *	Does the first step of session establishment process and determines
+ *	remote session number, Largest Frame Bits and response correlator for
+ *	further negotiations.
+ *
+ * Parameters:
+ *	called_name    : pointer to NetBIOS name of remote node
+ *	calling_name   : pointer to name_t element registered locally
+ *	lsn	       : local session number
+ *	rsn	       : (VRP) pointer to remote session number
+ *			  valid if return value is zero
+ *	lfb            : (VRP) pointer to Largest Frame Bits (for support of
+ *	                 Token-Ring)
+ *	xmit_correlator: (VRP) pointer to xmit correlator found in NAME RESPONSE
+ *			  valid if return value is zero
+ *
+ * Returns:
+ *	0 	       : if query was successful
+ *	-EINVAL	       : if called_name is not a valid NetBIOS name
+ *	-ENOMEM	       : if memory allocation for query_t element failed
+ *	-ETIMEDOUT     : if remote node did not respond
+ */
+int nbqs_query_name(char *called_name, name_t *calling_name, unsigned char lsn,
+		    unsigned char *rsn, unsigned char *lfb,
+		    unsigned short *xmit_correlator)
+{
+	query_t *nb_query;
+
+	if (nbns_validate_name(called_name))
+		return -EINVAL;
+	nb_query = nbqs_alloc_query();
+	if (!nb_query)
+		return -ENOMEM;
+	nb_query->state		= NETBEUI_QUERY_INITIAL;
+	nb_query->calling_name	= calling_name;
+	memcpy(nb_query->called_name, called_name, NETBEUI_NAME_LEN);
+	nb_query->lsn		= lsn;
+	nbqs_handle_event(NETBEUI_QUERY_NAME_QUERY, nb_query);
+
+	if (nb_query->state != NETBEUI_QUERY_RECOGNIZED) {
+		nbqs_free_query(nb_query);
+		return -ETIMEDOUT;
+	}
+	*rsn = nb_query->rsn;
+	*lfb = nb_query->tr_lfb;
+	*xmit_correlator = nb_query->xmit_correlator;
+	nbqs_handle_event(NETBEUI_QUERY_END_QUERY, nb_query);
+	nbqs_free_query(nb_query);
+	return 0;
+}
+
+/*
+ * Function: nbqs_find_name
+ *	This is NAME FIND interface which determines MAC address of a remote
+ *	node with a specific name. It also finds the device which connects
+ *	the host with remote node.
+ *
+ * Parameters:
+ *	called_name : pointer to NetBIOS name of remote node
+ *	mac_buff    : pointer to array of MAC buffers
+ *	dev_buff    : pointer to array of device pointers
+ *	buff_len    : maximum number of entries in mac_buff and dev_buff arrays
+ *
+ * Returns:
+ *	>= 0	    : count of dev_buff and mac_buff entries corresponding to
+ *		      to nodes which own called_name
+ *	-EINVAL	    : if called_name is not a valid NetBIOS name
+ *	-ENOMEM	    : if memory allocation for query_t element failed
+ *
+ * Notes:
+ *	- This routines is the point in which RNC cache is used for NetBIOS
+ *	  name resolution. The consistency of cache contents depends on
+ *	  upper layers which insert/delete cache entries.
+ */
+int nbqs_find_name(char *called_name, char *mac_buff,
+		   struct net_device **dev_buff, int buff_len)
+{
+	int names_found;
+	query_t *nb_query;
+	rnc_t *nb_rnc;
+
+	if (nbns_validate_name(called_name))
+		return -EINVAL;
+	nb_rnc = nbqs_find_rnc(called_name);
+	if (nb_rnc) {
+		*dev_buff = nb_rnc->dev;
+		memcpy(mac_buff, nb_rnc->mac, 6);
+		return 1;
+	}
+	nb_query = nbqs_alloc_query();
+	if (!nb_query)
+		return -ENOMEM;
+	nb_query->state		= NETBEUI_QUERY_INITIAL;
+	nb_query->calling_name	= NULL;
+	memcpy(nb_query->called_name, called_name, NETBEUI_NAME_LEN);
+	nb_query->lsn		= 0;
+	nb_query->mac_buff	= mac_buff;
+	nb_query->dev_buff	= dev_buff;
+	nb_query->buff_len	= buff_len;
+	nbqs_handle_event(NETBEUI_QUERY_NAME_FIND, nb_query);
+	names_found		= nb_query->buff_ofs;
+	nbqs_free_query(nb_query);
+	if (names_found > 0)
+		nbqs_add_rnc(called_name, *dev_buff, mac_buff);
+	return names_found;
+}
+
+void nbqs_get_name_recognized(struct sk_buff *skb, unsigned char *remote_mac)
+{
+	dgram_t *dgram = (dgram_t *)skb->data;
+	unsigned short data2 = dgram->data2;
+	query_t *nb_query =  nbqs_find_correlator(dgram->xmit_correlator);
+
+	/* If it does not match a query */
+	if (!nb_query)
+		goto out;
+	nb_query->rsn		  = NETBEUI_CALL_SS(data2);
+	nb_query->dev	  = skb->dev;
+	memcpy(nb_query->remote_mac, remote_mac, 6);
+	nb_query->xmit_correlator = dgram->resp_correlator;
+	nb_query->tr_lfb	  = skb->cb[0]; /* Token Ring support */
+	nb_query->responses++;
+	/* We should also set mac_header */
+	nbqs_handle_event(NETBEUI_QUERY_NAME_RECOGNIZED, nb_query);
+out:	kfree_skb(skb);
+}
diff -ruN linux-2.4.18-clean/net/netbeui/session_serve.c linux/net/netbeui/session_serve.c
--- linux-2.4.18-clean/net/netbeui/session_serve.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/session_serve.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,2821 @@
+/*
+ * session_serve.c - Contains functions that implement NetBIOS Session Service
+ *
+ * Important Note:
+ *	- Consider the following design issues when reading session service
+ *	  sources
+ *		1- Session Establishment, Session Termination and Session Data
+ *		   Output Stream are joined to from the Session States
+ *		2- Session Data Input Stream does is not implemented in State
+ *		   Machine model, it is simply a buffering and acknowledgement
+ *		   mechanism.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *	- Session Service is the most complicated service in NetBIOS. Numerous
+ *	  states and events used for session establishment, session data
+ *	  transfer and session termination need to much effort to overcome.
+ *	  Please read documentations before changing even a bit (!) in source
+ *	  codes.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <asm/uaccess.h>
+#include <linux/netbeui.h>
+#include <linux/if_arp.h>
+
+#define dprintk(format, a...) \
+                printk(KERN_INFO __FUNCTION__ ": " format, ##a)
+
+extern int llc_in_progress;
+
+/* These functions are used for locking sessions to avoid race conditions */
+static void nbss_lock_session(session_t *session);
+static int nbss_release_session(session_t *session);
+
+static void nbss_wait_timer_function(unsigned long input);
+static void nbss_resource_timer_function(unsigned long input);
+
+/* These functions are Session Service State Transition handlers */
+static int nbss_event_abort_send_in_all(session_t *session);
+static int nbss_event_call_in_initial(session_t *session);
+static int nbss_event_listen_in_initial(session_t *session);
+
+static int nbss_event_confirm_in_callwait(session_t *session);
+static int nbss_event_reject_in_callwait(session_t *session);
+static int nbss_event_abort_in_callwait(session_t *session);
+
+static int nbss_event_connect_in_confwait(session_t *session);
+static int nbss_event_timeout_in_confwait(session_t *session);
+static int nbss_event_abort_in_confwait(session_t *session);
+
+static int nbss_event_confirm_in_listenwait(session_t *session);
+static int nbss_event_reject_in_listenwait(session_t *session);
+
+static int nbss_event_connect_in_initwait(session_t *session);
+static int nbss_event_timeout_in_initwait(session_t *session);
+static int nbss_event_reject_in_initwait(session_t *session);
+static int nbss_event_abort_in_initwait(session_t *session);
+
+static int nbss_event_hangup_in_connected(session_t *session);
+static int nbss_event_first_middle_cont_in_connected(session_t *session);
+static int nbss_event_first_middle_in_connected(session_t *session);
+static int nbss_event_only_last_ack_in_connected(session_t *session);
+static int nbss_event_only_last_in_connected(session_t *session);
+static int nbss_event_resource_in_connected(session_t *session);
+static int nbss_event_end_in_connected(session_t *session);
+static int nbss_event_abort_in_connected(session_t *session);
+
+static int nbss_event_hangup_in_discwait(session_t *session);
+
+static int nbss_event_continue_in_contwait(session_t *session);
+static int nbss_event_restart_in_contwait(session_t *session);
+static int nbss_event_pause_in_contwait(session_t *session);
+static int nbss_event_nonblock_in_contwait(session_t *session);
+
+static int nbss_event_restart_in_standwait(session_t *session);
+static int nbss_event_pause2_in_standwait(session_t *session);
+
+static int nbss_event_data_acked_in_ackwait(session_t *session);
+static int nbss_event_restart_in_ackwait(session_t *session);
+static int nbss_event_pause_in_ackwait(session_t *session);
+static int nbss_event_nonblock_in_ackwait(session_t *session);
+
+static int nbss_event_norm_retry_in_rsrcwait(session_t *session);
+static int nbss_event_conn_retry_in_rsrcwait(session_t *session);
+
+static int nbss_event_first_middle_in_normal(session_t *session);
+static int nbss_event_only_last_ack_in_normal(session_t *session);
+static int nbss_event_only_last_in_normal(session_t *session);
+static int nbss_event_pause_in_normal(session_t *session);
+static int nbss_event_restart_in_normal(session_t *session);
+static int nbss_event_resource_in_normal(session_t *session);
+static int nbss_event_nonblock_in_normal(session_t *session);
+
+static unsigned short int nbss_correlator;
+#define nbss_next_correlator() (++nbss_correlator)
+
+/* This is a list for pending session listened for incoming session
+ * establishment requests */
+static session_t *session_list;
+static spinlock_t session_list_lock = SPIN_LOCK_UNLOCKED;
+
+/* Session service state machine definition */
+typedef int (*session_event_handler_t)(session_t *session);
+
+struct event_struct {
+	session_state_t next_state;
+	session_event_handler_t event_handler;
+};
+
+static struct event_struct session_state_table[12][23] = {
+			/* NETBEUI_SESS_INITIAL */
+{
+{ NETBEUI_SESS_CALLWAIT,
+	nbss_event_call_in_initial },	/* NETBEUI_SESS_CALL */
+{ NETBEUI_SESS_LISTENWAIT,
+	nbss_event_listen_in_initial },	/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+},			
+			/* NETBEUI_SESS_CALLWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ NETBEUI_SESS_CONFWAIT,
+	nbss_event_confirm_in_callwait },/* NETBEUI_SESS_CONFIRM */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_reject_in_callwait },/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_abort_in_callwait },	/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+},	
+			/* NETBEUI_SESS_CONFWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_connect_in_confwait },/* NETBEUI_SESS_CONNECT */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_timeout_in_confwait },/* NETBEUI_SESS_TIMEOUT */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_abort_in_confwait },	/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+},
+			/* NETBEUI_SESS_LISTENWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ NETBEUI_SESS_INITWAIT,
+	nbss_event_confirm_in_listenwait },/* NETBEUI_SESS_CONFIRM */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_reject_in_listenwait },/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+},	
+			/* NETBEUI_SESS_INITWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_reject_in_initwait },/* NETBEUI_SESS_REJECT */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_connect_in_initwait },/* NETBEUI_SESS_CONNECT */
+{ NETBEUI_SESS_LISTENWAIT,
+	nbss_event_timeout_in_initwait },/* NETBEUI_SESS_TIMEOUT */
+{ NETBEUI_SESS_LISTENWAIT,
+	nbss_event_abort_in_initwait },	/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				/* NETBEUI_SESS_ABORT_SEND */
+},	
+			/* NETBEUI_SESS_CONNECTED */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ NETBEUI_SESS_DISCWAIT,
+	nbss_event_abort_in_connected },/* NETBEUI_SESS_ABORT */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_hangup_in_connected },/* NETBEUI_SESS_HANGUP */
+{ NETBEUI_SESS_DISCWAIT,
+	nbss_event_end_in_connected },	/* NETBEUI_SESS_END */
+{ NETBEUI_SESS_CONTWAIT,
+	nbss_event_first_middle_cont_in_connected }, /* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_first_middle_in_connected },  /* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				   /* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				   /* NETBEUI_SESS_RESTART */
+{ NETBEUI_SESS_ACKWAIT,
+	nbss_event_only_last_ack_in_connected }, /* NETBEUI_SESS_ONLY_LAST_ACK */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_only_last_in_connected },/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				   /* NETBEUI_SESS_DATA_ACKED */
+{ NETBEUI_SESS_RSRCWAIT,
+	nbss_event_resource_in_connected },/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				   /* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				   /* NETBEUI_SESS_ABORT_SEND */
+},
+			/* NETBEUI_SESS_DISCWAIT */
+{
+{ -1, NULL },				   /* NETBEUI_SESS_CALL */
+{ -1, NULL },				   /* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				   /* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				   /* NETBEUI_SESS_REJECT */
+{ -1, NULL },				   /* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				   /* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				   /* NETBEUI_SESS_ABORT */
+{ NETBEUI_SESS_INITIAL,
+	nbss_event_hangup_in_discwait },   /* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				   /* NETBEUI_SESS_END */
+{ -1, NULL },				   /* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				   /* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_CONTINUE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL }, 				   /* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL }, 				   /* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				   /* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				   /* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				   /* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				   /* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				   /* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				   /* NETBEUI_SESS_NORM_RETRY */
+{ -1, NULL }				   /* NETBEUI_SESS_ABORT_SEND */
+},
+	   	       /* NETBEUI_SESS_CONTWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_continue_in_contwait },/* NETBEUI_SESS_CONTINUE */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_nonblock_in_contwait },/* NETBEUI_SESS_NONBLOCK */
+{ NETBEUI_SESS_STANDWAIT,
+	nbss_event_pause_in_contwait },	/* NETBEUI_SESS_PAUSE */
+{ -1, NULL }, 				/* NETBEUI_SESS_PAUSE2 */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_restart_in_contwait },/* NETBEUI_SESS_RESTART */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL }, 				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL }, 				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL }, 				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL }, 				/* NETBEUI_SESS_NORM_RETRY */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+},
+		       /* NETBEUI_SESS_STANDWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL },				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL },				/* NETBEUI_SESS_PAUSE */
+{ NETBEUI_SESS_STANDWAIT,
+	nbss_event_pause2_in_standwait },/* NETBEUI_SESS_PAUSE2 */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_restart_in_standwait },/* NETBEUI_SESS_RESTART */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+},
+		       /* NETBEUI_SESS_ACKWAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL }, 				/* NETBEUI_SESS_CONTINUE */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_nonblock_in_ackwait },/* NETBEUI_SESS_NONBLOCK */
+{ NETBEUI_SESS_STANDWAIT,
+	nbss_event_pause_in_ackwait },	/* NETBEUI_SESS_PAUSE */
+{ -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_restart_in_ackwait },/* NETBEUI_SESS_RESTART */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_data_acked_in_ackwait },/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+},
+		       /* NETBEUI_SESS_RSRCAIT */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+{ -1, NULL },				/* NETBEUI_SESS_NONBLOCK */
+{ -1, NULL },				/* NETBEUI_SESS_PAUSE */
+{ -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+{ -1, NULL },				/* NETBEUI_SESS_RESTART */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ -1, NULL },				/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+{ -1, NULL },				/* NETBEUI_SESS_RESOURCE */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_conn_retry_in_rsrcwait },/* NETBEUI_SESS_CONN_RETRY */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_norm_retry_in_rsrcwait },/* NETBEUI_SESS_NORM_RETRY */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_abort_send_in_all }	/* NETBEUI_SESS_ABORT_SEND */
+},
+		       /* NETBEUI_SESS_NORMAL */
+{
+{ -1, NULL },				/* NETBEUI_SESS_CALL */
+{ -1, NULL },				/* NETBEUI_SESS_LISTEN */
+{ -1, NULL },				/* NETBEUI_SESS_CONFIRM */
+{ -1, NULL },				/* NETBEUI_SESS_REJECT */
+{ -1, NULL },				/* NETBEUI_SESS_CONNECT */
+{ -1, NULL },				/* NETBEUI_SESS_TIMEOUT */
+{ -1, NULL },				/* NETBEUI_SESS_ABORT */
+{ -1, NULL },				/* NETBEUI_SESS_HANGUP */
+{ -1, NULL },				/* NETBEUI_SESS_END */
+{ -1, NULL },				/* NETBEUI_SESS_FIRST_MIDDLE_CONT */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_first_middle_in_normal },/* NETBEUI_SESS_FIRST_MIDDLE */
+{ -1, NULL },				/* NETBEUI_SESS_CONTINUE */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_nonblock_in_normal },/* NETBEUI_SESS_NONBLOCK */
+{ NETBEUI_SESS_STANDWAIT,
+	nbss_event_pause_in_normal },	/* NETBEUI_SESS_PAUSE */
+{ -1, NULL },				/* NETBEUI_SESS_PAUSE2 */
+{ NETBEUI_SESS_NORMAL,
+	nbss_event_restart_in_normal },	/* NETBEUI_SESS_RESTART */
+{ NETBEUI_SESS_ACKWAIT,
+	nbss_event_only_last_ack_in_normal },/* NETBEUI_SESS_ONLY_LAST_ACK */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_only_last_in_normal },/* NETBEUI_SESS_ONLY_LAST */
+{ -1, NULL },				/* NETBEUI_SESS_DATA_ACKED */
+{ NETBEUI_SESS_RSRCWAIT,
+	nbss_event_resource_in_normal },/* NETBEUI_SESS_RESOURCE */
+{ -1, NULL },				/* NETBEUI_SESS_CONN_RETRY */
+{ -1, NULL },				/* NETBEUI_SESS_NORM_RETRY */
+{ NETBEUI_SESS_CONNECTED,
+	nbss_event_abort_send_in_all}	/* NETBEUI_SESS_ABORT_SEND */
+}
+};
+
+/* Session service state machine functions */
+/*
+ * Function: nbss_free_session
+ *	Deallocates memory used for session_t and does a complete housekeeping
+ * Parameters:
+ *	session: pointer to session_t memory to be freed
+ * Returns: None
+ */
+static void nbss_free_session(session_t *session)
+{
+	skb_queue_purge(&session->back_log);
+	skb_queue_purge(&session->i_skbq);
+	kfree(session);
+}
+
+static inline void session_put(session_t *session)
+{
+	if (atomic_dec_and_test(&session->refcnt))
+		nbss_free_session(session);
+}
+
+static inline void session_hold(session_t *session)
+{
+	atomic_inc(&session->refcnt);
+}
+
+static inline void nbss_wait_event(session_t *session)
+{
+        set_current_state(TASK_UNINTERRUPTIBLE);
+        if (!nbss_release_session(session))
+                wait_event(session->waitq, (!session->o_txed ||
+                                            session->o_aborted));
+        else
+                set_current_state(TASK_RUNNING);
+}
+
+/*
+ * Function: NETBEUI_CALC_SESS_MTU
+ *	Calculates MAXimum length of user data that can send through a
+ *	session, and sets the 'mtu' field of it.
+ * Parameters:
+ *	sn: pointer to session that calculation is for it.
+ * Returns: None
+ */
+static void NETBEUI_CALC_SESS_MTU(session_t *sn)
+{
+	session_hold(sn);
+	sn->mtu = sn->dev->type == ARPHRD_LOOPBACK ? 1500 : sn->dev->mtu;
+	if (sn->dev->type == ARPHRD_IEEE802) { /* Token Ring */
+		__u16 dolfb;
+
+		switch (sn->tr_frame_lf) {
+			case 0x00: dolfb = 516;		break;
+			case 0x01: dolfb = 1470;	break;
+			case 0x02: dolfb = 2052;	break;
+			case 0x03: dolfb = 4399;	break;
+			case 0x04: dolfb = 8130;	break;
+			case 0x05: dolfb = 11407;	break;
+			case 0x06: dolfb = 17749;	break;
+			case 0x07:
+			default: dolfb = 0xFFFF;	break;
+		}
+		if (sn->mtu > dolfb)
+			sn->mtu = dolfb;
+	}
+	sn->mtu = sn->mtu - sn->llcmac_ihl - NETBEUI_ILEN;
+	session_put(sn);
+}
+
+/*
+ * Function: nbss_alloc_session
+ *	Allocates a session_t structure and does completely initialize all
+ *	fields
+ * Parameters: None
+ * Returns:
+ *	NULL	: if can not allocate memory for session_t
+ *	non-NULL: pointer to session_t
+ * Notes:
+ *	- Session timer is initialized but not started.
+ *	- The call to memset does implicitly initialize all fields. Those
+ *	  fields that need explicit non-zero initialization are manipulated
+ *	  afterwards.
+ */
+static session_t *nbss_alloc_session(void)
+{
+	session_t *session = kmalloc(sizeof(*session), GFP_KERNEL);
+
+	if (!session)
+		goto out;
+	/* Implicitly initialize all fields */
+	memset(session, 0, sizeof(*session));
+	init_timer(&session->timer);
+	session->timer.data	= (unsigned long)session;
+	session->timer.function	= nbss_wait_timer_function;
+	init_waitqueue_head(&session->waitq);
+	session->version	= NETBEUI_VERSION_2xx;
+	session->nack_indicator	= NETBEUI_NACK_ABLE;
+	skb_queue_head_init(&session->back_log);
+	skb_queue_head_init(&session->i_skbq);
+	session->o_receive_continue = 1;
+	session->i_rcvbuf	    = 0xFFFF;
+	atomic_set(&session->refcnt, 1);
+out:	return session;
+}
+
+/*
+ * Function: nbss_ack_bytes
+ *	Acknowledges reception of some bytes from input stream, by correctly
+ *	setting control variables of session.
+ * Parameters:
+ *	session: pointer to session_t whose bytes are to be acknowledged.
+ * Returns: None
+ * Notes:
+ *	- This function is used in transition handlers.
+ *	- It does not actually acknowledge byte, it simply justifies
+ *	  acknowledgement control variables.
+ */
+static void nbss_ack_bytes(session_t *session)
+{
+	unsigned short r_nacked;
+		
+	session_hold(session);
+	r_nacked = session->o_txed - session->r_acked;
+	session->o_size += r_nacked;
+	session->o_buff -= r_nacked;
+	session->o_acked += session->r_acked;
+	session->o_txed = session->r_acked = 0;
+	session_put(session);
+}
+
+/*
+ * Function: nbss_sleep_on
+ *	This is a process control routine and customized version of Linux
+ *	kernel sleep_on for session operations. It works in conjunction
+ *	with session locking facilities to provide a secure mechanism for
+ *	process control.
+ * Parameters:
+ *	session: pointer to session_t whose process is to be controlled
+ *	state  : Linux state parameter that describes how to sleep. Usually
+ *		 TASK_INTERRUPTIBLE or TASK_UNINTERRUPTIBLE are values passed
+ *		 for this argument.
+ * Returns: None
+ * Notes:
+ *	- The only difference between nbss_sleep_on and sleep_on is in the
+ *	  decision made before schedule() which in nbss_sleep_on is determined
+ *	  by nbss_release_session(). The reason is in abrupt termination of a
+ *	  session while the sleeping procedure runs. This routines integrates
+ *	  conditions so that race conditions are avoided.
+ */
+static inline void nbss_sleep_on(session_t *session, int state)
+{
+	wait_queue_t wait;
+
+	init_waitqueue_entry(&wait, current);
+	set_current_state(state);
+	add_wait_queue(&session->waitq, &wait);
+	
+	if (!nbss_release_session(session)) {
+		dprintk("about to call schedule\n");
+		schedule();
+#if WAITQUEUE_DEBUG
+		dprintk("sleeper=%p, waker=%lx\n",
+			 current_text_addr(), wait.__waker);
+#endif
+	} else
+		set_current_state(TASK_RUNNING);
+	remove_wait_queue(&session->waitq, &wait);
+}
+
+/*
+ * Function: nbss_add_session_to_list
+ *	Inserts a previously allocated/initialized session_t into session
+ *	pending list.
+ * Parameters:
+ *	session: pointer to session_t to add to pending session list
+ * Returns: None
+ */
+static void __nbss_add_session_to_list(session_t *session)
+{
+	session->next = session_list;
+	session_list  = session;
+}
+
+static void nbss_add_session_to_list(session_t *session)
+{
+	spin_lock_bh(&session_list_lock);
+	__nbss_add_session_to_list(session);
+	spin_unlock_bh(&session_list_lock);
+}
+
+/*
+ * Function: nbss_remove_session_from_list
+ *	Removes a session from pending session list
+ * Parameters:
+ *	session: Pointer to session_t to remove from pending session list
+ * Returns: None
+ */
+static void nbss_remove_session_from_list(session_t *session)
+{
+	session_t *entry, *prev_entry = NULL;
+
+	spin_lock_bh(&session_list_lock);
+	entry = session_list;
+	while (entry) {
+		if (entry == session) {
+			if (prev_entry)
+				prev_entry->next = entry->next;
+			else
+				session_list = entry->next;
+		}
+		prev_entry = entry;
+		entry	   = entry->next;
+	}
+	spin_unlock_bh(&session_list_lock);
+}
+
+/*
+ * Function: nbss_find_listen
+ *	Finds a session_t in session pending list who listens to a specific
+ *	name.
+ * Parameters:
+ *	name: pointer to NetBIOS name the session listens to
+ * Returns:
+ *	NULL	: if no pending session found listening to name
+ *	non-NULL: pointer to a pending session in list who listens to name
+ */
+static session_t *nbss_find_listen(unsigned char *name)
+{
+	session_t *session;
+
+	spin_lock_bh(&session_list_lock);
+	session = session_list;
+	while (session) {
+		if (session->state == NETBEUI_SESS_LISTENWAIT &&
+		    !memcmp(session->local_name->name, name, NETBEUI_NAME_LEN))
+			break;
+		session = session->next;
+	}
+	if (session)
+		session_hold(session);
+	spin_unlock_bh(&session_list_lock);
+	return session;
+}
+
+/*
+ * Function: nbss_unicast_name_recognized
+ *	Prepares a NetBIOS NAME RECOGNIZED frame and nbll_uisends it to network
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built from
+ *		 this session usually is selected from pending session list.
+ * Returns:
+ *	0	: if frame is successfully transmitted to network.
+ *	non-zero: if frame transmission encountered an error (usually at NDI
+ *		  layer)
+ * Notes:
+ *	- NetBIOS NAME RECOGNIZED frame is the response to a NetBIOS NAME QUERY
+ *	  frame received from network. The interface which accepts NAME QUERY
+ *	  frame passes the sk_buff via session->skb to reuse it for NAME
+ *	  RECOGNIZED frame, thus reducing memory consumption.
+ */
+static int nbss_unicast_name_recognized(session_t *session)
+{
+	/* It is supposed that name query skb is put in session->skb f/ reuse */
+	dgram_t *hdr;
+	int rc;
+
+	session_hold(session);
+	hdr = (dgram_t *)session->skb->data;
+	hdr->length	= nb_cmd_hdr_len[NETBEUI_NAME_RECOGNIZED];
+	hdr->command	= NETBEUI_NAME_RECOGNIZED;
+	hdr->data1	= 0;
+	hdr->data2	= NETBEUI_CALL_DATA2(session->local_name->type,
+					     session->lsn);
+	hdr->xmit_correlator	= hdr->resp_correlator;
+	hdr->resp_correlator	=
+		session->resp_correlator = nbss_next_correlator();
+	memcpy(hdr->dest_name, hdr->source_name, NETBEUI_NAME_LEN);
+	memcpy(hdr->source_name, session->local_name->name, NETBEUI_NAME_LEN);
+	rc = nbll_uisend(session->remote_mac, session->skb);
+	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_alloc_session_skb
+ *	Allocates and prepares a skb for session service purposes
+ * Parameters:
+ *	sn	: pointer to session that sk_buff is allocated for it.
+ *	len	: length of data in skb
+ *	priority: a Linux kernel style memory allocation policy flag from
+ *		  GFP_* (GFP_KERNEL, GF_ATOMIC, GFP_USER, ...) family.
+ * Returns:
+ *	NULL	: if can not allocate memory for sk_buff
+ *	non-NULL: pointer to sk_buff
+ */
+static struct sk_buff *nbss_alloc_session_skb(session_t *sn, int len,
+					      int priority)
+{
+	struct sk_buff *skb;
+
+	session_hold(sn);
+	skb = alloc_skb(len + sn->llcmac_ihl, priority);
+	if (skb) {
+		skb_reserve(skb, sn->llcmac_ihl);
+		skb->nh.raw = skb->h.raw = skb->data;
+	}
+	session_put(sn);
+	return skb;
+}
+
+/*
+ * Function: nbss_ack_with_data
+ *	Acknowledges incoming bytes with an outgoing frame by justifying data
+ *	control bytes.
+ * Parameters:
+ *	session: pointer to session_t, the acknowledgement is generated for
+ *	hdr    : pointer to packet_t header of outgoing frame.
+ * Returns: None
+ */
+static void nbss_ack_with_data(session_t *session, packet_t *hdr)
+{
+	session_hold(session);
+	barrier();
+	if (session->o_ack_correlator) {
+		del_timer(&session->timer);
+		NETBEUI_INCLUDE_ACK_WITH_DATA(hdr);
+		hdr->xmit_correlator = (unsigned short)
+						session->o_ack_correlator;
+		session->o_ack_correlator = 0;
+	}
+	session_put(session);
+}
+
+/*
+ * Function: nbss_isend_session_initialize
+ *	Prepares a NetBIOS SESSION INITIALIZE frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ * Returns:
+ *	0      : if frame is successfully transmitted to network.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ * Notes:
+ *	- NetBIOS NAME RECOGNIZED frame is the response to a NetBIOS NAME QUERY
+ *	  frame received from network. The interface which accepts NAME QUERY
+ *	  frame passes the sk_buff via session->skb to reuse it for NAME
+ *	  RECOGNIZED frame, thus reducing memory consumption.
+ */
+static int nbss_isend_session_initialize(session_t *session)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_SESSION_INITIALIZE];
+	struct sk_buff *skb;
+	packet_t *hdr;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_SESSION_INITIALIZE;
+	hdr->data1		= 0x81; /* NetBIOS 2.2 with ability to
+					   handle nack */
+	/* Token Ring support */
+	NETBEUI_CALC_SESS_MTU(session);
+	hdr->data1		|= (session->tr_frame_lf << 1) & 0x0E;
+	hdr->data2		= session->mtu;
+	hdr->xmit_correlator	= session->xmit_correlator;
+	hdr->resp_correlator	=
+		session->resp_correlator = nbss_next_correlator();
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_isend_session_confirm
+ *	Prepares a NetBIOS SESSION CONFIRM frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session : pointer to session_t structure the frame should be built for
+ * Returns:
+ *	0	: if frame is successfully transmitted to remote session.
+ *	non-zero: if frame transmission encountered an error
+ * Notes:
+ *	- NetBIOS SESSION INITIALIZE frame is the response to a NetBIOS SESSION
+ *	  CONFIRM frame received from remote session. The interface which
+ *	  accepts SESSION INITIALIZE frame passes the sk_buff via session->skb
+ *	  to reuse it for SESSION CONFIRM frame, thus reducing memory
+ *	  consumption.
+ */
+static int nbss_isend_session_confirm(session_t *session)
+{
+	/* I suppose get_session_initialize has set session->skb for reuse */
+	packet_t *hdr;
+	int rc;
+
+	session_hold(session);
+	hdr		= (packet_t *)session->skb->data;
+	hdr->length	= nb_cmd_hdr_len[NETBEUI_SESSION_CONFIRM];
+	hdr->command	= NETBEUI_SESSION_CONFIRM;
+	hdr->data1	= 0x81; /* NetBIOS 2.2 with ability to
+					    handle nack */
+	hdr->data2	= session->mtu;
+	session->resp_correlator = hdr->resp_correlator;
+	hdr->resp_correlator	 = session->xmit_correlator;
+	hdr->xmit_correlator	 = session->resp_correlator;
+	hdr->dest_num		 = session->rsn;
+	hdr->source_num		 = session->lsn;
+	rc = nbll_isend(session->link, session->skb);
+	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_isend_data_first_middle
+ *	Prepares a NetBIOS DATA FIRST MIDDLE frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ *	cflow  : flag that indicates requesting RECEIVE CONTINUE from remote
+ *		 session:
+ *		 zero means do not request RECEIVE CONTINUE
+ *		 non-zero means request RECEIVE CONTINUE
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_data_first_middle(session_t *session, int cflow)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_DATA_FIRST_MIDDLE];
+	struct sk_buff *skb;
+	packet_t *hdr;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len + session->mtu,
+				     GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_DATA_FIRST_MIDDLE;
+	hdr->data1		= 0;
+	hdr->data2		= session->o_receive_outstanding;
+	session->o_receive_outstanding = 0;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	
+	if (cflow) {
+		NETBEUI_REQUEST_RECEIVE_CONTINUE(hdr);
+		session->o_receive_continue = 0;
+		hdr->resp_correlator =
+			session->resp_correlator = nbss_next_correlator();
+	}
+	if (session->o_noack)
+		NETBEUI_INDICATE_NACK(hdr);
+	rc = -EFAULT;
+	if (copy_from_user(skb_put(skb, session->mtu), session->o_buff,
+			   session->mtu))
+		goto err;
+	nbss_ack_with_data(session, hdr);
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+err:	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbss_isend_data_only_last
+ *	Prepares a NetBIOS DATA ONLY LAST frame and nbll_isends it toward remote
+ *	session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_data_only_last(session_t *session)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_DATA_ONLY_LAST];
+	struct sk_buff *skb;
+	packet_t *hdr;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len +
+						session->o_size, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_DATA_ONLY_LAST;
+	hdr->data1		= 0;
+	hdr->data2		= session->o_receive_outstanding;
+	session->o_receive_outstanding = 0;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+
+	if (session->o_noack)
+		NETBEUI_INDICATE_NACK(hdr);
+	else {
+		hdr->resp_correlator = session->resp_correlator =
+			nbss_next_correlator();
+		NETBEUI_ALLOW_ACK_WITH_DATA(hdr);
+	}
+	rc = -EFAULT;
+	if (copy_from_user(skb_put(skb, session->o_size), session->o_buff,
+				   session->o_size))
+		goto err;
+	nbss_ack_with_data(session, hdr);
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+err:	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbss_isend_receive_continue
+ *	Prepares a NetBIOS RECEIVE CONTINUE frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ *	hdr    : pointer to packet_t header of the incoming frame which the
+ *		 RECEIVE CONTINUE frame is built for.
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_receive_continue(packet_t *source_hdr, session_t *session)
+{
+	packet_t *hdr;
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_RECEIVE_CONTINUE];
+	struct sk_buff *skb;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_RECEIVE_CONTINUE;
+	hdr->data1		= 0;
+	hdr->data2		= 0;
+	hdr->xmit_correlator	= source_hdr->resp_correlator;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_isend_no_receive
+ *	Prepares a NetBIOS RECEIVE CONTINUE frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ *	skb    : pointer to sk_buff to use for building frame. This sk_buff is
+ *		 the one that contained incoming frame and since its data is not
+ *		 accepted from input stream, it is passed for reuse.
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_no_receive(struct sk_buff *skb, session_t *session)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_NO_RECEIVE];
+	packet_t *hdr;
+	unsigned char data1;
+	int rc;
+
+	session_hold(session);
+	data1 = NETBEUI_NACK_INDICATOR(((packet_t *)skb->data));
+	skb_trim(skb, 0);
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_NO_RECEIVE;
+	hdr->data1		= data1;
+	hdr->data2		= session->i_notacked;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+
+	rc = nbll_isend(session->link, skb);
+	if (!rc) {
+		session->i_state	= NETBEUI_RECV_NO_RECEIVE;
+		session->i_notacked	= 0;
+	}
+	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_isend_receive_outstanding
+ *	Prepares a NetBIOS RECEIVE OUTSTANDING frame and nbll_isends it toward
+ *	remote session.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ * Notes:
+ *	- Since the frame is transmitted within a user process context,
+ *	  and and works with input state variable, it locks a session during
+ *	  transmission period.
+ *	- no need to hold refcnt, only called from nbss_receive that already
+ *	  does that
+ */
+static int nbss_isend_receive_outstanding(session_t *session)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_RECEIVE_OUTSTANDING];
+	packet_t *hdr;
+	int rc = -ENOMEM;
+	struct sk_buff *skb = nbss_alloc_session_skb(session,
+						     session_packet_len,
+						     GFP_KERNEL);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_RECEIVE_OUTSTANDING;
+	hdr->data1		= 0;
+	hdr->data2		= 0;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	nbss_lock_session(session);
+
+	rc = nbll_isend(session->link, skb);
+	if (!rc)
+		session->i_state = NETBEUI_RECV_RECEIVE_OUTSTANDING;
+	nbss_release_session(session);
+out:	return rc;
+}
+
+/*
+ * Function: nbss_isend_data_ack
+ *	Prepares a NetBIOS DATA ACK frame and nbll_isends it toward remote
+ *	session.
+ * Parameters:
+ *	session	      : pointer to session_t structure the frame should be
+ *			built for
+ *	ack_correlator: this is the xmit correlator found in the incoming frame
+ *		        passed to be put in response correlator of the DATA ACK
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_data_ack(session_t *session,
+			       unsigned short ack_correlator)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_DATA_ACK];
+	struct sk_buff *skb;
+	packet_t *hdr;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_DATA_ACK;
+	hdr->data1		= 0;
+	hdr->data2		= 0;
+	hdr->xmit_correlator	= ack_correlator;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_ack_session_data
+ *	Actually acknowledges incoming session data depending on current
+ *	condition either by sending DATA ACK frame or by postponing and sending
+ *	ACK WITH DATA.
+ * Parameters:
+ *	session: pointer to session_t structure the frame should be built for
+ *	hdr    : pointer to packet_t header of the incoming frame which the
+ *		 acknowledgement is built for.
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_ack_session_data(packet_t *hdr, session_t *session)
+{
+	int rc = 0;
+
+	session_hold(session);
+	if (NETBEUI_ACK_WITH_DATA_ALLOWED(hdr) &&
+	    !session->o_ack_correlator && !session->urgent_ack) {
+		session->o_ack_correlator = hdr->resp_correlator |
+					    NETBEUI_ACK_FLAG;
+		session->timer.expires	= jiffies + NETBEUI_DATA_ACK_TIMEOUT;
+		add_timer(&session->timer);
+		goto out;
+	}
+	rc = nbss_isend_data_ack(session, hdr->resp_correlator);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_ack_timer_function
+ *	Handles delayed acknowledgement for a session when its timer expires
+ *	by sending a DATA ACK frame.
+ * Parameters:
+ *	input: pointer to session_t structure whose timer is expired.
+ * Returns: None
+ * Notes:
+ *	- We never re-enter LLC from its upper layer interface since it is
+ *	  not re-entrant. However ack timers expire and thus cause NetBEUI
+ *	  to send DATA ACK which re-enters LLC.
+ */
+static void nbss_ack_timer_function(unsigned long input)
+{
+	session_t *session = (session_t *)input;
+
+	session_hold(session);
+	if (llc_in_progress ||
+	    nbss_isend_data_ack(session, session->o_ack_correlator)) {
+		session->timer.expires = jiffies + NETBEUI_DATA_ACK_TIMEOUT;
+		add_timer(&session->timer);
+	} else
+		session->o_ack_correlator = 0;
+	session_put(session);
+}
+
+/*
+ * Function: nbss_isend_session_end
+ *	Prepares a NetBIOS SESSION END frame and nbll_isends it toward remote
+ *	session.
+ * Parameters:
+ *	session : pointer to session_t structure the frame should be built for
+ * Returns:
+ *	0      : if frame is successfully transmitted to remote session.
+ *	-ENOMEM: if memory allocation for sk_buff failed.
+ *	other  : if frame transmission encountered an error
+ */
+static int nbss_isend_session_end(session_t *session)
+{
+	int session_packet_len = nb_cmd_hdr_len[NETBEUI_SESSION_END];
+	struct sk_buff *skb;
+	packet_t *hdr;
+	int rc = -ENOMEM;
+
+	session_hold(session);
+	skb = nbss_alloc_session_skb(session, session_packet_len, GFP_ATOMIC);
+	if (!skb)
+		goto out;
+	hdr			= (packet_t *)skb_put(skb, session_packet_len);
+	hdr->length		= session_packet_len;
+	hdr->delimiter		= NETBEUI_DELIMITER;
+	hdr->command		= NETBEUI_SESSION_END;
+	hdr->data1		= 0;
+	hdr->data2		= 0;
+	hdr->xmit_correlator	= 0;
+	hdr->resp_correlator	= 0;
+	hdr->dest_num		= session->rsn;
+	hdr->source_num		= session->lsn;
+	rc = nbll_isend(session->link, skb);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbns_handle_event
+ *	This is the heart of Session Service State Machine, which performs a
+ *	transition from current state of session element to new state based
+ *	on event occurred and session state table contents.
+ * Parameters:
+ *	event  : An integer of NETBEUI_SESS_* family that implies type of event
+ *	nb_name: pointer to name_t structure which the event occurred on
+ * Returns: None
+ * Notes:
+ *	- The state changes before actions be executed. This is due to
+ *	  non deterministic behavior of actions which may sleep the current
+ *	  process, thus stopping the function in the mid-way.
+ */
+static void nbss_handle_event(session_event_t event, session_t *session)
+{
+	struct event_struct *ev;
+
+	session_hold(session);
+	ev = &session_state_table[session->state][event];
+	if (ev && ev->event_handler) {
+		unsigned char old_state	= session->state;
+
+		session->state	= ev->next_state;
+		if (ev->event_handler(session))
+			session->state = old_state;
+	}
+	session_put(session);
+}
+
+/*
+ * Function: nbss_wait_timer_function
+ *	This is the callback function triggered upon expiration of session
+ *	wait timer used first during session establishment and then for
+ *	delaying acknowledgements.
+ * Parameters:
+ *	input: pointer to session_t structure whose timer is expired.
+ * Returns: None
+ * Notes:
+ *	- This timer function, set in session allocation time is used during
+ *	  session establishment.
+ */
+static void nbss_wait_timer_function(unsigned long input)
+{
+	session_t *session = (session_t *)input;
+
+	session_hold(session);
+	session->status = -ETIMEDOUT;
+	nbss_handle_event(NETBEUI_SESS_TIMEOUT, session);
+	session_put(session);
+}
+
+/*
+ * Function:
+ *	This is the callback function trigerred upon expiration of session
+ *	resource timer used when resources (usually memory) are ended up.
+ * Parameters:
+ *	input: pointer to session_t structure whose timer is expired.
+ * Returns: None
+ */
+static void nbss_resource_timer_function(unsigned long input)
+{
+	session_t *session = (session_t *)input;
+
+	session_hold(session);
+	switch (session->o_rsrc_origin) {
+		case NETBEUI_ORIGIN_CONNECTED:
+			nbss_handle_event(NETBEUI_SESS_CONN_RETRY, session);
+			break;
+		case NETBEUI_ORIGIN_NORMAL:
+			nbss_handle_event(NETBEUI_SESS_NORM_RETRY, session);
+			break;
+		default:
+			printk(KERN_ERR "NetBEUI serious error: Resource "
+			       "timer expired from %u\n",
+			       session->o_rsrc_origin);
+			break;
+		}
+	session_put(session);
+}
+
+/*
+ * Session service state machine functions
+ * Implementing transition actions
+ */
+static int nbss_event_abort_send_in_all(session_t *session)
+{
+	session->o_aborted = 1;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_call_in_initial(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbll_attach_session(session, session->dev,
+					      session->remote_mac);
+	if (session->status)
+		goto out;
+	rc = 0;
+	nbss_add_session_to_list(session);
+out:	return rc;
+}
+
+static int nbss_event_listen_in_initial(session_t *session)
+{
+	__nbss_add_session_to_list(session);
+	return 0;
+}
+
+static int nbss_event_confirm_in_callwait(session_t *session)
+{
+	int rc;
+
+	session->status = nbll_link_session(session->link);
+	if (session->status) {
+		rc = session->status;
+		goto out;
+	}
+	session->status = nbss_isend_session_initialize(session);
+	rc = -ENOMEM;
+	if (session->status)
+		goto out;
+	rc = 0;
+	nbss_remove_session_from_list(session);
+	session->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT *
+					   NETBEUI_TRANSMIT_COUNT;
+	add_timer(&session->timer);
+	sleep_on(&session->waitq);
+out:	return rc;
+}
+
+static int nbss_event_reject_in_callwait(session_t *session)
+{
+	nbss_remove_session_from_list(session);
+	nbll_detach_session(session->link, session->lsn);
+	session->status = -ECONNABORTED;
+	return 0;
+}
+
+static int nbss_event_abort_in_callwait(session_t *session)
+{
+	nbss_remove_session_from_list(session);
+	session->status = -ECONNRESET;
+	return 0;
+}
+
+static int nbss_event_connect_in_confwait(session_t *session)
+{
+	del_timer(&session->timer);
+	wake_up(&session->waitq);
+	session->status = 0;
+	return 0;
+}
+
+static int nbss_event_timeout_in_confwait(session_t *session)
+{
+	nbll_detach_session(session->link, session->lsn);
+	wake_up(&session->waitq);
+	session->status = -ECONNREFUSED;
+	return 0;
+}
+
+static int nbss_event_abort_in_confwait(session_t *session)
+{
+	del_timer(&session->timer);
+	wake_up(&session->waitq);
+	session->status = -ECONNRESET;
+	return 0;
+}
+
+static int nbss_event_confirm_in_listenwait(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbll_attach_session(session, session->dev,
+					      session->remote_mac);
+	if (session->status)
+		goto out;
+	session->status = nbss_unicast_name_recognized(session);
+	if (session->status) {
+		nbll_detach_session(session->link, session->lsn);
+		goto out;
+	}
+	rc = 0;
+	session->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT *
+					   NETBEUI_TRANSMIT_COUNT;
+	add_timer(&session->timer);
+out:	return rc;
+}
+
+static int nbss_event_reject_in_listenwait(session_t *session)
+{
+	nbss_remove_session_from_list(session);
+	session->status = -ECONNABORTED;
+	return 0;
+}
+
+static int nbss_event_connect_in_initwait(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_session_confirm(session);
+	if (session->status)
+		goto out;
+	rc = 0;
+	del_timer(&session->timer);
+	nbss_remove_session_from_list(session);
+	session->session_ready_callback(session->owner, session);
+	session->status = 0;
+out:	return rc;
+}
+
+static int nbss_event_timeout_in_initwait(session_t *session)
+{
+	nbll_detach_session(session->link, session->lsn);
+	session->status = -ECONNREFUSED;
+	return 0;
+}
+
+static int nbss_event_abort_in_initwait(session_t *session)
+{
+	del_timer(&session->timer);
+	session->status = -ECONNRESET;
+	return 0;
+}
+
+static int nbss_event_reject_in_initwait(session_t *session)
+{
+	del_timer(&session->timer);
+	nbll_detach_session(session->link, session->lsn);
+	nbss_remove_session_from_list(session);
+	session->status = -ECONNABORTED;
+	return 0;
+}
+
+static int nbss_event_abort_in_connected(session_t *session)
+{
+	if (session->owner)
+		session->abort_owner_callback(session->owner, session);
+	session->status = -ECONNRESET;
+	return 0;
+}
+
+static int nbss_event_hangup_in_connected(session_t *session)
+{
+	nbss_isend_session_end(session);
+	nbll_detach_session(session->link, session->lsn);
+	session->status = -ECONNABORTED;
+	return 0;
+}
+
+static int nbss_event_end_in_connected(session_t *session)
+{
+	if (session->owner)
+		session->abort_owner_callback(session->owner, session);
+	nbll_detach_session(session->link, session->lsn);
+	session->status = -ECONNRESET;
+	return 0;
+}
+
+static int nbss_event_hangup_in_discwait(session_t *session)
+{
+	return 0;
+}
+
+static int nbss_event_first_middle_cont_in_connected(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_first_middle(session, 1);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->mtu;
+	session->o_size -= session->mtu;
+	session->o_txed += session->mtu;
+	nbss_wait_event(session);
+out:	return rc;
+}
+
+static int nbss_event_first_middle_in_connected(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_first_middle(session, 0);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->mtu;
+	session->o_size -= session->mtu;
+	session->o_txed += session->mtu;
+out:	return rc;
+}
+
+static int nbss_event_only_last_ack_in_connected(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_only_last(session);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->o_size;
+	session->o_txed += session->o_size;
+	session->o_size -= session->o_size;
+	nbss_wait_event(session);
+out:	return rc;
+}
+
+static int nbss_event_only_last_in_connected(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_only_last(session);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->o_size;
+	session->o_txed += session->o_size;
+	session->o_size -= session->o_size;
+out:	return rc;
+}
+
+static int nbss_event_resource_in_connected(session_t *session)
+{
+	session->o_rsrc_origin	= NETBEUI_ORIGIN_CONNECTED;
+	session->timer.expires	= jiffies + NETBEUI_RESOURCE_TIMEOUT;
+	session->timer.function	= nbss_resource_timer_function;
+	add_timer(&session->timer);
+	sleep_on(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_continue_in_contwait(session_t *session)
+{
+	session->o_acked += session->o_txed;
+	session->o_txed = 0;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_restart_in_contwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_pause_in_contwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_nonblock_in_contwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_restart_in_standwait(session_t *session)
+{
+	session->o_no_receive = 0;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_pause2_in_standwait(session_t *session)
+{
+	nbss_sleep_on(session, TASK_INTERRUPTIBLE);
+	return 0;
+}
+
+static int nbss_event_data_acked_in_ackwait(session_t *session)
+{
+	session->o_acked += session->o_txed;
+	session->o_txed = 0;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_restart_in_ackwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_pause_in_ackwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_nonblock_in_ackwait(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_norm_retry_in_rsrcwait(session_t *session)
+{
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_conn_retry_in_rsrcwait(session_t *session)
+{
+	wake_up(&session->waitq);
+	return 0;
+}
+
+static int nbss_event_first_middle_in_normal(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_first_middle(session, 0);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->mtu;
+	session->o_size -= session->mtu;
+	session->o_txed += session->mtu;
+out:	return rc;
+}
+
+static int nbss_event_restart_in_normal(session_t *session)
+{
+	nbss_ack_bytes(session);
+	return 0;
+}
+
+static int nbss_event_only_last_ack_in_normal(session_t *session)
+{
+	int rc = -1;
+
+	session->status = nbss_isend_data_only_last(session);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->o_size;
+	session->o_txed += session->o_size;
+	session->o_size -= session->o_size;
+	nbss_wait_event(session);
+out:	return rc;
+}
+
+static int nbss_event_only_last_in_normal(session_t *session)
+{
+	int rc = -1;
+	
+	session->status = nbss_isend_data_only_last(session);
+	if (session->status)
+		goto out;
+	rc = 0;
+	session->o_buff += session->o_size;
+	session->o_txed += session->o_size;
+	session->o_size -= session->o_size;
+out:	return rc;
+}
+
+static int nbss_event_pause_in_normal(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	return 0;
+}
+
+static int nbss_event_nonblock_in_normal(session_t *session)
+{
+	nbss_ack_bytes(session);
+	session->o_no_receive = 1;
+	return 0;
+}
+
+static int nbss_event_resource_in_normal(session_t *session)
+{
+	session->o_rsrc_origin	= NETBEUI_ORIGIN_NORMAL;
+	session->timer.expires	= jiffies + NETBEUI_RESOURCE_TIMEOUT;
+	session->timer.function	= nbss_resource_timer_function;
+	add_timer(&session->timer);
+	sleep_on(&session->waitq);
+	return 0;
+}
+
+/*
+ * Session service state machine functions
+ * Implementing interface functions
+ */
+/*
+ * Function: nbss_call
+ *	This is a sophisticated interface routine for establishing a session
+ *	with a remote hosts. Finding host that owns name, establishing session
+ *	building LLC connection and configuring session are the phases a session
+ *	element passes through them to prepare session for transferring data.
+ * Parameters:
+ *	calling_name   : pointer to name_t structure that the session is built
+ *			 either registered by client or NAME_NUMBER_1 auto bound
+ *	called_name    : pointer to NetBIOS name of remote node
+ *	owner	       : pointer to a data structure of the owner of session
+ *			 used for calling its call backs
+ *	itf_abort_owner: pointer to a callback routine for alerting owner, of
+ *			 session abortion
+ *	session_ptr    : (VRP) pointer to session_structure if return value
+ *			 indicates a valid value which is a pointer to session_t
+ *			 The owner later uses this value for getting services
+ *			 from Session Service module
+ * Returns:
+ *	0	     : if a session successfully established to remote node
+ * 	-ENOMEM	     : if failed to allocate memory for session_t structure.	
+ *	-EHOSTUNREACH: if can not find a node on network who owns the name.
+ *	-ETOONAMYREFS: if more than one node responded to session establishment
+ *		       request. This means that it can not establish session
+ *		       with group names.
+ *	-ECONNREFUSED: if node responded to request but refused to establish a
+ *		       session anyway.
+ *	-ECONNRESET  : if connection reset by LLC before session establishment
+ *		       ends
+ *	other	     : any other error reported by LLC.
+ */
+int nbss_call(name_t *calling_name, char *called_name, struct sock *owner,
+	      abort_owner_cbt itf_abort_owner, session_t **session_ptr)
+{
+	int status;
+#define MAX_FIND 3
+	char macs[MAX_FIND][6];
+	struct net_device *devs[MAX_FIND];
+	session_t *session = nbss_alloc_session();
+	int rc = -ENOMEM;
+
+	if (!session)
+		goto out;
+	*session_ptr			= NULL;
+	session->state			= NETBEUI_SESS_INITIAL;
+	session->owner			= owner;
+	session->local_name		= calling_name;
+	memcpy(session->remote_name, called_name, NETBEUI_NAME_LEN);
+	session->abort_owner_callback	= itf_abort_owner;
+
+	rc = status = nbqs_find_name(called_name, (char *)macs, devs, MAX_FIND);
+	if (status < 0)
+		goto sput;
+	else if (!status) {
+		rc = -EHOSTUNREACH;
+		goto sput;
+	} else if (status != 1) {
+		rc = -ETOOMANYREFS;
+		goto sput;
+	}
+	session_hold(session);
+	session->dev = devs[0];
+	memcpy(session->remote_mac, macs, session->dev->addr_len);
+
+	for (;;) {
+		nbss_handle_event(NETBEUI_SESS_CALL, session);
+		if (session->state == NETBEUI_SESS_INITIAL) {
+			rc = status = session->status;
+			goto dsput;
+		}
+		session->status = nbqs_query_name(called_name, calling_name,
+						  session->lsn, &session->rsn,
+						  &session->tr_frame_lf,
+						  &session->xmit_correlator);
+		/* We may have got a session abort here */
+		if (session->state == NETBEUI_SESS_INITIAL)
+			continue;
+		else
+			break;
+	}
+	/* We may also could not query server */
+	rc = -ECONNREFUSED;
+	if (session->status || !session->rsn || session->rsn == 0xFF) {
+		nbss_handle_event(NETBEUI_SESS_REJECT, session);
+		goto dsput;
+	}
+	/* Token Ring support */
+	session->llcmac_ihl = LLCMAC_I_HEADLEN(session->dev);
+	nbss_handle_event(NETBEUI_SESS_CONFIRM, session);
+	if (session->state != NETBEUI_SESS_CONNECTED || session->status) {
+		status = session->status;
+		nbqs_delete_rnc(called_name);
+		rc = status ? : -ECONNRESET;
+		goto dsput;
+	}
+	rc = 0;
+	*session_ptr = session;
+sput:	session_put(session);
+out:	return rc;
+dsput:	session_put(session);
+	goto sput;
+}
+
+/*
+ * Function: __nbss_listen
+ *	Prepares backlog session_ts for a server who is going to listen on
+ *	a name, kept in pending session list. Has to be called with
+ *	session_list_lock held, with spin_lock_bh or spin_lock, depending
+ *	on the context (process or BH).
+ * Parameters:
+ *	nb_name		 : pointer to name_t the sessions listen to connection
+ *			   requests on it
+ *	backlog		 : count of concurrent session establishments the
+ *			   session service should process at once.
+ *	owner		 : pointer to a data structure of the owner of session
+ *			   used for calling its call backs
+ *	itf_abort_owner  : pointer to a callback routine for alerting owner, of
+ *			   session abortion
+ * 	itf_session_ready: pointer to callback routine alerting owner, of
+ *			   existence of an established session.
+ * Returns:
+ *	>= 0: count of backlog pending session in list who listen to name for
+ *	      connection establishment requests.
+ * Notes:
+ *	- The session does not guarantee to have as many pending sessions
+ *	  as requested by backlog parameter due to memory allocation fails.
+ *	  This should be considered by upper layer routines.
+ */
+int __nbss_listen(name_t *nb_name, int backlog, struct sock *owner,
+		  abort_owner_cbt itf_abort_owner,
+		  session_ready_cbt itf_session_ready)
+{
+	int count, exist = 0;
+	session_t *session = session_list;
+
+	while (session) {
+		if (session->local_name == nb_name)
+			exist++;
+		session = session->next;
+	}
+	for (count = exist; count < backlog; count++) {
+		session = nbss_alloc_session();
+		if (session) {
+			session->state			= NETBEUI_SESS_INITIAL;
+			session->owner			= owner;
+			session->local_name		= nb_name;
+			session->abort_owner_callback	= itf_abort_owner;
+			session->session_ready_callback	= itf_session_ready;
+			nbss_handle_event(NETBEUI_SESS_LISTEN, session);
+			exist++;
+		} else
+			break;
+	}
+	return exist;
+}
+
+int nbss_listen(name_t *nb_name, int backlog, struct sock *owner,
+		abort_owner_cbt itf_abort_owner,
+		session_ready_cbt itf_session_ready)
+{
+	int rc;
+	spin_lock(&session_list_lock);
+	rc = __nbss_listen(nb_name, backlog, owner, itf_abort_owner,
+			   itf_session_ready);
+	spin_unlock(&session_list_lock);
+	return rc;
+}
+
+int nbss_listen_bh(name_t *nb_name, int backlog, struct sock *owner,
+		   abort_owner_cbt itf_abort_owner,
+		   session_ready_cbt itf_session_ready)
+{
+	int rc;
+	spin_lock_bh(&session_list_lock);
+	rc = __nbss_listen(nb_name, backlog, owner, itf_abort_owner,
+			   itf_session_ready);
+	spin_unlock_bh(&session_list_lock);
+	return rc;
+}
+
+/*
+ * Function: nbss_end_listen
+ *	Removes session_ts on pending session list who listen to session
+ *	establishment requests on a specific name, called only from
+ *	nbso_session_release, in process context, so no need to spin_lock_bh,
+ *	plain spin_lock is enough.
+ * Parameters:
+ *	nb_name: pointer to name which sessions listening to it should be
+ *		 removed from pending session list.
+ * Returns: None
+ */
+void __nbss_end_listen(name_t *nb_name)
+{
+	session_t *session = session_list;
+
+	while (session) {
+		session_t *next_session = session->next;
+
+		if (session->local_name == nb_name) {
+			nbss_handle_event(NETBEUI_SESS_REJECT, session);
+			session_put(session);
+		}
+		session = next_session;
+	}
+}
+
+/*
+ * Function: nbss_send
+ *	This is the heart of output data stream.
+ *	Sends a block of user data to remote session by fragmenting and
+ *	controlling flow of data. In addition to simplicity it operates
+ *	a considerable part of Session Service State Machine by generating
+ *	different events carefully
+ * Parameters:
+ *	session	: pointer to session_t to send data on
+ *	buf	: pointer to user buffer that contains data
+ *	size	: size of data in user buffer
+ *	nonblock: flag that indicates to block user process or not block
+ *		  it (0/1)
+ *	noack	: flag that indicates to receive data receive acknowledgement
+ *		  or not (0/1)
+ * Returns:
+ *	>= 0	     : count of data bytes successfully sent to remote session
+ *	-ECONNABORTED: if session aborted.
+ *	-EINPROGRESS : if another process currently sends data in session this
+ *		       may happen if two process share a socket.
+ *	-ETIME	     : if send timeout. this happens if interface layer calls
+ *		       nbss_send_abort when its timers expire.
+ */
+int nbss_send(session_t *session, unsigned char *buf, unsigned short size,
+	      unsigned char nonblock, unsigned char noack)
+{
+	int rc = -ECONNABORTED;
+
+	session_hold(session);
+	if (session->zapped)
+		goto out;
+	rc = -EINPROGRESS;
+	if (session->state != NETBEUI_SESS_CONNECTED)
+		goto out;
+	session->o_nonblock    = nonblock;
+	session->o_noack       = session->version == NETBEUI_VERSION_2xx ?
+					noack : 0;
+	session->o_no_receive  = 0;
+	session->o_rsrc_origin = 0;
+	session->o_buff	       = buf;
+	session->o_buffsize    = size;
+	session->o_size	       = size;
+	session->o_txed	       = 0;
+	session->o_acked       = 0;
+	session->r_acked       = 0;
+	session->o_aborted     = 0;
+	while (session->o_acked < session->o_buffsize) {
+		nbss_lock_session(session);
+		session->status = 0;
+
+		if (session->o_size > session->mtu &&
+ 		    session->o_size == session->o_buffsize &&
+		    session->o_receive_continue)
+			nbss_handle_event(NETBEUI_SESS_FIRST_MIDDLE_CONT,
+					  session);
+		else if (session->o_size > session->mtu)
+			nbss_handle_event(NETBEUI_SESS_FIRST_MIDDLE, session);
+		else if (!noack && session->o_size > 0)
+			nbss_handle_event(NETBEUI_SESS_ONLY_LAST_ACK, session);
+		else if (session->o_size > 0)
+			nbss_handle_event(NETBEUI_SESS_ONLY_LAST, session);
+		rc = session->status;
+		if (nbss_release_session(session))
+			goto out;
+		rc = -ETIME;
+		if (session->o_aborted)
+			goto out;
+		if (session->o_no_receive && session->o_nonblock) {
+			rc = session->o_acked;
+			break;
+		}
+		if (session->o_no_receive) {
+			nbss_lock_session(session);
+			nbss_handle_event(NETBEUI_SESS_PAUSE2, session);
+			nbss_release_session(session);
+			if (signal_pending(current)) {
+				rc = session->o_acked > 0 ? session->o_acked :
+							    -ERESTART;
+				break;
+			}
+		}
+		if (session->status == -ENOMEM) {
+			nbss_lock_session(session);
+			nbss_handle_event(NETBEUI_SESS_RESOURCE, session);
+			nbss_release_session(session);
+		}
+		rc = session->o_acked;
+	}
+	session->state = NETBEUI_SESS_CONNECTED;
+	if (rc > size)
+		rc = size;
+	if (rc > 0)
+		session->o_total += rc;
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_send_zero
+ *	Sends a zero byte DATA ONLY LAST frame to remote node.
+ * Parameters:
+ *	session: pointer to session_t to send frame on
+ *	buf    : pointer to a user buffer that is referenced in transition
+ *		 handlers of state machine
+ * Returns:
+ *	>= 0	     : if size of data bytes successfully sent to remote session
+ *	-ECONNABORTED: if session aborted.
+ *	-EINPROGRESS : if another process currently sends data in session this
+ *		       may happen if two process share a socket.
+ * Notes:
+ *	- This feature is activated via ioctl interface and has special
+ *	  meaning to SAMBA that operates over NetBEUI
+ */
+int nbss_send_zero(session_t *session, char *buf)
+{
+	int rc = -ECONNABORTED;
+
+	session_hold(session);
+	if (session->zapped)
+		goto out;
+	rc = -EINPROGRESS;
+	if (session->state != NETBEUI_SESS_CONNECTED)
+		goto out;
+	session->o_nonblock	= 1;
+	session->o_noack	= 1;
+	session->o_no_receive	= 0;
+	session->o_rsrc_origin	= 0;
+	session->o_buff		= buf;
+	session->o_buffsize	= 0;
+	session->o_size		= 0;
+	session->o_txed		= 0;
+	session->o_acked	= 0;
+	session->r_acked	= 0;
+	session->o_aborted	= 0;
+	session->status		= 0;
+	nbss_handle_event(NETBEUI_SESS_ONLY_LAST, session);
+	rc = session->status;
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_abort_send
+ *	The interface which aborts a send operation, usually called from
+ *	upper interface when send timers expire.
+ * Parameters:
+ *	session: pointer to session_t whose send operation is to be aborted.
+ * Returns: None
+ */
+void nbss_abort_send(session_t *session)
+{
+	session_hold(session);
+	session->o_aborted = 1;
+	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_send_ready
+ *	Determines if session is ready to send data or not
+ * Parameters:
+ *	session: pointer to session_t.
+ * Returns:
+ *	1: if session is ready to send data
+ *	0: if session is not ready to send data
+ */
+int nbss_send_ready(session_t *session)
+{
+	int rc;
+
+	session_hold(session);
+	rc = !session->zapped &&
+	     session->state == NETBEUI_SESS_CONNECTED ? 1 : 0;
+	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_receive
+ *	Receives data from input stream buffer and copies it into user buffer.
+ * Parameters:
+ *	session	: pointer to session_t to receive data from
+ *	buf	: pointer to user space buffer to put data into
+ *	size	: maximum size of data to put in buf
+ *	nonblock: flag that indicates whether to block user process if data was
+ *	          not available
+ * Returns:
+ *	>= 0	     : count of data bytes fetched from input stream queue
+ *	-ECONNABORTED: if session aborted.
+ *	-ETIME	     : if receive timeout. this happens if interface layer calls
+ *		       nbss_receive_abort when its timers expire.
+ *	-ERESTART    : if process caught a signal
+ *	-EAGAIN	     : if zero data bytes received.
+ */
+int nbss_receive(session_t *session, unsigned char *buf, unsigned short size,
+		 unsigned char nonblock)
+{
+	unsigned short i_size = size;
+	struct sk_buff *skb;
+	int rc = -ECONNABORTED;
+	int passed_2nd = 0;
+	
+	session_hold(session);
+	if (session->zapped && !skb_queue_len(&session->i_skbq))
+		goto out;
+	session->i_aborted = 0;
+try_read:
+	nbss_lock_session(session);
+	while (i_size > 0 && (skb = skb_peek(&session->i_skbq)) != NULL) {
+		if (passed_2nd)
+			dprintk("entering 1st loop after the 2nd...\n");
+		passed_2nd = 0;
+		nbss_release_session(session);
+		if (i_size >= skb->len) {
+			rc = -EFAULT;
+			if (copy_to_user(buf, skb->data, skb->len))
+				goto out;
+			i_size -= skb->len;
+			buf += skb->len;
+			nbss_lock_session(session);
+			__skb_unlink(skb, &session->i_skbq);
+			session->i_size -= skb->len;
+			kfree_skb(skb);
+		} else {
+			rc = -EFAULT;
+			if (copy_to_user(buf, skb->data, i_size))
+				goto out;
+			skb_pull(skb, i_size);
+			buf += i_size;
+			nbss_lock_session(session);
+			session->i_size -= i_size;
+			i_size = 0;
+		}
+	}
+	while (i_size == size && !nonblock) {
+		dprintk("entering second loop...\n");
+		passed_2nd = 1;
+		rc = 0;
+		if (session->i_state == NETBEUI_RECV_NO_RECEIVE &&
+		    nbss_isend_receive_outstanding(session)) {
+			dprintk("session->i_state == "
+				"NETBEUI_RECV_NO_RECEIVE && "
+				"nbss_isend_receive_outstanding(session)\n");
+			goto out;
+		}
+		/* nbss_sleep_on calls nbss_release_session */
+		nbss_sleep_on(session, TASK_INTERRUPTIBLE);
+		rc = -ERESTART;
+		if (signal_pending(current)) {
+			dprintk("signal_pending(current)\n");
+			goto out;
+		}
+		if (session->i_size) {
+			dprintk("session->i_size != 0, goto try_read\n");
+			goto try_read;
+		}
+		rc = -ECONNABORTED;
+		if (session->zapped) {
+			dprintk("session->zapped != 0\n");
+			goto out;
+		}
+		rc = -ETIME;
+		if (session->i_aborted) {
+			dprintk("session->i_aborted != 0\n");
+			goto out;
+		}
+	}
+	nbss_release_session(session);
+	rc = i_size == size ? -EAGAIN : (size - i_size);
+out:	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_abort_receive
+ *	The interface which aborts a receive operation, usually called from
+ *	upper interface when receive timers expire.
+ * Parameters:
+ *	session: pointer to session_t whose send operation is to be aborted.
+ * Returns: None
+ */
+void nbss_abort_receive(session_t *session)
+{
+	session_hold(session);
+	session->i_aborted	= 1;
+	session->status		= -ETIME;
+	wake_up_interruptible(&session->waitq);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_receive_ready
+ *	Determines if session has data in input stream queue or not
+ * Parameters:
+ *	session: pointer to session_t.
+ * Returns:
+ *	1: if session is ready to send data
+ *	0: if session is not ready to send data
+ */
+int nbss_receive_ready(session_t *session)
+{
+	int rc;
+	session_hold(session);
+	rc = session->i_size;
+	session_put(session);
+	return rc;
+}
+
+/*
+ * Function: nbss_trim_data
+ *	Removes some bytes from a DATA ONLY LAST frame which is fetched
+ *	before.
+ * Parameters:
+ *	session: pointer to session_t.
+ * Returns:
+ *	0: always returns zero
+ * Notes:
+ *	- This feature is activated via ioctl interface and has special
+ *	  meaning to SAMBA that operates over NetBEUI
+ *	- skb->acked flags the frame as a DATA ONLY LAST frame
+ *	- skb->used  indicates that some of frame data is fetched
+ * Important Note:
+ *	- Windows API implements NetBEUI socket interface of type SOCK_SEQPACKET
+ *	  and sends garbage at end of SMB messages. We have implemented
+ *	  SOCK_STREAM which accepts those garbages. The users process
+ *	  activates an IOCTL to remove unused data bytes from the stream of
+ *	  bytes.
+ *	- Another solution is modifying socket read mechanism so that a process
+ *	  can read the whole message. This may significantly improve SAMBA reads
+ *	  but reduces NetBEUI extensibility.
+ */
+int nbss_trim_data(session_t *session)
+{
+	struct sk_buff *skb;
+
+	session_hold(session);
+	skb = skb_peek(&session->i_skbq);
+	if (skb) {
+		nbss_lock_session(session);
+		__skb_unlink(skb, &session->i_skbq);
+		session->i_size -= skb->len;
+		nbss_release_session(session);
+		kfree_skb(skb);
+	}
+	session_put(session);
+	return 0;
+}
+
+/*
+ * Function: nbss_hangup
+ *	The upper layer interface which terminates a session by generating a
+ *	proper event.
+ * Parameters:
+ *	session: pointer to session_t which is to be terminated
+ * Returns: None
+ * Notes:
+ *	- During session termination there may be some unacknowledged data in
+ *	  input stream queue whose acknowledgement is not a an action of session
+ *	  transition handlers, since session data input stream is not part of
+ *	  Session State Machine.
+ */
+void nbss_hangup(session_t *session)
+{
+	session_hold(session);
+	del_timer(&session->timer);
+	if (session->o_ack_correlator)
+		nbss_isend_data_ack(session,
+				    (unsigned short)session->o_ack_correlator);
+	nbss_handle_event(NETBEUI_SESS_HANGUP, session);
+	session_put(session);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_abort_session
+ *	This upper layer interface abnormally terminates a session.
+ * Parameters:
+ *	session: pointer to session_t which is to be aborted
+ * Returns: None
+ */
+void nbss_abort_session(session_t *session)
+{
+	session_hold(session);
+	session->zapped = 1;
+	del_timer(&session->timer);
+	nbss_abort_receive(session);
+	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+	nbss_handle_event(NETBEUI_SESS_ABORT, session);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_get_name_query
+ *	Accepts a NAME QUERY frame and depending on FIND/QUERY characteristic
+ *	of it either responds NAME FIND or generates an event to start
+ *	session establishment.
+ * Parameters:
+ *	skb	  : pointer to sk_buff that holds the frame
+ *	remote_mac: pointer to MAC address of remote node who sent the frame
+ * Returns: None
+ * Notes:
+ *	- NAME FIND and NAME QUERY use the same frame format with different
+ *	  flags and field values.
+ *	- NAME FIND processing is simply responding with a NAME RECOGNIZED
+ *	- NAME QUERY processing is doing the first step of session establishment
+ *	- Since the skb is reused for generating response frame it is passed to
+ *	  element in session->skb
+ */
+void nbss_get_name_query(struct sk_buff *skb, unsigned char *remote_mac)
+{
+	dgram_t *hdr = (dgram_t *)skb->data;
+	name_t *nb_name = nbns_find_name(hdr->dest_name);
+	session_t *session = nbss_find_listen(hdr->dest_name);
+	session_t tmp_session;
+
+	if (!session) {
+		session			= &tmp_session;
+		session->local_name	= nb_name;
+		session->rsn		= 0;
+		atomic_set(&session->refcnt, 1);
+		session_hold(session);
+	} else
+		session->rsn = NETBEUI_CALL_SS(hdr->data2);
+	if (!nb_name) {
+		kfree_skb(skb);
+		goto out;
+	}
+	session->skb = skb;
+	session->dev = skb->dev;
+	memcpy(session->remote_mac, remote_mac, skb->dev->addr_len);
+	memcpy(session->remote_name, hdr->source_name, NETBEUI_NAME_LEN);
+	session->lsn = 0;
+	if (!session->rsn || session->rsn == 0xFF)
+		nbss_unicast_name_recognized(session);
+	else {
+		/* Token Ring support */
+		session->llcmac_ihl = LLCMAC_I_HEADLEN(session->dev);
+		nbss_handle_event(NETBEUI_SESS_CONFIRM, session);
+	}
+	nbns_name_put(nb_name);
+out:	session_put(session);
+}
+
+/*
+ * Function: nbss_switch_get_session_initialize
+ *	Accepts a SESSION INITIALIZE frame and generates proper event.
+ * Parameters:
+ *	skb    : pointer to sk_buff that holds the frame
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ * Notes:
+ *	- Due to implementation of events in NetBEUI whose data is put element
+ *	  temporary variable and just event identifier is passed to state
+ *	  machine, the routine first checks if the session is in a proper state
+ *	  to accept event or not.
+ *	- Since the skb is reused for generating response frame it is passed to
+ *	  element in session->skb
+ *	- At this point session_t element timer callback function changes to the
+ *	  callback that processes delayed acknowledgements of input data
+ */
+static void nbss_switch_get_session_initialize(struct sk_buff *skb,
+					       session_t *session)
+{
+	packet_t *hdr;
+	unsigned short data2;
+
+	hdr = (packet_t *)skb->data;
+	data2 = hdr->data2;
+	if (session->state != NETBEUI_SESS_INITWAIT ||
+	    session->resp_correlator != hdr->xmit_correlator) {
+		kfree_skb(skb);
+		goto out;
+	}
+	if (!NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr))
+		session->nack_indicator = NETBEUI_NACK_NONE;
+	if (!NETBIOS_VERSION(hdr))
+		session->version = NETBEUI_VERSION_1xx;
+	session->tr_frame_lf = NETBEUI_TR_FRAME_LF(hdr);
+	/* Token Ring support */
+	NETBEUI_CALC_SESS_MTU(session);
+	if (session->mtu > data2)
+		session->mtu = data2;
+	session->skb = skb;
+	nbss_handle_event(NETBEUI_SESS_CONNECT, session);
+	/* From now on, the session timer is used for ACK piggy-backing */
+	session->timer.function = nbss_ack_timer_function;
+	/* skb is reused, thus we don't need to free it */
+out:;
+}
+
+/*
+ * Function: nbss_switch_get_session_confirm
+ *	Accepts a SESSION confirm frame and generates proper event.
+ * Parameters:
+ *	hdr    : pointer to packet_t which is frame header in sk_buff
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ * Notes:
+ *	- Due to implementation of events in NetBEUI whose data is put element
+ *	  temporary variable and just event identifier is passed to state
+ *	  machine, the routine first checks if the session is in a proper state
+ *	  to accept event or not.
+ *	- At this point session_t element timer callback function changes to the
+ *	  callback that processes delayed acknowledgements of input data
+ */
+static void nbss_switch_get_session_confirm(packet_t *hdr, session_t *session)
+{
+	unsigned short data2;
+
+	data2 = hdr->data2;
+	if (session->state != NETBEUI_SESS_CONFWAIT ||
+	    session->resp_correlator != hdr->xmit_correlator)
+		goto out;
+	if (!NETBEUI_IS_ABLE_TO_HANDLE_NACK(hdr))
+		session->nack_indicator = NETBEUI_NACK_NONE;
+	if (!NETBIOS_VERSION(hdr))
+		session->version = NETBEUI_VERSION_1xx;
+	if (session->mtu > data2)
+		session->mtu = data2;
+	nbss_handle_event(NETBEUI_SESS_CONNECT, session);
+	/* From now on, the session timer is used for ACK piggy-backing */
+	session->timer.function = nbss_ack_timer_function;
+out:;
+}
+
+/*
+ * Function: nbss_switch_get_data_ack
+ *	Accepts a DATA ACK frame and generates proper event.
+ * Parameters:
+ *	hdr    : pointer to packet_t which is frame header in sk_buff
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ */
+static void nbss_switch_get_data_ack(packet_t *hdr, session_t *session)
+{
+	if (session->resp_correlator == hdr->xmit_correlator)
+		nbss_handle_event(NETBEUI_SESS_DATA_ACKED, session);
+}
+
+/*
+ * Function: nbss_switch_get_session_data
+ *	Accepts DATA FIRST MIDDLE and DATA ONLY LAST frames and tries to process
+ *	frame by checking input state, data acknowledgement, controlling flow of
+ *	data and queueing frame in input stream queue. (It does more than you
+ *	may think at first glance)
+ * Parameters:
+ *	skb    : pointer to sk_buff which holds the frame
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ * Notes:
+ *	- The frame pointers are adjusted to user data when frame is queued.
+ *	- skb->acked is set for DATA ONLY LAST frames and is used in trimming
+ *	  user data in nbss_trim_data(). It is since we adjust pointers to user
+ *	  data not NetBIOS header of frame.
+ */
+static void nbss_switch_get_session_data(struct sk_buff *skb,
+					 session_t *session)
+{
+	packet_t *hdr;
+
+	hdr = (packet_t *)skb->data;
+	if (NETBEUI_ACK_WITH_DATA_INCLUDED(hdr))
+		nbss_switch_get_data_ack(hdr, session);
+	if (session->i_state == NETBEUI_RECV_NO_RECEIVE ||
+	    (session->i_state == NETBEUI_RECV_RECEIVE_OUTSTANDING &&
+	     NETBEUI_RESYNCH_INDICATOR(hdr) != 0x0001) ||
+	    (session->i_state == NETBEUI_RECV_NORMAL &&
+	     NETBEUI_RESYNCH_INDICATOR(hdr) != 0x0000)) {
+		kfree_skb(skb);
+		goto out;
+	}
+	session->i_state = NETBEUI_RECV_NORMAL;
+
+	if (session->i_size > session->i_rcvbuf ||
+	    (hdr->command == NETBEUI_DATA_FIRST_MIDDLE &&
+	     NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr) &&
+	     nbss_isend_receive_continue(hdr, session)) ||
+	    (hdr->command == NETBEUI_DATA_ONLY_LAST &&
+	     !NETBEUI_NACK_INDICATOR(hdr) &&
+	     nbss_ack_session_data(hdr, session))) {
+		nbss_isend_no_receive(skb, session);
+		goto out;
+	}
+	skb_pull(skb, hdr->length);
+	__skb_queue_tail(&session->i_skbq, skb);
+	session->i_size += skb->len;
+	if (hdr->command == NETBEUI_DATA_FIRST_MIDDLE) {
+		if (!NETBEUI_RECEIVE_CONTINUE_REQUESTED(hdr))
+			session->i_notacked += skb->len;
+		else
+			session->i_notacked = 0;
+	} else  /* DATA ONLY LAST */
+		session->i_notacked = 0;
+
+	wake_up_interruptible(&session->waitq);
+	session->i_total += skb->len;
+out:;
+}
+
+/*
+ * Function: nbss_switch_get_receive_continue
+ *	Accepts a RECEIVE CONTINUE frame and generates a proper event.
+ * Parameters:
+ *	hdr    : pointer to packet_t which is frame header in sk_buff
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ */
+static void nbss_switch_get_receive_continue(packet_t *hdr, session_t *session)
+{
+	if (session->resp_correlator == hdr->xmit_correlator)
+		nbss_handle_event(NETBEUI_SESS_CONTINUE, session);
+}
+
+/*
+ * Function: nbss_switch_get_no_receive
+ *	Accepts a NO RECEIVE frame and generates proper events. The session
+ *	state diagram purpose different events for blocking and non-blocking
+ *	sends
+ * Parameters:
+ *	hdr    : pointer to packet_t which is frame header in sk_buff
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ */
+static void nbss_switch_get_no_receive(packet_t *hdr, session_t *session)
+{
+	session->o_receive_continue = 1;
+	if (!session->o_nonblock)
+		nbss_handle_event(NETBEUI_SESS_PAUSE, session);
+	else
+		nbss_handle_event(NETBEUI_SESS_NONBLOCK, session);
+}
+
+/*
+ * Function: nbss_switch_get_receive_outstanding
+ *	Accepts a RECEIVE OUTSTANDING frame and generates a proper event.
+ * Parameters:
+ *	hdr    : pointer to packet_t which is frame header in sk_buff
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ */
+static void nbss_switch_get_receive_outstanding(packet_t *hdr,
+						session_t *session)
+{
+	if (session->version == NETBEUI_VERSION_1xx)
+		hdr->data2 = 0;
+	session->o_receive_outstanding	= 1;
+	session->r_acked		= hdr->data2;
+	nbss_handle_event(NETBEUI_SESS_RESTART, session);
+}
+
+/*
+ * Function: nbss_switch_get_session_end
+ *	Accepts a SESSION END frame and generates a proper event.
+ * Parameters:
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ */
+static void nbss_switch_get_session_end(session_t *session)
+{
+	session->zapped = 1;
+	del_timer(&session->timer);
+	nbss_abort_receive(session);
+	nbss_handle_event(NETBEUI_SESS_ABORT_SEND, session);
+	nbss_handle_event(NETBEUI_SESS_END, session);
+}
+
+/*
+ * Function: nbss_switch_frame
+ *	This is the I-frame dispatcher.
+ * Parameters:
+ *	skb    : pointer to sk_buff which holds the frame
+ *	session: pointer to session_t structure the frame is received from
+ * Returns: None
+ * Notes:
+ *       - This function has to be called with a reference held
+ */
+static void nbss_switch_frame(session_t *session, struct sk_buff *skb)
+{
+	packet_t *hdr = (packet_t *)skb->data;
+
+	switch (hdr->command) {
+		case NETBEUI_DATA_FIRST_MIDDLE:
+		case NETBEUI_DATA_ONLY_LAST:
+			nbss_switch_get_session_data(skb, session);
+			goto out; /* SKB is reused */
+		case NETBEUI_DATA_ACK:
+			nbss_switch_get_data_ack(hdr, session);
+			break;
+		case NETBEUI_RECEIVE_CONTINUE:
+			nbss_switch_get_receive_continue(hdr, session);
+			break;
+		case NETBEUI_NO_RECEIVE:
+			nbss_switch_get_no_receive(hdr, session);
+			break;
+		case NETBEUI_RECEIVE_OUTSTANDING:
+			nbss_switch_get_receive_outstanding(hdr, session);
+			break;
+		case NETBEUI_SESSION_INITIALIZE:
+			nbss_switch_get_session_initialize(skb, session);
+			goto out; /* SKB is reused */
+		case NETBEUI_SESSION_CONFIRM:
+			nbss_switch_get_session_confirm(hdr, session);
+			break;
+		case NETBEUI_SESSION_END:
+			nbss_switch_get_session_end(session);
+			break;
+	}
+	kfree_skb(skb);
+out:;
+}
+
+/*
+ * Function: nbss_deliver_frame
+ *	Accepts an I-Frame frame and depending on session locking state either
+ *	queues the frame for later processing (when session unlocked) or calls
+ *	frame dispatcher for direct processing.
+ * Parameters:
+ *	session: pointer to session_t structure the frame is received from
+ *	skb    : pointer to sk_buff which holds the frame
+ * Returns: None
+ */
+void nbss_deliver_frame(session_t *session, struct sk_buff *skb)
+{
+	session_hold(session);
+	if (session->users)
+		__skb_queue_tail(&session->back_log, skb);
+	else
+		nbss_switch_frame(session, skb);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_drop_session
+ *	Drops a specified session on a specified link.
+ * Parameters:
+ *	link    : an integer that indicates the link number.
+ *	session_no : an integer that indicates the session number.
+ * Returns: int
+ *	zero    : if the session dropped successfully.
+ *	negative: if operation fails.
+ *	          -EINVAL: at least one of the arguments is invalid.
+ */
+int nbss_drop_session(int link, int session_no)
+{
+	session_t *sn;
+	link_t *nb_link = nbll_get_link(link);
+	dextab_t *sn_tbl;
+	int rc = -EINVAL;
+
+	if (!nb_link) /* Invalid link number */
+		goto out;
+	sn_tbl = &nb_link->session_table;
+	spin_lock_bh(&sn_tbl->lock);
+	rc = -EINVAL;
+	if (session_no > sn_tbl->size) { /* Invalid session number */
+		spin_unlock_bh(&sn_tbl->lock);
+		goto out;
+	}
+	sn = sn_tbl->addr[session_no];
+	spin_unlock_bh(&sn_tbl->lock);
+	if (!sn) /* no such session */
+		goto out;
+	session_hold(sn);
+	/* Announce the link manager */
+	nbll_detach_session(link, session_no);
+	/* Announce the session state machine */
+	nbss_abort_session(sn);
+	session_put(sn);
+out:	nbll_link_put(nb_link);
+	return rc;
+}
+
+/* Session service state machine functions */
+/*
+ * Function: nbss_lock_session
+ *	Locks a session while processing a critical region.
+ * Parameters:
+ *	session: pointer to session_t structure which is to be locked
+ * Returns: None
+ * Notes:
+ *	- Locking is a low cost mechanism for avoiding races when a critical
+ *	  region appears in code.
+ */
+static void nbss_lock_session(session_t *session)
+{
+	session->users++;
+	barrier();
+}
+
+/*
+ * Function: nbss_process_backlog
+ *	Processes frames entered on a session while the session was locked it
+ *	simply calls dispatcher for every queued frame.
+ * Parameters:
+ *	session: pointer to session_t structure who may have some frames in its
+ *		 backlog.
+ * Returns: None
+ */
+static void nbss_process_backlog(session_t *session)
+{
+	struct sk_buff *skb;
+	
+	session_hold(session);
+	while ((skb = __skb_dequeue(&session->back_log)) != NULL)
+		nbss_switch_frame(session, skb);
+	session_put(session);
+}
+
+/*
+ * Function: nbss_release_session
+ *	Unlocks a previously locked session.
+ * Parameters:
+ *	session : pointer to session_t structure which is to be unlocked
+ * Returns:
+ *	0	     : if session is successfully unlocked.
+ *	-ECONNABORTED: if session is aborted
+ * Notes:
+ *	- The return value is important to nbss_sleep_on() who decides whether
+ *	  to re-schedule system or continue execution of current process.
+ */
+static int nbss_release_session(session_t *session)
+{
+	int rc = 0;
+
+	barrier();
+	if (!session->users)
+		goto out;
+	if (!--session->users)
+		nbss_process_backlog(session);
+	if (session->zapped)
+		rc = session->status = -ECONNABORTED;
+out:	return rc;
+}
diff -ruN linux-2.4.18-clean/net/netbeui/sock_dgram.c linux/net/netbeui/sock_dgram.c
--- linux-2.4.18-clean/net/netbeui/sock_dgram.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/sock_dgram.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,458 @@
+/*
+ * sock_dgram.c - Contains functions that supply SOCK_DGRAM type sockets for
+ *                NetBEUI protocol stack which their names has a 'nbso_dgram_'
+ *                prefix.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/uio.h>
+#include <linux/skbuff.h>
+#include <linux/poll.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+#include <linux/netbeui.h>
+
+/* SOCK_DGRAM Calls */
+/*
+ * Function: nbso_dgram_release
+ *	Performs additional actions at release of SOCK_DGRAM sockets.
+ *
+ * Parameters:
+ *	sock : pointer to socket that must be released.
+ *
+ * Returns: int
+ *	0 : in all cases. (this function always succeed)
+ */
+static int nbso_dgram_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (sk) {
+                sock_orphan(sk);
+                sock_hold(sk);
+                lock_sock(sk);
+		if (NB_SK(sk)->u.dg.namep) {
+			nbdg_del_name(NB_SK(sk)->u.dg.namep);
+			if (NB_SK(sk)->name)
+				nbns_del_name(NB_SK(sk)->name);
+		}
+                release_sock(sk);
+                sock_put(sk);
+	}
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * Function: nbso_dgram_bind
+ *	Performs additional actions at bind of SOCK_DGRAM sockets to names.
+ *
+ * Parameters:
+ *	sock     : pointer to socket that must bind a name to it.
+ *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+ *	           information about sightly name.
+ *	addr_len : length of 'struct sockaddr_netbeui'.
+ *
+ * Returns: int
+ *	0        : if name is binded to socket successfully.
+ *	negative : if a fault occurs.
+ *	           -EINVAL : if socket binds already, or given name is not
+ *	                     valid.
+ */
+static int nbso_dgram_bind(struct socket *sock, struct sockaddr *uaddr,
+			   int addr_len)
+{
+	name_t *nb_name;
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+	int rc = -EPERM;
+
+	if (!capable(CAP_NET_BIND_SERVICE))
+		goto out;
+	rc = -EINVAL;
+	if (NB_SK(sk)->u.dg.namep || addr->snb_addr.name[0] == '*')
+		goto out;
+	rc = nbns_add_name(addr->snb_addr.name, addr->snb_addr.name_type,
+			   &nb_name);
+	if (rc)
+		goto out;
+	rc = nbdg_add_name(addr->snb_addr.name, sk->sleep,
+			   &NB_SK(sk)->u.dg.namep);
+	if (rc)
+		nbns_del_name(nb_name);
+	else
+		NB_SK(sk)->name = nb_name;
+	nbns_name_put(nb_name);
+out:	return rc;
+}
+
+/*
+ * Function: nbso_dgram_connect
+ *	Performs additional actions at attach of SOCK_DGRAM sockets to a
+ *	specified peer.
+ *
+ * Parameters:
+ *	sock     : pointer to socket that must attach to peer.
+ *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+ *	           information about peer.
+ *	addr_len : length of 'struct sockaddr_netbeui'.
+ *	sflags   : bitwise integer that contains socket flags.
+ *
+ * Returns: int
+ *	0        : if socket attaches to the specified peer successfully.
+ *	negative : if a fault occurs.
+ *	           -EINVAL : means socket not bounded normally.
+ *	           -EACCES : permission denied for broadcasting. user must
+ *	                     sets the SO_BROADCAST socket option to active,
+ *	                     before try to connect to all ('*').
+ */
+static int nbso_dgram_connect(struct socket *sock, struct sockaddr *uaddr,
+			      int addr_len, int sflags)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (!NB_SK(sk)->name)
+		goto out;
+
+	if (uaddr && addr_len == sizeof(*addr)) {
+		rc = -EACCES;
+		if (addr->snb_addr.name[0] == '*' && !sk->broadcast)
+			goto out;
+		sock->state = SS_CONNECTING;
+		memcpy(&NB_SK(sk)->u.dg.conn_name, addr, sizeof(*addr));
+		nbdg_register_peername(NB_SK(sk)->u.dg.namep,
+				       NB_SK(sk)->u.dg.conn_name.snb_addr.name);
+		sock->state = SS_CONNECTED;
+	} else { /* Invalid address means detach from previous address */
+		if (sock->state == SS_UNCONNECTED)
+			goto out_ok;
+		sock->state = SS_DISCONNECTING;
+		nbdg_deregister_peername(NB_SK(sk)->u.dg.namep);
+		sock->state = SS_UNCONNECTED;
+	}
+out_ok:	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_dgram_getname
+ *	Gets SOCK_DGRAM socket name or peer name that attached to it.
+ *
+ * Parameters:
+ *	sock      : pointer to socket that we need to name of it or its peer.
+ *	uaddr     : (VRP) pointer to 'struct sockaddr_netbeui' that be filled
+ *	            with requested information.
+ *	uaddr_len : (VRP) pointer to an integer that returns length of
+ *	            'struct sockaddr_netbeui'.
+ *	peer      : an integer that indicates type of request.
+ *
+ * Returns: int
+ *	0        : if requested name is retrieved successfully.
+ *	negative : if a fault occurs.
+ *	           -ENOTCONN : name of peer was requested but socket has not
+ *	                       any attachment.
+ *	           -EBADF    : socket not bounded to a name but name of it
+ *	                       was requested.
+ */
+static int nbso_dgram_getname(struct socket *sock, struct sockaddr *uaddr,
+			      int *uaddr_len, int peer)
+{
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+	int rc;
+
+	*uaddr_len = sizeof(*addr);
+	lock_sock(sk);
+	if (peer) {
+		rc = -ENOTCONN;
+		if (sock->state != SS_CONNECTED)
+			goto out;
+		memcpy(addr, &NB_SK(sk)->u.dg.conn_name, sizeof(*addr));
+	} else {
+		rc = -EBADF;
+		if (!NB_SK(sk)->u.dg.namep)
+			goto out;
+		memcpy(addr->snb_addr.name, NB_SK(sk)->u.dg.namep->name,
+		       NETBEUI_NAME_LEN);
+		addr->snb_addr.name_type = NB_SK(sk)->name->type;
+	}
+	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_dgram_poll
+ *	Determines operational (particularly I/O) condition of SOCK_STREAM
+ *	socket.
+ *
+ * Parameters:
+ *	sock     : pointer to socket that check it.
+ *	sel_type : an integer that determines type of checking.
+ *	wait     : pointer to a particular structure that contains some
+ *	           wait queues. The system itself checks members of these
+ *	           wait queues for their time outs. we only sleep on this
+ *	           structure if there is not exist a categoric answer, so far.
+ *
+ * Returns: int
+ *	0 : means that however must wait.
+ *	1 : means that answer is positive or an error occurred.
+ */
+static unsigned int nbso_dgram_poll(struct file *file, struct socket *sock,
+				    poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	unsigned int mask = POLLWRNORM;
+
+	poll_wait(file, sk->sleep, wait);
+
+	if (sk->err)
+		mask |= POLLERR;
+	if (!NB_SK(sk)->u.dg.namep)
+		mask |= POLLERR;
+	else
+		if (!nbdg_receive_ready(NB_SK(sk)->u.dg.namep))
+			mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/*
+ * Function: nbso_dgram_ioctl
+ *	Performs some particular operations on SOCK_DGRAM socket, that can not
+ *	do with regular system calls.
+ *
+ * Parameters:
+ *	sock : pointer to socket that action must perform on it.
+ *	cmd  : an integer that indicates type of operation.
+ *	arg  : this parameter often is a pointer to 'cmd' relative data
+ *	       structure that be used by it as an argument.
+ *
+ * Returns: int
+ *	0        : if cmd is performed successfully.
+ *	negative : if a fault occurs. error codes that bubble to user are
+ *	           dependent to cmd.
+ */
+static int nbso_dgram_ioctl(struct socket *sock, unsigned int cmd,
+			    unsigned long arg)
+{
+	struct sock *sk = sock->sk;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (cmd == SIOCRUWDGF) {
+		int len;
+
+		if (!NB_SK(sk)->u.dg.namep)
+			goto out;
+		rc = -EFAULT;
+		if (get_user(len, (int *)arg))
+			goto out;
+		rc = -EINVAL;
+		if (len < 0)
+			goto out;
+		rc = nbdg_remove_unwanted_dgf(NB_SK(sk)->u.dg.namep, len);
+	}
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_dgram_sendmsg
+ *	Sends a DATAGRAM message through a SOCK_DGRAM socket to desired
+ *	target(s).
+ *
+ * Parameters:
+ *	sock     : a pointer to socket that data sends through it.
+ *	msg      : a pointer to 'struct msghdr' that contains message body,
+ *	           target name and etc.
+ *	           Note: msg->msg_control AND msg->msg_controllen are per
+ *	                 protocol magic fields, and in our sendmsg() they
+ *	                 indicate alias name to use for message sender name
+ *	                 instead of the name that socket binds to it.
+ *	len      : length of message all around.
+ *	nonblock : an integer that if be set to non-zero value means that
+ *	           no waiting (sleeping, blocking & ...) acceptable during
+ *	           operation.
+ *	sflags   : bitwise integer that contains socket flags.
+ *
+ * Returns: int
+ *	positive : indicates how many bytes of data was sent.
+ *	negative : if a fault occurs.
+ *	           -EINVAL   : if a flag specified (we do not support any
+ *	                       flags), or socket not bounded normally, or
+ *	                       given target name is not valid.
+ *	           -EACCES   : permission denied for broadcasting. user must
+ *	                       sets the SO_BROADCAST socket option to active,
+ *	                       before try to broadcasts a message.
+ *	           -ENOTCONN : target name not given and socket is not
+ *	                       attached to any peer.
+ */
+static int nbso_dgram_sendmsg(struct socket *sock, struct msghdr *msg, int len,
+			      struct scm_cookie *scm)
+{
+	char *local_name, name_buff[NETBEUI_NAME_LEN];
+	struct sock *sk = sock->sk;
+	int rc, noblock = msg->msg_flags & MSG_DONTWAIT;
+	struct sockaddr_netbeui *remote_addr;
+
+	lock_sock(sk);
+	if (msg->msg_name) {
+		struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)
+								msg->msg_name;
+		rc = -EINVAL;
+		if (!NB_SK(sk)->name || msg->msg_namelen < sizeof(*addr) ||
+		    (addr->snb_family && addr->snb_family != AF_NETBEUI))
+			goto out;
+		rc = -EACCES;
+		if (addr->snb_addr.name[0] == '*' && !sk->broadcast)
+			goto out;
+		remote_addr = addr;
+	} else {
+		rc = -ENOTCONN;
+		if (sock->state != SS_CONNECTED)
+			goto out;
+		remote_addr = &NB_SK(sk)->u.dg.conn_name;
+	}
+	if (msg->msg_control && msg->msg_controllen == NETBEUI_NAME_LEN) {
+		rc = -EFAULT;
+		if (copy_from_user(name_buff, msg->msg_control,
+				   NETBEUI_NAME_LEN))
+			goto out;
+		local_name = name_buff;
+	} else
+		local_name = NB_SK(sk)->name->name;
+	/* All things are good, so start to send data ... */
+	rc = nbdg_send(sk, local_name, remote_addr->snb_addr.name,
+		       remote_addr->snb_addr.name_type, msg->msg_iov,
+		       len, noblock);
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_dgram_recvmsg
+ *	Receives a DATAGRAM message through a SOCK_DGRAM socket.
+ *
+ * Parameters:
+ *	sock     : a pointer to socket that data receives through it.
+ *	msg      : (VRP) a pointer to 'struct msghdr' that at return contains
+ *	           message body, source name and etc.
+ *	           Note: msg->msg_control AND msg->msg_controllen are per
+ *	                 protocol magic fields, and in our recvmsg() at return
+ *	                 they indicate target name of received message, that
+ *	                 for sockets which connect to all ('*') may be different
+ *	                 from the socket name.
+ *	size     : MAXimum length of message all around.
+ *	nonblock : an integer that if be set to non-zero value means that
+ *	           no waiting (sleeping, blocking & ...) acceptable during
+ *	           operation.
+ *	sflags   : bitwise integer that contains socket flags.
+ *	addr_len : (VRP) a pointer to an integer that if it is not NULL, at
+ *	           return will be filled with length of 'struct
+ *	           sockaddr_netbeui'.
+ *
+ * Returns: int
+ *	positive : indicates how many bytes of data was received.
+ *	negative : if a fault occurs.
+ *	           -EINVAL      : if a flag specified (we do not support any
+ *	                          flags), or socket not bounded to a name
+ *	                          normally.
+ */
+static int nbso_dgram_recvmsg(struct socket *sock, struct msghdr *msg,
+			      int size, int flags, struct scm_cookie *scm)
+{
+	int iov_no, bytes_received;
+	struct iovec *iov;
+	int   nonblock = msg->msg_flags & MSG_DONTWAIT;
+	char   *dest_name = NULL,
+	       *source_name = NULL;
+	struct sock *sk = sock->sk;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (!NB_SK(sk)->u.dg.namep)
+		goto out;
+	if (msg->msg_name) {
+		struct sockaddr_netbeui *addr = msg->msg_name;
+
+		addr->snb_family = AF_NETBEUI;
+		addr->snb_addr.reserved = 0;
+		source_name = addr->snb_addr.name;
+	}
+	if (msg->msg_control && msg->msg_controllen == NETBEUI_NAME_LEN) {
+		rc = verify_area(VERIFY_WRITE, msg->msg_control,
+				 NETBEUI_NAME_LEN);
+		if (rc)
+			goto out;
+		dest_name = msg->msg_control;
+	}
+	bytes_received = 0;
+	iov = msg->msg_iov;
+	iov_no = msg->msg_iovlen;
+
+	/* All things are good, so start to receive data ... */
+	while (iov_no--) {
+		rc = verify_area(VERIFY_WRITE, iov->iov_base, iov->iov_len);
+		if (rc) {
+			rc = bytes_received ? : rc;
+			break;
+		}
+		rc = nbdg_receive(NB_SK(sk)->u.dg.namep, source_name, dest_name,
+		                  iov->iov_base, iov->iov_len, nonblock);
+		if (rc < 0) {
+			rc = bytes_received ? : rc;
+			break;
+		}
+		bytes_received += rc;
+		++iov;
+		rc = bytes_received;
+	}
+out:	release_sock(sk);
+	return rc;
+}
+
+/* Dispatcher struct for SOCK_DGRAM calls */
+struct proto_ops SOCKOPS_WRAPPED(nbso_dgram_proto_ops) = {
+	family:		PF_NETBEUI,
+	release:	nbso_dgram_release,
+	bind:		nbso_dgram_bind,
+	connect:	nbso_dgram_connect,
+	socketpair:	sock_no_socketpair,
+	accept:		sock_no_accept,
+	getname:	nbso_dgram_getname,
+	poll:		nbso_dgram_poll,
+	ioctl:		nbso_dgram_ioctl,
+	listen:		sock_no_listen,
+	shutdown:	sock_no_shutdown,
+	setsockopt:	sock_no_setsockopt,
+	getsockopt:	sock_no_getsockopt,
+	sendmsg:	nbso_dgram_sendmsg,
+	recvmsg:	nbso_dgram_recvmsg,
+};
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(nbso_dgram_proto, PF_NETBEUI);
diff -ruN linux-2.4.18-clean/net/netbeui/sock_name.c linux/net/netbeui/sock_name.c
--- linux-2.4.18-clean/net/netbeui/sock_name.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/sock_name.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,156 @@
+/*
+ * sock_name.c - Contains functions that implement first layer of socket
+ * 		 interface for socket type SOCK_NAME. SOCK_NAME is a new
+ * 		 socket type introduced in NetBEUI used as a interface for
+ * 		 manipulating NetBIOS names under kernel control.
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/uio.h>
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/netbeui.h>
+
+/*
+ * Socket interface layer
+ * SOCK_NAME interface routines
+ */
+/*
+ * Function: nbso_name_release
+ *	Releases a SOCK_NAME by requesting Name Service to remove all names
+ *	the socket owns.
+ *
+ * Parameters:
+ *	sock : pointer to socket that must be released.
+ *
+ * Returns:
+ *	0 	: always returns zero
+ *
+ * Notes:
+ *	- The names a SOCK_NAME type socket owns are detected by their
+ *	  identifier which is socket memory address.
+ */
+static int nbso_name_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	unsigned long id = (unsigned long)NB_SK(sk);
+
+	nbns_del_identifier(id);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/*
+ * Function: nbso_name_bind
+ *	Manipulates (binds/unbinds) names to SOCK_NAME type socket.
+ *
+ * Parameters:
+ *	sock     : pointer to socket structure
+ *	uaddr    : pointer to 'struct sockaddr_netbeui' that contains
+ *	           information about sightly name.
+ *	addr_len : length of 'struct sockaddr_netbeui'.
+ *
+ * Returns:
+ *	0	 : if name is bound to socket successfully.
+ *	other	 : errors reported by name service module.
+ *	
+ * Notes:
+ *	- NetBEUI extends SOCK_NAME bind system call by defining
+ *	 	bind+   for registering a name from socket
+ *		bind-	for deregistering or releasing a name from socket
+ *	  * bind- is recognized by setting name_type in sockaddr_netbeui to 255
+ *	  * bind+ is recognized by setting name_type in sockaddr_netbeui to
+ *	  	  other values
+ *
+ *	- The names a SOCK_NAME type socket owns are detected by their
+ *	  identifier which is socket memory address.
+ */
+static int nbso_name_bind(struct socket *sock, struct sockaddr *uaddr,
+			  int addr_len)
+{
+	struct sock *sk = sock->sk;
+	unsigned long id = (unsigned long)NB_SK(sk);
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+	name_t *nb_name;
+	int rc = -EPERM;
+
+	if (!capable(CAP_NET_BIND_SERVICE))
+		goto out;
+	nb_name = nbns_find_name(addr->snb_addr.name);
+	rc = 0;
+	if (addr->snb_addr.name_type == 0xFF) {   /* Remove name from socket */
+		if (nb_name) {
+		       if (nb_name->identifier == id)
+				nbns_del_name(nb_name);
+		       nbns_name_put(nb_name);
+		}
+		goto out;
+	}
+	/* Add name to socket */
+	if (nb_name) {
+		nbns_name_put(nb_name);
+		goto out;
+	}
+	rc = nbns_add_name(addr->snb_addr.name, addr->snb_addr.name_type,
+			   &nb_name);
+	if (!rc) {
+		nb_name->identifier = id;
+		nbns_name_put(nb_name);
+	}
+out:	return rc;
+}
+
+/*
+ * Function: nbso_name_ioctl
+ *
+ * Parameters:
+ *
+ * Returns:
+ *	
+ * Notes:
+ *	- is not supported in SOCK_NAME, pass it to the config functions
+ */
+static int nbso_name_ioctl(struct socket *sock, unsigned int cmd,
+			   unsigned long arg)
+{
+	return nbcs_ioctl(cmd, (void *)arg);
+}
+
+/* proto_ops definition for SOCK_NAME socket type */
+struct proto_ops SOCKOPS_WRAPPED(nbso_name_proto_ops) = {
+	family:		PF_NETBEUI,
+	release:	nbso_name_release,
+	bind:		nbso_name_bind,
+	connect:	sock_no_connect,
+	socketpair:	sock_no_socketpair,
+	accept:		sock_no_accept,
+	getname:	sock_no_getname,
+	ioctl:		nbso_name_ioctl,
+	listen:		sock_no_listen,
+	shutdown:	sock_no_shutdown,
+	setsockopt:	sock_no_setsockopt,
+	getsockopt:	sock_no_getsockopt,
+	sendmsg:	sock_no_sendmsg,
+	recvmsg:	sock_no_recvmsg,
+};
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(nbso_name_proto, PF_NETBEUI);
diff -ruN linux-2.4.18-clean/net/netbeui/sock_session.c linux/net/netbeui/sock_session.c
--- linux-2.4.18-clean/net/netbeui/sock_session.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/sock_session.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,864 @@
+/*
+ * sock_session.c - Contains functions that supply SOCK_STREAM type sockets for
+ *                  NetBEUI protocol stack which their names has a
+ *                  'nbso_session_' prefix, and also some utility functions that
+ *                  their names only has a 'nbso_' prefix.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ *		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/uio.h>
+#include <linux/poll.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+#include <linux/skbuff.h>
+#include <linux/netbeui.h>
+
+/* SOCK_STREAM internal functions */
+/*
+ * Function: nbso_end_backlog
+ *	Closes sessions that their connection was established but not
+ *	accepted yet.
+ * Parameters:
+ *	sk: pointer to NetBEUI socket that must close its waited connections.
+ * Returns: none
+ */
+static void nbso_end_backlog(struct sock *sk)
+{
+	while (NB_SK(sk)->u.st.backlog) {
+		session_t *sn = NB_SK(sk)->u.st.backlog;
+
+		NB_SK(sk)->u.st.backlog = NB_SK(sk)->u.st.backlog->next;
+		nbss_hangup(sn);
+	}
+}
+
+/*
+ * Function: nbso_autobind
+ *	Automatically binds a NetBEUI socket to NAME_NUMBER_1 .
+ * Parameters:
+ *	sk: pointer to NetBEUI socket that must bind it to NAME_NUMBER_1 .
+ * Returns: int
+ *	0 : if NetBEUI socket binds to NAME_NUMBER_1 successfully.
+ *	-1: if can not bind NetBEUI socket to NAME_NUMBER_1 .
+ */
+static int nbso_autobind(struct sock *sk)
+{
+	NB_SK(sk)->name = nbns_name_number_1();
+	return NB_SK(sk)->name ? 0 : -1;
+}
+
+/*
+ * Function: nbso_session_ready (Call back function)
+ *	Gets an established session from transport layer, and puts it
+ *	in its owner's queue for sessions which are waited for accept.
+ * Parameters:
+ *	sk     : a pointer to NetBEUI socket that is owner of established
+ *	         session.
+ *	session: a pointer to established session.
+ * Returns: none
+ */
+static void nbso_session_ready(struct sock *sk, session_t *sn)
+{
+	sock_hold(sk);
+	bh_lock_sock(sk);
+	if (NB_SK(sk)->u.st.backlog)
+		NB_SK(sk)->u.st.backlog->prev = sn;
+	sn->next = NB_SK(sk)->u.st.backlog;
+	sn->prev = NULL;
+	NB_SK(sk)->u.st.backlog = sn;
+	wake_up_interruptible(sk->sleep);
+	bh_unlock_sock(sk);
+	sock_put(sk);
+}
+/*
+ * Function: nbso_abort_interface_session (Call back function)
+ *	Transport layer announces that a session is not valid from now.
+ *	we must perform different actions depend on NetBEUI socket state:
+ *	i)   if socket state is NBSO_INIT, we are in a special case that causes
+ *	     when a 'nbss_call()' was interrupted. we must only announce
+ *	     process which wants to establish connection that its request was
+ *	     aborted.
+ *	ii)  if socket state is NBSO_RUNNING, we must announce all processes
+ *	     that wait for something on the socket.
+ *	iii) if socket state is NBSO_LISTENNING, we only must remove the
+ *	     session from backlog list.
+ * Parameters:
+ *	owner  : a pointer to NetBEUI socket that is owner of aborted session.
+ *	session: a pointer to aborted session.
+ * Returns: none
+ */
+static void nbso_abort_interface_session(struct sock *sk, session_t *sn)
+{
+	sock_hold(sk);
+	bh_lock_sock(sk);
+	if (sk->state == NBSO_INIT) {
+		sk->socket->state = SS_UNCONNECTED;
+		goto out;
+	}
+	if (sk->state == NBSO_RUNNING) {
+		sk->state = NBSO_INIT;
+		sk->socket->state = SS_UNCONNECTED;
+		wake_up_interruptible(sk->sleep);
+		goto out;
+	}
+	/* NOW, Certainly state is NBSO_LISTENING */
+	if (sn->next)
+		sn->next->prev = sn->prev;
+	if (sn->prev)
+		sn->prev->next = sn->next;
+	else
+		NB_SK(sk)->u.st.backlog = sn->next;
+	/* To countervail deletion of this session from backlog list */
+	nbss_listen_bh(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+		       nbso_abort_interface_session, nbso_session_ready);
+out:	bh_unlock_sock(sk);
+	sock_put(sk);
+}
+
+/* SOCK_STREAM Calls */
+/*
+ * Function: nbso_session_release
+ *	Performs additional actions at release of SOCK_STREAM sockets.
+ * Parameters:
+ *	sock : pointer to socket that must be released.
+ * Returns: int
+ *	0 : in all cases. (this function always succeed)
+ */
+static int nbso_session_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		goto out;
+	sock_orphan(sk);
+	sock_hold(sk);
+	lock_sock(sk);
+	sk->shutdown = SHUTDOWN_MASK;
+	if (sk->state == NBSO_LISTENING) {
+		__nbss_end_listen(NB_SK(sk)->name);
+		nbso_end_backlog(sk);
+	}
+	if (NB_SK(sk)->u.st.session)
+		nbss_hangup(NB_SK(sk)->u.st.session);
+	if (NB_SK(sk)->name)
+		nbns_del_name(NB_SK(sk)->name);
+	release_sock(sk);
+	sock_put(sk);
+	MOD_DEC_USE_COUNT;
+out:	return 0;
+}
+
+/*
+ * Function: nbso_session_bind
+ *	Performs additional actions at bind of SOCK_STREAM sockets to names.
+ * Parameters:
+ *	sock    : pointer to socket that must bind a name to it.
+ *	uaddr   : pointer to 'struct sockaddr_netbeui' that contains
+ *	          information about sightly name.
+ *	addr_len: length of 'struct sockaddr_netbeui'.
+ * Returns: int
+ *	0       : if name is binded to socket successfully.
+ *	negative: if a fault occurs.
+ *	          -EINVAL: if socket is bound already.
+ */
+static int nbso_session_bind(struct socket *sock, struct sockaddr *uaddr,
+			     int addr_len)
+{
+	name_t *nb_name;
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+	int rc = -EINVAL;
+
+	if (!NB_SK(sk)->name) {
+		rc = nbns_add_name(addr->snb_addr.name,
+				   addr->snb_addr.name_type, &nb_name);
+		if (!rc) {
+			NB_SK(sk)->name = nb_name;
+			nbns_name_put(nb_name);
+		}
+	}
+	return rc;
+}
+
+/*
+ * Function: nbso_session_connect
+ *	Performs additional actions at connect of SOCK_STREAM sockets to a
+ *	specified peer.
+ * Parameters:
+ *	sock    : pointer to socket that must connect to peer.
+ *	uaddr   : pointer to 'struct sockaddr_netbeui' that contains
+ *	           information about peer.
+ *	addr_len: length of 'struct sockaddr_netbeui'.
+ *	flags   : bitwise integer that contains socket flags.
+ * Returns: int
+ *	0       : if socket connects to the specified peer successfully.
+ *	negative: if a fault occurs.
+ *	           -EISCONN   : socket connected already or listens for
+ *	                        incoming connection requests.
+ *	           -EAGAIN    : no name available for the socket now, try
+ *	                        again.
+ *	           -ECONNRESET: connection reset by peer.
+ */
+static int nbso_session_connect(struct socket *sock, struct sockaddr *uaddr,
+				int addr_len, int flags)
+{
+	int rc;
+	session_t *sn;
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+
+	lock_sock(sk);
+	rc = -EISCONN;
+	if (sk->state != NBSO_INIT)
+		goto out;
+	if (!NB_SK(sk)->name) {
+		rc = -EAGAIN;   /* return -EADDRNOTAVAIL; ?! */
+		if (nbso_autobind(sk))
+			goto out;
+	}
+	sock->state = SS_CONNECTING;
+	rc = nbss_call(NB_SK(sk)->name, addr->snb_addr.name, sk,
+		       nbso_abort_interface_session, &sn);
+	if (rc)
+		goto out;
+	rc = -ECONNRESET;
+	if (sock->state != SS_CONNECTING)
+		goto out;
+	sock->state = SS_CONNECTED;
+	sk->state = NBSO_RUNNING;
+	sk->sleep = &sn->waitq;
+	NB_SK(sk)->u.st.session = sn;
+	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+static struct sock *nbso_session_accept_newsk(struct sock *sk,
+					      struct socket *newsock)
+{
+	struct sock *nsk = sk_alloc(PF_NETBEUI, sk->allocation, 1);
+
+	if (!nsk)
+		goto out;
+	memset(NB_SK(nsk), 0, sizeof(*NB_SK(nsk)));
+	sock_init_data(newsock, nsk);
+	NB_SK(nsk)->u.st.session = NB_SK(sk)->u.st.backlog;
+	NB_SK(nsk)->u.st.session->owner = nsk;
+	newsock->state = SS_CONNECTED;
+	NB_SK(nsk)->name = NB_SK(sk)->name;
+	nbns_name_hold(NB_SK(sk)->name);
+	nsk->state = NBSO_RUNNING;
+	nsk->sleep = &NB_SK(nsk)->u.st.session->waitq;
+	NB_SK(sk)->u.st.backlog = NB_SK(sk)->u.st.backlog->next;
+
+	if (NB_SK(sk)->u.st.backlog)
+		NB_SK(sk)->u.st.backlog->prev = NULL;
+	nbss_listen(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+		    nbso_abort_interface_session, nbso_session_ready);
+out:	return nsk;
+}
+
+/*
+ * Wait for an incoming connection, avoid race conditions. This must be called
+ * with the socket locked.
+ */
+static int nbso_session_wait_for_connect(struct sock *sk)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int rc, timeout = netbios_config.inactivity_timeout * HZ;
+
+	add_wait_queue_exclusive(sk->sleep, &wait);
+	for (;;) {
+		__set_current_state(TASK_INTERRUPTIBLE);
+		if (!NB_SK(sk)->u.st.backlog) {
+			release_sock(sk);
+			timeout = schedule_timeout(timeout);
+			lock_sock(sk);
+		}
+		rc = 0;
+		if (NB_SK(sk)->u.st.backlog)
+			break;
+		rc = -EINVAL;
+		if (sk->state != NBSO_LISTENING)
+			break;
+		rc = -ERESTARTSYS;
+		if (signal_pending(current))
+			break;
+		rc = -EAGAIN;
+		if (!timeout)
+			break;
+	}
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(sk->sleep, &wait);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_accept
+ *	Performs additional actions at accept of incoming connection requests
+ *	for a SOCK_STREAM socket.
+ * Parameters:
+ *	sock   : pointer to socket that wants to accept the incoming
+ *	          connection requests.
+ *	newsock: (Semi VRP!) pointer to a new socket with attributes like
+ *	          original that connection between it & peer will be
+ *	          established. This 'struct socket' created by system before
+ *	          call us, and we only must complete its fields.
+ *	flags  : bitwise integer that contains socket flags.
+ *
+ * Returns: int
+ *	0       : if connection is successfully established between newsock
+ *	           and peer.
+ *	negative: if a fault occurs.
+ *	          -EINVAL     : this operation permitted only after a
+ *	                        successful call of listen().
+ *	          -EAGAIN     : user requests non-blocking operation, but
+ *	                        operation would block.
+ *	          -ERESTARTSYS: interrupted system call.
+ */
+static int nbso_session_accept(struct socket *sock, struct socket *newsock,
+			       int flags)
+{
+	struct sock *sk = sock->sk, *nsk;
+	int rc = -EINVAL;
+
+	lock_sock(sk);
+	if (sk->state != NBSO_LISTENING)
+		goto out;
+	newsock->state = SS_CONNECTING;
+
+	if (!NB_SK(sk)->u.st.backlog) {
+		rc = -EAGAIN;
+		if (flags & O_NONBLOCK)
+			goto err;
+		rc = nbso_session_wait_for_connect(sk);
+		if (rc)
+			goto err;
+	}
+	nsk = nbso_session_accept_newsk(sk, newsock);
+	rc = -ENOBUFS;
+        if (!nsk)
+		goto out;
+	rc = nbss_listen(NB_SK(sk)->name, sk->max_ack_backlog, sk,
+			 nbso_abort_interface_session, nbso_session_ready);
+	if (rc < 0)
+		goto err;
+	MOD_INC_USE_COUNT;
+out:	release_sock(sk);
+	return rc;
+err:	newsock->state = SS_UNCONNECTED;
+	goto out;
+}
+
+/*
+ * Function: nbso_session_getname
+ *	Gets SOCK_STREAM socket name or peer name that connected to it.
+ * Parameters:
+ *	sock      : pointer to socket that we need to name of it or its peer.
+ *	uaddr     : (VRP) pointer to 'struct sockaddr_netbeui' that be filled
+ *	            with requested information.
+ *	uaddr_len : (VRP) pointer to an integer that returns length of
+ *	            'struct sockaddr_netbeui'.
+ *	peer      : an integer that indicates type of request.
+ * Returns: int
+ *	0        : if requested name is retrieved successfully.
+ *	negative : if a fault occurs.
+ *	           -ENOTCONN: name of peer was requested but socket has not
+ *	                      any connection.
+ *	           -EBADF   : socket not bounded to a name but name of it
+ *	                      was requested.
+ */
+static int nbso_session_getname(struct socket *sock, struct sockaddr *uaddr,
+				int *uaddr_len, int peer)
+{
+	int rc;
+	struct sock *sk = sock->sk;
+	struct sockaddr_netbeui *addr = (struct sockaddr_netbeui *)uaddr;
+
+	lock_sock(sk);
+	if (peer) {
+		rc = -ENOTCONN;
+		if (sk->state != NBSO_RUNNING)
+			goto out;
+		memcpy(addr->snb_addr.name,
+		       NB_SK(sk)->u.st.session->remote_name, NETBEUI_NAME_LEN);
+		addr->snb_addr.name_type =
+				     NB_SK(sk)->u.st.session->remote_name_type;
+	} else {
+		rc = -EBADF;
+		if (!NB_SK(sk)->name)
+			goto out;
+		memcpy(addr->snb_addr.name, NB_SK(sk)->name->name,
+		       NETBEUI_NAME_LEN);
+		addr->snb_addr.name_type = NB_SK(sk)->name->type;
+	}
+	rc = 0;
+	*uaddr_len = sizeof(*addr);
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_poll
+ *	Determines operational (particularly I/O) condition of SOCK_STREAM
+ *	socket.
+ * Parameters:
+ *	sock    : pointer to socket that check it.
+ *	sel_type: an integer that determines type of checking.
+ *	wait    : pointer to a particular structure that contains some wait
+ *		  queues. The system itself checks members of these wait queues
+ *		  for their time outs. we only sleep on this structure if there
+ *		  is not exist a categoric answer, so far.
+ * Returns: int
+ *	0: means that however must wait.
+ *	1: means that answer is positive or an error occurred.
+ */
+static unsigned int nbso_session_poll(struct file *file, struct socket *sock,
+				      poll_table *wait)
+{
+	struct sock *sk = sock->sk;
+	unsigned int mask = 0;
+
+	poll_wait(file, sk->sleep, wait);
+	if (sk->err)
+		mask |= POLLERR;
+	if (sk->shutdown == SHUTDOWN_MASK || sk->state != NBSO_RUNNING)
+		mask |= POLLHUP;
+	if (sk->shutdown & RCV_SHUTDOWN)
+		mask |= POLLIN | POLLRDNORM;
+	/* Connected? */
+	if (sk->state == NBSO_RUNNING) {
+		if (nbss_receive_ready(NB_SK(sk)->u.st.session))
+			mask |= POLLIN | POLLRDNORM;
+		if (!(sk->shutdown & SEND_SHUTDOWN) &&
+	    	    nbss_send_ready(NB_SK(sk)->u.st.session))
+			mask |= POLLOUT | POLLWRNORM;
+	}
+	return mask;
+}
+
+/*
+ * Function: nbso_session_ioctl
+ *	Performs some particular operations on SOCK_STREAM socket, that can not
+ *	do with regular system calls.
+ * Parameters:
+ *	sock: pointer to socket that action must perform on it.
+ *	cmd : an integer that indicates type of operation.
+ *	arg : this parameter often is a pointer to 'cmd' relative data
+ *	      structure that be used by it as an argument.
+ * Returns: int
+ *	0       : if cmd is performed successfully.
+ *	negative: if a fault occurs. error codes that bubble to user are
+ *	          dependent to cmd.
+ */
+static int nbso_session_ioctl(struct socket *sock, unsigned int cmd,
+			      unsigned long arg)
+{
+	int rc = -EOPNOTSUPP;
+	struct sock *sk = sock->sk;
+	session_t *session;
+
+	lock_sock(sk);
+	session = NB_SK(sk)->u.st.session;
+	if (cmd == SIOCTRIMDATA) {
+		if (sk->state == NBSO_RUNNING)
+			rc = nbss_trim_data(session);
+	} else if (cmd == SIOCSENDZERO) {
+		if (sk->state == NBSO_RUNNING)
+			rc = nbss_send_zero(session, (char *)arg);
+	} else
+		rc = -EINVAL;
+	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_listen
+ *	Listens for incoming connection requests, and places them in a queue
+ *	that MAXimum of its length is 'backlog'. this operation defined only
+ *	for SOCK_STREAM functions.
+ * Parameters:
+ *	sock   : pointer to socket that must listens for incoming requests.
+ *	backlog: an integer that indicates length of queue which holds
+ *	         incoming requests that not accepted yet.
+ * Returns: int
+ *	0       : if operation is performed successfully.
+ *	negative: if a fault occurs.
+ *	          -EPERM : this operation not permitted on a connected socket.
+ */
+static int nbso_session_listen(struct socket *sock, int backlog)
+{
+	struct sock *sk = sock->sk;
+	int rc = -EPERM;
+
+	lock_sock(sk);
+	if (sk->state == NBSO_RUNNING)
+		goto out;
+	if (!(unsigned)backlog)	/* BSDism */
+		backlog = 1;
+	if ((unsigned)backlog > SOMAXCONN)
+		backlog = SOMAXCONN;
+	if (backlog > sk->max_ack_backlog)
+		nbss_listen(NB_SK(sk)->name, backlog, sk,
+		            nbso_abort_interface_session, nbso_session_ready);
+	sk->max_ack_backlog = backlog;
+	sk->state = NBSO_LISTENING;
+	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_shutdown
+ *	Shuts down part of a full-duplex connection.
+ * Parameters:
+ *	sock: pointer to socket that part of its connection must be closed.
+ *	how : an integer that indicates part of full_duplex connection that
+ *	      must be closed.
+ * Returns: int
+ *	0       : if operation is performed successfully.
+ *	negative: if a fault occurs.
+ *	          -ENOTCONN: the specified socket is not connected.
+ *	          -EINVAL  : the 'how' parameter has not a valid value.
+ */
+static int nbso_session_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+	int rc = -ENOTCONN;
+
+	lock_sock(sk);
+	if (!sk)
+		goto out;
+	/* To avoid short circuiting by compiler */
+	rc = -ENOTCONN;
+	if (sk->state != NBSO_RUNNING)
+		goto out;
+	how++; /*
+		* maps 0->1 has the advantage of making bit 1 rcvs and
+		*      1->2 bit 2 snds.
+		*      2->3
+		*/
+	rc = -EINVAL;
+	if ((how & ~SHUTDOWN_MASK) || !how) /* Is "1 <= how <= 3" ?! */
+		goto out;
+	sk->shutdown |= how;
+	rc = 0;
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_setsockopt
+ *	Sets some operational options of SOCK_STREAM sockets.
+ * Parameters:
+ *	sock   : a pointer to socket that must tune its options.
+ *	level  : this parameter is not used in this function and always is
+ *		 zero.
+ *	optname: an integer that indicates option that must tune.
+ *	optval : a pointer to related data structure which used for assign
+ *	         value(s) to option.
+ *	optlen : length of data structure that 'optval' points to it.
+ *
+ * Returns: int
+ *	0       : if tuning is performed successfully.
+ *	negative: if a fault occurs.
+ *	          -EOPNOTSUPP : Operation not supported by us.
+ *	          -ENOPROTOOPT: Option name is not defined for us.
+ */
+static int nbso_session_setsockopt(struct socket *sock, int level, int optname,
+				   char *optval, int optlen)
+{
+	int rc = 0;
+	struct sock *sk = sock->sk;
+
+	lock_sock(sk);
+  	switch (optname) {
+		case SO_SNDBUF:
+		case SO_RCVBUF:
+		case SO_SNDLOWAT:
+		case SO_RCVLOWAT:
+			rc = -EOPNOTSUPP;
+			break;
+		case SO_SNDTIMEO:
+			if (copy_from_user((void *)&NB_SK(sk)->u.st.sto, optval,
+					   MIN(sizeof(NB_SK(sk)->u.st.sto),
+					       optlen)))
+				rc = -EFAULT;
+			break;
+		case SO_RCVTIMEO:
+			if (copy_from_user((void *)&NB_SK(sk)->u.st.rto, optval,
+					   MIN(sizeof(NB_SK(sk)->u.st.rto),
+						      optlen)))
+				rc = -EFAULT;
+			break;
+		default:
+			rc = -ENOPROTOOPT;
+			break;
+	}
+	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_getsockopt
+ *	Gets some operational options of SOCK_STREAM sockets.
+ * Parameters:
+ *	sock   : a pointer to socket that action performs on it.
+ *	level  : this parameter is not used in this function and always is
+ *		 zero.
+ *	optname: an integer that indicates option that must be gotten.
+ *	optval : (VRP) a pointer to related data structure which used for
+ *	         getting value(s) of option.
+ *	optlen : (VRP) length of data structure that 'optval' points to it.
+ *
+ * Returns: int
+ *	0       : if operation is performed successfully.
+ *	negative: if a fault occurs.
+ *	          -EOPNOTSUPP : Operation not supported by us.
+ *	          -ENOPROTOOPT: Option name is not defined for us.
+ */
+static int nbso_session_getsockopt(struct socket *sock, int level, int optname,
+				   char *optval, int *optlen)
+{
+	int len, rc = 0;
+	struct sock *sk = sock->sk;
+
+	lock_sock(sk);
+  	switch (optname) {
+		case SO_SNDBUF:
+		case SO_RCVBUF:
+		case SO_SNDLOWAT:
+		case SO_RCVLOWAT:
+			rc = -EOPNOTSUPP;
+			break;
+		case SO_SNDTIMEO:
+			if (get_user(len, (int *)optlen)) {
+				rc = -EFAULT;
+				break;
+			}
+			len = MIN(len, sizeof(NB_SK(sk)->u.st.sto));
+			if (copy_to_user(optval,
+					 (void *)&NB_SK(sk)->u.st.sto, len) ||
+			    put_user(len, (int *)optlen))
+				rc = -EFAULT;
+			break;
+		case SO_RCVTIMEO:
+			if (get_user(len, (int *)optlen)) {
+				rc = -EFAULT;
+				break;
+			}
+			len = MIN(len, sizeof(NB_SK(sk)->u.st.rto));
+			if (copy_to_user(optval,
+					 (void *)&NB_SK(sk)->u.st.rto, len) ||
+			    put_user(len, (int *)optlen))
+				rc = -EFAULT;
+			break;
+		default:
+			rc = -ENOPROTOOPT;
+			break;
+  	}
+	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_sendmsg
+ *	Sends a message through a SOCK_STREAM socket to desired target.
+ * Parameters:
+ *	sock    : a pointer to socket that data sends through it.
+ *	msg     : a pointer to 'struct msghdr' that contains message body,
+ *	          target name and etc.
+ *	len     : length of message all around.
+ *	nonblock: an integer that if be set to non-zero value means that
+ *	          no waiting (sleeping, blocking & ...) acceptable during
+ *	          operation.
+ *	flags   : bitwise integer that contains socket flags.
+ * Returns: int
+ *	positive: indicates how many bytes of data was sent.
+ *	negative: if a fault occurs.
+ *	          -EINVAL     : we do not support any flags.
+ *	          -EPIPE      : 'send part' of full-duplex connection was
+ *	                        closed already.
+ *	          -ENOTCONN   : socket is not connected yet.
+ *	          -EMSGSIZE   : length of one of iovec buffers is greater
+ *	                        than NETBEUI_MAX_DATALEN.
+ *	          -EWOULDBLOCK: user requests non-blocking operation, but
+ *	                        operation would block.
+ */
+static int nbso_session_sendmsg(struct socket *sock, struct msghdr *msg,
+				int len, struct scm_cookie *scm)
+{
+	int rc, iov_no, bytes_sent;
+	int nonblock = msg->msg_flags & MSG_DONTWAIT;
+	struct iovec *iov;
+	struct timer_list snd_tmr;
+	struct sock *sk = sock->sk;
+
+	lock_sock(sk);
+	rc = -EPIPE;
+	if (sk->shutdown & SEND_SHUTDOWN) {
+		send_sig(SIGPIPE, current, 1);
+		goto out;
+	}
+	rc = -ENOTCONN;
+	if (sock->state != SS_CONNECTED || sk->state != NBSO_RUNNING)
+		goto out;
+	init_timer(&snd_tmr);
+	if (NB_SK(sk)->u.st.sto.tv_sec || NB_SK(sk)->u.st.sto.tv_usec) {
+		snd_tmr.expires = jiffies + NB_SK(sk)->u.st.sto.tv_sec * HZ +
+				  NB_SK(sk)->u.st.sto.tv_usec / (1000000 / HZ);
+		snd_tmr.data	 = (unsigned long)NB_SK(sk)->u.st.session;
+		snd_tmr.function = (void *)nbss_abort_send;
+		add_timer(&snd_tmr);
+	}
+	rc = bytes_sent = 0;
+	iov = msg->msg_iov;
+	iov_no = msg->msg_iovlen;
+	/* All things are good, so start to send data ... */
+	while (iov_no--) {
+		/* Currently, limit on size of data
+		   which can be sent is 64K-bytes */
+		if (iov->iov_len > NETBEUI_MAX_DATALEN) {
+			rc = bytes_sent ? : -EMSGSIZE;
+			break;
+		}
+		rc = nbss_send(NB_SK(sk)->u.st.session, iov->iov_base,
+			       iov->iov_len, nonblock, 0);
+		if (rc < 0) {
+			rc = bytes_sent ? : rc;
+			break;
+		}
+		bytes_sent += rc;
+
+		if (rc < iov->iov_len) {
+			rc = bytes_sent ? : -EWOULDBLOCK;
+			break;
+		}
+		++iov;
+		rc = bytes_sent;
+	}
+	del_timer(&snd_tmr);
+out:	release_sock(sk);
+	return rc;
+}
+
+/*
+ * Function: nbso_session_recvmsg
+ *	Receives a message through a SOCK_STREAM socket from desired source.
+ * Parameters:
+ *	sock    : a pointer to socket that data receives through it.
+ *	msg     : (VRP) a pointer to 'struct msghdr' that at return contains
+ *	          message body, source name and etc.
+ *	size    : MAXimum length of message all around.
+ *	nonblock: an integer that if be set to non-zero value means that no
+ *		  waiting (sleeping, blocking & ...) acceptable during
+ *	          operation.
+ *	flags    : bitwise integer that contains socket flags.
+ *	addr_len : (VRP) a pointer to an integer that if it is not NULL, at
+ *	           return will be filled with length of struct sockaddr_netbeui.
+ *
+ * Returns: int
+ *	positive: indicates how many bytes of data was received.
+ *	negative: if a fault occurs.
+ *	          -EINVAL     : we do not support any flags.
+ *	          -EPIPE      : 'receive part' of full-duplex connection was
+ *				closed already.
+ *	          -ENOTCONN   : socket is not connected yet.
+ *	          -EWOULDBLOCK: user requests non-blocking operation, but
+ *				operation would block.
+ */
+static int nbso_session_recvmsg(struct socket *sock, struct msghdr *msg,
+				int size, int flags, struct scm_cookie *scm)
+{
+	int rc, iov_no, bytes_received;
+	int nonblock = msg->msg_flags & MSG_DONTWAIT;
+	struct iovec *iov;
+	struct timer_list rcv_tmr;
+	struct sock *sk = sock->sk;
+
+	lock_sock(sk);
+	rc = -EPIPE;
+	if (sk->shutdown & RCV_SHUTDOWN) {
+		send_sig(SIGPIPE, current, 1);
+		goto out;
+	}
+	if (sock->state != SS_CONNECTED || sk->state != NBSO_RUNNING) {
+		rc = -ENOTCONN;
+	 	if (!(NB_SK(sk)->u.st.session &&
+		      nbss_receive_ready(NB_SK(sk)->u.st.session)))
+			goto out;
+	}
+	init_timer(&rcv_tmr);
+	if (NB_SK(sk)->u.st.rto.tv_sec || NB_SK(sk)->u.st.rto.tv_usec) {
+		rcv_tmr.expires  = jiffies + NB_SK(sk)->u.st.rto.tv_sec * HZ +
+		                   NB_SK(sk)->u.st.rto.tv_usec / (1000000 / HZ);
+		rcv_tmr.data     = (unsigned long)NB_SK(sk)->u.st.session;
+		rcv_tmr.function = (void *)nbss_abort_receive;
+		add_timer(&rcv_tmr);
+	}
+	rc = bytes_received = 0;
+	iov = msg->msg_iov;
+	iov_no = msg->msg_iovlen;
+
+	while (iov_no--) {
+		rc = nbss_receive(NB_SK(sk)->u.st.session, iov->iov_base,
+				  iov->iov_len, nonblock);
+		if (rc < 0) {
+			rc = bytes_received ? : rc;
+			break;
+		}
+		bytes_received += rc;
+
+		if (rc < iov->iov_len) {
+			rc = bytes_received ? : -EWOULDBLOCK;
+			break;
+		}
+		++iov;
+		rc = bytes_received;
+	}
+	del_timer(&rcv_tmr);
+out:	release_sock(sk);
+	return rc;
+}
+
+/* Dispatcher struct for SOCK_STREAM calls */
+struct proto_ops SOCKOPS_WRAPPED(nbso_session_proto_ops) = {
+	family:		PF_NETBEUI,
+	release:	nbso_session_release,
+	bind:		nbso_session_bind,
+	connect:	nbso_session_connect,
+	socketpair:	sock_no_socketpair,
+	accept:		nbso_session_accept,
+	getname:	nbso_session_getname,
+	poll:		nbso_session_poll,
+	ioctl:		nbso_session_ioctl,
+	listen:		nbso_session_listen,
+	shutdown:	nbso_session_shutdown,
+	setsockopt:	nbso_session_setsockopt,
+	getsockopt:	nbso_session_getsockopt,
+	sendmsg:	nbso_session_sendmsg,
+	recvmsg:	nbso_session_recvmsg,
+};
+#include <linux/smp_lock.h>
+SOCKOPS_WRAP(nbso_session_proto, PF_NETBEUI);
diff -ruN linux-2.4.18-clean/net/netbeui/status_serve.c linux/net/netbeui/status_serve.c
--- linux-2.4.18-clean/net/netbeui/status_serve.c	Wed Dec 31 19:00:00 1969
+++ linux/net/netbeui/status_serve.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,767 @@
+/*
+ * status_serve.c - Contains functions that supply STATUS service for NetBEUI
+ *                  protocol stack, and also some utility functions.
+ * Notes:
+ *	- VRP in comments is the acronym of "Value Result Parameter"
+ *	- EHF in comments is the acronym of "Event Handling Function".
+ *
+ * Copyright (c) 1997 by Procom Technology, Inc.
+ * 		 2001 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+#include <asm/types.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+#include <linux/netbeui.h>
+#include <asm/uaccess.h>
+
+static void nbst_timer_function(unsigned long input);
+
+/* These functions are STATUS State Transition handlers */
+static int nbst_status_query_in_initial(status_t *nb_status);
+static int nbst_retry_timeout_in_all(status_t *nb_status);
+static int nbst_response_timeout_in_all(status_t *nb_status);
+static int nbst_status_response_in_respwait(status_t *nb_status);
+static int nbst_incomp_response_in_respwait(status_t *nb_status);
+
+#define NBST_LENGTH_MASK	0x3FFF
+#define NBST_OVERFLOW_MASK	0x4000
+#define NBST_FRAGMENT_MASK	0x8000
+
+/* DataGram BroadCast Maximum Transfer Unit */
+extern unsigned int dgbc_mtu;
+
+static unsigned long jiffies_at_reset;
+
+static unsigned short int nbst_correlator;
+#define nbst_next_correlator() (++nbst_correlator)
+
+static status_t *status_request_list;
+static rwlock_t status_request_list_lock = RW_LOCK_UNLOCKED;
+
+typedef int (* status_event_handler_t)(status_t *);
+
+struct event_struct {
+	status_state_t next_state;
+	status_event_handler_t event_handler;
+};
+
+static struct event_struct status_state_table[2][5] = {
+		/* NBS_STAT_INITIAL */
+{
+{ NBS_STAT_RESPWAIT,
+	nbst_status_query_in_initial }, /* NBE_STAT_STATUS_QUERY     */
+{ -1, NULL },				/* NBE_STAT_RETRY_TIMEOUT    */
+{ -1, NULL },				/* NBE_STAT_RESPONSE_TIMEOUT */
+{ -1, NULL },				/* NBE_STAT_STATUS_RESPONSE  */
+{ -1, NULL }				/* NBE_STAT_INCOMP_RESPONSE  */
+},
+     		/* NBS_STAT_RESPWAIT */
+{
+{ -1, NULL },					/* NBE_STAT_STATUS_QUERY     */
+{ NBS_STAT_RESPWAIT,
+	nbst_retry_timeout_in_all },		/* NBE_STAT_RETRY_TIMEOUT    */
+{ NBS_STAT_INITIAL,
+	nbst_response_timeout_in_all },		/* NBE_STAT_RESPONSE_TIMEOUT */
+{ NBS_STAT_INITIAL,
+	nbst_status_response_in_respwait },	/* NBE_STAT_STATUS_RESPONSE  */
+{ NBS_STAT_RESPWAIT,
+	nbst_incomp_response_in_respwait }	/* NBE_STAT_INCOMP_RESPONSE  */
+}
+};
+
+static nb_status_buffer_t nb_status_record;
+/* Internal NBST functions */
+/*
+ * Function: nbst_alloc_status
+ *	Allocates a 'nb_status' structure and initializes its fields.
+ * Parameters: none
+ * Returns: status_t *
+ *       non NULL : address of allocated nb_status.
+ *       NULL     : if can not allocate nb_status, or initialize its fields
+ *	           properly.
+ */
+static status_t *nbst_alloc_status(void)
+{
+	int status_dgram_len;
+	status_t *nb_status = kmalloc(sizeof(*nb_status), GFP_KERNEL);
+
+	if (!nb_status)
+		goto out;
+	/* Implicitly initialize all fields */
+	memset(nb_status, 0, sizeof(*nb_status));
+	/* Allocate status skb */
+	status_dgram_len = nb_cmd_hdr_len[NETBEUI_STATUS_QUERY];
+	nb_status->tx_skb = alloc_skb(CALC_DG_SKBLEN(NETBEUI_MAC_B_HEADLEN,
+				      status_dgram_len), GFP_KERNEL);
+	if (!nb_status->tx_skb)
+		goto err;
+	skb_reserve(nb_status->tx_skb, LLCMAC_UIB_HEADLEN());
+	nb_status->tx_skb->nh.raw = nb_status->tx_skb->h.raw =
+		nb_status->tx_skb->data;
+	skb_put(nb_status->tx_skb, status_dgram_len);
+	nb_status->tx_skb->dev = NULL;
+	init_timer(&nb_status->timer);
+	nb_status->timer.data = (unsigned long)nb_status;
+	nb_status->timer.function = nbst_timer_function;
+	init_waitqueue_head(&nb_status->waitq);
+out:	return nb_status;
+err:	kfree(nb_status);
+	nb_status = NULL;
+	goto out;
+}
+
+/*
+ * Function: nbst_free_status
+ *	Frees a nb_status structure and its sk_buff.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that must be freed.
+ * Returns: none
+ */
+static void nbst_free_status(status_t *nb_status)
+{
+	kfree_skb(nb_status->tx_skb);
+	kfree(nb_status);
+}
+
+/*
+ * Function: nbst_add_status_to_list
+ *	Adds a nb_status structure to the 'status_request_list'.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that must be added to the
+ *	            list.
+ * Returns: none
+ */
+static inline void nbst_add_status_to_list(status_t *nb_status)
+{
+	write_lock(&status_request_list_lock);
+	nb_status->next = status_request_list;
+	status_request_list = nb_status;
+	write_unlock(&status_request_list_lock);
+}
+
+/*
+ * Function: nbst_remove_status_from_list
+ *	Removes a nb_status structure from the 'status_request_list'.
+ * Parameters:
+ *       nb_status : pointer to nb_status structure that must be removed from
+ *	            the list.
+ * Returns: none
+ */
+static void nbst_remove_status_from_list(status_t *nb_status)
+{
+	status_t *entry, *prev_entry = NULL;
+
+	write_lock(&status_request_list_lock);
+	for (entry = status_request_list; entry; entry = entry->next) {
+		if (entry == nb_status) {
+			if (prev_entry)
+				prev_entry->next = entry->next;
+			else
+				status_request_list = entry->next;
+			break;
+		}
+		prev_entry = entry;
+	}
+	write_unlock(&status_request_list_lock);
+}
+
+/*
+ * Function: nbst_find_correlator
+ *	Finds a nb_status in the 'status_request_list' that have a specific
+ *	response correlator.
+ * Parameters:
+ *	correlator : the response correlator that we search for it.
+ * Returns: status_t *
+ *       non NULL : address of sightly nb_status in the list.
+ *       NULL     : if no match be found.
+ */
+static status_t *nbst_find_correlator(__u16 correlator)
+{
+	status_t *nb_status;
+
+	read_lock(&status_request_list_lock);
+	nb_status = status_request_list;
+	for (; nb_status; nb_status = nb_status->next)
+		if (nb_status->resp_correlator == correlator)
+			break;
+	read_unlock(&status_request_list_lock);
+	return nb_status;
+}
+
+/*
+ * Function: nbst_handle_event
+ *	Handles an entrant event to STATUS state machine.
+ * Parameters:
+ *	event     : the entrant event.
+ *	nb_status : (Semi VRP!) pointer to nb_status structure (entity) that
+ *	            event is for it.
+ * Returns: none
+ */
+static void nbst_handle_event(status_event_t event, status_t *nb_status)
+{
+	struct event_struct *ev = &status_state_table[nb_status->state][event];
+
+	if (ev && ev->event_handler)
+		if (!ev->event_handler(nb_status))
+			nb_status->state = ev->next_state;
+}
+
+/*
+ * Function: nbst_timer_function (Call back function)
+ *	Produces an appropriate event related to number of retries
+ *	so far, due to fire of a timer.
+ * Parameters:
+ *	input : pointer to nb_status structure that timer of it has been fired.
+ * Returns: none
+ */
+static void nbst_timer_function(unsigned long input)
+{
+	status_t *nb_status = (status_t *)input;
+
+	if (nb_status->retries < NETBEUI_TRANSMIT_COUNT)
+		nbst_handle_event(NBE_STAT_RETRY_TIMEOUT, nb_status);
+	else
+		nbst_handle_event(NBE_STAT_RESPONSE_TIMEOUT, nb_status);
+}
+
+/*
+ * Function: nbst_status_query_in_initial
+ *	(EHF) Handles NBE_STAT_STATUS_QUERY event in NBS_STAT_INITIAL state.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that event happens on it.
+ * Returns: int
+ *	zero     : if event be handled successfully.
+ *	non zero : if an error occurred during event handling.
+ */
+static int nbst_status_query_in_initial(status_t *nb_status)
+{
+	int rc;
+	dgram_t *hdrp;
+
+	/* all fields were set to zero in nbst_alloc_status() */
+	nb_status->resp_status = NO_RESPONSE;
+	hdrp = (dgram_t *)nb_status->tx_skb->data;
+	hdrp->length = nb_cmd_hdr_len[NETBEUI_STATUS_QUERY];
+	hdrp->delimiter = NETBEUI_DELIMITER;
+	hdrp->command = NETBEUI_STATUS_QUERY;
+	/* We implement NetBIOS 3.0 */
+	hdrp->data1 = 1;
+	hdrp->data2 = nb_status->sbuff_len;
+	hdrp->resp_correlator = nb_status->resp_correlator =
+		nbst_next_correlator();
+	rc = -EFAULT;
+	if (copy_from_user(hdrp->dest_name, nb_status->called_name,
+			   NETBEUI_NAME_LEN))
+		goto out;
+	memcpy(hdrp->source_name, nbns_name_number_1()->name, NETBEUI_NAME_LEN);
+
+	/* BroadCast NETBEUI_STATUS_QUERY */
+	rc = nbll_uisend(NULL, nb_status->tx_skb);
+	if (!rc) {
+		nb_status->retries++;
+		nb_status->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+		add_timer(&nb_status->timer);
+		nbst_add_status_to_list(nb_status);
+	}
+out:	return rc;
+}
+
+/*
+ * Function: nbst_retry_timeout_in_all
+ *	(EHF) Handles NBE_STAT_RETRY_TIMEOUT event in all of states.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that event happens on it.
+ * Returns: int
+ *	zero     : if event be handled successfully.
+ *	non zero : if an error occurred during event handling.
+ */
+static int nbst_retry_timeout_in_all(status_t *nb_status)
+{
+	int rc = 0;
+
+	nb_status->timer.expires = jiffies+ NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_status->timer);
+	if (nb_status->unicast) {
+		/* UniCast NETBEUI_STATUS_QUERY */
+		rc = nbll_uisend(nb_status->remote_mac, nb_status->tx_skb);
+		if (rc)
+			goto out;
+		skb_pull(nb_status->tx_skb,
+			LLCMAC_UI_HEADLEN(MAC_HEADLEN(nb_status->tx_skb->dev)));
+	} else {
+		/* BroadCast NETBEUI_STATUS_QUERY */
+		rc = nbll_uisend(NULL, nb_status->tx_skb);
+		if (rc)
+			goto out;
+	}
+	nb_status->retries++;
+out:	return rc;
+}
+
+/*
+ * Function: nbst_response_timeout_in_all
+ *	(EHF) Handles NBE_STAT_RESPONSE_TIMEOUT event in all of states.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that event happens on it.
+ * Returns: int
+ *	zero     : this function always succeed.
+ */
+static int nbst_response_timeout_in_all(status_t *nb_status)
+{
+	nbst_remove_status_from_list(nb_status);
+	wake_up(&nb_status->waitq);
+	return 0;
+}
+
+/*
+ * Function: nbst_status_response_in_respwait
+ *	(EHF) Handles NBE_STAT_STATUS_RESPONSE event in NBS_STAT_RESPWAIT state.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that event happens on it.
+ * Returns: int
+ *	zero     : this function always succeed.
+ */
+static int nbst_status_response_in_respwait(status_t *nb_status)
+{
+	del_timer(&nb_status->timer);
+	nbst_remove_status_from_list(nb_status);
+	if (nb_status->overflowed)
+		nb_status->resp_status = USER_BUFFER_OVERFLOW;
+	else
+		nb_status->resp_status = COMPLETED_RESPONSE;
+	return 0;
+}
+
+/*
+ * Function: nbst_incomp_response_in_respwait
+ *	(EHF) Handles NBE_STAT_INCOMP_RESPONSE event in NBS_STAT_RESPWAIT state.
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that event happens on it.
+ * Returns: int
+ *	zero     : if event be handled successfully.
+ *	non zero : if an error occurred during event handling.
+ */
+static int nbst_incomp_response_in_respwait(status_t *nb_status)
+{
+	int rc;
+
+	del_timer(&nb_status->timer);
+	nb_status->unicast = 1;
+	nb_status->retries = 0;
+	nb_status->resp_status = INCOMPLETE_RESPONSE;
+	((dgram_t *)(nb_status->tx_skb->data))->data1 = nb_status->no_rx_names;
+	((dgram_t *)(nb_status->tx_skb->data))->data2 = nb_status->sbuff_len -
+	                                                nb_status->len_rx_info;
+	nb_status->timer.expires = jiffies + NETBEUI_TRANSMIT_TIMEOUT;
+	add_timer(&nb_status->timer);
+	rc = nbll_uisend(nb_status->remote_mac, nb_status->tx_skb);
+	if (!rc) {
+		skb_pull(nb_status->tx_skb,
+			LLCMAC_UI_HEADLEN(MAC_HEADLEN(nb_status->tx_skb->dev)));
+		nb_status->retries++;
+	}
+	return rc;
+}
+
+/*
+ * Function: nbst_gather_status_info
+ *	Gathers NetBIOS status information in local machine.
+ * Parameters:
+ *	dev : pointer to struct net_device that its related status information
+ *	      has been requested.
+ * Returns: int
+ *	positive : length of gathered status information. this function always
+ *	           succeed.
+ */
+static int nbst_gather_status_info(struct net_device *dev)
+{
+	int i;
+	__u8 tmp8;
+	__u16 non;
+	name_t *ntp;
+	unsigned long tmpl;
+
+	if (!dev)
+		dev = netbeui_adapters.dev[0];
+	if (dev) {
+		dev_hold(dev);
+		memcpy(nb_status_record.adptr_addr, dev->dev_addr, 6);
+		if (dev->type == ARPHRD_IEEE802)
+			nb_status_record.adptr_type_AND_sftwr_level.adptr_type =
+			       	NETBEUI_TOKEN_RING;
+		else if (dev->type == ARPHRD_ETHER ||
+			 dev->type == ARPHRD_EETHER)
+			nb_status_record.adptr_type_AND_sftwr_level.adptr_type =
+				NETBEUI_ETHERNET;
+	} else {
+		memset(nb_status_record.adptr_addr, 0, 6);
+		nb_status_record.adptr_type_AND_sftwr_level.adptr_type = 0;
+	}
+	/* We support new parameters , NetBIOS 3.0 */
+	nb_status_record.adptr_type_AND_sftwr_level.sftwr_level = 0x20;
+	nb_status_record.sftwr_release_no = 3; /* We implement NetBIOS 3.0 */
+	tmpl = (jiffies - jiffies_at_reset) / (HZ * 60);
+	nb_status_record.duration = tmpl > 0xFFFF ? 0xFFFF : tmpl;
+	nb_status_record.max_dgram_packet_size = dgbc_mtu;
+	nb_status_record.max_no_pend_sess = 0xFFFF; /* No limit! */
+	nb_status_record.max_size_sess_data_packet = dev ?
+			  (dev->mtu - LLCMAC_I_HEADLEN(dev) - NETBEUI_ILEN) : 0;
+	if (dev)
+		dev_put(dev);
+	non = nbns_count_names();
+	nb_status_record.no_names_in_local_name_tbl = non;
+	ntp = nbns_get_name_list();
+	for (i = 0; i < non; i++, ntp = ntp->next) {
+		memcpy(nb_status_record.local_names[i].name, ntp->name,
+		       NETBEUI_NAME_LEN);
+		nb_status_record.local_names[i].name_number = ntp->name_number;
+
+		tmp8 = ntp->type == NETBEUI_NAME_GROUP ? 0x80 : 0x00;
+		switch (ntp->state) {
+			case NETBEUI_NAME_ACQUIRED: /* A registered name */
+				tmp8 |= 0x04;
+				break;
+			case NETBEUI_NAME_INITIAL:  /* A deregistered name */
+				tmp8 |= 0x05;
+			default: ;	/* Only for silence of the gcc! */
+		}
+		if (ntp->conflicted)           /* A detected duplicate name */
+			tmp8 |= 0x06;
+		nb_status_record.local_names[i].name_status = tmp8;
+	}
+	return NETBEUI_MIN_STATUS_BUFF_LEN + (NETBEUI_NAME_LEN + 2) * non;
+}
+
+/*
+ * Function: nbst_local_status
+ *	Retrieves local NetBIOS status information.
+ *
+ * Parameters:
+ *	status_buff : pointer to user buffer that must be filled with local
+ *	              status information.
+ *	buff_len    : (VRP) pointer to an integer that indicates length of
+ *	              user buffer at start and length of retrieved information
+ *	              at end.
+ *
+ * Returns: int
+ *	zero     : if information retrieved successfully.
+ *	negative : if something is bad.
+ *	           -EOVERFLOW : user buffer length is not large enough to
+ *	                        keep all of information, so some of it was
+ *	                        copied to user buffer.
+ */
+static int nbst_local_status(char *status_buff, int *buff_len)
+{
+	int len, info_len;
+
+	if (get_user(len, buff_len))
+		return -EFAULT;
+	info_len = nbst_gather_status_info(NULL);
+	len = MIN(len, info_len);
+	if (copy_to_user(status_buff, &nb_status_record, len) ||
+	    put_user(len, buff_len))
+		return -EFAULT;
+	return len < info_len ? -EOVERFLOW : 0;
+}
+
+/*
+ * Function: nbst_wait_for_resp
+ *	Waits for end of STATUS state machine operation, and supervise
+ *	received status response frames.
+ *
+ * Parameters:
+ *	nb_status : pointer to nb_status structure that operations perform
+ *	            on it.
+ *
+ * Returns: none
+ */
+static void nbst_wait_for_resp(status_t *nb_status)
+{
+	sleep_on(&nb_status->waitq);
+	nb_status->locked = 1;
+
+	while (nb_status->rx_skb) {
+		int sdl, tmp;
+		char *sdp;
+		dgram_t *hdrp = (dgram_t *)nb_status->rx_skb->data;
+
+		nb_status->overflowed = hdrp->data2 & NBST_OVERFLOW_MASK;
+		/* Pointer to the status data in the received frame */
+		sdp = skb_pull(nb_status->rx_skb, NETBEUI_UILEN);
+		sdl = hdrp->data2 & NBST_LENGTH_MASK;
+		tmp = nb_status->len_rx_info ?
+			sdl : (sdl - NETBEUI_MIN_STATUS_BUFF_LEN);
+		nb_status->no_rx_names += tmp / (NETBEUI_NAME_LEN + 2);
+		nb_status->len_rx_info += sdl;
+
+		if (nb_status->len_rx_info < nb_status->sbuff_len) {
+			/* FIXME(acme): check copy_to_user result! */
+			copy_to_user(nb_status->user_sbuff, (char *)sdp, sdl);
+
+			if ((hdrp->data2 & NBST_FRAGMENT_MASK) && hdrp->data1)
+				nbst_handle_event(NBE_STAT_INCOMP_RESPONSE,
+						  nb_status);
+			else
+				nbst_handle_event(NBE_STAT_STATUS_RESPONSE,
+						  nb_status);
+		}
+		else {
+			sdl -= nb_status->len_rx_info - nb_status->sbuff_len;
+			copy_to_user(nb_status->user_sbuff, sdp, sdl);
+
+			nbst_handle_event(NBE_STAT_STATUS_RESPONSE, nb_status);
+		}
+		nb_status->user_sbuff += sdl;
+		kfree_skb(nb_status->rx_skb);
+		nb_status->rx_skb = NULL;
+
+		if (nb_status->state == NBS_STAT_RESPWAIT) {
+			barrier();
+			nb_status->locked = 0;
+			sleep_on(&nb_status->waitq);
+		}
+	}
+}
+
+/*
+ * Function: nbst_remote_status
+ *	Retrieves NetBIOS status information of a remote host.
+ *
+ * Parameters:
+ *	remote_name : pointer to a NetBIOS name that must retrieve status
+ *	              information about it.
+ *	status_buff : (VRP) pointer to user buffer that must be filled with
+ *	              status information of remote host.
+ *	buff_len    : (VRP) pointer to an integer that indicates length of
+ *	              user buffer at start and length of retrieved information
+ *	              at end.
+ *
+ * Returns: int
+ *	zero     : if information retrieved successfully.
+ *	negative : if something is bad.
+ *	           -ENONET       : no network device found.
+ *	           -ENOMEM       : out of memory condition.
+ *	           -EHOSTUNREACH : no response from remote host.
+ *	           -ETIMEDOUT    : system timed out before retrieving all of
+ *	                           information, so some of it was copied to
+ *	                           user buffer.
+ *	           -EOVERFLOW    : user buffer length is not large enough to
+ *	                           keep all of information, so some of it was
+ *	                           copied to user buffer.
+ */
+static int nbst_remote_status(char *remote_name, char *status_buff,
+			      int *buff_len)
+{
+	status_t *nb_status;
+	int rc = -ENONET;
+
+	if (!netbeui_adapters.dev[0])
+		goto out;
+	nb_status = nbst_alloc_status();
+	rc = -ENOMEM;
+	if (!nb_status)
+		goto out;
+	nb_status->called_name = remote_name;
+	nb_status->user_sbuff = status_buff;
+	rc = -EFAULT;
+	if (get_user(nb_status->sbuff_len, buff_len))
+		goto out_status;
+	nb_status->state = NBS_STAT_INITIAL;
+	nbst_handle_event(NBE_STAT_STATUS_QUERY, nb_status);
+	if (nb_status->state != NBS_STAT_INITIAL)
+		nbst_wait_for_resp(nb_status);
+	rc = -EFAULT;
+	if (put_user(MIN(nb_status->sbuff_len, nb_status->len_rx_info),
+			buff_len))
+		goto out_status;
+	switch (nb_status->resp_status) {
+		case NO_RESPONSE:
+			rc = -EHOSTUNREACH;
+			break;
+		case INCOMPLETE_RESPONSE:
+			rc = -ETIMEDOUT;
+			break;
+		case USER_BUFFER_OVERFLOW:
+			rc = -EOVERFLOW;
+		default: /* COMPLETED_RESPONSE */
+			rc = 0;
+	}
+out_status:
+	nbst_free_status(nb_status);
+out:	return rc;
+}
+
+/* Exported  N B S T  Functions */
+/*
+ * Function: nbst_init_status
+ *	Performs some initializes for STATUS service functions during
+ *	installation of NetBEUI in memory.
+ *
+ * Parameters: none
+ *
+ * Returns: none
+ */
+void nbst_init_status(void)
+{
+	memset(&nb_status_record, 0, sizeof(nb_status_record));
+	jiffies_at_reset = jiffies;
+}
+
+/*
+ * Function: nbst_obtain_status
+ *	Interface function for NetBEUI STATUS service.
+ *
+ * Parameters:
+ *	remote_name : pointer to a NetBIOS name that must retrieve status
+ *	              information about it.
+ *	status_buff : (VRP) pointer to user buffer that must be filled with
+ *	              status information.
+ *	buff_len    : (VRP) pointer to an integer that indicates length of
+ *	              user buffer at start and length of retrieved information
+ *	              at end.
+ *
+ * Returns: int
+ *	zero     : if information retrieved successfully.
+ *	negative : if something is bad.
+ */
+int nbst_obtain_status(char *called_name, char *status_buff, int *buff_len)
+{
+	int name;
+
+	if (get_user(name, called_name))
+		return -EFAULT;
+	return name == '*' ?  nbst_local_status(status_buff, buff_len) :
+			      nbst_remote_status(called_name, status_buff,
+					         buff_len);
+}
+
+/*
+ * Function: nbst_get_status_query
+ *	Takes a NETBEUI_STATUS_QUERY frame from 'llc supplementary' and response
+ *	to it.
+ *
+ * Parameters:
+ *	skb        : pointer to sk_buff that contains received frame.
+ *	remote_mac : pointer to buffer that contains MAC address of sender
+ *	             of the frame.
+ *
+ * Returns: none
+ */
+void nbst_get_status_query(struct sk_buff *skb, unsigned char *remote_mac)
+{
+	int tmp, losd, nonts, info_len;
+	__u16 loits;
+	struct sk_buff *resp_skb;
+	dgram_t *resp_hdrp, *hdrp = (dgram_t *)skb->data;
+	/* Test for illegal requests */
+	name_t *nb_name = nbns_find_name(hdrp->dest_name);
+
+	if (!nb_name)
+		goto free_skb;
+	/* Status query for a group name has no meaning */
+	if (nb_name->type == NETBEUI_NAME_GROUP)
+		goto out_put;
+	info_len = nbst_gather_status_info(skb->dev);
+	if (hdrp->data1 > 1 &&
+	    hdrp->data1 >= nb_status_record.no_names_in_local_name_tbl)
+		goto out_put;
+	/* Make a sk_buff for response */
+	resp_skb = alloc_skb(skb->dev->mtu, GFP_ATOMIC);
+	if (!resp_skb)
+		goto out_put;
+	tmp = LLCMAC_UI_HEADLEN(MAC_HEADLEN(skb->dev));
+	skb_reserve(resp_skb, tmp);
+	resp_skb->nh.raw = resp_skb->h.raw = resp_skb->data;
+	resp_hdrp = (dgram_t *)skb_put(resp_skb,
+				       nb_cmd_hdr_len[NETBEUI_STATUS_RESPONSE]);
+	resp_hdrp->length = nb_cmd_hdr_len[NETBEUI_STATUS_RESPONSE];
+	resp_hdrp->delimiter = NETBEUI_DELIMITER;
+	resp_hdrp->command = NETBEUI_STATUS_RESPONSE;
+	resp_hdrp->xmit_correlator = hdrp->resp_correlator;
+	/* Find length of data that can be sent */
+	tmp = skb->dev->mtu - tmp;
+	losd = tmp - nb_cmd_hdr_len[NETBEUI_STATUS_RESPONSE];
+	losd = MIN(losd, hdrp->data2);
+
+	if (hdrp->data1 <= 1) { /* An initial request */
+		nonts = (losd - NETBEUI_MIN_STATUS_BUFF_LEN) /
+			(NETBEUI_NAME_LEN + 2);
+		nonts = MIN(nonts, nb_status_record.no_names_in_local_name_tbl);
+		loits = NETBEUI_MIN_STATUS_BUFF_LEN + nonts *
+				(NETBEUI_NAME_LEN + 2);
+		memcpy(skb_put(resp_skb, loits), &nb_status_record, loits);
+		resp_hdrp->data1 = nonts ? nonts : 1;
+	} else {
+		nonts = losd / (NETBEUI_NAME_LEN + 2);
+		tmp = nb_status_record.no_names_in_local_name_tbl - hdrp->data1;
+		nonts = MIN(nonts, tmp);
+		info_len = tmp * (NETBEUI_NAME_LEN + 2);
+		loits = nonts * (NETBEUI_NAME_LEN + 2);
+		memcpy(skb_put(resp_skb, loits),
+		       &nb_status_record.local_names[hdrp->data1], loits);
+		resp_hdrp->data1 = nonts + hdrp->data1;
+	}
+	loits &= NBST_LENGTH_MASK;
+	if (info_len > losd)
+		loits |= NBST_FRAGMENT_MASK;
+	if (info_len > hdrp->data2)
+		loits |= NBST_OVERFLOW_MASK;
+	resp_hdrp->data2 = loits;
+	memcpy(resp_hdrp->dest_name, hdrp->source_name, NETBEUI_NAME_LEN);
+	memcpy(resp_hdrp->source_name, hdrp->dest_name, NETBEUI_NAME_LEN);
+	resp_skb->dev = skb->dev;
+	kfree_skb(skb);
+	nbll_uisend(remote_mac, resp_skb);
+	nbns_name_put(nb_name);
+out:	return;
+out_put:
+	nbns_name_put(nb_name);
+free_skb:
+	kfree_skb(skb);
+	goto out;
+}
+
+/*
+ * Function: nbst_get_status_response
+ *	Takes a NETBEUI_STATUS_RESPONSE frame from 'llc supplementary' and
+ *	place it on appropriate nb_status structure.
+ *
+ * Parameters:
+ *	skb        : pointer to sk_buff that contains received frame.
+ *	remote_mac : pointer to buffer that contains MAC address of sender
+ *	             of the frame.
+ *
+ * Returns: none
+ */
+void nbst_get_status_response(struct sk_buff *skb, unsigned char *remote_mac)
+{
+	dgram_t *dgram = (dgram_t *)skb->data;
+	status_t *nb_status = nbst_find_correlator(dgram->xmit_correlator);
+
+	/* If it does not match a waited status query */
+	if (!nb_status)
+		goto free_skb;
+	barrier();
+	if (nb_status->locked) 
+		goto free_skb;
+	nb_status->rx_skb = skb;
+	nb_status->tx_skb->dev = skb->dev;
+	memcpy(nb_status->remote_mac, remote_mac, MAC_ADDR_LEN);
+	wake_up(&nb_status->waitq);
+out:	return;
+free_skb:
+	kfree_skb(skb);
+	goto out;
+}
diff -ruN linux-2.4.18-clean/net/netsyms.c linux/net/netsyms.c
--- linux-2.4.18-clean/net/netsyms.c	Mon Feb 25 14:38:14 2002
+++ linux/net/netsyms.c	Fri Jun  7 04:57:42 2002
@@ -54,6 +54,12 @@
 #include <linux/mroute.h>
 #include <linux/igmp.h>
 
+#include <net/cpic.h>
+
+/* linux-SNA attach */
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+
 extern struct net_proto_family inet_family_ops;
 
 #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE) || defined (CONFIG_KHTTPD) || defined (CONFIG_KHTTPD_MODULE)
@@ -160,6 +166,15 @@
 EXPORT_SYMBOL(sock_kmalloc);
 EXPORT_SYMBOL(sock_kfree_s);
 
+EXPORT_SYMBOL(cpic_register_side_info);
+EXPORT_SYMBOL(cpic_unregister_side_info);
+EXPORT_SYMBOL(cpic_query_side_info);
+EXPORT_SYMBOL(cpic_get_info_side);
+EXPORT_SYMBOL(cpic_register);
+EXPORT_SYMBOL(cpic_unregister);
+EXPORT_SYMBOL(attach_register);
+EXPORT_SYMBOL(attach_unregister);
+
 #ifdef CONFIG_FILTER
 EXPORT_SYMBOL(sk_run_filter);
 EXPORT_SYMBOL(sk_chk_filter);
@@ -458,6 +473,7 @@
 #endif  /* CONFIG_INET */
 
 #ifdef CONFIG_TR
+EXPORT_SYMBOL(tr_source_route);
 EXPORT_SYMBOL(tr_type_trans);
 #endif
 
@@ -476,6 +492,7 @@
 EXPORT_SYMBOL(__dev_get_by_index);
 EXPORT_SYMBOL(dev_get_by_name);
 EXPORT_SYMBOL(__dev_get_by_name);
+EXPORT_SYMBOL(dev_getbyhwaddr);
 EXPORT_SYMBOL(netdev_finish_unregister);
 EXPORT_SYMBOL(netdev_set_master);
 EXPORT_SYMBOL(eth_type_trans);
diff -ruN linux-2.4.18-clean/net/sna/Config.in linux/net/sna/Config.in
--- linux-2.4.18-clean/net/sna/Config.in	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/Config.in	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,12 @@
+#
+# Linux-SNA Configuration
+#
+
+bool '  SNA: IEEE 802.2 device support' CONFIG_SNA_LLC
+bool '  SNA: Loopback device support' CONFIG_SNA_LOOPBACK
+bool '  SNA: ATM device support (EXPERIMENTAL)' CONFIG_SNA_ATM
+bool '  SNA: IBM compliant channel device support (EXPERIMENTAL)' CONFIG_SNA_CHANNEL
+bool '  SNA: SDLC device support (EXPERIMENTAL)' CONFIG_SNA_SDLC
+bool '  SNA: X.25 device support (EXPERIMENTAL)' CONFIG_SNA_X25
+bool '  SNA: TwinAxial device support (EXPERIMENTAL)' CONFIG_SNA_TWINAX
+bool '  SNA: Coaxial device supprt (EXPERIMENTAL)' CONFIG_SNA_COAX
diff -ruN linux-2.4.18-clean/net/sna/Makefile linux/net/sna/Makefile
--- linux-2.4.18-clean/net/sna/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/Makefile	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,27 @@
+#
+# Makefile for the Linux Systems Network Architecture layer.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := sna.o
+
+export-objs := af_sna.o 
+
+obj-y := af_sna.o sna_ebcdic.o sna_nof.o sna_cs.o sna_asm.o sna_cosm.o \
+	    sna_ds.o sna_isr.o sna_pc.o sna_rss.o sna_ss.o sna_tdm.o \
+	    sna_dlc.o sna_trs.o sna_rm.o sna_sm.o \
+	    sna_hsr.o sna_tc.o sna_dfc.o sna_appc.o sna_attach.o \
+	    sna_cpic.o sna_ps_main.o sna_ps_conv.o sna_ps_copr.o sna_ps_mc.o \
+	    sna_ps_sync.o
+obj-m := $(O_TARGET)
+
+obj-$(CONFIG_SYSCTL) += sysctl_net_sna.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+		tar -cvf /dev/f1 .
diff -ruN linux-2.4.18-clean/net/sna/af_sna.c linux/net/sna/af_sna.c
--- linux-2.4.18-clean/net/sna/af_sna.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/af_sna.c	Sat Jun  8 15:29:31 2002
@@ -0,0 +1,663 @@
+/* af_sna.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/ctype.h>
+
+#include <linux/sna.h>
+#include <linux/cpic.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif
+
+#ifdef CONFIG_SYSCTL
+extern inline void sna_register_sysctl(void);
+extern inline void sna_unregister_sysctl(void);
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_net_sna = NULL;
+#endif
+
+static struct proto_ops sna_ops;
+
+char sna_version[] 	= "0.1.20";
+char sna_maintainer[] 	= "Jay Schulist <jschlst@linux-sna.org>";
+char sna_product_id[] 	= "GoBig-or-GoHome";
+char sna_product_name[] = "Linux-SNA";
+
+__u32	sysctl_max_link_stations_cnt;
+__u32	sysctl_max_lu_cnt;
+__u32	sysctl_max_mode_cnt;
+__u32	sysctl_max_inbound_activations;
+__u32	sysctl_max_outbound_activations;
+__u32	sysctl_max_retry_limit;
+__u32	sysctl_max_btu_size;
+__u32	sysctl_max_tx_ru_size;
+__u32	sysctl_max_rx_ru_size;
+__u32	sysctl_max_auto_activation_limit;
+__u32	sysctl_bind_pacing_cnt;
+__u32	sna_debug_level = 0;
+
+#define MAX_SNA_ADDR		1024
+
+/* Display an Ethernet address in readable format. */
+char *sna_pr_ether(unsigned char *ptr)
+{
+  	static char buff[64];
+
+  	sprintf(buff, "%02X%02X%02X%02X%02X%02X",
+        	(ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+        	(ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377));
+  	return buff;
+}
+
+char *sna_pr_nodeid(struct sna_nodeid *n)
+{
+        static char buff[20];
+
+        sprintf(buff, "%03X%05X", n->block_id, n->pu_id);
+
+        return buff;
+}
+
+/* display a padded netid correctly */
+char *sna_pr_netid(struct sna_netid *n)
+{
+        struct sna_netid p;
+	char *buff;
+        int i;
+
+	new_s(buff, 20, GFP_ATOMIC);
+	if (!buff)
+		return "";
+        memcpy(&p, n, sizeof(struct sna_netid));
+        for (i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for (i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+        return buff;
+}
+
+int sna_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if (ulen < 0|| ulen > MAX_SNA_ADDR)
+                return -EINVAL;
+        if (ulen == 0)
+                return 0;
+        if (copy_from_user(kaddr,uaddr,ulen))
+                return -EFAULT;
+        return 0;
+}
+
+int sna_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if (klen < 0 || klen > MAX_SNA_ADDR)
+                return -EINVAL;
+        if (klen) {
+                if (copy_to_user(uaddr,kaddr,klen))
+                        return -EFAULT;
+        }
+        return 0;
+}
+
+struct sna_netid *sna_char_to_netid(unsigned char *b)
+{
+        struct sna_netid *n;
+	unsigned char c[40];
+        int i;
+
+	sna_debug(5, "init: %s\n", b);
+	strcpy(c, b);	/* always use protection */
+	new(n, GFP_KERNEL);
+	if (!n)
+		return NULL;
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for (i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for (i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for (i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+	for (i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return n;
+} 
+
+int sna_netid_to_char(struct sna_netid *n, unsigned char *c)
+{
+	int len = 0, i;
+
+	sna_debug(5, "init: %s.%s\n", n->net, n->name);
+	for (i = 0; i < 8 && (n->net[i] != 0x20); i++)
+		/* Nothing */ ;
+	len = i;
+	strncpy(c, n->net, i);
+	len = i + 1;
+	strncpy(c + i, ".", 1);
+	for (i = 0; i < 8 && (n->name[i] != 0x20); i++)
+		/* Nothing */ ;
+	strncpy(c + len, n->name, i);
+	len += i;
+	strncpy(c + len, "\0", 1);
+	sna_debug(5, "finished string is (%s) length is (%d) (%d)\n",
+		c, strlen(c), len);
+
+	return len;
+}
+
+/* Temporary HexDump function. */
+int hexdump(unsigned char *pkt_data, int pkt_len)
+{
+        int i;
+
+        while (pkt_len > 0) {
+                printk("  ");   /* Leading spaces. */
+
+                /* Print the HEX representation. */
+                for (i = 0; i < 8; ++i) {
+                        if (pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i] & 0xFF);
+                        else
+                                printk("  ");
+                }
+
+                printk(":");
+
+                for (i = 8; i < 16; ++i) {
+                        if (pkt_len - (long)i > 0)
+                                printk("%2.2X ", pkt_data[i]&0xFF);
+                        else
+                                printk("  ");
+                }
+
+                /* Print the ASCII representation. */
+                printk("  ");
+                for (i = 0; i < 16; ++i) {
+                        if (pkt_len - (long)i > 0) {
+                                if (isprint(pkt_data[i]))
+                                        printk("%c", pkt_data[i]);
+                                else
+                                        printk(".");
+                        }
+                }
+
+                printk("\n");
+                pkt_len  -= 16;
+                pkt_data += 16;
+        }
+        printk("\n");
+	return 0;
+}
+
+/* Create a SNA socket. */
+static int sna_create(struct socket *sock, int protocol)
+{
+	struct sock *sk = sock->sk;
+
+	sna_debug(5, "init\n");
+	sk = sk_alloc(PF_SNA, GFP_KERNEL, 1);
+	if(!sk)
+		return -ENOMEM;
+
+	switch (sock->type) {
+		case (SOCK_STREAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_DGRAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_RAW):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_SEQPACKET):
+			sock->ops = &sna_ops;
+			break;
+
+		default:
+			sk_free((void *)sk);
+			return (-ESOCKTNOSUPPORT);
+	}
+
+	MOD_INC_USE_COUNT;
+
+	sock_init_data(sock, sk);
+
+	sk->destruct 	= NULL;
+        sk->zapped 	= 1;
+        return 0;
+}
+
+static int sna_destroy_socket(struct sock *sk)
+{
+	sna_debug(5, "sna_destroy_socket\n");
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static int sna_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	sna_debug(5, "sna_release\n");
+
+        if (!sk)
+                return 0;
+        if (!sk->dead)
+                sk->state_change(sk);
+        sk->dead = 1;
+        sock->sk = NULL;
+	sna_destroy_socket(sk);
+	return 0;
+}
+
+static int sna_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	return 0;
+}
+
+static int sna_connect(struct socket *sock, struct sockaddr *uaddr,
+	int addr_len, int flags)
+{
+	return 0;
+}
+
+static int sna_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return 0;
+}
+
+static unsigned int sna_poll(struct file * file, struct socket *sock,
+	poll_table *pt)
+{
+	return 0;
+}
+
+static int sna_getname(struct socket *sock, struct sockaddr *uaddr,
+	int *uaddr_len, int peer)
+{
+	return 0;
+}
+
+static int sna_transmit(struct sock *sk, struct sk_buff *skb, int size)
+{
+	sna_debug(5,"SNA tx'd packet!/n");
+	kfree_skb(skb);
+	return 0;
+}
+
+/* This is the Linux frontend to the SNA transmit code.
+ * For now this is just a fake sendmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */ 
+static int sna_sendmsg(struct socket *sock, struct msghdr *msg, int size,
+	struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+        int flags = msg->msg_flags;
+        struct sk_buff *skb;
+	int err;
+
+	if (size > 10000)	/* Fake max. */
+		return -EMSGSIZE;
+	if (flags&~MSG_DONTWAIT)
+                return -EINVAL;
+
+        skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &err);
+        if (!skb)
+                return err;
+        skb->sk = sk;
+
+	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+        if (err) {
+                kfree_skb(skb);
+                return -EFAULT;
+        }
+
+	err = sna_transmit(sk, skb, size);
+	if (err)
+		return -EAGAIN;
+	return size;
+}
+
+#ifdef NOT
+static int sna_rcv(struct sk_buff *skb, struct net_device *dev, 
+	struct packet_type *pt)
+{
+	sna_debug(5, "SNA rx'd packet!\n");
+	kfree_skb(skb);
+	return 0;
+}
+#endif
+
+/* This function is the Linux frontend to the SNA receive code.
+ * For now this is just a fake recvmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */
+static int sna_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+	int flags, struct scm_cookie *scm)
+{
+	return -EINVAL;
+}
+
+static int sna_shutdown(struct socket *sk, int how)
+{
+	return -EOPNOTSUPP;
+}
+
+/* SNA ioctl calls. */
+static int sna_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+		case SIOCGNODE:
+		case SIOCGDLC:
+		case SIOCGPORT:
+		case SIOCGLS:
+		case SIOCGMODE:
+		case SIOCGLU:
+		case SIOCGPLU:
+		case SIOCGCOS:
+			return sna_nof_ioctl(cmd, (void *)arg);
+
+		case SIOCGCPICS:
+			return sna_cpic_ioctl(cmd, (void *)arg);
+
+#ifdef NOT
+		case SIOPS:
+			return sna_ps_ioctl(cmd, (void *)arg);
+#endif
+
+		default:
+			return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int sna_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+	sna_debug(5, "init\n");
+        switch (level) {
+		case SOL_SNA_NOF:
+			err = sna_nof_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef NOT
+		case SOL_SNA_PS:
+			err = sna_ps_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		case SOL_SNA_CPIC:
+			err = sna_cpic_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+		default:
+			return -ENOPROTOOPT;
+	}
+	return err;
+}
+
+static int sna_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+	int err;
+
+	sna_debug(5, "init\n");
+        switch (level) {
+		case SOL_SNA_NOF:
+			err = sna_nof_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef NOT
+		case SOL_SNA_PS:
+			err = sna_ps_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		default:
+			return -ENOPROTOOPT;
+        }
+	return err;
+}
+
+void sna_mod_inc_use_count(void)
+{
+	MOD_INC_USE_COUNT;
+}
+
+void sna_mod_dec_use_count(void)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static struct net_proto_family sna_family_ops =
+{
+	PF_SNA,
+	sna_create
+};
+
+static struct proto_ops sna_ops =
+{
+	PF_SNA,
+	sna_release,
+	sna_bind,
+	sna_connect,
+	sock_no_socketpair,
+	sna_accept,
+	sna_getname,
+	sna_poll,
+	sna_ioctl,
+	sock_no_listen,
+	sna_shutdown,
+	sna_setsockopt,		/* Okay. */
+	sna_getsockopt,		/* Okay. */
+	sna_sendmsg,
+	sna_recvmsg,
+	sock_no_mmap
+};
+
+#ifdef CONFIG_PROC_FS
+static void sna_proc_init(void)
+{
+        if (!proc_net_sna) {
+                struct proc_dir_entry *ent;
+                ent = proc_mkdir("net/sna", 0);
+                if (ent) {
+                        ent->owner = THIS_MODULE;
+                        proc_net_sna = ent;
+                }
+        }
+	return;
+}
+
+static void sna_proc_cleanup(void)
+{
+        if (proc_net_sna) {
+                proc_net_sna = NULL;
+                remove_proc_entry("net/sna", 0);
+        }
+	return;
+}
+
+inline struct proc_dir_entry *proc_sna_create(const char *name,
+        mode_t mode, get_info_t *get_info)
+{
+        return create_proc_info_entry(name,mode,proc_net_sna,get_info);
+}
+
+inline void proc_sna_remove(const char *name)
+{
+        remove_proc_entry(name, proc_net_sna);
+	return;
+}
+#endif
+
+/* Watch the network devices to see if we need to add/delete/start/stop
+ * a data link control. (Device)
+ */
+int sna_netdev_event(struct notifier_block *self, unsigned long event,
+        void *data)
+{
+        struct net_device *dev = (struct net_device *)data;
+
+        if (event == NETDEV_UP)
+                sna_nof_define_dlc(dev);
+        if (event == NETDEV_DOWN)
+                sna_nof_delete_dlc(dev);
+        return NOTIFY_DONE;
+}
+
+struct notifier_block nb_sna = {
+        sna_netdev_event,
+        NULL,
+        0
+};
+
+int __init sna_init(void)
+{
+	struct net_device *dev;
+
+	/* Scan all the existing interfaces for SNA
+         * compatible devices, add the device to our list if it
+         * is available for sna transfers.
+         */
+        rtnl_lock();
+        for (dev = dev_base; dev != NULL; dev = dev->next) {
+                if (dev->flags & IFF_UP)
+                        sna_nof_define_dlc(dev);
+        }
+        rtnl_unlock();
+
+        /* Attach a device notifier so we can watch for devices
+         * going up and down.
+         */
+        register_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_PROC_FS
+        sna_proc_init();
+	proc_sna_create("virtual_nodes", 0, sna_nof_get_info);
+	proc_sna_create("devices", 0, sna_cs_get_info_dlc);
+	proc_sna_create("ports", 0, sna_cs_get_info_port);
+	proc_sna_create("link_stations", 0, sna_cs_get_info_ls);
+	proc_sna_create("modes", 0, sna_rm_get_info_mode);
+
+	proc_sna_create("local_lus", 0, sna_rm_get_info_local_lu);
+	proc_sna_create("remote_lus", 0, sna_rm_get_info_remote_lu);
+
+	proc_sna_create("cpic_side_information", 0, sna_cpic_get_info_side);
+	proc_sna_create("cpic_conversations", 0, sna_cpic_get_info);
+
+	proc_sna_create("cos_levels", 0, sna_cosm_get_info);
+	proc_sna_create("cos_tg_characteristics", 0, sna_cosm_get_info_tg);
+	proc_sna_create("cos_node_characteristics", 0, sna_cos_get_info_node);
+
+	proc_sna_create("node_map", 0, sna_tdm_get_info);
+	proc_sna_create("transmission_groups", 0, sna_tdm_get_info_tg);
+
+	proc_sna_create("path_controls", 0, sna_pc_get_info_tg);
+
+	proc_sna_create("asm_active_address_space", 0, sna_asm_get_info);
+	proc_sna_create("asm_active_lfsids", 0, sna_asm_get_active_lfsids);
+#endif
+
+        printk(KERN_INFO "Linux-SNA (System Network Architecture) "
+		"v%s (%s) for Linux NET4.0\n", sna_version, sna_product_id);
+
+	(void) sock_register(&sna_family_ops);
+
+#ifdef CONFIG_SYSCTL
+        sna_register_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+        return 0;
+}
+
+void __exit sna_exit(void)
+{
+	/* Remove out notifier from the netdevice layer. */
+        unregister_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_SYSCTL
+        sna_unregister_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+	proc_sna_remove("cpic_conversations");
+	proc_sna_remove("cpic_side_information");
+	proc_sna_remove("remote_lus");
+	proc_sna_remove("local_lus");
+	proc_sna_remove("modes");
+	proc_sna_remove("link_stations");
+	proc_sna_remove("ports");
+	proc_sna_remove("devices");
+	proc_sna_remove("virtual_nodes");
+        sna_proc_cleanup();
+#endif
+
+	sock_unregister(PF_SNA);
+        return;
+}
+
+EXPORT_SYMBOL(hexdump);
+EXPORT_SYMBOL(sna_utok);
+EXPORT_SYMBOL(sna_ktou);
+
+module_init(sna_init);
+module_exit(sna_exit);
+#endif /* CONFIG_SNA || CONFIG_SNA_MODULE */
diff -ruN linux-2.4.18-clean/net/sna/sna_appc.c linux/net/sna/sna_appc.c
--- linux-2.4.18-clean/net/sna/sna_appc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_appc.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,38 @@
+/* sna_appc.c: Linux Systems Network Architecture implementation
+ * - SNA Advanced Program to Program Communications (APPC).
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
diff -ruN linux-2.4.18-clean/net/sna/sna_asm.c linux/net/sna/sna_asm.c
--- linux-2.4.18-clean/net/sna/sna_asm.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_asm.c	Sat Jun  8 15:30:25 2002
@@ -0,0 +1,340 @@
+/* sna_asm.c: Linux Systems Network Architecture implementation
+ * - Linux-SNA Address Space Manager (Connect HS to PC).
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+
+static LIST_HEAD(asm_clients);
+
+/* Display a Path Control ID */
+char *sna_asm_pr_pcid(unsigned char *ptr)
+{
+        static char buff[64];
+
+        sprintf(buff, "%02X%02X%02X%02X%02X%02X%02X%02X",
+                (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+                (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377),
+                (ptr[6] & 0377), (ptr[7] & 0377));
+        return buff;
+}
+
+struct sna_asm_pinfo *sna_asm_find_by_pcid(unsigned char *pc_id)
+{
+	struct sna_asm_pinfo *a;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+		if (!memcmp(&a->pc_id, pc_id, 8))
+			return a;
+	}
+	return NULL;
+}
+
+struct sna_lfsid_block *sna_asm_find_lblk_by_lfsid(struct sna_lfsid *lfsid)
+{
+        struct sna_asm_pinfo *a;
+        struct sna_lfsid_block *l;
+	struct list_head *le, *be;
+	int i;
+
+	sna_debug(5, "init\n");
+	list_for_each(le, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+		list_for_each(be, &a->l_blks) {
+			l = list_entry(be, struct sna_lfsid_block, list);
+			for (i = 0; i < 256; i++) {
+                        	if (!memcmp(lfsid, &l->l[i].lfsid, 
+					sizeof(struct sna_lfsid)))
+                                	return l;
+			}
+		}
+	}
+        return NULL;
+}
+
+int sna_asm_activate_as(struct sna_activate_as *as)
+{
+	struct sna_asm_pinfo *a;
+
+	sna_debug(5, "init\n");
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if (a)
+		return -EEXIST;
+	new(a, GFP_ATOMIC);
+	if (!a)
+		return -ENOMEM;
+	memcpy(&a->pc_id, &as->pc_id, 8);
+	a->intranode			= as->intranode;
+	a->odai				= as->odai;
+	a->max_btu			= as->max_btu;
+	a->tx_rx_bind_pacing		= as->tx_rx_bind_pacing;
+	a->dependent_lulu		= as->dependent_lulu;
+	a->adp_bind_pacing_dep_lulu	= as->adp_bind_pacing_dep_lulu;
+	a->generalized_oadi		= as->generalized_oadi;
+	INIT_LIST_HEAD(&a->l_blks);
+	list_add_tail(&a->list, &asm_clients);
+	kfree(as);
+        return 0;
+}
+
+int sna_asm_deactivate_as(unsigned char *pc_id)
+{
+	struct list_head *le, *se;
+	struct sna_asm_pinfo *a;
+	
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+		if (!memcmp(&a->pc_id, pc_id, 8)) {
+			list_del(&a->list);
+                        kfree(a);
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+/* Locate address space, look for a free lfsid, if not in any of the
+ * existing blocks, then allocate a new block, return a fresh lfsid.
+ */
+int sna_asm_assign_lfsid(struct sna_assign_lfsid *as)
+{
+	struct sna_lfsid_block *l;
+	struct sna_asm_pinfo *a;
+	struct list_head *le;
+	int i, blk_num = 0;
+
+	sna_debug(5, "init: %s\n", sna_asm_pr_pcid(as->pc_id));
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if (!a)
+		return -ENOENT;
+rstart:	/* search for a free lfsid */
+	list_for_each(le, &a->l_blks) {
+		l = list_entry(le, struct sna_lfsid_block, list);
+		blk_num++;
+		for (i = 0; i < 256; i++) {
+			if (l->l[i].active)	/* lfsid is in use */
+				continue;
+
+			/* found a non-active lfsid */
+			l->l[i].active 		= 1;
+			l->l[i].sm_id		= as->sm_id;
+
+			/* We dynamicly assign the lfsid on request */
+			l->l[i].lfsid.odai	= a->odai;
+			l->l[i].lfsid.sid.raw	= ((blk_num * 256) - 256) + i;
+			memcpy(&as->lfsid, &l->l[i].lfsid, 
+				sizeof(struct sna_lfsid));
+			return 0;
+		}
+	}
+
+	/* could not find any non-active lfsids in already alloc'd blocks */
+	new(l, GFP_ATOMIC);
+	if (!l)
+		return -ENOMEM;
+	list_add_tail(&l->list, &a->l_blks);
+	a->blk_count++;
+	goto rstart;	/* just added 256 addresses, lets try it again */
+}
+
+int sna_asm_free_lfsid(struct sna_free_lfsid *f)
+{
+        struct sna_lfsid_block *l;
+	struct sna_asm_pinfo *a;
+	struct list_head *le;
+        int i;
+
+	sna_debug(5, "init: %s\n", sna_asm_pr_pcid(f->pc_id));
+        a = sna_asm_find_by_pcid(f->pc_id);
+        if (!a)
+                return -ENOENT;
+
+	/* locate the lfsid */
+	list_for_each(le, &a->l_blks) {
+		l = list_entry(le, struct sna_lfsid_block, list);
+		for (i = 0; i < 256; i ++) {
+			if (l->l[i].active && (l->l[i].sm_id == f->sm_id)
+				&& (l->l[i].lfsid.odai == f->lfsid.odai)
+				&& (l->l[i].lfsid.sid.raw == f->lfsid.sid.raw)) {
+				l->l[i].active 	= 0;
+				l->l[i].sm_id	= 0;
+				memset(&l->l[i].lfsid, 0, 
+					sizeof(struct sna_lfsid));
+				return 0;
+			}
+		}
+	}
+	return -ENOENT;
+}
+
+int sna_asm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "init: %s\n", start->netid.name);
+        return 0;
+}
+
+int sna_asm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_lfsid_block *l;
+	struct list_head *le, *se, *ae, *be;
+	struct sna_asm_pinfo *a;
+	
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+		list_for_each_safe(ae, be, &a->l_blks) {
+			l = list_entry(ae, struct sna_lfsid_block, list);
+			list_del(&l->list);
+			kfree(l);
+		}
+		list_del(&a->list);
+		kfree(a);
+	}
+        return 0;
+}
+
+/* receive and process bind data */
+int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	struct sna_lfsid_block *l;
+
+	sna_debug(5, "init\n");
+	l = sna_asm_find_lblk_by_lfsid(lfsid);
+	if (!l) {
+		kfree(lfsid);
+		kfree_skb(skb);
+		return -ENOENT;
+	}
+
+	/* for now we kinda cheat and just send to sm rightaway... */
+	sna_sm_process_mu(skb, l);
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+        off_t pos = 0, begin = 0;
+	struct sna_asm_pinfo *a;
+	struct list_head *le;
+        int len = 0;
+
+        len += sprintf(buffer, "%-9s%-8s%-6s%-5s%-6s%-9s%-8s%-9s\n", 
+		"pc_id", "max_btu", "intra", "odai", "godai", 
+		"dep_lulu", "bpacing", "dbpacing");
+
+	list_for_each(le, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+                len += sprintf(buffer + len, "%9s%8d%6d%5d%6d%9d%8d%9d",
+			sna_asm_pr_pcid(a->pc_id), a->max_btu, a->intranode,
+			a->odai, a->generalized_oadi, a->dependent_lulu,
+			a->tx_rx_bind_pacing, a->adp_bind_pacing_dep_lulu);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+
+int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_lfsid_block *l;
+	struct list_head *le, *se;
+	off_t pos = 0, begin = 0;
+        struct sna_asm_pinfo *a;
+        int i, len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%-6s%-6s%-5s%-6s%-5s\n", 
+		"pc_id", "intra", "sm_id", "odai", "sidh", "sidl");
+
+	list_for_each(le, &asm_clients) {
+		a = list_entry(le, struct sna_asm_pinfo, list);
+
+		list_for_each(se, &a->l_blks) {
+			l = list_entry(se, struct sna_lfsid_block, list);
+			for (i = 0; i < 256; i++) {
+				if (l->l[i].active) {
+                			len += sprintf(buffer + len, 
+						"%9s%6d%6d%5d%6d%5d\n",
+						sna_asm_pr_pcid(a->pc_id),
+						a->intranode,
+						l->l[i].sm_id,
+						l->l[i].lfsid.odai,
+						l->l[i].lfsid.sid.hl.sidh,
+						l->l[i].lfsid.sid.hl.sidl);
+				}
+			}
+		}
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_attach.c linux/net/sna/sna_attach.c
--- linux-2.4.18-clean/net/sna/sna_attach.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_attach.c	Fri Jun  7 12:16:25 2002
@@ -0,0 +1,121 @@
+/* sna_attach.c: Linux Systems Network Architecture implementation
+ * - SNA Attach Manager Kernel Backend.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+struct sk_buff_head attach_queue;
+wait_queue_head_t attach_wait;
+
+int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "init\n");
+	memcpy(&skb->cb, &tcb_id, sizeof(unsigned long));
+	skb_queue_head(&attach_queue, skb);
+	wake_up_interruptible(&attach_wait);
+	return 0;
+}
+
+int sna_attach_tp_correlate(pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "init: %d %ld\n", pid, tcb_id);
+	tcb = sna_cpic_find_tcb_by_id(tcb_id);
+	if (!tcb)
+		return -1;
+	tcb->pid = pid;
+	return 0;
+}
+
+/* Get an attach from the SNA stack, then pass it to a manager. */
+int sna_attach_listen(struct attach *at, void *buf, int len)
+{
+	struct sk_buff *skb;
+	struct fmhdr *fm;
+	struct tp_attach tp;
+	__u8 tp_len;
+	__u8 *ptr;
+
+	sna_debug(5, "init\n");
+rstart:	while (skb_queue_empty(&attach_queue)) {     /* No data */
+		/* handle signals */
+                if (signal_pending(current))
+			return -ERESTARTSYS;
+                if (skb_peek(&attach_queue) == NULL)
+                        interruptible_sleep_on(&attach_wait);
+        }
+
+        skb = skb_dequeue(&attach_queue);
+        if (!skb)
+                goto rstart;
+	fm  = skb->f.fm;
+	ptr = &fm->fm.f5.raw;
+	memcpy(&tp_len, ptr, sizeof(__u8));
+	sna_debug(5, "len of name is %d\n", tp_len);
+	sna_debug(5, "Hex is %02X\n", *ptr);
+	tp.tp_len = tp_len;
+	strncpy(tp.tp_name, ptr + 1, tp_len);
+	memcpy(&tp.tcb_id, &skb->cb, sizeof(unsigned long));
+	sna_debug(5, "TCB ID of the incomming attach id %ld\n", tp.tcb_id);
+
+	if (copy_to_user(buf, &tp, sizeof(tp)))
+		return -EFAULT;
+	kfree_skb(skb);
+	return sizeof(tp);
+}
+
+static struct attach_ops aops = {
+	PF_SNA,
+	sna_attach_tp_correlate,
+	sna_attach_listen,
+};
+
+int sna_attach_create(struct sna_start_node *start)
+{
+	sna_debug(5, "init\n");
+        skb_queue_head_init(&attach_queue);
+	init_waitqueue_head(&attach_wait);
+	attach_register(&aops);
+	return 0;
+}
+
+int sna_attach_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "init\n");
+	attach_unregister(0);
+	return 0;
+};
diff -ruN linux-2.4.18-clean/net/sna/sna_cosm.c linux/net/sna/sna_cosm.c
--- linux-2.4.18-clean/net/sna/sna_cosm.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_cosm.c	Sat Jun  8 15:31:20 2002
@@ -0,0 +1,566 @@
+/* sna_cosm.c: Linux Systems Network Architecture implementation
+ * - Class-of-Service Manager
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+/*
+ * Jay Please Look 00
+ *		  [==]
+ *
+ * o You probably are not handling the BLANK and NULL mode names properly.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+
+static LIST_HEAD(cosm_list);
+
+struct sna_cosm_cb *sna_cosm_find(unsigned char *name)
+{
+	struct sna_cosm_cb *c;
+	struct list_head *le;
+
+	list_for_each(le, &cosm_list) {
+		c = list_entry(le, struct sna_cosm_cb, list);
+		if (!strncmp(c->name, name, SNA_RESOURCE_NAME_LEN))
+			return c;
+	}
+	return NULL;
+}
+
+struct sna_cosm_tg_cb *sna_cosm_find_tg_weight(struct sna_cosm_cb *c,
+	unsigned short rsn)
+{
+	struct sna_cosm_tg_cb *t;
+
+	for (t = c->tg; t != NULL; t = t->next) {
+		if (t->rsn == rsn)
+			return t;
+	}
+	return NULL;
+}
+
+struct sna_cosm_node_cb *sna_cosm_find_node_weight(struct sna_cosm_cb *c,
+        unsigned short rsn)
+{
+        struct sna_cosm_node_cb *n;
+
+        for (n = c->node; n != NULL; n = n->next) {
+                if (n->rsn == rsn)
+                        return n;
+	}
+        return NULL;
+}
+
+/* Add a COS definition to the table, this function will create a new
+ * entry or update and existing entry.
+ */
+int sna_cosm_define_cos(struct sna_define_cos *cos)
+{
+	struct sna_cosm_cb *c;
+	struct sna_cosm_node_cb *n;
+	struct sna_cosm_tg_cb *t;
+
+	sna_debug(5, "init: %s\n", cos->name);
+	c = sna_cosm_find(cos->name);
+	if (!c) {
+		new(c, GFP_ATOMIC);
+		if (!c)
+			return -ENOMEM;
+		strncpy(c->name, cos->name, SNA_RESOURCE_NAME_LEN);
+		c->tg			= NULL;
+		c->node			= NULL;
+		list_add_tail(&c->list, &cosm_list);
+	}
+	c->weight               = cos->weight;
+        c->tx_priority          = cos->tx_priority;
+        c->default_cos_invalid  = cos->default_cos_invalid;
+        c->default_cos_null     = cos->default_cos_null;
+
+	/* now append tg cos records */
+	t = sna_cosm_find_tg_weight(c, cos->tg_rsn);
+	if (!t) {
+		new(t, GFP_ATOMIC);
+		if (!t)
+			return -ENOMEM;
+		t->prev = NULL;
+		t->next	= c->tg;
+		c->tg	= t;
+	}
+	t->rsn				= cos->tg_rsn;
+        t->min_cost_per_connect		= cos->min_cost_per_connect;
+        t->max_cost_per_connect		= cos->max_cost_per_connect;
+        t->min_cost_per_byte		= cos->min_cost_per_byte;
+        t->max_cost_per_byte		= cos->max_cost_per_byte;
+        t->min_security			= cos->min_security;
+        t->max_security			= cos->max_security;
+        t->min_propagation_delay	= cos->min_propagation_delay;
+        t->max_propagation_delay	= cos->max_propagation_delay;
+        t->min_effective_capacity	= cos->min_effective_capacity;
+        t->max_effective_capacity	= cos->max_effective_capacity;
+        t->min_user1			= cos->min_user1;
+        t->max_user1			= cos->max_user1;
+        t->min_user2			= cos->min_user2;
+        t->max_user2			= cos->max_user2;
+        t->min_user3			= cos->min_user3;
+        t->max_user3			= cos->max_user3;
+
+	/* now append node cos records */
+	n = sna_cosm_find_node_weight(c, cos->node_rsn);
+	if (!n) {
+		new(n, GFP_ATOMIC);
+		if (!n)
+			return -ENOMEM;
+		n->prev = NULL;
+		n->next	= c->node;
+		c->node	= n;
+	}
+	n->rsn				= cos->node_rsn;
+	n->route_resistance		= cos->max_route_resistance;
+	n->node_congested		= cos->max_node_congested;
+//	n->inter_routing_depleted	= cos->inter_routing_depleted;
+	return 0;
+}
+
+int sna_cosm_delete_cos(struct sna_delete_cos *cos)
+{
+	struct list_head *le, *se;
+	struct sna_cosm_cb *c;
+
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &cosm_list) {
+		c = list_entry(le, struct sna_cosm_cb, list);
+                if (!strcmp(c->name, cos->name)) {
+			struct sna_cosm_tg_cb *t;
+			struct sna_cosm_node_cb *n;
+
+			for (t = c->tg; t != NULL; t = t->next)
+				kfree(t);
+			for (n = c->node; n != NULL; n = n->next)
+				kfree(n);
+			list_del(&c->list);
+                        kfree(c);
+                        return 0;
+                }
+        }
+	return -ENOENT;
+}
+
+int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos)
+{
+	struct sna_cosm_cb *c;
+	int i;
+
+	sna_debug(5, "sna_cosm_cos_tpf_vector\n");
+	c = sna_cosm_find(cos->mode_name);
+	if (!c)
+		return -ENOENT;
+	memset(&cos->v, 0, sizeof(struct sna_cos));
+	cos->v.type		= 0x2C;
+	cos->v.tx_priority	= c->tx_priority;
+	i = strlen(c->name);
+	memcpy(cos->v.cos_name, c->name, i);
+	for (i = strlen(cos->v.cos_name); i < 8; i++)
+		cos->v.cos_name[i] = 0x40;
+	cos->v.len = sizeof(struct sna_cos);
+	return 0;
+}
+
+/* Slick little way to initialize all of the default COS records. */
+struct sna_define_cos cos_defaults[] = {
+	{"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 120, 0, 0, 0, 0, 0x01, 0xFF,
+	0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 180, 0, 128, 0, 128, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCH", 10, SNA_TP_LOW      , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#INTER", 20, SNA_TP_HIGH     , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1}
+};
+
+int sna_cosm_init_default_cos(void)
+{
+	struct sna_cosm_cb *c;
+	struct list_head *le;
+	int i;
+
+	sna_debug(5, "init\n");
+	for (i = 0; i < 56; i++)
+		sna_cosm_define_cos(&cos_defaults[i]);
+	list_for_each(le, &cosm_list) {
+		c = list_entry(le, struct sna_cosm_cb, list);
+		sna_debug(5, "cos_name %s\n", c->name);
+	}
+	return 0;
+}
+
+int sna_cos_ginfo(struct sna_cosm_cb *cos, char *buf, int len)
+{
+	struct cosreq cr;
+	int done = 0;
+
+	sna_debug(10, "init\n");
+	if (!buf) {
+                done += sizeof(cr);
+                return done;
+        }
+        if (len < (int)sizeof(cr))
+                return done;
+        memset(&cr, 0, sizeof(struct cosreq));
+
+        /* Move the data here */
+	strncpy(cr.name, cos->name, SNA_RESOURCE_NAME_LEN);
+	cr.weight		= cos->weight;
+	cr.tx_priority		= cos->tx_priority;
+	cr.default_cos_invalid	= cos->default_cos_invalid;
+	cr.default_cos_null	= cos->default_cos_null;
+
+	if (copy_to_user(buf, &cr, sizeof(struct cosreq)))
+                return -EFAULT;
+        buf  += sizeof(struct cosreq);
+        len  -= sizeof(struct cosreq);
+        done += sizeof(struct cosreq);
+        return done;
+}
+
+int sna_cosm_query_cos(char *arg)
+{
+	struct sna_cosm_cb *cos;
+	struct list_head *le;
+	int len, total, done;
+	struct cosconf cc;
+	char *pos;
+
+	sna_debug(5, "init\n");
+	if (copy_from_user(&cc, arg, sizeof(cc)))
+                return -EFAULT;
+
+        pos = cc.cosc_buf;
+        len = cc.cos_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &cosm_list) {
+		cos = list_entry(le, struct sna_cosm_cb, list);
+                if (pos == NULL)
+                        done = sna_cos_ginfo(cos, NULL, 0);
+                else
+                        done = sna_cos_ginfo(cos, pos + total, len - total);
+                if (done < 0)
+                        return -EFAULT;
+                total += done;
+        }
+
+        cc.cos_len = total;
+	if (copy_to_user(arg, &cc, sizeof(cc)))
+                return -EFAULT;
+        return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+	/* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%5s%5s"
+                "%5s%5s%4s%4s%4s%4s%4s%4s%4s"
+                "%4s%4s%4s%5s%6s\n",
+                "name", "lcpc",
+                "hcpc", "lcpb",
+                "hcpb", "lpd",
+                "hpd", "lec",
+                "lec", "lu1", "hu1",
+                "lu2", "hu2", "lu3", "hu3",
+                "stat", "quisc");
+
+	list_for_each(le, &cosm_list) {
+		struct sna_cosm_tg_cb *t;
+
+		c = list_entry(le, struct sna_cosm_cb, list);
+		for (t = c->tg; t != NULL; t = t->next) {
+			len += sprintf(buffer + len, "%-9s%5d%5d"
+                	"%5d%5d%4d%4d%4d%4d%4d%4d%4d"
+                	"%4d%4d%4d%5d%6d\n",
+			c->name, t->min_cost_per_connect, 
+			t->max_cost_per_connect, t->min_cost_per_byte,
+			t->max_cost_per_byte, t->min_propagation_delay,
+			t->max_propagation_delay, t->min_effective_capacity,
+			t->max_effective_capacity, t->min_user1, t->max_user1,
+			t->min_user2, t->max_user2, t->min_user3, t->max_user3,
+			t->operational, t->quiescing);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+	return len;
+}
+
+int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%4s%4s%4s%7s%8s%10s\n",
+                "name", "rr", "nc",
+		"ird", "quiesc", "gateway",
+		"directory");
+
+	list_for_each(le, &cosm_list) {
+		struct sna_cosm_node_cb *n;
+
+		c = list_entry(le, struct sna_cosm_cb, list);
+		for (n = c->node; n != NULL; n = n->next) {
+			len += sprintf(buffer + len, "%-9s%4d%4d%4d%7d%8d%10d\n",
+			c->name, n->route_resistance, n->node_congested,
+			n->inter_routing_depleted, n->quiescing, 
+			n->gateway_support, n->central_directory);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+	return len;
+}
+
+int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%7s%12s%17s%20s\n",
+		"name", "weight", "tx_priority", "default_cos_null",
+		"default_cos_invalid");
+
+	list_for_each(le, &cosm_list) {
+		c = list_entry(le, struct sna_cosm_cb, list);
+		len += sprintf(buffer+len, "%-9s%7d%12d%17d%20d\n",
+		c->name, c->weight, c->tx_priority, c->default_cos_null,
+		c->default_cos_invalid);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
+
+int sna_cosm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_cosm_create\n");
+	sna_cosm_init_default_cos();
+	return 0;
+}
+
+int sna_cosm_destroy(struct sna_delete_node *delete)
+{
+	struct list_head *le, *se;
+	struct sna_cosm_cb *c;
+	
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &cosm_list) {
+		struct sna_cosm_tg_cb *t;
+                struct sna_cosm_node_cb *n;
+
+		c = list_entry(le, struct sna_cosm_cb, list);
+                for (t = c->tg; t != NULL; t = t->next)
+	                kfree(t);
+                for (n = c->node; n != NULL; n = n->next)
+                        kfree(n);
+		list_del(&c->list);
+		kfree(c);
+	}
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_cpic.c linux/net/sna/sna_cpic.c
--- linux-2.4.18-clean/net/sna/sna_cpic.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_cpic.c	Sat Jun  8 15:31:45 2002
@@ -0,0 +1,1071 @@
+/* sna_cpic.c: Linux Systems Network Architecture implementation
+ * - SNA CPI Communications (CPI-C) Pure processing backend.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static unsigned long tcb_ids = 0;
+static LIST_HEAD(sna_tcb_clients);
+
+#define MAX_CPIC_ADDR	1024
+
+struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id)
+{
+	struct list_head *le;
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "init\n");
+	list_for_each(le, &sna_tcb_clients) {
+		tcb = list_entry(le, struct sna_tcb, list);
+		sna_debug(5, "%d %ld\n", tcb->tcb_id, tcb_id);
+		if (tcb->tcb_id == tcb_id)
+			return tcb;
+	}
+	return NULL;
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_pid(pid_t pid)
+{
+	struct list_head *le;
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "init: %d\n", pid);
+	list_for_each(le, &sna_tcb_clients) {
+		tcb = list_entry(le, struct sna_tcb, list);
+		sna_debug(5, "%d %d\n", tcb->pid, pid);
+		if (tcb->pid == pid)
+			return tcb;
+	}
+	return NULL;
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf)
+{
+	struct list_head *le;
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "init: %d\n", daf);
+	list_for_each(le, &sna_tcb_clients) {
+		tcb = list_entry(le, struct sna_tcb, list);
+		sna_debug(5, "%d %d\n", tcb->oaf, daf);
+		if (tcb->oaf == daf)
+			return tcb;
+	}
+	return NULL;
+}
+
+struct sna_cpic *sna_cpic_find_client(unsigned long conversation_id)
+{
+	struct sna_cpic *cpic;
+
+	sna_debug(5, "init\n");
+
+/*
+	for(cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next)
+		if(cpic->conversation_id == conversation_id)
+				return (cpic);
+*/
+
+	return NULL;
+}
+
+int sna_cpic_release_session(struct cpic *cpic)
+{
+	struct sna_tcb *sc = cpic->vi.sna;
+
+	sna_debug(5, "init\n");
+	if (!sc)
+		return 0;
+	cpic->vi.sna = NULL;
+	kfree(sc);
+        return 0;
+}
+
+unsigned long sna_cpic_create_tcb(int *err)
+{
+	struct sna_tcb *tcb;
+
+	*err = 0;
+	sna_debug(5, "init\n");
+	new(tcb, GFP_ATOMIC);
+	if (!tcb) {
+		*err = -EINVAL;
+		return 0;
+	}
+	tcb->state 	= CM_INIT;
+	tcb->tcb_id	= tcb_ids++;
+	tcb->pid	= 0;
+	init_waitqueue_head(&tcb->sleep);
+	skb_queue_head_init(&tcb->receive_queue);
+	skb_queue_head_init(&tcb->transmit_queue);
+
+	/* Temporary hack to do without PC. */
+	tcb->oaf = 5;
+	tcb->daf = 4;
+
+	list_add_tail(&tcb->list, &sna_tcb_clients);
+	return tcb->tcb_id;
+}
+
+int sna_cpic_create_session(struct cpic *cpic, int s)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "init\n");
+	new(tcb, GFP_ATOMIC);
+	if (!tcb)
+		return -ENOMEM;
+	tcb->state	= CM_INIT;
+	tcb->tcb_id	= tcb_ids++;
+	init_waitqueue_head(&tcb->sleep);
+	skb_queue_head_init(&tcb->receive_queue);
+	skb_queue_head_init(&tcb->transmit_queue);
+	if (s) {	/* Client, copy TP name  */
+		tcb->tp_name_length = strlen(cpic->side->tp_name);
+		if (tcb->tp_name_length > 0) {
+			strncpy(tcb->tp_name, cpic->side->tp_name,
+				tcb->tp_name_length);
+		}
+		tcb->partner_lu_name_length = sprintf(tcb->partner_lu_name, "%s", 
+			sna_pr_netid((struct sna_netid *)&cpic->side->netid_plu));
+		tcb->mode_name_length = strlen(cpic->side->mode_name);
+		if (tcb->mode_name_length > 0) {
+			strncpy(tcb->mode_name, cpic->side->mode_name,
+				tcb->mode_name_length);
+		}
+		tcb->oaf	= 4;
+		tcb->daf	= 5;
+	} else {
+		tcb->oaf	= 5;
+		tcb->daf	= 4;
+	}
+
+	cpic->vi.sna = tcb;
+	list_add_tail(&tcb->list, &sna_tcb_clients);
+        return 0;
+}
+
+__u32 sna_cmsaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ae_len;
+	__u8 ae_title;
+
+	sna_debug(5, "init\n");
+	copy_from_user(&ae_len, ae_qualifier_length, sizeof(__u32));
+	copy_from_user(&ae_title, ap_title_format, sizeof(__u8));
+        if ((ae_len < 0 || ae_len > 1024)
+		|| (ae_title != CM_DN )) {
+//		&& ae_title != CM_INT_DIGITS)) {
+                return CM_PROGRAM_PARAMETER_CHECK;
+        }
+        if (tcb->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+
+        if (copy_from_user(&tcb->ae_qualifier, ae_qualifier, ae_len))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+        tcb->ae_qualifier_length = ae_len;
+	tcb->ae_qualifier_format = ae_title;
+        return CM_OK;
+}
+
+__u32 sna_cmsac(struct cpic *c, __u32 *allocate_confirm)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ap_context_len;
+
+        sna_debug(5, "init\n");
+	copy_from_user(&ap_context_len,appl_context_name_length,sizeof(__u32));
+        if ((ap_context_len < 1 || ap_context_len > 256))
+		return CM_PROGRAM_PARAMETER_CHECK;
+        if (tcb->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+
+        if (copy_from_user(&tcb->application_context_name, 
+		application_context_name, ap_context_len)) {
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	}
+        tcb->application_context_length = ap_context_len;
+	return CM_OK;
+}
+
+__u32 sna_cmsapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(ap_title_length, sizeof(__u32), &cpic->ap_title_length);
+        sna_utok(ap_title_format, sizeof(__u8), &cpic->ap_title_format);
+	if ((cpic->ap_title_length < 0 || cpic->ap_title_length > 1024)
+                || (cpic->ap_title_format != CM_DN
+                && cpic->ap_title_format != CM_OID)) {
+		return CM_PROGRAM_PARAMETER_CHECK;
+        }
+        if (cpic->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+	if (sna_utok(ap_title, cpic->ap_title_length, cpic->ap_title))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmsbt(struct cpic *c, __u32 *begin_transaction)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_utok(begin_transaction, sizeof(__u8), &cpic->begin_transaction);
+	return CM_OK;
+}
+
+__u32 sna_cmscsp(struct cpic *c, __u32 *password, __u32 *password_length)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmscst(struct cpic *c, __u32 *conv_security_type)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmscsu(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsct(struct cpic *c, __u32 *conversation_type)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmscu(struct cpic *c, __u32 *confirmation_urgency)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsdt(struct cpic *c, __u32 *deallocate_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+
+	/* Do error checking on this later */
+	sna_utok(deallocate_type, sizeof(CM_DEALLOCATE_TYPE),
+		&cpic->deallocate_type);
+	switch (cpic->deallocate_type) {
+		case CM_DEALLOCATE_SYNC_LEVEL:
+			break;
+		case CM_DEALLOCATE_FLUSH:
+			break;
+		case CM_DEALLOCATE_CONFIRM:
+			break;
+		case CM_DEALLOCATE_ABEND:
+			break;
+		default:
+			return CM_PROGRAM_PARAMETER_CHECK;
+	}
+	return CM_OK;
+}
+
+__u32 sna_cmsed(struct cpic *c, __u32 *error_direction)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsend(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+	struct sk_buff *skb;
+	int err, slen;
+
+	sna_debug(5, "init\n");
+	sna_utok(send_length, sizeof(__u32), &slen);
+
+	skb = alloc_skb(slen + 250, GFP_ATOMIC);
+	if (!skb)
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	skb_reserve(skb, sizeof(struct snarhdr));
+        skb_reserve(skb, sizeof(struct sna_fid2) + 8);
+	err = sna_utok(buffer, slen, skb_put(skb, slen));
+        if (err) {
+                kfree_skb(skb);
+		return CM_PRODUCT_SPECIFIC_ERROR;
+        }
+
+	hexdump(skb->data, skb->len);
+
+	skb_queue_tail(&tcb->transmit_queue, skb);
+	sna_ps_verb_router(SEND_DATA, tcb);
+	return CM_OK;
+}
+
+__u32 sna_cmrcv(struct cpic *c, __u32 *buffer, __u32 *requested_length,
+	__u32 *data_received, __u32 *received_length, __u32 *status_received,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+        struct sk_buff *skb;
+        int err, copied, rlen;
+	__u32 wr, sr;
+
+	sna_debug(5, "init\n");
+	sna_ps_verb_router(RECEIVE_AND_WAIT, cpic);
+        skb = skb_dequeue(&cpic->receive_queue);
+        if (!skb)
+		return CM_PRODUCT_SPECIFIC_ERROR;
+
+	sna_debug(5, "got backed in cmrcv !!!!!!!!!\n");
+	hexdump(skb->data, skb->len);
+
+        sna_utok(requested_length, sizeof(__u32), &rlen);
+	wr = CM_DATA_RECEIVED;
+	sna_utok(data_received, sizeof(__u32), &wr);
+	sr = CM_SEND_RECEIVED;
+	sna_utok(status_received, sizeof(__u32), &sr);
+
+        copied  = skb->len;
+        if (copied > rlen) 
+                copied = rlen;
+	err = sna_ktou(&skb->data[9], copied, buffer);
+	if (err)
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmserr(struct cpic *c, __u32 *control_information_recevied)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsf(struct cpic *c, __u32 *fill)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(fill, sizeof(CM_FILL), &cpic->fill);
+	if (cpic->fill != CM_FILL_LL && cpic->fill != CM_FILL_BUFFER)
+		return CM_PROGRAM_PARAMETER_CHECK;
+	return CM_OK;
+}
+
+__u32 sna_cmsid(struct cpic *c, __u32 *initialization_data, 
+	__u32 *init_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(init_data_length, sizeof(CM_INT32), &cpic->init_data_length);
+	if (cpic->init_data_length < 0 || cpic->init_data_length > 10000)
+		return CM_PROGRAM_PARAMETER_CHECK;
+        if (cpic->state != CM_INIT && cpic->state != CM_RCV 
+		&& cpic->state != CM_SEND_RCV) {
+		return CM_PROGRAM_STATE_CHECK;
+        }
+
+	if (sna_utok(initialization_data,cpic->init_data_length,cpic->init_data))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmsld(struct cpic *c, __u32 *log_data, __u32 *log_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(log_data_length, sizeof(CM_INT32), &cpic->log_data_length);
+ 	if (cpic->log_data_length < 0 || cpic->log_data_length > 512)
+		return CM_PROGRAM_PARAMETER_CHECK;
+
+	if (sna_utok(log_data, cpic->log_data_length, cpic->log_data))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmsltp(__u32 *tp, __u32 *tp_name_length)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsmn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(mode_name_length, sizeof(CM_INT32), &cpic->mode_name_length);
+	if (cpic->mode_name_length < 0 || cpic->mode_name_length > 8)
+		return CM_PROGRAM_PARAMETER_CHECK;
+	if (cpic->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+	if (sna_utok(mode_name, cpic->mode_name_length, cpic->mode_name))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmsndx(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmspdp(struct cpic *c, __u32 *prepare_data_permitted)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmspid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *partner_id_length, __u32 *partner_id_scope, 
+	__u32 *directory_syntax, __u32 *directory_encoding)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmspln(struct cpic *c, __u32 *partner_lu_name, 
+	__u32 *partner_lu_name_length)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	sna_utok(partner_lu_name_length, sizeof(CM_INT32), 
+		&cpic->partner_lu_name_length);
+	if (cpic->partner_lu_name_length<1 || cpic->partner_lu_name_length>17)
+		return CM_PROGRAM_PARAMETER_CHECK;
+	if (cpic->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+	if (sna_utok(partner_lu_name, cpic->partner_lu_name_length,
+		cpic->partner_lu_name)) {
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	}
+	return CM_OK;
+}
+
+__u32 sna_cmspm(struct cpic *c, __u32 *processing_mode)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsptr(struct cpic *c, __u32 *prepare_to_receive_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	if (cpic->state != CM_INIT_INCOMING)	/* Should be just CM_INIT_INCOMING */
+		return CM_PROGRAM_STATE_CHECK;
+
+	/* Do error checking on this later. */
+	sna_utok(prepare_to_receive_type, sizeof(CM_PREPARE_TO_RECEIVE_TYPE),
+		&cpic->prepare_to_receive_type);
+	switch (cpic->prepare_to_receive_type) {
+		case CM_PREP_TO_RECEIVE_SYNC_LEVEL:
+			break;
+		case CM_PREP_TO_RECEIVE_FLUSH:
+			break;
+		case CM_PREP_TO_RECEIVE_CONFIRM:
+			break;
+		default:
+			return CM_PROGRAM_PARAMETER_CHECK;
+	}
+	return CM_OK;
+}
+
+__u32 sna_cmsqcf(struct cpic *c, __u32 *conversation_queue, 
+	__u32 *callback_function, __u32 *callback_info, __u32 *user_field)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmcanc(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmprep(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsqpm(struct cpic *c, __u32 *conversation_queue,
+	__u32 *queue_processing_mode, __u32 *user_field, __u32 *ooid)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsrc(struct cpic *c, __u32 *return_control)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmsrt(struct cpic *c, __u32 *receive_type)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+	sna_utok(receive_type, sizeof(CM_RECEIVE_TYPE), &cpic->receive_type);
+	if (cpic->receive_type != CM_RECEIVE_AND_WAIT
+		&& cpic->receive_type != CM_RECEIVE_IMMEDIATE) {
+		return CM_PROGRAM_PARAMETER_CHECK;
+        }
+	return CM_OK;
+}
+
+__u32 sna_cmssl(struct cpic *c, __u32 *sync_level)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+	if (cpic->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+
+	/* Preform some error checking on this later. */
+	sna_utok(sync_level, sizeof(__u32), &cpic->sync_level);
+	switch (cpic->sync_level) {
+		case CM_NONE:
+			break;
+/*
+		case CM_CONFIRM:
+			break;
+
+		case CM_SYNC_POINT:
+			break;
+*/
+		case CM_SYNC_POINT_NO_CONFIRM:
+			break;
+
+		default:
+			return CM_PROGRAM_PARAMETER_CHECK;
+	}
+	return CM_OK;
+}
+
+__u32 sna_cmssrm(struct cpic *c, __u32 *send_receive_mode)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+	sna_utok(send_receive_mode, sizeof(CM_SEND_RECEIVE_MODE), 
+		&cpic->send_receive_mode);
+        if (cpic->send_receive_mode != CM_HALF_DUPLEX 
+		&& cpic->send_receive_mode != CM_FULL_DUPLEX) {
+		return CM_PROGRAM_PARAMETER_CHECK;
+        }
+        if (cpic->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+	return CM_OK;
+}
+
+__u32 sna_cmsst(struct cpic *c, __u32 *send_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+
+	/* Do some error checking on this later. */
+	sna_utok(send_type, sizeof(CM_SEND_TYPE), &cpic->send_type);
+	switch (cpic->send_type) {
+		case CM_BUFFER_DATA:
+			break;
+		case CM_SEND_AND_FLUSH:
+			break;
+		case CM_SEND_AND_CONFIRM:
+			break;
+		case CM_SEND_AND_PREP_TO_RECEIVE:
+			break;
+		case CM_SEND_AND_DEALLOCATE:
+			break;
+		default:
+			return CM_PROGRAM_PARAMETER_CHECK;
+	}
+	return CM_OK;
+}
+
+__u32 sna_cmstc(struct cpic *c, __u32 *transaction_control)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmstpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+	sna_utok(tp_name_length, sizeof(CM_INT32), &cpic->tp_name_length);
+        if (cpic->tp_name_length < 1 || cpic->tp_name_length > 64)
+		return CM_PROGRAM_PARAMETER_CHECK;
+        if (cpic->state != CM_INIT && cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	if (sna_utok(tp_name, cpic->tp_name_length, cpic->tp_name))
+		return CM_PRODUCT_SPECIFIC_ERROR;
+	return CM_OK;
+}
+
+__u32 sna_cmeaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->ae_qualifier, cpic->ae_qualifier_length, ae_qualifier);
+	sna_ktou(&cpic->ae_qualifier_length, sizeof(cpic->ae_qualifier_length),
+		ae_qualifier_length);
+	sna_ktou(&cpic->ae_qualifier_format, sizeof(cpic->ae_qualifier_format),
+		ap_title_format);
+	return CM_OK;
+}
+
+__u32 sna_cmeapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->ap_title, cpic->ap_title_length, ap_title);
+	sna_ktou(&cpic->ap_title_length, sizeof(cpic->ap_title_length),
+		ap_title_length);
+	sna_ktou(&cpic->ap_title_format, sizeof(cpic->ap_title_format),
+		ap_title_format);
+	return CM_OK;
+}
+
+__u32 sna_cmeacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->application_context_name, 
+		cpic->application_context_length, application_context_name);
+	sna_ktou(&cpic->application_context_length, 
+		sizeof(cpic->application_context_length), 
+		appl_context_name_length);
+	return CM_OK;
+}
+
+__u32 sna_cmecs(struct cpic *c, __u32 *conversation_state)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+	sna_ktou(&cpic->state, sizeof(cpic->state), conversation_state);
+
+	return CM_OK;
+}
+
+__u32 sna_cmect(struct cpic *c, __u32 *conversation_type)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmectx(struct cpic *c, __u32 *context_id, __u32 *context_id_length)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmeid(struct cpic *c, __u32 *initialization_data,
+	__u32 *requested_length, __u32 *initialization_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+	CM_INT32 len;
+	
+        sna_debug(5, "init\n");
+	sna_utok(requested_length, sizeof(CM_INT32), &len);
+ 	if (len < 0)
+		return CM_PROGRAM_PARAMETER_CHECK;
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->init_data, len, initialization_data);
+	sna_ktou(&len, sizeof(len), initialization_data_length);
+	return CM_OK;
+}
+
+__u32 sna_cmemn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->mode_name, cpic->mode_name_length, mode_name);
+	sna_ktou(&cpic->mode_name_length, sizeof(cpic->mode_name_length),
+		mode_name_length);
+	return CM_OK;
+}
+
+__u32 sna_cmepid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *requested_length, __u32 *partner_id_length, 
+	__u32 *partner_id_scope, __u32 *directory_syntax,
+	__u32 *directory_encoding)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmepln(struct cpic *c, __u32 *partner_lu_name,
+	__u32 *partner_lu_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+
+/*
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->partner_lu_name, cpic->partner_lu_name_length, 
+		partner_lu_name);
+	sna_ktou(&cpic->partner_lu_name_length, 
+		sizeof(cpic->partner_lu_name_length), partner_lu_name_length);
+*/
+	return CM_OK;
+}
+
+__u32 sna_cmesi(struct cpic *c, __u32 *call_id, __u32 *buffer,
+	__u32 *requested_length, __u32 *data_received)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmesl(struct cpic *c, __u32 *sync_level)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmesrm(struct cpic *c, __u32 *send_receive_mode)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmesui(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmetc(struct cpic *c, __u32 *transaction_control)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmetpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "init\n");
+        if (cpic->state != CM_INIT_INCOMING)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ktou(&cpic->tp_name, cpic->tp_name_length, tp_name);
+	sna_ktou(&cpic->tp_name_length, sizeof(cpic->tp_name_length),
+		tp_name_length);
+	return CM_OK;
+}
+
+/* Build SKB, send on for further processing. */
+__u32 sna_cmallc(struct cpic *c)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	if (tcb->state != CM_INIT)
+		return CM_PROGRAM_STATE_CHECK;
+	sna_ps_verb_router(ALLOCATE, tcb);
+	tcb->state = CM_INIT_INCOMING;
+	return CM_OK;
+}
+
+__u32 sna_cmcfmd(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+	return CM_OK;
+}
+
+__u32 sna_cmdfde(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmacci(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmwait(struct cpic *c, __u32 *a1)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmflus(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmincl(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmptr(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmrts(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmtrts(struct cpic *c, __u32 *a1)
+{
+	return CM_OK;
+}
+
+__u32 sna_cminic(struct cpic *c)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmcfm(struct cpic *cpic, __u32 *a1)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmrcvx(struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5)
+{
+	return CM_OK;
+}
+
+__u32 sna_cmdeal(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "init\n");
+
+	return CM_OK;
+}
+
+int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+                         char *optval, int optlen)
+{
+        int err = -EINVAL;
+
+	if (level != SOL_SNA_CPIC)
+		goto out;
+	switch (optname) {
+		case CPIC_DEFINE_SIDE: {
+			struct cpic_define_side_info c;
+			if (optlen < sizeof(c))
+				return -EINVAL;
+			if (copy_from_user(&c, optval, sizeof(c)))
+				return -EFAULT;
+			err = cpic_register_side_info(&c);
+			break;
+		}
+		case CPIC_DELETE_SIDE: {
+			struct cpic_delete_side_info c;
+			if (optlen < sizeof(c))
+                                return -EINVAL;
+                        if (copy_from_user(&c, optval, sizeof(c)))
+                                return -EFAULT;
+			err = cpic_unregister_side_info(&c);
+			break;
+		}
+		default:
+			break;
+	}
+out:	return err;
+}
+
+int sna_cpic_ioctl(int cmd, void *arg)
+{
+	int err = -EINVAL;
+	
+        switch (cmd) {
+                case SIOCGCPICS:
+                        err = cpic_query_side_info(arg);
+                        break;
+                default:
+			break;
+        }
+        return err;
+}
+
+static struct cpic_ops sna_cpic_ops = {
+        PF_SNA,
+	sna_cpic_find_tcb_by_pid,
+        sna_cpic_release_session,
+        sna_cpic_create_session,
+	sna_cmsaeq,
+	sna_cmsac,			/* 5 */
+	sna_cmsacn,
+	sna_cmsapt,
+	sna_cmsbt,
+	sna_cmscsp,
+	sna_cmscst,			/* 10 */
+	sna_cmscsu,
+	sna_cmsct,
+	sna_cmscu,
+	sna_cmsdt,
+	sna_cmsed,			/* 15 */
+	sna_cmsend,
+	sna_cmserr,
+	sna_cmsf,
+	sna_cmsid,
+	sna_cmsld,			/* 20 */
+	sna_cmsmn,
+	sna_cmsndx,
+	sna_cmspdp,
+	sna_cmspid,
+	sna_cmspln,			/* 25 */
+	sna_cmspm,
+	sna_cmsptr,
+	sna_cmsqcf,
+	sna_cmsqpm,
+	sna_cmsrc,			/* 30 */
+	sna_cmsrt,
+	sna_cmssl,
+	sna_cmssrm,
+	sna_cmsst,
+	sna_cmstc,			/* 35 */
+	sna_cmstpn,
+	sna_cmeaeq,
+	sna_cmeapt,
+	sna_cmeacn,
+	sna_cmecs,			/* 40 */
+	sna_cmect,
+	sna_cmectx,
+	sna_cmeid,
+	sna_cmemn,
+	sna_cmepid,			/* 45 */
+	sna_cmepln,
+	sna_cmesi,
+	sna_cmesl,
+	sna_cmesrm,
+	sna_cmesui,			/* 50 */
+	sna_cmetc,
+	sna_cmetpn,
+	sna_cmallc,
+	sna_cmcanc,
+	sna_cmcfmd,			/* 55 */
+	sna_cmcfm,
+	sna_cmdeal,
+	sna_cmrcv,
+	sna_cmdfde,
+	sna_cmacci,			/* 60 */
+	sna_cmwait,			
+	sna_cmsltp,
+	sna_cmflus,
+	sna_cmincl,
+	sna_cmprep,			/* 65 */
+	sna_cmptr,	
+	sna_cmrcvx,
+	sna_cmrts,
+	sna_cmtrts,
+	sna_cminic			/* 70 */
+};
+
+int sna_cpic_create(struct sna_start_node *start)
+{
+        cpic_register(&sna_cpic_ops);
+        return 0;
+}
+
+int sna_cpic_destroy(struct sna_delete_node *delete)
+{
+        cpic_unregister(PF_SNA);
+        return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+	return cpic_get_info_side(buffer, start, offset, length);
+}
+
+int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	struct sna_tcb *cpic;
+	off_t pos = 0, begin = 0;
+	int len = 0;
+
+	len += sprintf(buffer, "%-5s%-6s%-6s\n", "cvid", "state", "flags");
+#ifdef NOT
+	for (cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next) {
+		len += sprintf(buffer + len, "%04X %02X %04X\n",
+			cpic->conversation_id, cpic->state, cpic->flags);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+#endif
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_cs.c linux/net/sna/sna_cs.c
--- linux-2.4.18-clean/net/sna/sna_cs.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_cs.c	Sat Jun  8 16:23:03 2002
@@ -0,0 +1,1679 @@
+/* sna_cs.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/if_arp.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+extern char sna_version[];
+extern char sna_product_id[];
+extern char sna_product_name[];
+
+__u32	sysctl_xid_idle_limit		= SNA_XID_IDLE_LIMIT;
+__u32	sysctl_xid_retry_interval	= SNA_XID_RETRY_INTERVAL;
+__u32	sysctl_xid_retry_limit		= SNA_XID_RETRY_LIMIT;
+
+static LIST_HEAD(cs_clients);
+static LIST_HEAD(dlc_clients);
+
+static __u32	sna_dlc_system_id	= 0;
+static __u32	sna_port_system_id 	= 0;
+static __u32	sna_ls_system_id 	= 0;
+
+int sna_cs_delete_dlc(struct net_device *dev)
+{
+	struct list_head *le, *se;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "init: %s\n", dev->name);
+	list_for_each_safe(le, se, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+		if (!strncmp(dlc->dev->name, dev->name, 8)) {
+			list_del(&dlc->list);
+                        kfree(dlc);
+                        return 0;
+		}
+        }
+	return -ENOENT;
+}
+
+struct sna_cs_pinfo *sna_cs_find(char *name)
+{
+        struct sna_cs_pinfo *cs;
+	struct list_head *le;
+
+	sna_debug(5, "init: %s\n", name);
+	list_for_each(le, &cs_clients) {
+		cs = list_entry(le, struct sna_cs_pinfo, list);
+		if (!strncmp(cs->netid.name, name, SNA_NODE_NAME_LEN))
+                       	return cs;
+	}
+        return NULL;
+}
+
+struct sna_dlc_cb *sna_cs_find_dlc_name(char *name)
+{
+        struct sna_dlc_cb *dlc;
+	struct list_head *le;
+
+	sna_debug(5, "init\n");
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+                if (!strcmp(dlc->dev->name, name))
+			return dlc;
+	}
+        return NULL;
+}
+
+struct sna_port_cb *sna_cs_find_port(struct sna_dlc_cb *dlc, char *saddr)
+{
+        struct sna_port_cb *port;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &dlc->port_list) {
+		port = list_entry(le, struct sna_port_cb, list);
+		sna_debug(5, "p->s(%02X) s(%02X)\n", port->saddr[0], saddr[0]);
+		if (!strncmp(port->saddr, saddr, 1))
+			return port;
+	}
+        return NULL; 
+}
+
+struct sna_ls_cb *sna_cs_find_ls(struct sna_port_cb *port, char *dname,
+	char *daddr)
+{
+        struct sna_ls_cb *ls;
+	struct list_head *le;
+	
+        sna_debug(5, "init\n");
+	list_for_each(le, &port->ls_list) {
+		ls = list_entry(le, struct sna_ls_cb, list);
+		sna_debug(5, "%s %s\n", ls->dname, dname);
+                if (!strncmp(ls->dname, dname, 6) && ls->daddr[0] == daddr[0])
+			return ls;
+	}
+        return NULL;
+}
+
+int sna_cs_shutdown(void)
+{
+        return 0;
+}
+
+int sna_cs_create(struct sna_start_node *start)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_pc_create_parms *pc;
+	struct sna_rm_act_session_rq *as;
+
+	sna_debug(5, "init: %s\n", start->netid.name);
+	cs = sna_cs_find(start->netid.name);
+	if (cs)
+		return -EEXIST;
+	new(cs, GFP_ATOMIC);
+	if (!cs)
+		return -ENOMEM;
+	memcpy(&cs->netid, &start->netid, sizeof(struct sna_netid));
+        memcpy(&cs->nodeid, &start->nodeid, sizeof(struct sna_nodeid));
+	list_add_tail(&cs->list, &cs_clients);
+
+	/* Create the intranode Path Control - One per Node */
+	new(pc, GFP_ATOMIC);
+	if (!pc)
+		return -ENOMEM;
+	pc->type 	= SNA_PC_INTRANODE;
+	pc->dlc		= NULL;
+	pc->port	= NULL;
+	pc->ls		= NULL;
+	memcpy(&pc->fqcp, &cs->netid, sizeof(struct sna_netid));
+	sna_pc_init(pc);
+	memcpy(&cs->intranode_pc_id, &pc->pc_id, 8);
+	kfree(pc);
+	cs->node_type		= start->type;
+
+	/* Activate the loopback link - hidden */
+	new(as, GFP_ATOMIC);
+	if (!as)
+		return -ENOMEM;
+	memcpy(&as->plu_netid, &cs->netid, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "CONNECT");
+	sna_rm_activate_session(as);
+	return 0;
+}
+
+int sna_cs_destroy(struct sna_delete_node *delete)
+{
+	struct list_head *le, *se, *ae, *be, *ce, *de, *ee, *fe;
+	struct sna_cs_pinfo *cs;
+	
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &cs_clients) {
+		cs = list_entry(le, struct sna_cs_pinfo, list);
+                if (!strncmp(cs->netid.name, delete->netid.name, 8)) {
+			struct sna_dlc_cb *dlc;
+			struct sna_port_cb *port;
+			struct sna_ls_cb *ls;
+
+			list_for_each_safe(ae, be, &dlc_clients) {
+				dlc = list_entry(ae, struct sna_dlc_cb, list);
+				list_for_each_safe(ce, de, &dlc->port_list) {
+					port = list_entry(ce, struct sna_port_cb, list);
+					if (strncmp(port->netid.name, 
+						delete->netid.name, 8))
+						break;
+					list_for_each_safe(ee, fe, &port->ls_list) {
+						ls = list_entry(ee, struct sna_ls_cb, list);
+						ls->port 	= NULL;
+						ls->dlc 	= NULL;
+						list_del(&ls->list);
+						kfree(ls);
+						port->ls_qlen--;
+						sna_mod_dec_use_count();
+					}
+
+					switch (port->dev->type) {
+#ifdef CONFIG_SNA_LLC
+                		                case ARPHRD_ETHER:
+                        		        case ARPHRD_IEEE802:
+                        		        case ARPHRD_FDDI:
+							llc_sap_close(port->llc_dl);
+                                		        break;
+#endif
+					}
+					port->dev 	= NULL;
+#ifdef CONFIG_SNA_LLC
+					port->llc_dl	= NULL;
+#endif
+					list_del(&port->list);
+					kfree(port);
+					dlc->port_qlen--;
+					sna_mod_dec_use_count();
+				}
+			}
+
+//			cs->dlc_list = NULL;
+			sna_pc_destroy(cs->intranode_pc_id);
+			list_del(&cs->list);
+                        kfree(cs);
+                        return 0;
+                }
+        }
+	return -ENOENT;
+}
+
+int sna_cs_query_connection_network(int type, 
+	struct sna_query_connection_network *query_connection_network)
+{
+	return 0;
+}
+
+int sna_cs_query_link_station(struct sna_query_link_station *query_link_station)
+{
+#ifdef NOT
+	struct sna_ls_cb *ls_cb;
+        struct sna_cs_pinfo *cs
+                = sna_cs_find(query_link_station->connection_name);
+
+        sna_debug(5, "init\n");
+        if (!cs)
+		return -1;
+        sna_debug(5, "cs != NULL\n");
+	ls_cb = sna_cs_find_ls_name(query_link_station->ls_name);
+		return -1;
+
+	query_link_station->adj_node_type	= ls_cb->adj_node_type;
+	query_link_station->fsm_ls_state	= 0;
+	query_link_station->ls_entered_act_state= ls_cb->ls_entered_act_state;
+	query_link_station->node_act		= ls_cb->node_act;
+	query_link_station->ls_activation	= ls_cb->ls_activation;
+	memcpy(query_link_station->dest_addr, ls_cb->dest_addr, 6);
+	query_link_station->tx_win_size		= ls_cb->tx_win_size;
+	query_link_station->rx_win_size		= ls_cb->rx_win_size;
+	query_link_station->fsm_xid_state	= 0;
+	query_link_station->fsm_nonact_xid_state= 0;
+	query_link_station->fsm_ls_role_state	= 0;
+#endif
+	return 0;
+}
+
+int sna_cs_define_connection_network(
+	struct sna_define_connection_network *define_connection_network)
+{
+	return 0;
+}
+
+int sna_cs_define_dlc(struct net_device *dev)
+{
+	sna_debug(5, "init: %s\n", dev->name);
+	switch (dev->type) {
+#ifdef CONFIG_SNA_LOOPBACK
+		case ARPHRD_LOOPBACK: {
+			struct sna_dlc_cb *dlc;
+			new(dlc, GFP_KERNEL);
+			if (!dlc)
+				return -ENOMEM;
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+                        dlc->port_qlen  = 0;
+			INIT_LIST_HEAD(&dlc->port_list);
+			list_add_tail(&dlc->list, &dlc_clients);
+			break;
+		}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case ARPHRD_ETHER:
+		case ARPHRD_IEEE802:
+		case ARPHRD_FDDI: {
+			struct sna_dlc_cb *dlc;
+			new(dlc, GFP_KERNEL);
+			if (!dlc)
+				return -ENOMEM;
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+			dlc->port_qlen	= 0;
+			INIT_LIST_HEAD(&dlc->port_list);
+			list_add_tail(&dlc->list, &dlc_clients);
+                        break;
+		}
+#endif
+#ifdef CONFIG_SNA_ATM
+		case ARPHRD_ATM:
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case ARPHRD_CHANNEL:
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case ARPHRD_HDLC:
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case ARPHRD_SDLC:
+			break;
+#endif
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+int sna_cs_delete_ls(struct sna_delete_link_station *dls)
+{
+	struct list_head *le, *se;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls;
+	int err = -ENOENT;
+	
+	sna_debug(5, "init\n");
+        cs = sna_cs_find(dls->netid.name);
+        if (!cs)
+		goto out;
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if (!dlc)
+		goto out;
+	port = sna_cs_find_port(dlc, dls->saddr);
+	if (!port)
+		goto out;
+	list_for_each_safe(le, se, &port->ls_list) {
+		ls = list_entry(le, struct sna_ls_cb, list);
+                if (!strcmp(ls->daddr, dls->daddr)
+			&& !strcmp(ls->dname, dls->dname)) {
+			sna_pc_destroy(ls->pc_id);
+			list_del(&ls->list);
+                        kfree(ls);
+			port->ls_qlen--;
+			sna_mod_dec_use_count();
+			err = 0;
+			break;
+                }
+        }
+out:	return err;
+}
+
+int sna_cs_define_ls(struct sna_define_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls;
+	struct sna_pc_create_parms *pc;
+	struct sna_tg_update *tg;
+	unsigned char name[20];
+        int len = 0, err = -ENOENT;
+
+	sna_debug(5, "init\n");
+	cs = sna_cs_find(dls->netid.name);
+	if (!cs)
+		goto out;
+	dlc = sna_cs_find_dlc_name(dls->name);
+	if (!dlc)
+		goto out;
+	port = sna_cs_find_port(dlc, dls->saddr);
+	if (!port)
+		goto out;
+	err = -EEXIST;
+	ls = sna_cs_find_ls(port, dls->dname, dls->daddr);
+	if (ls)
+		goto out;
+	err = -ENOMEM;
+	new(ls, GFP_KERNEL);
+	if (!ls)
+		goto out;
+	memcpy(&ls->netid, &dls->netid, sizeof(struct sna_netid));
+	memcpy(&ls->plu_name, &dls->plu_name, sizeof(struct sna_netid));
+	memcpy(ls->dname, dls->dname, MAX_ADDR_LEN);
+	memcpy(ls->daddr, dls->daddr, SNA_PORT_ADDR_LEN);
+	memcpy(ls->devname, dls->name, 8);
+	ls->sport	= dls->saddr[0];
+	ls->auto_act	= dls->autoact;
+	ls->auto_deact	= dls->autodeact;
+	ls->port	= port;
+	ls->dlc		= dlc;
+	ls->flags	= (SNA_UP | SNA_STOPPED);
+	ls->proc_id	= sna_ls_system_id++;
+	list_add_tail(&ls->list, &port->ls_list);
+	port->ls_qlen++;
+
+	/* Update this TG */
+	new(tg, GFP_ATOMIC);
+	if (!tg)
+		goto out;
+        if (!ls->tg_id)
+                sna_tdm_init_tg_update(tg);
+        memcpy(&tg->tg_desc.dlc.mac, &ls->dname, MAX_ADDR_LEN);
+	tg->dev				= port->dev;
+	tg->lsap			= port->saddr[0];
+        tg->node_type                   = cs->node_type;
+        tg->tg_desc.dlc.lsap            = ls->daddr[0];
+        tg->tg_desc.id.pcp_len = len = sna_netid_to_char(&port->netid, name);
+	new_s(tg->tg_desc.id.pcp_name, len + 1, GFP_ATOMIC);
+	if (!tg->tg_desc.id.pcp_name)
+		goto out;
+	strcpy(tg->tg_desc.id.pcp_name, name);
+        err = sna_tdm_tg_update(tg);
+        if (err < 0) {
+		sna_debug(5, "tg_update failed `%d'.\n", err);
+		goto out;
+	}
+
+	/* Create Internode PC instance - our side of the link */
+	err = -ENOMEM;
+	new(pc, GFP_ATOMIC);
+	if (!pc)
+		goto out;
+	err = 0;
+	memcpy(&pc->fqcp, &ls->netid, sizeof(struct sna_netid));
+	pc->type 	= SNA_PC_INTERNODE;
+	pc->dlc		= dlc;
+	pc->ls		= ls;
+	pc->port	= port;
+	pc->max_tx_btu	= dlc->dev->mtu;
+	pc->max_rx_btu	= dlc->dev->mtu;
+	sna_pc_init(pc);
+	memcpy(&ls->pc_id, &pc->pc_id, 8);
+	kfree(pc);
+	sna_mod_inc_use_count();
+out:	sna_debug(5, "fini: %d\n", err);
+	return err;
+}
+
+int sna_cs_delete_port(struct sna_delete_port *dport)
+{
+	struct list_head *le, *se;
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "init: (%s, %s)\n", dport->name,dport->saddr);
+	cs = sna_cs_find(dport->netid.name);
+	if (!cs)
+		return -ENOENT;
+	dlc = sna_cs_find_dlc_name(dport->name);
+        if (!dlc)
+                return -ENOENT;
+	list_for_each_safe(le, se, &dlc->port_list) {
+		port = list_entry(le, struct sna_port_cb, list);
+                if (!strcmp(port->saddr, dport->saddr)) {
+			switch (port->dev->type) {
+#ifdef CONFIG_SNA_LLC
+				case ARPHRD_ETHER:
+				case ARPHRD_IEEE802:
+				case ARPHRD_FDDI:
+					llc_sap_close(port->llc_dl);
+					break;
+#endif
+#ifdef CONFIG_SNA_ATM
+				case ARPHRD_ATM:
+					break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+				case ARPHRD_CHANNEL:
+					break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+				case ARPHRD_HDLC:
+					break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+				case ARPHRD_SDLC:
+					break;
+#endif
+				default:
+					break;
+			}
+			list_del(&port->list);
+                        kfree(port);
+			dlc->port_qlen--;
+			sna_mod_dec_use_count();
+                        return 0;
+                }
+        }
+	return -ENOENT;
+}
+
+int sna_cs_define_port(struct sna_define_port *dport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "init\n");
+	cs = sna_cs_find(dport->netid.name);
+	if (!cs)
+		return -ENOENT;
+	dlc = sna_cs_find_dlc_name(dport->name);
+	if (!dlc)
+		return -ENOENT;
+	port = sna_cs_find_port(dlc, dport->saddr);
+	if (port)
+		return -EEXIST;
+	new(port, GFP_ATOMIC);
+	if (!port)
+		return -ENOMEM;
+	memcpy(&port->netid, &dport->netid, sizeof(struct sna_netid));
+	memcpy(&port->saddr, &dport->saddr, SNA_PORT_ADDR_LEN);
+	port->dev	= dlc->dev;
+	port->proc_id	= sna_port_system_id++;
+	port->flags	= (SNA_UP | SNA_STOPPED);
+	INIT_LIST_HEAD(&port->ls_list);
+	port->ls_qlen	= 0;
+	port->btu	= dport->btu;
+	port->mia	= dport->mia;
+	port->moa	= dport->moa;
+
+	switch (dport->role) {
+		case SNA_PORT_ROLE_PRI:
+		case SNA_PORT_ROLE_SEC:
+		case SNA_PORT_ROLE_NEG:
+			port->role = dport->role;
+			break;
+		default:
+			return -EINVAL;
+	}
+	list_add_tail(&port->list, &dlc->port_list);
+        dlc->port_qlen++;
+	sna_mod_inc_use_count();
+	return 0;
+}
+
+int sna_cs_query_statistics(struct sna_query_stats *qs)
+{
+
+	return 0;
+}
+
+int sna_cs_start_ls(struct sna_start_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+//	struct sna_tg_update *tg;
+	struct sna_rm_act_session_rq *as;
+//	unsigned char name[20];
+//	int len = 0, err;
+
+        sna_debug(5, "init\n");
+        cs = sna_cs_find(dls->netid.name);
+        if (!cs)
+                return -ENOENT;
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if (!dlc)
+                return -ENOENT;
+        port = sna_cs_find_port(dlc, dls->saddr);
+        if (!port)
+                return -ENOENT;
+        ls = sna_cs_find_ls(port, dls->dname, dls->daddr);
+        if (!ls)
+                return -ENOENT;
+
+	ls->flags     &= ~SNA_STOPPED;
+        ls->flags     |= SNA_RUNNING;
+
+	new(as, GFP_ATOMIC);
+	if (!as)
+		return -ENOMEM;
+	as->tcb_id	= ls->proc_id;
+	memcpy(&as->plu_netid, &dls->netid_plu, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "#BATCH");
+	sna_rm_activate_session(as);
+	return 0;
+}
+
+/* Start the "port". Depending on the underlying device and
+ * network type and what DLC support we have enabled we will
+ * start the DLC specific actions to start the DLC to send up
+ * packets. We mux all similar DLC types into the same rx
+ * handlers and demux it there. Actual specific DLC handlers are
+ * located in sna_dlc.c.
+ */
+int sna_cs_start_port(struct sna_start_port *sport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "init\n");
+	cs = sna_cs_find(sport->netid.name);
+	if (!cs)
+		return -ENOENT;
+	dlc = sna_cs_find_dlc_name(sport->name);
+	if (!dlc)
+		return -ENOENT;
+	port = sna_cs_find_port(dlc, sport->saddr);
+	if (!port)
+		return -ENOENT;
+
+	switch (port->dev->type) {
+#ifdef CONFIG_SNA_LOOPBACK
+		case ARPHRD_LOOPBACK:
+			break;
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case ARPHRD_ETHER:
+		case ARPHRD_IEEE802:
+		case ARPHRD_FDDI:
+			port->flags |= SNA_UP;
+			port->llc_dl = llc_sap_open(sna_dlc_llc_indicate,
+				sna_dlc_llc_confirm, port->saddr[0]);
+			if (!port->llc_dl) {
+				sna_debug(5, "Unable to register 8022 client\n");
+				return -1;
+			}
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case ARPHRD_ATM:
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case ARPHRD_CHANNEL:
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case ARPHRD_SDLC:
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case ARPHRD_HDLC:
+			break;
+#endif
+
+		default:
+			return -EINVAL;
+	}
+
+	port->flags	&= ~SNA_STOPPED;
+	port->flags	|= SNA_RUNNING;
+	return 0;
+}
+
+int sna_cs_stop_ls(struct sna_stop_link_station *sls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+	struct sna_tg_cb *tg;
+
+        sna_debug(5, "init\n");
+        cs = sna_cs_find(sls->netid.name);
+        if (!cs)
+                return -ENOENT;
+        dlc = sna_cs_find_dlc_name(sls->name);
+        if (!dlc)
+                return -ENOENT;
+        port = sna_cs_find_port(dlc, sls->saddr);
+        if (!port)
+                return -ENOENT;
+        ls = sna_cs_find_ls(port, sls->dname, sls->daddr);
+        if (!ls)
+                return -ENOENT;
+	tg = sna_tdm_find_tg_by_id(ls->tg_id);
+	if (tg) {
+		del_timer(&tg->co_retry);
+		tg->co_status = CO_RESET;
+		tg->co_retries = 0;
+	}
+
+	ls->flags &= ~SNA_RUNNING;
+	ls->flags |= SNA_STOPPED;
+
+#ifdef NOT
+	/* Send formal disconnect to partner if link is active */
+	if (tg->xid_info != NULL) {
+		if (tg->xid_info->xid_status == XID_ACTIVE)
+			llc_disconnect(port->llc_dl, port->dev, 
+				tg->tg_vector.desc.dlc.mac,
+				tg->tg_vector.desc.dlc.lsap, 0);
+	}
+#endif
+	return 0;
+}
+
+int sna_cs_stop_port(struct sna_stop_port *sport)
+{
+	struct sna_port_cb *port;
+        struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+
+        sna_debug(5, "init\n");
+        cs = sna_cs_find(sport->netid.name);
+        if (!cs)
+                return -ENOENT;
+        dlc = sna_cs_find_dlc_name(sport->name);
+        if (!dlc)
+                return -ENOENT;
+        port = sna_cs_find_port(dlc, sport->saddr);
+        if (!port)
+                return -ENOENT;
+
+        switch (port->dev->type) {
+#ifdef CONFIG_SNA_LLC
+		case ARPHRD_ETHER:
+                case ARPHRD_IEEE802:
+                case ARPHRD_FDDI:
+			port->flags &= ~SNA_RUNNING;
+			port->flags |= SNA_STOPPED;
+			llc_sap_close(port->llc_dl);
+			/* Need to wait for the correct event response. */
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case ARPHRD_ATM:
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case ARPHRD_CHANNEL:
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case ARPHRD_HDLC:
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case ARPHRD_SDLC:
+			break;
+#endif
+	}
+	return 0;
+}
+
+int sna_dlc_ginfo(struct sna_dlc_cb *dlc, char *buf, int len)
+{
+	struct dlcreq dr;
+	int done = 0;
+
+	sna_debug(5, "init\n");
+	if (!buf) {
+                done += sizeof(dr);
+                return done;
+        }
+        if (len < (int)sizeof(dr))
+                return done;
+        memset(&dr, 0, sizeof(struct dlcreq));
+
+        /* Move the data here */
+//	strncpy(dr.dlc_net, cs->netid.net, 8);
+//	strncpy(dr.dlc_name, cs->netid.name, 8);
+	strncpy(dr.devname, dlc->dev->name, SNA_RESOURCE_NAME_LEN);
+	dr.port_qlen		= dlc->port_qlen;
+	dr.proc_id 		= dlc->proc_id;
+	dr.flags 		= dlc->flags;
+
+        if (copy_to_user(buf, &dr, sizeof(struct dlcreq)))
+                return -EFAULT;
+        buf  += sizeof(struct dlcreq);
+        len  -= sizeof(struct dlcreq);
+        done += sizeof(struct dlcreq);
+	return done;
+}
+
+int sna_cs_query_dlc(char *arg)
+{
+        struct sna_dlc_cb *dlc;
+	struct list_head *le;
+	int len, total, done;
+        struct dlconf dc;
+        char *pos;
+
+        sna_debug(5, "sna_cs_query_dlc\n");
+        if (copy_from_user(&dc, arg, sizeof(dc)))
+                return -EFAULT;
+
+        pos = dc.dlc_buf;
+        len = dc.dlc_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+                if (pos == NULL)
+                        done = sna_dlc_ginfo(dlc, NULL, 0);
+                else
+                        done = sna_dlc_ginfo(dlc, pos + total, len - total);
+                if (done < 0)
+                        return -EFAULT;
+                total += done;
+        }
+
+        dc.dlc_len = total;
+        if (copy_to_user(arg, &dc, sizeof(dc)))
+                return -EFAULT;
+        return 0;
+}
+
+int sna_port_ginfo(struct sna_port_cb *port, char *buf, int len)
+{
+        struct portreq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_port_ginfo\n");
+        if (!buf) {
+                done += sizeof(pr);
+                return done;
+        }
+        if (len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct portreq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &port->netid, sizeof(struct sna_netid));
+	strncpy(pr.devname, port->dev->name, SNA_RESOURCE_NAME_LEN);
+	memcpy(&pr.saddr, port->saddr, 12);
+	pr.ls_qlen	= port->ls_qlen;
+	pr.proc_id	= port->proc_id;
+	pr.flags	= port->flags;
+	pr.role		= port->role;
+	pr.btu		= port->btu;
+	pr.mia		= port->mia;
+	pr.moa		= port->moa;
+
+        if (copy_to_user(buf, &pr, sizeof(struct portreq)))
+                return -EFAULT;
+        buf  += sizeof(struct portreq);
+        len  -= sizeof(struct portreq);
+        done += sizeof(struct portreq);
+        return done;
+}
+
+int sna_cs_query_port(char *arg)
+{
+	struct list_head *le, *se;
+	struct sna_port_cb *port;
+	struct sna_dlc_cb *dlc;
+	int len, total, done;
+	struct portconf pc;
+        char *pos;
+
+        sna_debug(10, "init\n");
+        if (copy_from_user(&pc, arg, sizeof(pc)))
+                return -EFAULT;
+        pos = pc.portc_buf;
+        len = pc.port_len;
+
+	/*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+		list_for_each(se, &dlc->port_list) {
+			port = list_entry(se, struct sna_port_cb, list);
+	                if (pos == NULL)
+	                        done = sna_port_ginfo(port, NULL, 0);
+	                else
+	                        done = sna_port_ginfo(port,pos+total,len-total);
+	                if (done < 0)
+	                        return -EFAULT;
+	                total += done;
+	        }
+	}
+        pc.port_len = total;
+        if (copy_to_user(arg, &pc, sizeof(pc)))
+                return -EFAULT;
+	return 0;
+}
+
+int sna_ls_ginfo(struct sna_ls_cb *ls, char *buf, int len)
+{
+        struct lsreq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_ls_ginfo\n");
+        if (!buf) {
+                done += sizeof(lr);
+                return done;
+        }
+        if (len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lsreq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &ls->netid, sizeof(struct sna_netid));
+	memcpy(&lr.devname, ls->devname, SNA_RESOURCE_NAME_LEN);
+	memcpy(&lr.dname, ls->dname, SNA_FQCP_NAME_LEN);
+	memcpy(&lr.daddr, ls->daddr, 12);
+	lr.sport	= ls->sport;
+	lr.proc_id	= ls->proc_id;
+	lr.flags	= ls->flags;
+	lr.auto_act	= ls->auto_act;
+	lr.auto_deact	= ls->auto_deact;
+
+        if (copy_to_user(buf, &lr, sizeof(struct lsreq)))
+                return -EFAULT;
+        buf  += sizeof(struct lsreq);
+        len  -= sizeof(struct lsreq);
+        done += sizeof(struct lsreq);
+        return done;
+}
+
+int sna_cs_query_ls(char *arg)
+{
+	struct sna_port_cb *port;
+	struct sna_dlc_cb *dlc;
+        int len, total, done;
+	struct sna_ls_cb *ls;
+	struct list_head *le, *se, *ae;
+	struct lsconf lc;
+        char *pos;
+
+       	sna_debug(10, "init\n");
+        if (copy_from_user(&lc, arg, sizeof(lc)))
+                return -EFAULT;
+        pos = lc.lsc_buf;
+        len = lc.ls_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+		list_for_each(se, &dlc->port_list) {
+			port = list_entry(se, struct sna_port_cb, list);
+			list_for_each(ae, &port->ls_list) {
+				ls = list_entry(ae, struct sna_ls_cb, list);
+		                if (pos == NULL)
+		                        done = sna_ls_ginfo(ls, NULL, 0);
+		                else
+			                done = sna_ls_ginfo(ls,pos+total,len-total);
+		                if (done < 0)
+		                        return -EFAULT;
+		                total += done;
+		        }
+		}
+	}
+        lc.ls_len = total;
+        if (copy_to_user(arg, &lc, sizeof(lc)))
+                return -EFAULT;
+        return 0;
+}
+
+/* Build a specified Xid control vector at the specified memory location,
+ * we build it using dynamic data were applicable.
+ */
+int sna_cs_build_xid_cv(struct sna_tg_cb *tg, struct sk_buff *skb, __u8 type)
+{
+	int len = 0, size;
+	unsigned char name[50], scratch[50];
+	__u8 l, s, r, *cv_start;
+
+	sna_debug(10, "init: %d -%s-\n",
+		tg->tg_vector.desc.id.pcp_len, 
+		tg->tg_vector.desc.id.pcp_name);
+
+	switch (type) {
+		case CV_KEY_NETNAME:
+			size = 1 + 3 + tg->tg_vector.desc.id.pcp_len;
+			cv_start = (__u8 *)skb_put(skb, size);
+			len = 1;
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+			l = tg->tg_vector.desc.id.pcp_len + 1;
+                        memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+			r = CV_CP_NAME;
+			memcpy(cv_start + len, &r, sizeof(__u8));
+			len += sizeof(__u8);
+			fatoe_strncpy(name, tg->tg_vector.desc.id.pcp_name,
+				tg->tg_vector.desc.id.pcp_len);
+			memcpy(cv_start + len, name, 
+				tg->tg_vector.desc.id.pcp_len);
+			len += tg->tg_vector.desc.id.pcp_len;
+			break;
+
+		case CV_KEY_PRODUCT_ID:
+			memset(scratch, 0, 50);
+			sprintf(scratch, "%s %s", sna_product_name,sna_version);
+			size = 10 + strlen(sna_product_id) + strlen(scratch);
+                        cv_start = (__u8 *)skb_put(skb, size);
+
+			/* Cv type */
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* entire length of cv */
+			l = (6 + strlen(sna_product_id))+(2 + strlen(scratch));
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* Length of data fields */
+			l = 2 + strlen(sna_product_id) + 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* Common SV code */
+			s = 0x11;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* version length */
+			l = 2 + strlen(sna_product_id);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* version codec */
+			s = 0x02;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual version */
+			atoe_strncpy(name, sna_product_id, 
+				strlen(sna_product_id));
+			memcpy(cv_start + len, name, strlen(sna_product_id));
+			len += strlen(sna_product_id);
+
+			/* Product Name length */
+			l = 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* product name codec */
+			s = 0x06;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual product name */
+			memset(name, 0, 50);
+			fatoe_strncpy(name, scratch, strlen(scratch));
+                        memcpy(cv_start + len, name, strlen(scratch));
+			len += strlen(scratch);
+			break;
+	}
+	return len;
+}
+
+/* Initialize an XID, we load any defaults and initialize any fields
+ * that we have the data provided in sna_tg_cb. The xid is not valid
+ * when this function finishes, we return the length of data added.
+ */
+sna_xid3 *sna_cs_init_xid(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	struct sna_nodeid *n;
+	sna_xid3 *xid;
+
+	sna_debug(5, "init\n");
+	xid = (sna_xid3 *)skb_push(skb, sizeof(sna_xid3));
+        xid->xid_node           	= SNA_XID_NODE_T2;
+        xid->xid_type           	= SNA_XID_TYPE_3;
+        xid->nc1                	= 0x00;
+	xid->nc2			= 0x00;
+        xid->tx_adptv_bind_pacing	= 1;
+        xid->rx_adprv_bind_pacing	= 1;
+        xid->quiesce_tg_req      	= 0;
+        xid->pu_cap_sup          	= 1;
+        xid->appn_pbn            	= 0;
+        xid->adptv_bind_pacing   	= 0x01;
+        xid->tg_sharing_prohibited 	= 0;
+        xid->dedicated_scv       	= 0;
+        xid->parallel_tg_sup     	= 0;
+        xid->dlur_actpu          	= 0;
+        xid->dlus_lu_reg         	= 1;
+        xid->gen_odai_usage_opt_set 	= 0;
+        xid->dlc_type           	= 0x01;
+        xid->dlc_len            	= 11;
+	xid->ls_flags			= 0x00;
+	xid->dlc_init_mode      	= 1;
+
+	/* only dynamic inits for now. */
+	n = sna_nof_find_nodeid(sna_char_to_netid
+		(tg->tg_vector.desc.id.pcp_name));
+	if (n) {
+		xid->block_id	= n->block_id;
+		xid->pu_id	= n->pu_id;
+	}
+
+	sna_debug(5, "Nodeid is %X %X\n", xid->block_id, xid->pu_id);
+	xid->tg_num             = tg->tg_vector.desc.id.tg_number;
+        xid->max_btu_len	= htons(tg->dev->mtu);
+        xid->max_rx_iframes 	= 0x07;
+	return xid;
+}
+
+/* Build a complete XID header. This is done by using the data we
+ * have saved and by using the existing state information.
+ * We receive an SKB will space allocated for the MAC header, we need
+ * to push on enough space for the DL header and XID header, then we
+ * return the skb.
+ */
+int sna_cs_build_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+	struct sk_buff *skb;
+	int size, len, err;
+	sna_xid3 *x3;
+	
+	sna_debug(5, "init\n");
+	switch (xid->xid_status) {
+		case XID_S_NULL:
+			sna_debug(5, "sending NULL XID\n");
+			size = sna_dlc_xid_min_len(tg) + 150;   /* static max for now. */
+		        skb = alloc_skb(size, GFP_ATOMIC);
+		        if (!skb)
+		                return -ENOMEM;
+		        sna_dlc_xid_reserve(tg, skb);
+			break;
+		case XID_S_NEG:
+			size = sna_dlc_xid_min_len(tg) + sizeof(*x3) + 150;
+                        skb = alloc_skb(size, GFP_ATOMIC);
+                        if (!skb)
+                                return -ENOMEM;
+                        sna_dlc_xid_reserve(tg, skb);
+			x3   = sna_cs_init_xid(tg, skb);
+			len  = sizeof(sna_xid3);
+			len += sna_cs_build_xid_cv(tg, skb, CV_KEY_NETNAME);
+                        len += sna_cs_build_xid_cv(tg, skb, CV_KEY_PRODUCT_ID);
+			x3->len 	= len;
+			x3->nc2        	= 0xF7;
+			x3->ls_flags   	= 0x41;
+			break;
+		case XID_ACTIVE:
+		case XID_S_PN:
+		case XID_S_PRI:
+		case XID_S_SEC:
+		case XID_FAIL:
+		default:
+			sna_debug(5, "unable to handle XID tossing\n");
+			return -1;
+	}
+
+	if (sna_debug_level >= 5) {
+                sna_debug(5, "check out the Xids\n");
+                hexdump(skb->data, skb->len);
+        }
+
+	/* cache a local copy and then transmit this xid.  */
+	xid->xid_count++;
+	if (xid->last_tx_xid != NULL)
+		kfree_skb(xid->last_tx_xid);
+	xid->last_tx_xid = skb_copy(skb, GFP_ATOMIC);
+	if (xid->xid_direction == XID_OUTBOUND)
+		err = sna_dlc_xid_req(tg, skb);
+	else
+		err = sna_dlc_xid_rsp(tg, skb);
+	sna_debug(5, "xid_x error is %d\n", err);
+	return err;
+}
+
+int sna_cs_xid_xchg_state(struct sk_buff *skb)
+{
+	sna_xid3 *xid = (sna_xid3 *)&skb->data[3];
+
+	sna_debug(5, "init: %02X, len = %d\n", xid->nc2, skb->len);
+	if (skb->len == 3)
+		return XID_NULL;
+
+	if (xid->nc2 == 0xFB)
+		return XID_PN;
+
+	if (xid->nc2 == 0xF7)
+		return XID_NEG;
+	else
+		return -1;
+
+	return 0;
+}
+
+int sna_cs_fsm_tgn_neg(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_fsm_tgn_neg\n");
+
+	return 0;
+}
+
+int sna_cs_validate_adjacent_node_id(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_validate_adjacent_node_id\n");
+
+	return 0;
+}
+
+int sna_cs_xid_error_chk(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_xid_error_chk\n");
+
+	return 0;
+}
+
+int sna_cs_process_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "init\n");
+	switch (xid->xid_status) {
+		case XID_RESET:		/* Send XID PN Cmd or Rsp */
+		case XID_S_NULL:	/* last tx xnull timed out, retry */
+			xid->xid_status = XID_S_NULL;
+			sna_cs_build_xid(tg);
+			break;
+
+		/* received a xid null, this could be a poll or a resposne */
+		case XID_R_NULL:
+			sna_debug(5, "Received an XID_R_NULL can proceed\n");
+			if (xid->xid_initiator)	{		/* rx poll */
+				sna_debug(5, "Sending an Null Xid Response\n");
+				xid->xid_status = XID_S_NULL;	/* tx final */
+				sna_cs_build_xid(tg);
+			} else { /* rx final, proceed to next state */
+				xid->xid_status = XID_S_NEG;
+				/* Will be followed by a Xid Poll sent by the
+				 * remote side, then we will proceed to actually
+				 * sending the NEG xid in case (XID_S_NEG).
+				 * sna_cs_build_xid(tg);
+				 */
+			}
+			break;
+
+		/* At this point we have verified the host exists and have
+		 * exchanged NULL Xids. We now start to negotiate the options.
+		 */
+		case XID_S_NEG:
+			sna_debug(5, "Permission to send NEG XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case XID_R_NEG:
+			sna_debug(5, "Responding with another NEG\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case XID_ACTIVE:
+                        sna_debug(5, "Active XID estabilished\n");
+                        xid->xid_retries = 0;
+			wake_up_interruptible(&tg->sleep);
+			break;
+
+		case XID_R_PN:
+			sna_debug(5, "I see a Pre Neg XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case XID_S_PN:
+		case XID_FAIL:
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return -1;
+	}
+	return 0;
+}
+
+/* Only called if we have an incomming XID, this is basicly the same as
+ * connect_out(), just from the other side.
+ */
+int sna_cs_connect_in(struct sna_tg_cb *tg, struct sk_buff *skb, 
+	struct net_device *dev)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "init\n");
+	if (sna_debug_level > 5)
+		hexdump(skb->data, skb->len);
+
+	/* xid is one of ours increase the count */
+	xid->xid_count++;
+
+	/* determine type of xid packet */
+        switch (sna_cs_xid_xchg_state(skb)) {
+                case XID_NULL:
+			/* Reveived Null Xid Poll, send response */
+			if (xid->xid_status == XID_RESET) {
+				tg->co_status 		= CO_TEST_OK;
+				xid->xid_initiator 	= 1;		/* remote */
+				xid->xid_direction 	= XID_INBOUND;
+				xid->xid_status 	= XID_R_NULL;
+				break;
+			}
+
+			if (!xid->xid_initiator && xid->xid_status == XID_S_NEG) {
+				sna_debug(5, "Some funky shit happen'n here\n");
+                        	break;
+			} else {
+				sna_debug(5, "Can't handle NULL XID\n");
+				kfree_skb(skb);
+				return -1;
+			}
+
+                case XID_NEG:
+			sna_debug(5, "Received an XID NEG\n");
+			xid->xid_direction 	= XID_INBOUND;
+			xid->xid_status 	= XID_S_NEG;
+			break;
+
+                case XID_PN:
+			xid->xid_direction 	= XID_INBOUND;
+			xid->xid_status 	= XID_S_NEG;
+			break;
+
+		default:
+        		sna_debug(5, "Got XID not handle ignoring\n");
+			kfree_skb(skb);
+			return -1;
+	}
+
+	/* we need to do further processing on this xid, save then do it. */
+	if (xid->last_rx_xid != NULL)
+        	kfree_skb(xid->last_rx_xid);
+        xid->last_rx_xid = skb;
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+	return 0;
+}
+
+/**
+ * sna_cs_connect_out - init and xid connection state machine.
+ * 			perform all necessary functions to bind a link up.
+ */
+void sna_cs_connect_out(unsigned long data)
+{
+	struct sna_tg_cb *tg = (struct sna_tg_cb *)data;
+	struct sna_xid_info *xid = tg->xid_info;
+	int err;
+	
+	sna_debug(5, "init: (test %d %d) (xid %d %d)\n", 
+		tg->co_retries, tg->co_max_retries, xid->xid_retries, 
+		xid->xid_retry_limit);
+	del_timer(&tg->co_retry);
+	switch (tg->co_status) {
+		case CO_RESET:
+		case CO_S_TEST_C:
+			if (tg->co_retries < tg->co_max_retries) {
+				tg->co_status = CO_S_TEST_C;
+				tg->co_retries++;
+				err = sna_dlc_test_req(tg);
+				sna_debug(5, "dlc_test_req err = %d\n", err);
+				tg->co_retry.expires = jiffies+tg->co_interval;
+				add_timer(&tg->co_retry);
+			} else
+				tg->co_status = CO_FAIL;
+			return;
+		case CO_R_TEST_R:	/* Received valid TEST rsp */
+			tg->co_status = CO_TEST_OK;
+			/* Fall through */
+
+		case CO_TEST_OK:
+			tg->co_retries = 0;
+			break;
+
+		case CO_FAIL:
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return;
+	}
+
+	switch (xid->xid_status) {
+		/* Null Xid poll failed, retry */
+		case XID_S_NULL:
+			xid->xid_direction 	= XID_OUTBOUND;
+			xid->xid_status 	= XID_S_NULL;
+			break;
+		case XID_R_NEG:
+			xid->xid_direction 	= XID_OUTBOUND;
+			break;
+		default:
+//                      sna_debug(5, "Got XID not handle ignoring\n");
+//			xid->xid_status = XID_RESET;
+			break;
+	}
+
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+	return;
+}
+
+/**
+ * sna_cs_activate_route - negotiate the actual connection. ie perform XID.
+ *
+ * currently blocks for debug purposes. This will be:
+ * sna_cs_activate_route
+ *   connect_out
+ *   return;
+ *
+ * connect_out (timer expire or xid finished).
+ *   sna_cs_activate_route_finish
+ *   return;
+ */
+int sna_cs_activate_route(struct sna_activate_route *ar)
+{
+	struct sna_tdm_node_cb *nc;
+	struct sna_tg_cb *tg;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_pc_pinfo *pc;
+	struct sna_pc_create_parms *pp;
+	struct sna_activate_as *as;
+	char tsap[3];		/* XXX */
+
+	sna_debug(5, "init: %s\n",sna_pr_netid(&ar->cp_name));
+	pc = sna_pc_find_by_netid(&ar->cp_name);
+	if (pc) {
+		sna_debug(5, "found an already active route\n");
+		/* route is already active, this can be either a loopback
+		 * connection or an actual physical connection. No further
+		 * XID negotiation is needed. We just return the Path Control
+		 * ID.
+		 */
+		memcpy(&ar->pc_id, &pc->pc_id, 8);
+		return 0;
+	}
+
+/*
+	nc = sna_tdm_find_node_entry(&ar->cp_name);
+	if (!nc)
+		return -ENOENT;
+	tc = sna_tdm_find_tg(nc, ar->tg_id);
+*/
+	tg = sna_tdm_find_tg_by_id(ar->tg_id);
+	if (!tg)
+		return -ENOENT;
+	cs = sna_cs_find("EHEAD   ");
+//	cs = sna_cs_find(ar->cp_name.name);
+	if (!cs)
+		return -ENOENT;
+	dlc = sna_cs_find_dlc_name("eth0");
+	if (!dlc)
+		return -ENOENT;
+	tsap[0] = 0x04;
+	port = sna_cs_find_port(dlc, tsap);
+	if (!port)
+		return -ENOENT;
+
+	/* this will be located elsewhere when we restructure. */
+#ifdef CONFIG_SNA_LLC
+	tg->type = ARPHRD_ETHER;
+	tg->llc_addr.ssap = 0x04;
+	tg->llc_addr.dsap = tg->tg_vector.desc.dlc.lsap;
+	memset(&tg->llc_addr.smac, 0, IFHWADDRLEN);
+	memcpy(&tg->llc_addr.dmac, &tg->tg_vector.desc.dlc.mac, IFHWADDRLEN);
+	tg->llc_dl = port->llc_dl;
+#endif
+	tg->co_status 			= CO_RESET;
+	tg->xid_info->xid_status 	= XID_RESET;
+	tg->xid_info->xid_initiator 	= 0x00;		/* US */
+	tg->xid_info->xid_direction	= XID_OUTBOUND;
+	sna_cs_connect_out((unsigned long)tg);
+
+	sna_debug(5, "sleep now\n");
+	/* Now we must wait for the link activation to complete */
+	cli();
+	interruptible_sleep_on(&tg->sleep);
+        if (signal_pending(current)) {
+        	sti();
+		return -ERESTARTSYS;
+	}
+	sti();
+
+	sna_debug(5, "woke from sleep.. why?\n");
+
+	/* check reason for being woken up.. test/xid failed, or success */
+	if (tg->co_status != CO_TEST_OK 
+		&& tg->xid_info->xid_status != XID_ACTIVE) {
+		sna_debug(5, "failed activation\n");
+		return -ENONET;	/* test/xid link activation failed */
+	}
+
+	/* we now have an activated link, lets finish her up */
+	new(pp, GFP_ATOMIC);
+	if (!pp)
+		return -ENOMEM;
+	memcpy(&pp->fqcp, &cs->netid, sizeof(struct sna_netid));
+	pp->dlc		= dlc;
+	pp->ls		= NULL;
+	pp->port	= port;
+	pp->type	= 0;
+	pp->max_tx_btu	= 0; 
+	pp->max_rx_btu	= 0;
+	pp->bind_seg	= 0;
+	pp->limited_tg	= 0;
+	pp->tg_number	= ar->tg_id;
+	pp->odai	= 0;
+	pp->local_seg	= 0;
+	pp->godai	= 0;
+	sna_pc_init(pp);
+	memcpy(&ar->pc_id, &pp->pc_id, 8);
+	kfree(pp);
+
+	/* lets finally activate this links address space and return */
+	new(as, GFP_ATOMIC);
+	if (!as)
+		return -ENOMEM;
+	memcpy(&as->pc_id, &ar->pc_id, 8);
+	as->intranode			= 0;
+	as->odai			= 0;
+	as->max_btu			= 0;
+	as->tx_rx_bind_pacing 		= 0;
+	as->dependent_lulu 		= 0;
+	as->adp_bind_pacing_dep_lulu 	= 0;
+	as->generalized_oadi 		= 0;
+	sna_asm_activate_as(as);
+	kfree(as);
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length)
+{
+        off_t pos = 0, begin = 0;
+	struct sna_dlc_cb *dlc;
+	struct list_head *le;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-7s%-8s%-6s%-10s\n", "dlc_id", 
+		"name", "flags", "port_qlen");
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+                len += sprintf(buffer + len, "%-7d%-8s%02X    %-10d\n", 
+			dlc->proc_id, dlc->dev->name, dlc->flags,
+			dlc->port_qlen);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+
+int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length)
+{
+	off_t pos = 0, begin = 0;
+        struct sna_port_cb *port;
+	struct sna_dlc_cb *dlc;
+	struct list_head *le, *se;
+        int len = 0;
+
+        /* Output the Port data for the /proc filesystem. */
+        len += sprintf(buffer, "%-17s%-8s%-7s%-5s%-5s%-5s%-5s%-6s%-8s\n", 
+		"NetID.Node",
+		"port_id", "device", "port", "btu", "mia", "moa", "flags", 
+		"ls_qlen");
+
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+		list_for_each(se, &dlc->port_list) {
+			port = list_entry(se, struct sna_port_cb, list);
+			len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&port->netid));
+        	        len += sprintf(buffer + len, "%-8d%-7s%02X   %-5d%-5d%-5d%02X    %-8d\n", 
+				port->proc_id,
+        	                port->dev->name, port->saddr[0], port->btu,
+				port->mia, port->moa, port->flags,
+				port->ls_qlen);
+	
+			pos = begin + len;
+	                if (pos < offset) {
+	                        len = 0; 
+				begin = pos;
+       	         	}
+                	if (pos > offset + length)
+                        	break;
+        	}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+
+int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length)
+{
+        off_t pos = 0, begin = 0;
+	struct sna_port_cb *port;
+	struct sna_dlc_cb *dlc;
+        struct sna_ls_cb *ls;
+	struct list_head *le, *se, *ae;
+        int len = 0;
+
+        /* Output the Link Station data for the /proc filesystem. */
+        len += sprintf(buffer, "%-18s%6s%7s%5s%13s%6s%5s%7s%6s\n", 
+		"NetID.Node", "ls_id", "device", "port", "adjacent_mac",
+		"aport", "aact", "adeact", "flags");
+	list_for_each(le, &dlc_clients) {
+		dlc = list_entry(le, struct sna_dlc_cb, list);
+		list_for_each(se, &dlc->port_list) {
+			port = list_entry(se, struct sna_port_cb, list);
+			list_for_each(ae, &port->ls_list) {
+				ls = list_entry(ae, struct sna_ls_cb, list);
+                        	len += sprintf(buffer + len, "%-18s",
+					sna_pr_netid(&ls->netid));
+                		len += sprintf(buffer + len, 
+					"%6d%7s   %02X %6s"
+					"    %02X%5d%7d  %04X\n", 
+					ls->proc_id, ls->dlc->dev->name,
+					ls->sport, sna_pr_ether(ls->dname),
+					ls->daddr[0],
+					ls->auto_act, ls->auto_deact,
+					ls->flags);
+
+                			if (pos < offset) {
+                        			len = 0;
+						begin = pos;
+                			}
+                			if (pos > offset + length) 
+                        			break;
+        		}
+		}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_dfc.c linux/net/sna/sna_dfc.c
--- linux-2.4.18-clean/net/sna/sna_dfc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_dfc.c	Sat Jun  8 16:03:28 2002
@@ -0,0 +1,1512 @@
+/* sna_dfc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Data Flow Control (DFC)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+/* Needs to put data right on the rx_queue of the local listener
+ * corresponding with the bracket ID in the packet.
+ */
+static int sna_dfc_send_to_ps(struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+	struct snathdr *th;
+	__u32 lfsid;
+
+	sna_debug(5, "sna_dfc_send_to_ps\n");
+/*
+	lfsid = sna_pc_find_lfsid_by_daf(skb->th.fm.f5.daf);
+	if(!lfsid)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	rcb = sna_asm_find_rcb_by_lfsid(lfsid);
+	if(!rcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	tcb = sna_cpic_find_tcb_by_id(rcb->tcb_id);
+	if(!tcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+*/
+	th = (struct snathdr *)skb->data;
+	sna_debug(5, "DAF is %02X\n", th->fid.f2.daf);
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if (!tcb) {
+		sna_debug(5, "Not client found\n");
+		return -1;
+	}
+
+	skb_queue_tail(&tcb->receive_queue, skb);
+	wake_up_interruptible(&tcb->sleep);
+        return 0;
+}
+
+static int sna_dfc_process_ru_data(struct sk_buff *skb)
+{
+	struct snarhdr *rh = (struct snarhdr *)&skb->data[6];
+	struct fmhdr *fm = NULL;
+
+	sna_debug(5, "sna_dfc_process_ru_data\n");
+	/* User Data */
+	if (rh->fi != SNA_RH_FI_FMH) {
+		sna_debug(5, "inside user data if\n");
+
+		/* will never fail for now */
+		if (rh->eci == SNA_RH_ECI_EC || skb->data != NULL)
+                        sna_dfc_send_to_ps(skb);
+                else
+			kfree_skb(skb);
+
+                return 0;
+	}
+
+	/* Control data */
+	fm = (struct fmhdr *)&skb->data[9];
+	sna_debug(5, "FM type is %02X %02X %02X\n", fm->len, fm->type, skb->data[10]);
+        switch (fm->type) {
+                case FMH_5:    /* ATTACH */
+			sna_rm_process_hs_to_rm(skb);
+
+#ifdef NOT
+                        sna_build_hs_to_ps_header(mu);
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+
+                        /* Received HS_PS_CONNECTED from RM */
+                        lulu->ps_id      = hs_ps_connected->ps_id;
+                        lulu->bracket_id = hs_ps_connected->bracket_id;
+
+                        sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+                        kfree(hs_ps_connected);
+
+                        if(local->half_session == SNA_HS_PRI)
+                                lulu->current_bracket_sqn
+                                        = lulu->shs_bb_register;
+                        else
+                                lulu->current_bracket_sqn
+                                        = lulu->phs_bb_register;
+#endif
+                        break;
+
+                case FMH_7:    /* Error Description. */
+			sna_dfc_send_to_ps(skb);
+                        break;
+
+                case FMH_12:    /* Security. */
+#ifdef NOT
+			new(mu->layer.hs_to_ps, GFP_ATOMIC);
+			if (!mu->layer.hs_to_ps)
+				return -ENOMEM;
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+#endif
+                        break;
+
+		default:
+			sna_debug(5, "packet does NOT match anything!!!!!!\n");
+			kfree_skb(skb);
+			break;
+        }
+        return 0;
+}
+
+int sna_dfc_send_rsp_to_rm_or_ps(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_send_rsp_to_rm_or_ps\n");
+	return 0;
+}
+
+int sna_dfc_generate_rm_ps_inputs(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_generate_rm_ps_inputs\n");
+	sna_dfc_process_ru_data(skb);
+	return 0;
+}
+
+int sna_dfc_rcv_fsms(struct sk_buff *skb)
+{
+	sna_dfc_generate_rm_ps_inputs(skb);
+
+	/* if normal flow response */
+//	sna_dfc_send_rsp_to_rm_or_ps(skb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *llucb = &local->lulu;
+        int err;
+
+        err = sna_rcv_state_error(mu);
+        if (err)
+                sna_free_buffer(mu);
+        else
+                llucb->saved_mu_ptr = mu;
+#endif
+        return 0;
+}
+
+int sna_dfc_rcv(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_rcv\n");
+	sna_dfc_rcv_fsms(skb);
+	return 0;
+}
+
+/* Maintain states by invoking the appropriate FSM while sending requests
+ * and responses.
+ */
+int sna_dfc_send_fsms(struct sk_buff *skb)
+{
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+        struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+        lulu->direction = SNA_HS_SEND;
+        th->snf = lulu->ct_rcv.snf;
+
+        if (req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_NORM) {
+                if (lulu->rqd_required_on_ceb == SNA_DFC_NO) {
+                        lulu->normal_flow_rq_cnt++;
+                        if (lulu->normal_flow_rq_cnt > 24)
+                                lulu->rqd_required_on_ceb = SNA_DFC_YES;
+                }
+                sna_ct_update(mu);
+
+                if (req_h->cebi == SNA_RH_CEBI_CEB) {
+                        if (SNA_DFC_RQE1(req_h))
+                                SNA_DFC_SET_RQD1(req_h);
+
+                        if (SNA_DFC_RQD(req_h)) {
+                                lulu->rqd_required_on_ceb = SNA_DFC_NO;
+                                lulu->normal_flow_rq_cnt = 0;
+                        }
+
+/*
+                        if (rq = SNA_DEALLOCATE_ABEND)
+                                SNA_DFC_SET_RQD1(req_h);
+*/
+                }
+
+                if (sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT)
+                        == SNA_DFC_FSM_PEND_SEND_REPLY)
+                        sna_fsm_chain_rcv_fmp19(mu, 0);
+
+                if (req_h->bbi == SNA_RH_BBI_BB) {
+                        if (lulu->direction == SNA_HS_SEND) {
+                                if (local->half_session == SNA_HS_PRI) {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_PRI;
+                                } else {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_SEC;
+                                }
+                        } else {
+                                if (local->half_session == SNA_HS_PRI) {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_SEC;
+                                } else {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_PRI;
+                                }
+                        }
+
+                        if (req_h->bci == SNA_RH_BCI_BC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_BEGIN_CHAIN);
+                        if (req_h->eci == SNA_RH_ECI_EC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_END_CHAIN);
+                }
+        }
+
+        if (req_h->rri == SNA_RH_RRI_RSP && th->efi == SNA_TH_EFI_NORM) {
+                sna_ct_update(mu);
+                sna_fsm_chain_rcv_fmp19(mu, 0);
+        }
+
+        if (req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_EXP)
+                lulu->sig_rq_outstanding = SNA_DFC_YES;
+#endif
+
+        sna_tc_send_mu(skb);
+        return 0;
+}
+
+/* Initialize the TH and RH fields of an MU record. */
+int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snathdr *th;
+	struct snarhdr *rh;
+
+	sna_debug(5, "sna_dfc_init_th_rh\n");
+	skb->h.raw = skb_push(skb, sizeof(struct snarhdr));
+	rh = skb->h.rh;
+	rh->rri		= SNA_RH_RRI_REQ;
+	rh->ru		= SNA_RH_RU_FMD;
+	rh->fi		= SNA_RH_FI_NO_FMH;
+	rh->sdi		= SNA_RH_SDI_NO_SD;
+	rh->rti		= SNA_RH_RTI_POS;
+	rh->bci		= SNA_RH_BCI_NO_BC;
+        rh->eci      	= SNA_RH_ECI_NO_EC;
+        rh->rlwi     	= SNA_RH_RLWI_NO_RLW;
+        rh->qri      	= SNA_RH_QRI_NO_QR;
+        rh->pi       	= SNA_RH_PI_NO_PAC;
+        rh->bbi      	= SNA_RH_BBI_NO_BB;
+        rh->ebi      	= SNA_RH_EBI_NO_EB;
+        rh->cdi      	= SNA_RH_CDI_NO_CD;
+        rh->csi      	= SNA_RH_CSI_CODE0;
+        rh->edi      	= SNA_RH_EDI_NO_ED;
+        rh->cebi     	= SNA_RH_CEBI_NO_CEB;
+
+	if (rcb == NULL) {
+		skb->h.raw[0] = 0x6B;
+		skb->h.raw[1] = 0x81;
+		skb->h.raw[2] = 0;
+	}
+
+	skb->nh.raw = skb_push(skb, sizeof(struct sna_fid2));
+        th = skb->nh.fidh;
+        th->fid.f2.efi          = SNA_TH_EFI_NORM;
+        th->fid.f2.snf.sqn      = 0;
+        th->fid.f2.snf.biui     = 0;
+	if (rcb != NULL) {
+		th->fid.f2.oaf = rcb->oaf;
+		th->fid.f2.daf = rcb->daf;
+	} else {
+		struct sna_fid2_cheat *t = (struct sna_fid2_cheat *)skb->nh.raw;
+		t->bits[0] = 0x2F;	/* 0x2D */
+		t->bits[1] = 0;
+		t->bits[2] = 0;
+		t->bits[3] = 0x02;
+		t->bits[4] = 0x80;
+		t->bits[5] = 0x03;
+/*
+		th->fid.f2.ft  = 0x02;
+		th->fid.f2.mpf = 1;
+		th->fid.f2.efi = 1;
+		th->fid.f2.oaf = 0x02;
+		th->fid.f2.daf = 0x00;
+*/
+	}
+        return 0;
+}
+
+/* Send an MU according to passed instructions. */
+static int sna_dfc_send_fmd_mu(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snarhdr *rh;
+	struct sna_ps_to_hs op = rcb->l.ps_to_hs;
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+#endif
+
+	sna_debug(5, "sna_dfc_send_fmd_mu %d %d\n", rcb->oaf, rcb->daf);
+        sna_dfc_init_th_rh(skb, rcb);
+	rh = skb->h.rh;
+
+	if (op.fmh) {
+		sna_debug(5, "putting on FI_FMH\n");
+		rh->fi = SNA_RH_FI_FMH;
+/*
+		if (op.type == SNA_DEALLOCATE_ABEND) {
+			lulu->deallocate_abend = SNA_DFC_YES;
+		}
+*/
+	}
+
+#ifdef NOT
+
+        if (lulu->ct_send.rq_code == SNA_CT_RQCODE_EC) {
+                req_h->bci = SNA_RH_BCI_BC;
+                lulu->betc = SNA_DFC_NO;
+                if (mu->layer.ps_to_hs.allocate == SNA_DFC_YES)
+                        req_h->bbi = SNA_RH_BBI_BB;
+        }
+
+        if (mu->layer.ps_to_hs.type != SNA_MU_FLUSH) {
+        /*      mu->rh = rh_stuff_in_ps_to_hs;  */
+                lulu->betc = SNA_DFC_YES;
+        }
+
+        if (req_h->bci && req_h->eci && mu->biu->ru.ru.raw == NULL) {
+		new(mu->biu->ru.ru.lustat, GFP_ATOMIC);
+		if (!mu->biu->ru.ru.lustat)
+			return -ENOMEM;l
+        }
+#endif
+
+        sna_dfc_send_fsms(skb);
+        return 0;
+}
+
+/* Process the record received from presentation services (PS) and determine
+ * the proper response (positive or negative) or MU (data or signal) that needs
+ * to be sent to the partner HS via transmission control (TC). If an error
+ * is found while processing the PS_TO_HS record, the buffer will be freed
+ * by this procedure.
+ */
+int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	sna_debug(5, "sna_dfc_send_from_ps\n");
+
+	/* SNA_MU_SEND_DATA_RECORD */
+	sna_dfc_send_fmd_mu(skb, rcb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_ru *ru = &mu->biu->ru;
+
+        if (mu->layer.ps_to_hs.bracket_id == local->lulu.bracket_id) {
+                sna_free_buffer(mu);
+                return 0;
+        }
+
+        switch (mu->layer.ps_to_hs.ps_to_hs_variant) {
+                case SNA_MU_SEND_DATA_RECORD:
+                        sna_dfc_send_fmd_mu(skb);
+                        break;
+
+                case SNA_MU_CONFIRMED:
+                        if(lulu->ct_rcv.rq_code == SNA_DFC_RQD2_HEX
+                                || lulu->ct_rcv.rq_code == SNA_DFC_RQD3_HEX) {
+                                sna_send_rsp_mu(NULL, SNA_NORMAL, SNA_DFC_POS, 0);
+                        } else 
+                                sna_free_buffer(mu);
+                        break;
+
+                case SNA_MU_SEND_ERROR:
+                        if (local->state == SNA_DFC_FSM_BETC) {
+                                lulu->send_error_rsp_state = SNA_DFC_NEG_OWED;
+                                sna_free_buffer(mu);
+                        } else
+                                sna_send_rsp_mu(NULL, SNA_TH_EFI_NORM,
+                                        SNA_DFC_NEG, 0x08460000);
+                        break;
+
+                case SNA_MU_REQUEST_TO_SEND:
+                        sna_init_th_rh(mu);
+			new(ru->ru.sig, , GFP_ATOMIC);
+			if (!ru->ru.sig)
+				return -ENOMEM;
+                        local->rq_code = SNA_LOCAL_SIG;
+                        sna_dfc_send_fsms(mu);
+                        break;
+
+                default:
+                        return -1;
+        }
+#endif
+        return 0;
+}
+
+#ifdef NOT
+
+static int sna_try_to_rcv_signal(struct sna_mu *mu);
+static int sna_build_hs_to_ps_header(struct sna_mu *mu);
+static int sna_ct_update(struct sna_mu *mu);
+static int sna_format_error(struct sna_mu *mu);
+static int sna_format_error_exp_rsp(struct sna_mu *mu);
+static int sna_format_error_norm_rsp(struct sna_mu *mu);
+static int sna_format_error_rq_dfc(struct sna_mu *mu);
+static int sna_format_error_rq_fmd(struct sna_mu *mu);
+static int sna_invalid_sense_code(struct sna_mu *mu);
+static int sna_ok_to_reply(struct sna_mu *mu);
+static int sna_rcv_state_error(struct sna_mu *mu);
+static int sna_reply_to_bid(struct sna_mu *mu);
+static int sna_send_bid_pos_rsp(struct sna_mu *mu);
+static int sna_send_rsp_if_required(struct sna_mu *mu);
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense);
+static int sna_signal_status(struct sna_mu *mu);
+static int sna_stray_rsp(struct sna_mu *mu);
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal);
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu);
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu);
+
+/* Process records received from the resource manager (RM). This procedure
+ * is called by the half session router.
+ */
+int sna_dfc_send_from_rm(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_ru *ru = &mu->biu->ru;
+
+	switch(mu->record_type)
+	{
+		case (SNA_REC_BID_WITHOUT_ATTACH):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM, 
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			new(ru->ru.lustat, GFP_ATOMIC);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_REPLY):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			new(ru->ru.bis, GFP_ATOMIC);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BRACKET_FREED):
+			sna_free_buffer(mu);
+			break;
+
+		case (SNA_REC_HS_PS_CONNECTED):
+			lulu->ps_id = hs_ps_connected->ps_id;
+			local->lulu.bracket_id = hs_ps_connected->bracket_id;
+
+			sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			else
+			{
+				lulu->current_bracket_sqn.number
+					= lulu->sqn_send_cnt.number++;
+				lulu->current_bracket_sqn.bracket_started_by
+					= local->half_session;
+				if(local->half_session == SNA_HS_PRI)
+					lulu->phs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+				else
+					lulu->shs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+			}
+			break;
+
+		case (SNA_REC_RTR_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			new(ru->ru.rtr, GFP_ATOMIC);
+			local->rq_code = SNA_LOCAL_RTR;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_YIELD_SESSION):
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			new(ru->ru.lustat, GFP_ATOMIC);
+			local->rq_code = SNA_LOCAL_LUSTAT;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_SECURITY_REPLY_2):
+			if(ru->ru.security_reply_2.send_parm.type 
+				== SNA_MU_DEALLOCATE_FLUSH)
+			{
+				lulu->session_just_started = SNA_DFC_NO;
+			}
+
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			new(ru->ru.security_reply_2, GFP_ATOMIC);
+			sna_send_fmd_mu(mu);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+/* This procedure determines if a REQUEST_TO_SEND record should be sent
+ * to PS to indicate a SIGNAL has been received. This procedure is called
+ * by the half-session router.
+ */
+static int sna_try_to_rcv_signal(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+
+	if(sna_fsm_bsm_fmp19(0, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB
+		&& lulu->sig_received == SNA_DFC_YES)
+	{
+		switch(sna_signal_status(mu))
+		{
+			case (SNA_DFC_SIG_CURRENT):
+				sna_dfc_send_to_ps(NULL);
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_STRAY):
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_FUTURE):
+				break;
+		}
+	}
+
+	return (0);
+}
+
+/* Process MUs received from TC. This procedure is called by TC. */
+int sna_dfc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u32 err;
+
+	lulu->direction = SNA_HS_RECEIVE;
+	if(local->sense == 0x00000000)
+	{
+		if(req_h->ru == SNA_RH_RU_DFC)
+		{
+			local->rq_code = req_h->rri;
+			if(local->rq_code == SNA_LOCAL_NO_CRV
+				|| local->rq_code == SNA_LOCAL_NO_BIS
+				|| local->rq_code == SNA_LOCAL_NO_LUSTAT
+				|| local->rq_code == SNA_LOCAL_NO_RTR
+				|| local->rq_code == SNA_LOCAL_NO_SIG)
+			{
+				local->rq_code = SNA_LOCAL_OTHER;
+			}
+		}
+		else
+			local->rq_code = SNA_LOCAL_OTHER;
+
+		err = sna_format_error(mu);
+		if(err)
+		{
+			sna_free_buffer(mu);
+			local->sense = err;
+			return (0);
+		}
+
+		if(req_h->rri == SNA_RH_RRI_REQ)
+		{
+			if(th->efi == SNA_TH_EFI_NORM)
+				sna_dfc_rcv_fsms(mu);
+			else
+			{
+				lulu->sig_received = SNA_DFC_YES;
+				lulu->sig_snf = th->snf;
+				sna_send_rsp_mu(mu, SNA_TH_EFI_EXP, 
+					SNA_DFC_POS, 0);
+				sna_free_buffer(mu);
+			}
+		}
+		else
+		{
+			if(sna_stray_rsp(mu))
+				sna_free_buffer(mu);
+			else
+				sna_dfc_rcv_fsms(mu);
+		}
+	}
+
+	return (0);
+}
+
+int sna_dfc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_mu *mu = NULL;
+
+	lulu->first_speaker 				= init_hs->type;
+	lulu->alternate_code				= SNA_DFC_TRUE;
+	lulu->sqn_send_cnt.number			= 0;
+	lulu->current_bracket_sqn.bracket_started_by 	= SNA_HS_PRI;
+	lulu->current_bracket_sqn.number 		= 0;
+	lulu->phs_bb_register.bracket_started_by 	= SNA_HS_PRI;
+	lulu->phs_bb_register.number 			= 0;
+	lulu->shs_bb_register.bracket_started_by 	= SNA_HS_SEC;
+	lulu->shs_bb_register.number 			= 0;
+	lulu->rqd_required_on_ceb 			= SNA_DFC_NO;
+	lulu->normal_flow_rq_cnt 			= 0;
+	lulu->sig_received 				= SNA_DFC_NO;
+	lulu->sig_snf.number 				= 0;
+	lulu->ps_id 					= 0;
+
+	/* Reset all FSMs to state 1 */
+
+	lulu->betc 			= SNA_DFC_YES;
+	lulu->send_error_rsp_state 	= 1; 
+	lulu->bb_rsp_state 		= 1;
+	lulu->rtr_rsp_state 		= 1;
+	lulu->sig_rq_outstanding 	= SNA_DFC_NO;
+
+	if(local->half_session == SNA_HS_PRI)
+		lulu->session_just_started = SNA_DFC_YES;
+	else
+		lulu->session_just_started = SNA_DFC_NO;
+
+	lulu->saved_mu_ptr = mu;
+	sna_dfc_send_to_ps(mu);
+
+        return (0);
+}
+
+/* Fill in mu->hs_to_ps_header based on the contents of mu->rh. */
+static int sna_build_hs_to_ps_header(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu->header_type = SNA_MU_HS_TO_PS;
+	mu->layer.hs_to_ps.fmh = SNA_DFC_NO;
+
+	if(req_h->fi == SNA_RH_FI_FMH)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			mu->layer.hs_to_ps.fmh = SNA_DFC_YES;
+		else
+			mu->dcf = sizeof(mu->biu->rh);
+	}
+
+	if(req_h->eci == SNA_RH_ECI_EC)
+	{
+		if(SNA_DFC_RQE1(req_h) && req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_FLUSH;
+
+		if(SNA_DFC_RQ1(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_FLUSH;
+		
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cdi != SNA_RH_CDI_CD
+			&& req_h->cebi != SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_CONFIRM;
+
+		if((SNA_DFC_RQ2(req_h) || SNA_DFC_RQ3(req_h)) 
+			&& req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_CONFIRM;
+
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_CONFIRM;
+	}
+	else
+		mu->layer.hs_to_ps.type = SNA_MU_NOT_END_OF_DATA;
+
+	return (0);
+}
+
+/* Record information about the last chain sent or received. This is done by
+ * updating the correlation table entry.
+ */
+static int sna_ct_update(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ct *ct = &local->lulu.ct_rcv;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->bci == SNA_RH_BCI_BC)
+		{
+			ct->entry_present	= SNA_DFC_YES;
+			ct->snf 		= th->snf;
+			ct->neg_rsp_sense 	= 0;
+			ct->rh.rh.req_h.ru 	= req_h->ru;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+				ct->rq_code = local->rq_code;
+			else
+				ct->rq_code = SNA_CT_OTHER;
+
+		}
+
+		if(req_h->eci == SNA_RH_ECI_EC)
+			ct->rh.rh.req_h.ru = req_h->ru;
+	}
+	else
+	{
+		if(rsp_h->sdi == SNA_RH_SDI_SD)
+			ct->neg_rsp_sense = local->sense;
+	}
+
+	return (0);
+}
+
+/* Perform format checks on all requests and responses for LU-LU session.
+ * These checks are optional. If an error is detected, the local->sense
+ * is set to the appropriate sense data. None, some, or all of these checks
+ * may be done.
+ */
+static int sna_format_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int rcode;
+
+	rcode = SNA_DFC_FALSE;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			sna_format_error_rq_fmd(mu);
+		else
+			sna_format_error_rq_dfc(mu);
+	}
+
+	if(th->efi == SNA_TH_EFI_NORM)
+		sna_format_error_norm_rsp(mu);
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		sna_format_error_exp_rsp(mu);
+
+	if(local->sense != 0x00000000)
+		rcode = SNA_DFC_TRUE;
+
+	return (rcode);
+}
+
+/* Perform format checks on expedited-flow responses. These checks are
+ * optional.
+ */
+static int sna_format_error_exp_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x40110000;
+
+	if(req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->qri == SNA_RH_QRI_QR)
+		local->sense = 0x40150000;
+
+	if(local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x40120000;
+
+	if(rsp_h->rti == SNA_RH_RTI_NEG)
+		memcpy(&local->sense, &mu->biu->ru, 4);
+
+	return (0);
+}
+
+/* Perform format checks on normal-flow responses. These checks are optional. */
+static int sna_format_error_norm_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC && req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F000;
+
+	if(req_h->ru == SNA_RH_RU_FMD && rsp_h->rti == SNA_RH_RTI_POS 
+		&& req_h->fi == SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if((rsp_h->rti == SNA_RH_RTI_NEG
+		&& *(__u32 *)mu->biu->ru.ru.raw != 0x08130000)
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08140000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08190000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08460000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x088B0000)
+	{
+		local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+	}
+
+	return (0);
+}
+
+/* Perform format checks for data flow control (DFC) request. These checks
+ * are optional.
+ */
+static int sna_format_error_rq_dfc(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(th->efi == SNA_TH_EFI_NORM && (local->rq_code != SNA_LOCAL_BIS 
+		|| local->rq_code != SNA_LOCAL_LUSTAT
+		|| local->rq_code != SNA_LOCAL_RTR))
+	{
+		local->sense = 0x10030000;
+	}
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x10030000;
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code == SNA_LOCAL_SIG)
+	{
+		local->sense = 0x10050000;
+	}
+
+	if(req_h->fi != SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->edi == SNA_RH_EDI_ED)
+		local->sense = 0x40160000;
+
+	if(req_h->pdi == SNA_RH_PDI_PD)
+		local->sense = 0x40170000;
+
+	/* Other wise. */
+	if(local->rq_code == SNA_LOCAL_LUSTAT)
+	{
+		if(mu->dcf > sizeof(struct sna_ru_lustat))
+		{
+			if(mu->biu->ru.ru.lustat.status)
+				sna_format_error_rq_fmd(mu);
+			else
+				return (0);
+		}
+	}
+
+	return (0);
+}
+
+/* Perform format checks on FM data (FMD) requests. The checks are optional. */
+static int sna_format_error_rq_fmd(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_fmh1 *fmh = &mu->biu->ru.ru.fmh1;
+	int fmh_type;
+
+	fmh_type = fmh->type;
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		local->sense = 0x40110000;
+
+	if(!SNA_DFC_RQD(req_h) || !SNA_DFC_RQE(req_h))
+		local->sense = 0x40140000;
+
+	if(1)	/* See SNA formats RH formats 5.2-2 */
+		local->sense = 0x40070000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		local->sense = 0x40030000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->ru == SNA_RH_RU_FMD
+		&& req_h->fi != SNA_RH_FI_FMH)
+	{
+		local->sense = 0x40003000;
+	}
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->ebi == SNA_RH_EBI_EB)
+		local->sense = 0x40040000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40090000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && SNA_DFC_RQD1(req_h))
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40040000;
+
+	if(req_h->bci == SNA_RH_BCI_BC && ((req_h->bbi == SNA_RH_BBI_BB
+		&& req_h->qri == SNA_RH_QRI_NO_QR) 
+		||(req_h->bbi == SNA_RH_BBI_BB || req_h->qri == SNA_RH_QRI_QR)))
+		local->sense = 0x40180000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->cdi == SNA_RH_CDI_CD)
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB 
+		&& (SNA_DFC_RQE2(req_h) || SNA_DFC_RQE3(req_h)))
+		local->sense = 0x40040000;
+
+	if(req_h->cebi == SNA_RH_CEBI_NO_CEB && req_h->cdi == SNA_RH_CDI_NO_CD
+		&& req_h->eci == SNA_RH_ECI_EC && SNA_DFC_RQE(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_NO_CEB
+		&& SNA_DFC_RQD1(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->cebi == SNA_RH_CEBI_CEB
+		&& SNA_DFC_RQE1(req_h))
+		local->sense = 0x40040000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_CEB
+		&& fmh->type == SNA_FMH_HDR_ERROR && SNA_DFC_RQE(req_h))
+		local->sense = 0x40060000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->ru == SNA_RH_RU_FMD
+		&& (fmh->type != SNA_FMH_HDR_ATTACH 
+		|| fmh->type != SNA_FMH_HDR_ERROR))
+	{
+		if(fmh->type == SNA_FMH_HDR_SECURITY)
+		{
+			if(req_h->eci == SNA_RH_ECI_EC 
+				&& req_h->cebi == SNA_RH_CEBI_NO_CEB)
+				local->sense = 0x080F6051;
+		}
+		else
+			local->sense = 0x10084001;
+	}
+
+	return (0);
+}
+
+/* Determine if sense data on a negative response is valid. */
+static int sna_invalid_sense_code(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(req_h->rri == SNA_RH_RRI_RSP && req_h->bbi == SNA_RH_BBI_BB)
+	{
+		if(local->half_session == SNA_HS_PRI)
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x08140000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x0814000
+				|| local->sense != 0x088B0000)
+			{
+				return (SNA_DFC_TRUE);
+			}
+		}
+	}
+	else
+	{
+		if(req_h->rri == SNA_RH_RRI_RSP 
+			&& req_h->bbi == SNA_RH_BBI_NO_BB)
+		{
+			if(local->sense == 0x08190000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(req_h->rri == SNA_RH_RRI_RSP)
+				return (SNA_DFC_TRUE);
+			else
+			{
+				if(local->sense == 0x08460000)
+					return (SNA_DFC_TRUE);
+			}
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine whether or not a request is a valid reply. A reply is a request
+ * sent (or received) after receiving (or sending) an (RQE,CD) request.
+ */
+static int sna_ok_to_reply(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_BIS || local->rq_code == SNA_LOCAL_RTR)
+		return (SNA_DFC_FALSE);
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		return (SNA_DFC_FALSE);
+
+	if((sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_SEND_REPLY)
+		|| (sna_fsm_chain_send_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_RCV_REPLY))
+		return (SNA_DFC_FALSE);
+
+	if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB)
+		return (SNA_DFC_FALSE);
+
+	return (SNA_DFC_TRUE);
+}
+
+/* Perform state error checking on received RQ/RSP. The types of errors
+ * found here are protocol violations by the sender of the RQ/RSP. These
+ * checks are optional. None, some, or all of the checks may be made.
+ */
+static int sna_rcv_state_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(th->efi == SNA_TH_EFI_EXP && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		{
+			local->sense = 0x200E0000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal Flow request. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_BB 
+			&& mu->biu->ru.ru.fmh1.type != FMH_5)
+		{
+			if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+				return (SNA_DFC_TRUE);	/* local->sense set. */
+		}
+
+		if(SNA_DFC_RQE(req_h) && req_h->bbi == SNA_RH_BBI_BB 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+		{
+			local->sense = 0x40040000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal flow response. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(rsp_h->ru != req_h->ru)
+		{
+			local->sense = 0x40110000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->ru == SNA_RH_RU_DFC
+			&& rsp_h->rri != req_h->rri)
+		{
+			local->sense = 0x40120000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->qri != req_h->qri)
+		{
+			local->sense = 0x40210000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(sna_invalid_sense_code(mu))
+		{
+			local->sense = 0x20120000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine if a normal-flow request is a reply to a BID request. A reply
+ * is a request sent (or received) immediately after receving (or sending) a
+ * request carrying (RQE, CD. A reply implies a positive response to the
+ * (RQE, CD) request.
+ */
+static int sna_reply_to_bid(struct sna_mu *mu)
+{
+//	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(sna_ok_to_reply(mu))
+		return (SNA_DFC_TRUE);
+	else
+		return (SNA_DFC_FALSE);
+}
+
+/* Send RM a positive reponse to a BID, and receive the HS_PS_CONNECTED
+ * record that will result in this half-session being connected to a PS.
+ */
+static int sna_send_bid_pos_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_bid_rsp *pos_bid;
+
+	new(pos_bid, GFP_KERNEL);
+	if (!pos_bid)
+		return -ENOMEM;
+	pos_bid->hs_id = local->hs_id;
+	pos_bid->sense = 0;
+	sna_send_to_rm(mu);
+
+	/* Receive the hs_ps_connected record. */
+	lulu->ps_id 		= hs_ps_connected->ps_id;
+	lulu->bracket_id 	= hs_ps_connected->bracket_id;
+
+	sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+	kfree(hs_ps_connected);
+
+	lulu->current_bracket_sqn.number = 0;
+
+	return (0);
+}
+
+/* Send a response to the passed MU if required. */
+static int sna_send_rsp_if_required(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_TH_EFI_NORM, SNA_DFC_POS, 0);
+		else
+		{
+			if(SNA_DFC_RQE(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+				sna_debug(5, "error\n");
+			else
+				sna_send_rsp_mu(mu, SNA_TH_EFI_NORM,SNA_DFC_NEG,
+					lulu->bb_rsp_sense);
+		}
+
+		lulu->bb_rsp_state = 0;
+		lulu->bb_rsp_sense = 0;
+	}
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+		else
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG,
+				lulu->rtr_rsp_sense);
+
+		lulu->rtr_rsp_state = 0;
+	}
+
+	if(SNA_DFC_NEG_RSP(req_h))
+	{
+		if((req_h->bci == SNA_RH_BCI_BC && req_h->ru == SNA_RH_RU_FMD)
+			|| (req_h->ru == SNA_RH_RU_DFC
+			&& req_h->bbi != SNA_RH_BBI_BB))
+		{
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG, 0x08460000);
+			lulu->send_error_rsp_state = 0;
+		}
+	}
+
+	if(sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		== SNA_DFC_FSM_PEND_REPLY)
+		sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+
+	return (0);
+}
+
+/* Create and send a response. The response is based on the request MU (if
+ * passed by the caller) or on information about the last chain received
+ * (if a null MU is passed).
+ */
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_ct *ct = &lulu->ct_send;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int direction;
+	int null_mu = 0;
+
+	if(mu == NULL)
+	{
+		null_mu = 1;
+		mu = sna_get_buffer(SNA_BM_TYPE_PERM, local->perm_buf_pool_id,
+			0, SNA_BM_NO_WAIT);
+	}
+
+	sna_init_th_rh(mu);
+	mu->dcf 	= sizeof(struct sna_req_h);
+	req_h->rri 	= SNA_RH_RRI_RSP;
+	req_h->bci 	= SNA_RH_BCI_BC;
+	req_h->eci 	= SNA_RH_ECI_EC;
+
+	if(rsp == SNA_DFC_NEG)
+	{
+		req_h->sdi 	= SNA_RH_SDI_SD;
+		rsp_h->rti 	= SNA_RH_RTI_NEG;
+		mu->dcf 	+= sizeof(mu->biu->ru.ru);
+		local->sense 	= sense;
+	}
+	else
+		rsp_h->rti = SNA_RH_RTI_POS;
+
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		if(null_mu)
+		{
+			req_h->ru 	= ct->rh.rh.rsp_h.ru;
+			req_h->dr1i 	= ct->rh.rh.rsp_h.dr1i;
+			req_h->dr2i 	= ct->rh.rh.rsp_h.dr2i;
+			req_h->qri 	= ct->rh.rh.rsp_h.qri;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+				local->rq_code = ct->rq_code;
+			}
+		}
+		else
+		{
+			req_h->ru 	= req_h->ru;
+			req_h->dr1i 	= req_h->dr1i;
+			req_h->dr2i 	= req_h->dr2i;
+			req_h->qri 	= req_h->qri;
+			local->rq_code 	= req_h->csi;
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+			}
+		}
+	}
+	else
+	{
+		th->efi = SNA_TH_EFI_EXP;
+		req_h->ru = SNA_RH_RU_DFC;
+		req_h->dr1i = req_h->dr1i;
+		local->rq_code = SNA_LOCAL_SIG;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC)
+		req_h->fi = SNA_RH_FI_FMH;
+
+	direction = lulu->direction;
+	lulu->direction = SNA_HS_SEND;
+	if(!sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		sna_dfc_send_fsms(mu);
+	else
+		sna_free_buffer(mu);
+
+	lulu->direction = direction;
+
+	return (0);
+}
+
+/* Determine if a SIGNAL is for a past, current, or future bracket. The
+ * in-bracket (INB) state exists when this procedure is called.
+ */
+static int sna_signal_status(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	int result, reg;
+
+	if(lulu->current_bracket_sqn.number 
+		== lulu->current_bracket_sqn.number)
+		return (SNA_DFC_SIG_CURRENT);
+
+	if(SNA_HS_PRI)
+		reg = lulu->phs_bb_register.number;
+	else
+		reg = lulu->shs_bb_register.number;
+
+	result = (lulu->sig_snf.number -  reg) % 25;
+	if(result < 0)
+	{
+		result += 25;
+		if(result == 0)
+			return (SNA_DFC_SIG_STRAY);
+		if(result == 24)
+			return (SNA_DFC_SIG_FUTURE);
+		if(result > 24)
+			return (SNA_DFC_SIG_STRAY);
+	}
+
+	return (0);
+}
+
+/* Determines if a response is stray. (A stray response is one that was sent
+ * in a bracket (conversation) but recevied in a different (later bracket).
+ */
+static int sna_stray_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_RTR)
+	{
+		local->sense = 0x200E0000;
+		return (SNA_DFC_TRUE);
+	}
+
+	if(local->rq_code == SNA_LOCAL_SIG)
+		return (SNA_DFC_TRUE);
+
+	if(local->rq_code == SNA_LOCAL_LUSTAT || req_h->ru == SNA_RH_RU_FMD)
+	{
+		/* More. */
+		return (SNA_DFC_TRUE);
+	}
+
+	/* More. */
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Enforce the bracket protocol. State transitions are forced via the input
+ * signals INB (go in brackets) and BETB (go between bracket). The inputs R,
+ * RQ, ... are used for error checking only. INB state means DFC (the half
+ * session) is connected to a PS; BETB state means DFC is not connected to a
+ * PS.
+ */
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(local->state == SNA_DFC_FSM_BETB)
+	{
+		if(signal == SNA_DFC_FSM_INB)
+			local->state = SNA_DFC_FSM_INB;
+		else
+			local->sense = 0x20030000;
+		return (0);
+	}
+
+	if(local->state == SNA_DFC_FSM_INB)
+	{
+		if(signal == SNA_DFC_FSM_BETB)
+			local->state = SNA_DFC_FSM_BETB;
+		
+		return (0);
+	}
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for received chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been received and any required
+ * associated response or reply has been sent. A reply is a request sent after
+ * receiving an (RQE, CD) chain that has not been negatively responsed to. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for sending chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been sent and any required associated
+ * response or reply has been received. A reply is a request recevied after
+ * sending an (RQE, CD) chain that has not received a negative response. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the setting of the QRI indicator in the RH. This indicator is
+ * set the same for all MUs in a chain; ie. all MUs in a chain have QRI = QR
+ * or have QRI = -QR.
+ */
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+/* Maintain a purging state for received BB chains that have been negatively
+ * responded to indicating a bracket error (0813, 0814, 088B). It is called
+ * with a PURGE signal when the negative response is sent and reset when
+ * the end-of-chain (EC) RU is received. When in the purging state, no records
+ * are generated for PS or RM as a result of receiving a request RU in the
+ * BB chain (ie. the remainder of the BB chain is purged).
+ */
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_dlc.c linux/net/sna/sna_dlc.c
--- linux-2.4.18-clean/net/sna/sna_dlc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_dlc.c	Sat Jun  8 13:32:12 2002
@@ -0,0 +1,485 @@
+/* sna_dlc.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <linux/if_arp.h>
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif
+
+extern char sna_product_name[];
+
+#ifdef CONFIG_SNA_LOOPBACK
+int sna_loopback_xmit(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_loopback_xmit\n");
+	netif_rx(skb);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+static inline u16 sna_dlc_llc_protocol_type(u16 arphrd)
+{
+        u16 rc = htons(ETH_P_802_2);
+
+        if (arphrd == ARPHRD_IEEE802)
+                rc = htons(ETH_P_TR_802_2);
+        return rc;
+}
+
+static inline u_int8_t sna_dlc_llc_header_len(u_int8_t type)
+{
+        u_int8_t len = LLC_PDU_LEN_U;
+
+        if (type == LLC_TEST_PRIM || type == LLC_XID_PRIM) {
+                len = LLC_PDU_LEN_U;
+                if (type == LLC_XID_PRIM)
+                        len += 3;
+        } else if (type == LLC_DATA_PRIM)
+                len = LLC_PDU_LEN_I;
+        return len;
+}
+
+static int sna_dlc_llc_send_llc1(struct llc_sap *sap, struct sk_buff *skb,
+	struct sna_dlc_llc_addr *addr, int primitive, int type)
+{
+	union llc_u_prim_data prim_data;
+        struct llc_prim_if_block prim;
+
+	sna_debug(5, "init\n");
+        prim.data                 = &prim_data;
+        prim.sap                  = sap;
+        prim.prim                 = primitive;
+	prim.type		  = type;
+        prim_data.test.skb        = skb;
+        prim_data.test.saddr.lsap = sap->laddr.lsap;
+        prim_data.test.daddr.lsap = addr->dsap;
+        skb->protocol = sna_dlc_llc_protocol_type(addr->arphrd);
+        memcpy(prim_data.test.saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);
+        memcpy(prim_data.test.daddr.mac, addr->dmac, IFHWADDRLEN);
+        return sap->req(&prim);
+}
+
+#ifdef NOT
+static int sna_dlc_llc_send_data(struct llc_sap *sap, struct sock *core_sk,
+	struct sk_buff *skb)
+{
+        union llc_u_prim_data prim_data;
+        struct llc_prim_if_block prim;
+        int rc;
+
+        prim.data          = &prim_data;
+        prim.sap           = sap;
+        prim.prim          = LLC_DATA_PRIM;
+        prim_data.data.skb = skb;
+        prim_data.data.pri = 0;
+        prim_data.data.sk  = core_sk;
+        skb->protocol      = sna_dlc_llc_protocol_type(addr->sllc_arphrd);
+        rc = wait_event_interruptible(sk->socket->wait,
+                !LLC_SK(core_sk)->failed_data_req);
+        if (rc < 0)
+                goto out;
+        rc = sap->req(&prim);
+out:    return rc;
+}
+#endif
+
+/**
+ * sna_dlc_llc_ind_test_cmd - echo test cmd back to sender.
+ *
+ * ideally we could keep some counters for diagnostics here.
+ */
+static void sna_dlc_llc_ind_test_cmd(struct llc_sap *sap,
+	struct llc_prim_test *prim_data)
+{
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sna_dlc_llc_addr addr;
+
+	sna_debug(5, "init\n");
+	skb2 = skb_copy(skb, GFP_ATOMIC);
+	if (!skb2)
+		goto out;
+	memset(&addr, 0, sizeof(addr));
+	addr.ssap = prim_data->daddr.lsap;
+        memcpy(addr.smac, prim_data->daddr.mac, IFHWADDRLEN);
+        addr.dsap = prim_data->saddr.lsap;
+        memcpy(addr.dmac, prim_data->saddr.mac, IFHWADDRLEN);
+	sna_dlc_llc_send_llc1(sap, skb2, &addr, LLC_TEST_PRIM, 
+		LLC_PRIM_TYPE_RESP);
+out:	return;
+}
+
+static void sna_dlc_llc_ind_test_rsp(struct llc_sap *sap, 
+	struct llc_prim_test *prim_data)
+{
+	struct sna_tg_cb *tg;
+
+        sna_debug(5, "init\n");
+        tg = sna_tdm_find_tg_by_mac(prim_data->saddr.mac);
+        if (tg) {
+                tg->co_status = CO_R_TEST_R;
+                sna_cs_connect_out((unsigned long)tg);
+	} else {
+		sna_debug(5, "unknown test rsp\n");
+	}
+	return;
+}
+
+static void sna_dlc_llc_ind_test(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_test *prim_data = &prim->data->test;
+	struct llc_sap *sap = prim->sap;
+
+	if (prim_data->pri == LLC_PRIM_TYPE_REQ)
+		sna_dlc_llc_ind_test_cmd(sap, prim_data);
+	else
+		sna_dlc_llc_ind_test_rsp(sap, prim_data);
+	return;
+}
+
+static void sna_dlc_llc_ind_xid_cmd(struct llc_prim_xid *prim_data)
+{
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sna_tg_cb *tg;
+
+	sna_debug(5, "init\n");
+	tg = sna_tdm_find_tg_by_mac(prim_data->saddr.mac);
+        if (!tg) {
+		sna_debug(5, "rouge xid cmd\n");
+		return;
+	}
+	skb2 = skb_copy(skb, GFP_ATOMIC);
+	if (!skb2)
+		return;
+        sna_cs_connect_in(tg, skb2, skb2->dev);
+	return;
+}
+
+static void sna_dlc_llc_ind_xid_rsp(struct llc_prim_xid *prim_data)
+{
+	struct sk_buff *skb2, *skb = prim_data->skb;
+	struct sna_xid_info *xid;
+        struct sna_tg_cb *tg;
+
+        sna_debug(5, "init\n");
+	tg = sna_tdm_find_tg_by_mac(prim_data->saddr.mac);
+        if (!tg) {
+                sna_debug(5, "rouge xid rsp\n");
+                return;
+        }
+	skb2 = skb_copy(skb, GFP_ATOMIC);
+	if (!skb2)
+		return;
+
+	xid = tg->xid_info;
+        del_timer(&xid->xid_timer);
+        if (xid->last_rx_xid != NULL)
+		kfree_skb(xid->last_rx_xid);
+        xid->last_rx_xid = skb2;
+        xid->xid_count++;
+
+        /* determine type of xid packet */
+        switch (sna_cs_xid_xchg_state(skb2)) {
+		case XID_NULL:
+			xid->xid_status = XID_R_NULL;
+                        break;
+                case XID_NEG:
+                        xid->xid_status = XID_R_NEG;
+                        break;
+                case XID_PN:
+                        xid->xid_status = XID_R_PN;
+                        break;
+                default:
+                        sna_debug(5, "unknown xid dropping, reset XID.\n");
+                        xid->xid_status = XID_RESET;
+                        break;
+        }
+        sna_cs_connect_out((unsigned long)tg);
+	return;
+}
+
+static void sna_dlc_llc_ind_xid(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_xid *prim_data = &prim->data->xid;
+	if (prim_data->pri == LLC_PRIM_TYPE_REQ)
+                sna_dlc_llc_ind_xid_cmd(prim_data);
+        else
+                sna_dlc_llc_ind_xid_rsp(prim_data);
+	return;
+}
+
+static void sna_dlc_llc_ind_dataunit(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_unit_data *prim_data = &prim->data->udata;
+
+	return;
+}
+
+static void sna_dlc_llc_ind_conn(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_conn *prim_data = &prim->data->conn;
+#ifdef NOT
+	struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct sna_tg_cb *tg;
+
+        sna_debug(5, "llc SAMBE cmd received.\n");
+	tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+        if (tg) {
+		struct sna_xid_info *xid = tg->xid_info;
+                del_timer(&xid->xid_timer);
+                xid->xid_status = XID_ACTIVE;
+                sna_cs_connect_out((unsigned long)tg);
+	}
+#endif
+	return;
+}
+
+static void sna_dlc_llc_ind_data(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_data *prim_data = &prim->data->data;
+	sna_debug(5, "llc I cmd received \n");
+#ifdef NOT
+        err = sna_pc_mu_error_checker(skb);
+        if (err < 0) {
+		/* Should send proper sense code */
+                kfree_skb(skb);
+                return;
+        }
+        sna_pc_mu_rcv_router(skb);
+#endif
+	return;
+}
+
+static void sna_dlc_llc_ind_disc(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_disc *prim_data = &prim->data->disc;
+	sna_debug(5, "llc SAMBE cmd received.\n");
+#ifdef NOT
+        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+        if (tg) {
+	        struct sna_xid_info *xid = tg->xid_info;
+                del_timer(&xid->xid_timer);
+                xid->xid_status = XID_RESET;
+        }
+#endif
+	return;
+}
+
+int sna_dlc_llc_indicate(struct llc_prim_if_block *prim)
+{
+	switch (prim->prim) {
+                case LLC_TEST_PRIM:
+                        sna_dlc_llc_ind_test(prim);          
+			break;
+                case LLC_XID_PRIM:
+                        sna_dlc_llc_ind_xid(prim);           
+			break;
+                case LLC_DATAUNIT_PRIM:
+                        sna_dlc_llc_ind_dataunit(prim);      
+			break;
+                case LLC_CONN_PRIM:
+                        sna_dlc_llc_ind_conn(prim);          
+			break;
+                case LLC_DATA_PRIM:
+                        sna_dlc_llc_ind_data(prim);          
+			break;
+                case LLC_DISC_PRIM:
+                        sna_dlc_llc_ind_disc(prim);          
+			break;
+                case LLC_RESET_PRIM:
+                case LLC_FLOWCONTROL_PRIM:
+                default:                                
+			break;
+        }
+        return 0;
+}
+
+static void sna_dlc_llc_conf_conn(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_conn *prim_data = &prim->data->conn;
+
+	return;
+}
+
+static void sna_dlc_llc_conf_data(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_data *prim_data = &prim->data->data;
+
+	return;
+}
+
+static void sna_dlc_llc_conf_disc(struct llc_prim_if_block *prim)
+{
+        struct llc_prim_disc *prim_data = &prim->data->disc;
+
+	return;
+}
+
+int sna_dlc_llc_confirm(struct llc_prim_if_block *prim)
+{
+        switch (prim->prim) {
+                case LLC_CONN_PRIM:
+                        sna_dlc_llc_conf_conn(prim);         
+			break;
+                case LLC_DATA_PRIM:
+                        sna_dlc_llc_conf_data(prim);         
+			break;
+                case LLC_DISC_PRIM:
+                        sna_dlc_llc_conf_disc(prim);         
+			break;
+                case LLC_RESET_PRIM:                    
+			break;
+                default:
+                        sna_debug(5, "unknown prim %d\n",
+                               prim->prim);
+                        break;
+        }
+        return 0;
+}
+
+static int sna_dlc_llc_tx_test_c(struct sna_tg_cb *tg)
+{
+	struct sna_dlc_llc_addr *addr = &tg->llc_addr;
+	struct net_device *dev = tg->dev;
+	struct sk_buff *skb;
+	int size;
+
+	size = dev->hard_header_len + sna_dlc_llc_header_len(LLC_TEST_PRIM);
+	skb = alloc_skb(size + strlen(sna_product_name), GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+	skb_reserve(skb, size);
+	skb->dev = dev;
+	strncpy(skb_put(skb, strlen(sna_product_name)), sna_product_name,
+		strlen(sna_product_name));
+	return sna_dlc_llc_send_llc1(tg->llc_dl, skb, addr,
+		LLC_TEST_PRIM, LLC_PRIM_TYPE_REQ);
+}
+
+static int sna_dlc_llc_tx_xid_c(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	struct sna_dlc_llc_addr *addr = &tg->llc_addr;
+	struct net_device *dev = tg->dev;
+
+	skb->dev = dev;
+	return sna_dlc_llc_send_llc1(tg->llc_dl, skb, addr,
+                LLC_XID_PRIM, LLC_PRIM_TYPE_REQ);
+}
+
+static int sna_dlc_llc_tx_xid_r(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	struct sna_dlc_llc_addr *addr = &tg->llc_addr;
+        struct net_device *dev = tg->dev;
+
+	skb->dev = dev;
+        return sna_dlc_llc_send_llc1(tg->llc_dl, skb, addr,
+                LLC_XID_PRIM, LLC_PRIM_TYPE_RESP);
+}
+
+#endif	/* CONFIG_SNA_LLC */
+
+int sna_dlc_test_req(struct sna_tg_cb *tg) 
+{
+	int err = -EINVAL;
+	
+	switch (tg->type) {
+#ifdef CONFIG_SNA_LLC
+		case ARPHRD_FDDI:
+		case ARPHRD_ETHER:
+		case ARPHRD_IEEE802:
+			err = sna_dlc_llc_tx_test_c(tg);
+			break;
+#endif	/* CONFIG_SNA_LLC */
+	}
+	return err;
+}
+
+int sna_dlc_xid_min_len(struct sna_tg_cb *tg)
+{
+	int size = tg->dev->hard_header_len;
+
+#ifdef CONFIG_SNA_LLC
+	size += sna_dlc_llc_header_len(LLC_XID_PRIM);
+#endif
+	return size;
+}
+
+int sna_dlc_xid_reserve(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	skb_reserve(skb, sna_dlc_xid_min_len(tg));
+	return 0;
+}
+
+int sna_dlc_xid_req(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	int err = -EINVAL;
+
+	sna_debug(5, "init\n");
+        switch (tg->type) {
+#ifdef CONFIG_SNA_LLC
+                case ARPHRD_FDDI:
+                case ARPHRD_ETHER:
+                case ARPHRD_IEEE802:
+                        err = sna_dlc_llc_tx_xid_c(tg, skb);
+                        break;
+#endif  /* CONFIG_SNA_LLC */
+        }
+        return err;
+}
+
+int sna_dlc_xid_rsp(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	int err = -EINVAL;
+
+	sna_debug(5, "init\n");
+        switch (tg->type) {
+#ifdef CONFIG_SNA_LLC
+                case ARPHRD_FDDI:
+                case ARPHRD_ETHER:
+                case ARPHRD_IEEE802:
+                        err = sna_dlc_llc_tx_xid_r(tg, skb);
+                        break;
+#endif  /* CONFIG_SNA_LLC */
+        }
+        return err;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_ds.c linux/net/sna/sna_ds.c
--- linux-2.4.18-clean/net/sna/sna_ds.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ds.c	Sat Jun  8 15:38:12 2002
@@ -0,0 +1,116 @@
+/* sna_ds.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static LIST_HEAD(ds_clients);
+
+struct sna_ds_pinfo *sna_ds_find(__u8 *name)
+{
+	struct sna_ds_pinfo *ds;
+	struct list_head *le;
+
+	list_for_each(le, &ds_clients) {
+		ds = list_entry(le, struct sna_ds_pinfo, list);
+                if (!strncmp(ds->netid.name, name, SNA_NODE_NAME_LEN))
+			return ds;
+	}
+        return NULL;
+}
+
+int sna_ds_shutdown(void)
+{
+	struct list_head *le, *se;
+	struct sna_ds_pinfo *ds;
+
+	sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &ds_clients) {
+		ds = list_entry(le, struct sna_ds_pinfo, list);
+		list_del(&ds->list);
+                kfree(ds);
+        }
+        return 0;
+}
+
+int sna_ds_create(struct sna_start_node *start)
+{
+	struct sna_ds_pinfo *ds;
+
+	sna_debug(5, "init: %s\n", start->netid.name);
+	ds = sna_ds_find(start->netid.name);
+	if (ds)
+		return -EEXIST;
+	new(ds, GFP_ATOMIC);
+	if (!ds)
+		return -ENOMEM;
+	memcpy(&ds->netid, &start->netid, sizeof(struct sna_netid));
+	list_add_tail(&ds->list, &ds_clients);
+	return 0;
+}
+
+int sna_ds_destroy(struct sna_delete_node *delete)
+{
+	struct list_head *le, *se;
+        struct sna_ds_pinfo *ds;
+
+        sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &ds_clients) {
+		ds = list_entry(le, struct sna_ds_pinfo, list);
+                if (!strncmp(ds->netid.name, delete->netid.name, 8)) {
+			list_del(&ds->list);
+                        kfree(ds);
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+int sna_ds_update_directory(void)
+{
+	return 0;
+}
+
+int sna_ds_update_cp_status(void)
+{
+	return 0;
+}
+
+int sna_ds_locate_message(void)
+{
+	return 0;
+}
+
+int sna_ds_request_local_search(void)
+{
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_ebcdic.c linux/net/sna/sna_ebcdic.c
--- linux-2.4.18-clean/net/sna/sna_ebcdic.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ebcdic.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,169 @@
+/* sna_ebcdic.c: Linux-SNA EBCDIC/ASCII converter.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+
+#include <linux/sna.h>
+
+unsigned char etor(unsigned char a)
+{
+        return ebcdic_to_rotated[a];
+}
+
+char *etor_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while (count-- && (*dest++ = etor(*src++)) != '\0')
+                /* Nothing */;
+        return tmp;
+}
+
+/* Convert a single charater from EBCDIC to ASCII */
+unsigned char etoa(unsigned char a)
+{
+        return ebcdic_to_ascii_sna[a];
+}
+
+/* Convert a single character from ASCII to EBCDIC */
+unsigned char atoe(unsigned char a)
+{
+	return ascii_to_ebcdic_sna[a];
+}
+
+char *atoe_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while ((*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+        return tmp;
+}
+
+char *etoa_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while ((*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+        return tmp;
+}
+
+char *atoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while (count-- && (*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+        return tmp;
+}
+
+char *fatoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while (count--)
+		(*dest++ = atoe(*src++));
+	return tmp;
+}
+
+char *etoa_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while (count-- && (*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+        return tmp;
+}
+
+int atoe_strcmp(const char *acs, const char *ect)
+{
+        register signed char __res;
+
+        while (1) {
+                if ((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+        }
+        return __res;
+}
+
+int etoa_strcmp(const char *ecs, const char *act)
+{
+        register signed char __res;
+
+        while (1) {
+                if ((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+        }
+        return __res;
+}
+
+int atoe_strncmp(const char *acs, const char *ect, size_t count)
+{
+        register signed char __res = 0;
+
+        while (count) {
+                if ((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+                count--;
+        }
+        return __res;
+}
+
+int etoa_strncmp(const char *ecs, const char *act, size_t count)
+{
+        register signed char __res = 0;
+
+        while (count) {
+                if ((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+                count--;
+        }
+        return __res;
+}
+
+#define nibble(v, w)    ((v >> (w * 4)) & 0x0F)
+
+static unsigned char rbits[16] = {
+        0x00, 0x08, 0x04, 0x0C, 0x02, 0x0A, 0x06, 0x0E,
+        0x01, 0x09, 0x05, 0x0D, 0x03, 0x0B, 0x07, 0x0F
+};
+
+unsigned char flip_nibble(unsigned char v)
+{
+        return rbits[v & 0x0F];
+}
+
+unsigned char flip_byte(unsigned char v)
+{
+        return (flip_nibble(nibble(v, 0)) << 4) | flip_nibble(nibble(v, 1));
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_hsr.c linux/net/sna/sna_hsr.c
--- linux-2.4.18-clean/net/sna/sna_hsr.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_hsr.c	Fri Jun  7 14:21:21 2002
@@ -0,0 +1,156 @@
+/* sna_hsr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Half Session Router (HSR)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+#include <linux/uio.h>
+#include <linux/unistd.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/sna.h>
+
+#ifdef NOT
+struct sna_hs_local *hs_local_list = NULL;
+
+__u16	sys_snf_ids = 0;
+
+int sna_hs_local_queue_head(struct sna_hs_local *local);
+
+/* This procedure causes the half-session to be initialized. */
+int sna_hs_create(struct sna_init_hs *hs)
+{
+	struct sna_hs_local *local;
+	struct sna_init_hs_rsp *hs_rsp;
+
+	local = SNA_HS_MALLOC(struct sna_hs_local);
+	memset(local, 0, sizeof(struct sna_hs_local));
+	local->hs_id 			= hs->hs_id;
+	local->lu_id 			= hs->lu_id;
+	local->half_session 		= hs->type;
+	local->sense 			= 0;
+	local->perm_buf_pool_id 	= hs->perm_buf_pool_id;
+	local->limit_buf_pool_id	= hs->limit_buf_pool_id;
+	local->dynamic_buf_pool_id	= hs->dynamic_buf_pool_id;
+	local->catch_mu			= NULL;
+	sna_hs_local_queue_head(local);
+
+	sna_tc_init(hs);
+	sna_dfc_init(hs);
+
+	hs_rsp = SNA_HS_MALLOC(struct sna_init_hs_rsp);
+	hs_rsp->sense = local->sense;
+	hs_rsp->hs_id = local->hs_id;
+
+	if (local->sense == 0)
+		hs_rsp->type = 1;
+	else
+		hs_rsp->type = 0;
+
+	sna_send_to_sm((struct sna_mu *)hs_rsp);
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return 0;
+}
+
+/* Does processing for the half-session (FM profile 19). Message units
+ * received from RM and PS are routed to DFC. Message units received from
+ * PC are routed to TC. THe half-session continues to operate until and error
+ * condition occurs or the half session process is destroyed. If an error
+ * condition occurs, local->sense is set (by DFC or TC) with the sense
+ * data indicating what kind of error occured. When this field is set, the
+ * half-session sends an ABORT message to SM. This causes SM to send an
+ * UNBIND(protocol error) for this session. HS recevies BUFFERS_RESERVED
+ * signals from buffer manager and builds and sends the appropriate pacing
+ * response.
+ *
+ * sna_process_lu_lu_session();
+ */
+int sna_hs_local_queue_head(struct sna_hs_local *local)
+{
+	struct sna_hs_local *next, *prev;
+
+	prev 		= hs_local_list;
+	next 		= prev->next;
+	local->next	= next;
+	local->prev	= prev;
+	next->prev	= local;
+	prev->next	= local;
+	return 0;
+}
+
+struct sna_hs_local *sna_hs_find_local(__u8 hs_id)
+{
+	struct sna_hs_local *local;
+
+        for (local = hs_local_list; local != NULL; local = local->next) {
+		if (local->hs_id == hs_id)
+			return local;
+        }
+        return NULL;
+}
+
+struct sna_mu *sna_catch_mu(struct sna_hs_local *local)
+{
+	while (local->catch_mu == NULL)
+		schedule();
+	return local->catch_mu;
+}
+#endif
+
+extern int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb);
+
+int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+	struct sna_rcb *rcb)
+{
+	sna_debug(5, "init\n");
+	switch (who) {
+		case SNA_PS:
+			sna_dfc_send_from_ps(skb, rcb);
+			break;
+
+#ifdef NOT
+		case SNA_RM:
+			sna_dfc_send_from_rm(skb);
+			break;
+
+		case SNA_PC:
+			sna_tc_rcv(skb);
+			break;
+#endif
+
+		default:
+			return -1;
+	}
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_isr.c linux/net/sna/sna_isr.c
--- linux-2.4.18-clean/net/sna/sna_isr.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_isr.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,92 @@
+/* sna_isr.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_isr_create(struct sna_cp_create_parms *newisr)
+{
+	return 0;
+}
+
+int sna_isr_assign_lfsid_rsp(void)
+{
+	return 0;
+}
+
+int sna_isr_lfsid_in_use(void)
+{
+	return 0;
+}
+
+int sna_isr_session_route_inop(void)
+{
+	return 0;
+}
+
+int sna_isr_update_slu_mode(void)
+{
+	return 0;
+}
+
+int sna_isr_delete_slu_mode(void)
+{
+	return 0;
+}
+
+int sna_isr_query_slu_mode(void)
+{
+	return 0;
+}
+
+int sna_isr_abort_sc(void)
+{
+	return 0;
+}
+
+int sna_isr_assign_pcid_rsp(void)
+{
+	return 0;
+}
+
+int sna_isr_cinit(void)
+{
+	return 0;
+}
+
+int sna_isr_init_neg_rsp(void)
+{
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_nof.c linux/net/sna/sna_nof.c
--- linux-2.4.18-clean/net/sna/sna_nof.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_nof.c	Sat Jun  8 15:39:10 2002
@@ -0,0 +1,1032 @@
+/* sna_nof.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif	/* CONFIG_SNA_LLC */
+
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+
+/* One entry for each "node" started. */
+static LIST_HEAD(nof_node_list);
+
+struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n)
+{
+	struct sna_nof_pinfo *nof;
+	struct list_head *le;
+
+	sna_debug(5, "init\n");
+	list_for_each(le, &nof_node_list) {
+		nof = list_entry(le, struct sna_nof_pinfo, list);
+		if (!strcmp(n->net, nof->netid.net) 
+			&& !strcmp(n->name, nof->netid.name))
+				return &nof->nodeid;
+	}
+	return NULL;
+}
+
+struct sna_nof_pinfo *sna_nof_find(char *node_name)
+{
+        struct sna_nof_pinfo *nof;
+	struct list_head *le;
+
+	list_for_each(le, &nof_node_list) {
+		nof = list_entry(le, struct sna_nof_pinfo, list);
+		if (!strncmp(nof->netid.name, node_name, SNA_NODE_NAME_LEN))
+			return nof;
+        }
+        return NULL;
+}
+
+int sna_nof_delete_dlc(struct net_device *dev)
+{
+        sna_debug(5, "init: %s\n", dev->name);
+        return sna_cs_delete_dlc(dev);
+}
+
+int sna_nof_define_dlc(struct net_device *dev)
+{
+        sna_debug(5, "init: %s\n", dev->name);
+	return sna_cs_define_dlc(dev);
+}
+
+static int sna_nof_delete_node(struct sna_delete_node *delete)
+{
+	struct list_head *le, *se;
+	struct sna_nof_pinfo *nof; 
+	int err = -ENOENT;
+
+        sna_debug(5, "init: %s\n", delete->netid.name);
+	sna_attach_destroy(delete);
+	sna_cpic_destroy(delete);
+	sna_rm_destroy(delete);
+	sna_trs_destroy(delete);
+	sna_cs_destroy(delete);
+	sna_ds_destroy(delete);
+	sna_ss_destroy(delete);
+	sna_asm_destroy(delete);
+
+	list_for_each_safe(le, se, &nof_node_list) {
+		nof = list_entry(le, struct sna_nof_pinfo, list);
+                if (!strncmp(nof->netid.name, delete->netid.name, 8)) {
+			list_del(&nof->list);
+                        kfree(nof);
+			sna_mod_dec_use_count();
+			err = 0;
+			break;
+                } 
+        }
+        return err;
+}
+
+static int sna_nof_stop_node(struct sna_stop_node *stop)
+{
+	sna_debug(5, "init: %s\n", stop->netid.name);
+	sna_debug(5, "Function not implemented use delete\n");
+	return -EINVAL;
+}
+
+static int sna_nof_start_node(struct sna_start_node *start)
+{
+	struct sna_nof_pinfo *nof;
+
+	sna_debug(5, "init: %s\n", start->netid.name);
+	if (sna_nof_find(start->netid.name))
+		return -EEXIST;
+	new(nof, GFP_ATOMIC);
+	if (!nof)
+		return -ENOMEM;
+        memcpy(&nof->netid, &start->netid, sizeof(struct sna_netid));
+	nof->nodeid.block_id	= start->nodeid.block_id;
+	nof->nodeid.pu_id	= start->nodeid.pu_id;
+	nof->type	= start->type;
+	nof->lu_seg	= start->lu_seg;
+	nof->bind_seg	= start->bind_seg;
+	nof->max_lus	= start->max_lus;
+
+	switch (start->type) {
+		case SNA_LEN_END_NODE:
+		case SNA_APPN_END_NODE:
+		case SNA_APPN_NET_NODE:
+			nof->type = start->type;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	nof->status	= (SNA_UP | SNA_RUNNING);
+	list_add_tail(&nof->list, &nof_node_list);
+
+	sna_asm_create(start);
+	sna_ss_create(start);
+	sna_ds_create(start);
+	sna_cs_create(start);
+	sna_trs_create(start);
+	sna_cpic_create(start);
+	sna_attach_create(start);
+	sna_tc_init();
+
+	sna_mod_inc_use_count();
+
+#ifdef NOT
+	nof->netid_registered			= start->netid_registered;
+	nof->ls_supp_type			= start->ls_supp_type;
+	nof->resource_registration		= start->resource_registration;
+	nof->segment_generation_lvl		= start->segment_generation_lvl;
+	nof->mode_to_cos_mapping		= start->mode_to_cos_mapping;
+	nof->ms_node_type			= start->ms_node_type;
+	nof->mj_vector_file			= start->mj_vector_file;
+	nof->ms_log_file			= start->ms_log_file;
+	nof->peer_resource_registration		
+		= start->peer_resource_registration;
+	nof->network_node_type			= start->network_node_type;
+	nof->directory_type_supp		= start->directory_type_supp;
+	nof->rs_tree_update_type		= start->rs_tree_update_type;
+	nof->tdm_node_name			= start->tdm_node_name;
+	nof->cosdm_node_name			= start->cosdm_node_name;
+	nof->max_rs_cache_trees			= start->max_rs_cache_trees;
+	nof->max_oos_tdm_updates		= start->max_oos_tdm_updates;
+	nof->resource_service_search		
+		= start->resource_service_search;
+	nof->general_odai_usage_supp		
+		= start->general_odai_usage_supp;
+#endif
+	return 0;
+}
+
+static int sna_nof_reset_session_limit(struct sna_reset_session_limit *rsl)
+{
+	return 0;
+}
+
+static int sna_nof_delete_link_station(struct sna_delete_link_station *dls)
+{
+	int err;
+
+	sna_debug(5, "init\n");
+	err = sna_cs_delete_ls(dls);
+	return err;
+}
+
+static int sna_nof_deactivate_control_sessions(struct sna_deactivate_control_sessions *dcs)
+{
+	return 0;
+}
+
+static int sna_nof_delete_port(struct sna_delete_port *dp)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_delete_port(dp);
+}
+
+static int sna_nof_define_mode(struct sna_define_mode *dm)
+{
+	sna_debug(5, "init\n");
+	return sna_rm_define_mode(dm);
+}
+
+static int sna_nof_activate_control_sessions(struct sna_activate_control_sessions *acs)
+{
+	return 0;
+}
+
+static int sna_nof_change_session_limit(struct sna_change_session_limit *csl)
+{
+
+	return 0;
+}
+
+static int sna_nof_define_adjacent_node(struct sna_define_adjacent_node *daj)
+{
+	return 0;
+}
+
+static int sna_nof_define_class_of_service(struct sna_define_cos *cos)
+{
+	sna_debug(5, "init\n");
+	return sna_cosm_define_cos(cos);
+}
+
+static int sna_nof_define_connection_network(struct sna_define_connection_network *dcn)
+{
+	return 0;
+}
+
+static int sna_nof_define_directory_entry(struct sna_define_directory_entry *de)
+{
+	return 0;
+}
+
+static int sna_nof_define_isr_tuning(struct sna_define_isr_tuning *dit)
+{
+	return 0;
+}
+
+static int sna_nof_define_link_station(struct sna_define_link_station *dls)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_define_ls(dls);
+}
+
+static int sna_nof_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	sna_debug(5, "init\n");
+	return sna_rm_define_local_lu(dlu);
+}
+
+static int sna_nof_define_node_chars(struct sna_define_node_chars *dnc)
+{
+	sna_debug(5, "init\n");
+	return sna_tdm_define_node_chars(dnc);
+}
+
+static int sna_nof_define_partner_lu(struct sna_define_partner_lu *dplu)
+{
+	sna_debug(5, "init\n");
+	return sna_rm_define_remote_lu(dplu);
+}
+
+static int sna_nof_define_port(struct sna_define_port *dp)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_define_port(dp);
+}
+
+static int sna_nof_define_tp(struct sna_define_tp *dtp)
+{
+	return 0;
+}
+
+static int sna_nof_delete_adjacent_node(struct sna_delete_adjacent_node *dan)
+{
+	return 0;
+}
+
+static int sna_nof_delete_class_of_service(struct sna_delete_cos *cos)
+{
+	sna_debug(5, "init\n");
+	return sna_cosm_delete_cos(cos);
+}
+
+static int sna_nof_delete_connection_network(struct sna_delete_connection_network *dcn)
+{
+	return 0;
+}
+
+static int sna_nof_delete_directory_entry(struct sna_delete_directory_entry *dde)
+{
+	return 0;
+}
+
+static int sna_nof_delete_isr_tuning(struct sna_delete_isr_tuning *dit)
+{
+	return 0;
+}
+
+static int sna_nof_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+	sna_debug(5, "init\n");
+	return sna_rm_delete_local_lu(dlu);
+}
+
+static int sna_nof_delete_mode(struct sna_delete_mode *dm)
+{
+	sna_debug(5, "init\n");
+	return 0;
+//	return sna_rm_delete_mode(dm);
+}
+
+static int sna_nof_delete_partner_lu(struct sna_delete_partner_lu *dplu)
+{
+	sna_debug(5, "init\n");
+	return sna_rm_delete_remote_lu(dplu);
+}
+
+static int sna_nof_delete_tp(struct sna_delete_tp *dtp)
+{
+	return 0;
+}
+
+static int sna_nof_initialize_session_limit(struct sna_initialize_session_limit *isl)
+{
+	return 0;
+}
+
+static int sna_nof_start_link_station(struct sna_start_link_station *sls)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_start_ls(sls);
+}
+
+static int sna_nof_start_port(struct sna_start_port *sp)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_start_port(sp);
+}
+
+static int sna_nof_start_tp(struct sna_start_tp *stp)
+{
+	return 0;
+}
+
+static int sna_nof_stop_link_station(struct sna_stop_link_station *sls)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_stop_ls(sls);
+}
+
+static int sna_nof_stop_port(struct sna_stop_port *sp)
+{
+	sna_debug(5, "init\n");
+	return sna_cs_stop_port(sp);
+}
+
+/*
+ * NOF: Operators facility into the SNA node.
+ *
+ * setsockopt:
+ *  - 
+ * getsockopt:
+ *  -
+ */
+
+#ifdef CONFIG_PROC_FS
+int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_nof_pinfo *nof;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%s%s %s\n%-17s%-5s%-7s%-9s%-8s\n", 
+		"Linux-SNA v", sna_version, sna_maintainer, "NetID.Node",
+		"type", "lu_seg", "bind_seg", "max_lus");
+
+	list_for_each(le, &nof_node_list) {
+		nof = list_entry(le, struct sna_nof_pinfo, list);
+		len += sprintf(buffer + len, "%-18s",sna_pr_netid(&nof->netid));
+		len += sprintf(buffer + len, "%02X   %-7d%-9d%-8ld\n",
+			nof->type, nof->lu_seg, nof->bind_seg, nof->max_lus);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
+
+int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+        switch (optname) {
+                case SNA_ACTIVATE_CONTROL_SESSIONS: {
+                        struct sna_activate_control_sessions act_ctrl_sess;
+                        if (optlen<sizeof(struct sna_activate_control_sessions))
+                                return -EINVAL;
+                        if (copy_from_user(&act_ctrl_sess, optval,
+                                sizeof(struct sna_activate_control_sessions)))
+                                return -EFAULT;
+                        err = sna_nof_activate_control_sessions(&act_ctrl_sess);
+                        break;
+                }
+
+                case SNA_CHANGE_SESSION_LIMIT: {
+                        struct sna_change_session_limit chg_sess_limit;
+                        if (optlen < sizeof(struct sna_change_session_limit))
+                                return -EINVAL;
+                        if (copy_from_user(&chg_sess_limit, optval,
+                                sizeof(struct sna_change_session_limit)))
+                                return -EFAULT;
+                        err = sna_nof_change_session_limit(&chg_sess_limit);
+                        break;
+                }
+
+                case SNA_DEACTIVATE_CONTROL_SESSIONS: {
+                        struct sna_deactivate_control_sessions deact_cntrl_sess;
+                        if (optlen < sizeof(struct sna_deactivate_control_sessions))
+                                return -EINVAL;
+                        if (copy_from_user(&deact_cntrl_sess, optval,
+                                sizeof(struct sna_deactivate_control_sessions)))
+				return -EFAULT;
+			err = sna_nof_deactivate_control_sessions(&deact_cntrl_sess);
+                        break;
+                }
+
+                case SNA_DEFINE_ADJACENT_NODE: {
+                        struct sna_define_adjacent_node define_adjacent_node;
+                        if (optlen < sizeof(struct sna_define_adjacent_node))
+                                return -EINVAL;
+                        if (copy_from_user(&define_adjacent_node, optval,
+                                sizeof(struct sna_define_adjacent_node)))
+                                return -EFAULT;
+                        err = sna_nof_define_adjacent_node(&define_adjacent_node);
+                        break;
+                }
+
+                case SNA_DEFINE_CLASS_OF_SERVICE: {
+                        struct sna_define_cos cos;
+                        if (optlen < sizeof(struct sna_define_cos))
+                                return -EINVAL;
+                        if (copy_from_user(&cos, optval,
+                                sizeof(struct sna_define_cos)))
+                                return -EFAULT;
+                        err = sna_nof_define_class_of_service(&cos);
+                        break;
+                }
+
+                case SNA_DEFINE_CONNECTION_NETWORK: {
+                        struct sna_define_connection_network define_cn;
+                        if (optlen < sizeof(struct sna_define_connection_network))
+                                return -EINVAL;
+                        if (copy_from_user(&define_cn, optval,
+                                sizeof(struct sna_define_connection_network)))
+                                return -EFAULT;
+                        err = sna_nof_define_connection_network(&define_cn);
+                        break;
+                }
+
+                case SNA_DEFINE_DIRECTORY_ENTRY: {
+                        struct sna_define_directory_entry define_dir_entry;
+                        if (optlen < sizeof(struct sna_define_directory_entry))
+                                return -EINVAL;
+                        if (copy_from_user(&define_dir_entry, optval,
+                                sizeof(struct sna_define_directory_entry)))
+                                return -EFAULT;
+                        err = sna_nof_define_directory_entry(&define_dir_entry);
+                        break;
+                }
+
+                case SNA_DEFINE_ISR_TUNING: {
+                        struct sna_define_isr_tuning define_isr_tuning;
+                        if (optlen < sizeof(struct sna_define_isr_tuning))
+                                return -EINVAL;
+                        if (copy_from_user(&define_isr_tuning, optval,
+                                sizeof(struct sna_define_isr_tuning)))
+                                return -EFAULT;
+                        err = sna_nof_define_isr_tuning(&define_isr_tuning);
+                        break;
+                }
+
+                case SNA_DEFINE_LINK_STATION: {
+                        struct sna_define_link_station define_ls;
+                        if (optlen < sizeof(struct sna_define_link_station))
+                                return -EINVAL;
+                        if (copy_from_user(&define_ls, optval,
+                                sizeof(struct sna_define_link_station)))
+                                return -EFAULT;
+                        err = sna_nof_define_link_station(&define_ls);
+                        break;
+                }
+
+                case SNA_DEFINE_LOCAL_LU: {
+                        struct sna_define_local_lu define_llu;
+                        if (optlen < sizeof(struct sna_define_local_lu))
+                                return -EINVAL;
+                        if (copy_from_user(&define_llu, optval,
+                                sizeof(struct sna_define_local_lu)))
+                                return -EFAULT;
+                        err = sna_nof_define_local_lu(&define_llu);
+                        break;
+                }
+
+                case SNA_DEFINE_MODE: {
+                        struct sna_define_mode define_mode;
+                        if (optlen < sizeof(struct sna_define_mode))
+                                return -EINVAL;
+                        if (copy_from_user(&define_mode, optval,
+                                sizeof(struct sna_define_mode)))
+                                return -EFAULT;
+                       	err = sna_nof_define_mode(&define_mode);
+                        break;
+                }
+
+                case SNA_DEFINE_NODE_CHARS: {
+                        struct sna_define_node_chars define_node_chars;
+                        if (optlen < sizeof(struct sna_define_node_chars))
+                                return -EINVAL;
+                        if (copy_from_user(&define_node_chars, optval,
+                                sizeof(struct sna_define_node_chars)))
+                                return -EFAULT;
+                        err = sna_nof_define_node_chars(&define_node_chars);
+                        break;
+                }
+
+                case SNA_DEFINE_PARTNER_LU: {
+                        struct sna_define_partner_lu define_plu;
+                        if (optlen < sizeof(struct sna_define_partner_lu))
+                                return -EINVAL;
+                        if (copy_from_user(&define_plu, optval,
+                                sizeof(struct sna_define_partner_lu)))
+                                return -EFAULT;
+                        err = sna_nof_define_partner_lu(&define_plu);
+                        break;
+                }
+
+                case SNA_DEFINE_PORT: {
+                        struct sna_define_port define_port;
+                        if (optlen < sizeof(struct sna_define_port))
+                                return -EINVAL;
+                        if (copy_from_user(&define_port, optval,
+                                sizeof(struct sna_define_port)))
+                                return -EFAULT;
+                        err = sna_nof_define_port(&define_port);
+                        break;
+                }
+
+                case SNA_DEFINE_TP: {
+                        struct sna_define_tp define_tp;
+                        if (optlen < sizeof(struct sna_define_tp))
+                                return -EINVAL;
+                        if (copy_from_user(&define_tp, optval,
+                                sizeof(struct sna_define_tp)))
+                                return -EFAULT;
+                        err = sna_nof_define_tp(&define_tp);
+                        break;
+                }
+
+                case SNA_DELETE_ADJACENT_NODE: {
+                        struct sna_delete_adjacent_node delete_adjacent_node;
+                        if (optlen < sizeof(struct sna_delete_adjacent_node))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_adjacent_node, optval,
+                                sizeof(struct sna_delete_adjacent_node)))
+                                return -EFAULT;
+                        err = sna_nof_delete_adjacent_node(&delete_adjacent_node);
+                        break;
+                }
+
+                case SNA_DELETE_CLASS_OF_SERVICE: {
+                        struct sna_delete_cos cos;
+                        if (optlen < sizeof(struct sna_delete_cos))
+                                return -EINVAL;
+                        if (copy_from_user(&cos, optval,
+                                sizeof(struct sna_delete_cos)))
+                                return -EFAULT;
+                        err = sna_nof_delete_class_of_service(&cos);
+                        break;
+                }
+
+                case SNA_DELETE_CONNECTION_NETWORK: {
+                        struct sna_delete_connection_network delete_cn;
+                        if (optlen < sizeof(struct sna_delete_connection_network))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_cn, optval,
+                                sizeof(struct sna_delete_connection_network)))
+                                return -EFAULT;
+                        err = sna_nof_delete_connection_network(&delete_cn);
+                        break;
+                }
+
+                case SNA_DELETE_DIRECTORY_ENTRY: {
+                        struct sna_delete_directory_entry delete_dir_entry;
+                        if (optlen < sizeof(struct sna_delete_directory_entry))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_dir_entry, optval,
+                                sizeof(struct sna_delete_directory_entry)))
+                                return -EFAULT;
+                        err = sna_nof_delete_directory_entry(&delete_dir_entry);
+                        break;
+                }
+
+                case SNA_DELETE_ISR_TUNING: {
+                        struct sna_delete_isr_tuning delete_isr_tuning;
+                        if (optlen < sizeof(struct sna_delete_isr_tuning))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_isr_tuning, optval,
+                                sizeof(struct sna_delete_isr_tuning)))
+                                return -EFAULT;
+                        err = sna_nof_delete_isr_tuning(&delete_isr_tuning);
+                        break;
+                }
+
+                case SNA_DELETE_LINK_STATION: {
+                        struct sna_delete_link_station delete_ls;
+                        if (optlen < sizeof(struct sna_delete_link_station))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_ls, optval,
+                                sizeof(struct sna_delete_link_station)))
+                                return -EFAULT;
+                        err = sna_nof_delete_link_station(&delete_ls);
+                        break;
+                }
+
+                case SNA_DELETE_LOCAL_LU: {
+                        struct sna_delete_local_lu delete_llu;
+                        if (optlen < sizeof(struct sna_delete_local_lu))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_llu, optval,
+                                sizeof(struct sna_delete_local_lu)))
+                                return -EFAULT;
+                        err = sna_nof_delete_local_lu(&delete_llu);
+                        break;
+                }
+
+                case SNA_DELETE_MODE: {
+                        struct sna_delete_mode delete_mode;
+                        if (optlen < sizeof(struct sna_delete_mode))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_mode, optval,
+                                sizeof(struct sna_delete_mode)))
+                                return -EFAULT;
+                        err = sna_nof_delete_mode(&delete_mode);
+                        break;
+                }
+
+                case SNA_DELETE_PARTNER_LU: {
+                        struct sna_delete_partner_lu delete_plu;
+                        if (optlen < sizeof(struct sna_delete_partner_lu))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_plu, optval,
+                                sizeof(struct sna_delete_partner_lu)))
+                                return -EFAULT;
+                        err = sna_nof_delete_partner_lu(&delete_plu);
+                        break;
+                }
+
+                case SNA_DELETE_PORT: {
+                        struct sna_delete_port delete_port;
+                        if (optlen < sizeof(struct sna_delete_port))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_port, optval,
+                                sizeof(struct sna_delete_port)))
+                                return -EFAULT;
+                        err = sna_nof_delete_port(&delete_port);
+                        break;
+                }
+
+                case SNA_DELETE_TP: {
+                        struct sna_delete_tp delete_tp;
+                        if (optlen < sizeof(struct sna_delete_tp))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_tp, optval,
+                                sizeof(struct sna_delete_tp)))
+                                return -EFAULT;
+                        err = sna_nof_delete_tp(&delete_tp);
+                        break;
+                }
+
+                case SNA_INITIALIZE_SESSION_LIMIT: {
+                        struct sna_initialize_session_limit init_sess_limit;
+                        if (optlen < sizeof(struct sna_initialize_session_limit))
+				return -EINVAL;
+                        if (copy_from_user(&init_sess_limit, optval,
+                                sizeof(struct sna_initialize_session_limit)))
+                                return -EFAULT;
+                        err = sna_nof_initialize_session_limit(&init_sess_limit);
+                        break;
+                }
+
+                case SNA_RESET_SESSION_LIMIT: {
+                        struct sna_reset_session_limit reset_sess_limit;
+                        if (optlen < sizeof(struct sna_reset_session_limit))
+                                return -EINVAL;
+                        if (copy_from_user(&reset_sess_limit, optval,
+                                sizeof(struct sna_reset_session_limit)))
+                                return -EFAULT;
+                        err = sna_nof_reset_session_limit(&reset_sess_limit);
+                        break;
+                }
+
+                case SNA_START_LINK_STATION: {
+                        struct sna_start_link_station start_link_station;
+                        if (optlen < sizeof(struct sna_start_link_station))
+                                return -EINVAL;
+                        if (copy_from_user(&start_link_station, optval,
+                                sizeof(struct sna_start_link_station)))
+                                return -EFAULT;
+                        err = sna_nof_start_link_station(&start_link_station);
+                        break;
+                }
+
+                /* Start the SNA Node. */
+                case SNA_START_NODE: {
+                        struct sna_start_node start_node;
+                        if (optlen < sizeof(struct sna_start_node))
+                                return -EINVAL;
+                        if (copy_from_user(&start_node, optval,
+                                sizeof(struct sna_start_node)))
+                                return -EFAULT;
+                        err = sna_nof_start_node(&start_node);
+                        break;
+                }
+
+		case SNA_STOP_NODE: {
+			struct sna_stop_node stop_node;
+                        if (optlen < sizeof(struct sna_stop_node))
+                                return -EINVAL;
+                        if (copy_from_user(&stop_node, optval,
+                                sizeof(struct sna_stop_node)))
+                                return -EFAULT;
+                        err = sna_nof_stop_node(&stop_node);
+                        break;
+                }
+
+		case SNA_DELETE_NODE: {
+			struct sna_delete_node delete_node;
+                        if (optlen < sizeof(struct sna_delete_node))
+                                return -EINVAL;
+                        if (copy_from_user(&delete_node, optval,
+                                sizeof(struct sna_delete_node)))
+                                return -EFAULT;
+                        err = sna_nof_delete_node(&delete_node);
+                        break;
+                }
+
+                case SNA_START_PORT: {
+                        struct sna_start_port start_port;
+                        if (optlen < sizeof(struct sna_start_port))
+                                return -EINVAL;
+                        if (copy_from_user(&start_port, optval,
+                                sizeof(struct sna_start_port)))
+                                return -EFAULT;
+                        err = sna_nof_start_port(&start_port);
+                        break;
+                }
+
+                case SNA_START_TP: {
+                        struct sna_start_tp start_tp;
+                        if (optlen < sizeof(struct sna_start_tp))
+                                return -EINVAL;
+                        if (copy_from_user(&start_tp, optval,
+                                sizeof(struct sna_start_tp)))
+                                return -EFAULT;
+                        err = sna_nof_start_tp(&start_tp);
+                        break;
+                }
+
+                case SNA_STOP_LINK_STATION: {
+                        struct sna_stop_link_station stop_ls;
+                        if (optlen < sizeof(struct sna_stop_link_station))
+                                return -EINVAL;
+                        if (copy_from_user(&stop_ls, optval,
+                                sizeof(struct sna_stop_link_station)))
+                                return -EFAULT;
+                        err = sna_nof_stop_link_station(&stop_ls);
+                        break;
+                }
+
+                case SNA_STOP_PORT: {
+                        struct sna_stop_port stop_port;
+                        if (optlen < sizeof(struct sna_stop_port))
+                                return -EINVAL;
+                        if (copy_from_user(&stop_port, optval,
+                                sizeof(struct sna_stop_port)))
+                                return -EFAULT;
+                        err = sna_nof_stop_port(&stop_port);
+                        break;
+                }
+
+                default:
+                        return -EINVAL;
+        }
+	return err;
+}
+
+int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+        int len;
+
+        if (get_user(len, optlen))
+                return -EFAULT;
+        switch (optname) {
+                case SNA_QUERY_CLASS_OF_SERVICE: {
+                        struct sna_query_class_of_service *cos;
+
+                        len = min_t(int, len, sizeof(*cos));
+                        if (copy_to_user((void *)optval, &cos, len))
+                                return -EFAULT;
+                        break;
+                }
+
+                case SNA_QUERY_CONNECTION_NETWORK: {
+                        struct sna_query_connection_network *cn;
+
+                        len = min_t(int, len, sizeof(*cn));
+                        if (copy_to_user((void *)optval, &cn, len))
+                                return -EFAULT;
+                        break;
+                }
+
+		case SNA_QUERY_DLC: {
+                        struct sna_query_dlc *dlc;
+
+                        len = min_t(int, len, sizeof(*dlc));
+                        if (copy_to_user((void *)optval, &dlc, len))
+                                return -EFAULT;
+                        break;
+                }
+
+                case SNA_QUERY_ISR_TUNING: {
+                        struct sna_query_isr_tuning *isr;
+
+                        len = min_t(int, len, sizeof(*isr));
+                        if (copy_to_user((void *)optval, &isr, len))
+                                return -EFAULT;
+                        break;
+                }
+
+		case SNA_QUERY_LINK_STATION: {
+                        struct sna_query_link_station *ls;
+
+                        len = min_t(int, len, sizeof(*ls));
+                        if (copy_to_user((void *)optval, &ls, len))
+                                return -EFAULT;
+                        break;
+                }
+
+                case SNA_QUERY_PORT: {
+                        struct sna_query_port *port;
+
+                        len = min_t(int, len, sizeof(*port));
+                        if (copy_to_user((void *)optval, &port, len))
+                                return -EFAULT;
+                        break;
+                }
+
+#ifdef NOT
+                case SNA_QUERY_STATISTICS: {
+                        struct sna_query_statistics *stats;
+
+                        len = min_t(int, len, sizeof(*stats));
+                        if (copy_to_user((void *)optval, &stats, len))
+                                return -EFAULT;
+                }
+#endif
+                default:
+			return -EINVAL;
+        }
+
+        if (put_user(len, optlen))
+                return -EFAULT;
+        return 0;
+}
+
+int sna_nof_ginfo(struct sna_nof_pinfo *nof, char *buf, int len)
+{
+	struct snareq sr;
+	int done = 0;
+
+	sna_debug(10, "init\n");
+        if (!buf) {
+                done += sizeof(sr);
+                return done;
+        }
+        if (len < (int)sizeof(sr))
+                return done;
+        memset(&sr, 0, sizeof(struct snareq));
+
+        /* Move the data here */
+	strncpy(sr.net, nof->netid.net, 8);
+	strncpy(sr.name, nof->netid.name, 8);
+	sr.type 	= nof->type;
+	sr.lu_seg	= nof->lu_seg;
+	sr.bind_seg	= nof->bind_seg;
+	sr.max_lus	= nof->max_lus;
+	sr.node_status	= nof->status;
+	memcpy(&sr.nodeid, &nof->nodeid, sizeof(struct sna_nodeid));
+
+	if (copy_to_user(buf, &sr, sizeof(struct snareq)))
+                return -EFAULT;
+        buf  += sizeof(struct snareq);
+        len  -= sizeof(struct snareq);
+        done += sizeof(struct snareq);
+        return done;
+}
+	
+int sna_nof_query_node(char *arg)
+{
+	struct sna_nof_pinfo *nof;
+	int len, total, done;
+	struct list_head *le;
+	struct snaconf sc;
+	char *pos;
+
+	sna_debug(10, "init\n");
+	if (copy_from_user(&sc, arg, sizeof(sc)))
+                return -EFAULT;
+	pos = sc.snac_buf;
+        len = sc.snac_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &nof_node_list) {
+		nof = list_entry(le, struct sna_nof_pinfo, list);
+                if (pos == NULL)
+                        done = sna_nof_ginfo(nof, NULL, 0);
+                else
+                        done = sna_nof_ginfo(nof, pos + total, len - total);
+                if (done < 0)
+                        return -EFAULT;
+                total += done;
+	}
+
+	sc.snac_len = total;
+	if (copy_to_user(arg, &sc, sizeof(sc)))
+                return -EFAULT;
+	return 0;
+}
+
+int sna_nof_ioctl(int cmd, void *arg)
+{
+	sna_debug(5, "init\n");
+        switch (cmd) {
+		case SIOCGLS:
+			sna_cs_query_ls(arg);
+			break;
+
+		case SIOCGPORT:
+			sna_cs_query_port(arg);
+			break;
+
+		case SIOCGDLC:
+			sna_cs_query_dlc(arg);
+			break;
+
+                case SIOCGNODE:
+			sna_nof_query_node(arg);
+			break;
+
+		case SIOCGMODE:
+			sna_rm_query_mode(arg);
+			break;
+
+		case SIOCGLU:
+			sna_rm_query_lu(arg);
+			break;
+
+		case SIOCGPLU:
+			sna_rm_query_plu(arg);
+			break;
+
+		case SIOCGCOS:
+			sna_cosm_query_cos(arg);
+			break;
+
+                default:
+                        return -EINVAL;
+        }
+        return 0;
+} 
diff -ruN linux-2.4.18-clean/net/sna/sna_pc.c linux/net/sna/sna_pc.c
--- linux-2.4.18-clean/net/sna/sna_pc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_pc.c	Sat Jun  8 15:40:17 2002
@@ -0,0 +1,561 @@
+/* sna_pc.c: Linux Systems Network Architecture implementation
+ * - Path Control (Route message units between HS and DLC). 
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+
+static LIST_HEAD(pc_clients);
+
+struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id)
+{
+	struct sna_pc_pinfo *pc;
+	struct list_head *le;
+	
+	list_for_each(le, &pc_clients) {
+		pc = list_entry(le, struct sna_pc_pinfo, list);
+		if (!memcmp(&pc->pc_id, pc_id, 8))
+			return pc;
+	}
+	return NULL;
+}
+
+struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n)
+{
+	struct sna_pc_pinfo *pc;
+	struct list_head *le;
+	
+	list_for_each(le, &pc_clients) {
+		pc = list_entry(le, struct sna_pc_pinfo, list);
+		if (!strcmp(pc->fqcp.net, n->net)
+			&& !strcmp(pc->fqcp.name, n->name))
+			return pc;
+	}
+	return NULL;
+}
+
+/* Destroy a single PC instance. */
+int sna_pc_destroy(unsigned char *pc_id)
+{
+	struct list_head *le, *se;
+	struct sna_pc_pinfo *pc;
+
+	list_for_each_safe(le, se, &pc_clients) {
+		pc = list_entry(le, struct sna_pc_pinfo, list);
+		if (!memcmp(&pc->pc_id, pc_id, 8)) {
+			list_del(&pc->list);
+			kfree(pc);
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+/* Create a single PC instance. Return the PC ID. */
+int sna_pc_init(struct sna_pc_create_parms *npc)
+{
+	struct sna_pc_pinfo *pc;
+
+        sna_debug(5, "init: %s\n", sna_pr_netid(&npc->fqcp));
+	new(pc, GFP_ATOMIC);
+	if (!pc)
+		return -ENOMEM;
+	pc->type		= npc->type;
+	pc->dlc			= npc->dlc;
+	pc->ls			= npc->ls;
+	pc->port		= npc->port;
+
+	pc->max_tx_btu		= npc->max_tx_btu;
+	pc->max_rx_btu		= npc->max_rx_btu;
+	pc->bind_seg		= npc->bind_seg;
+	pc->limited_tg		= npc->limited_tg;
+	pc->tg_number		= npc->tg_number;
+
+	pc->odai		= npc->odai;
+	memcpy(&pc->fqcp, &npc->fqcp, sizeof(struct sna_netid));
+	pc->local_seg		= npc->local_seg;
+	pc->godai		= npc->godai;
+	list_add_tail(&pc->list, &pc_clients);
+
+	sna_ss_generate_pcid(pc->fqcp.net, pc->fqcp.name);
+	sna_ss_update_pcid(pc->pc_id);
+        return 0;
+}
+
+int sna_pc_mu_error_checker(struct sk_buff *skb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_pc_mu_error_checker (skb %d)\n", skb->len);
+
+	/* Need to check that FID type is valid and
+	 * correct TH, RH, and RU lengths.
+	 */
+
+	return err;
+}
+
+struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb)
+{
+	struct snathdr *th = skb->nh.fidh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "init: %02X\n", th->fid.f0.ft);
+	new(l, GFP_ATOMIC);
+	if (!l)
+		return NULL;
+	switch (th->fid.f0.ft) {	/* type field is in the same location for all */
+		case SNA_TH_FID0:
+		case SNA_TH_FID1:
+			break;
+
+		case SNA_TH_FID2:
+			l->odai 	= th->fid.f2.odai;
+			l->sid.hl.sidh 	= th->fid.f2.oaf;
+			l->sid.hl.sidl 	= th->fid.f2.daf;
+			break;
+
+		case SNA_TH_FID3:
+			break;
+
+		case SNA_TH_FID4:
+			break;
+
+		case SNA_TH_FID5:
+			break;
+
+		case SNA_TH_FIDF:
+			break;
+
+		default:
+			return NULL;
+	}
+	return l;
+}
+
+int sna_pc_mu_rcv_router(struct sk_buff *skb)
+{
+	struct snarhdr *rh = skb->h.rh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "sna_pc_mu_rcv_router\n");
+	l = sna_pc_xtract_lfsid(skb);
+	switch (rh->ru) {
+		case SNA_RH_RU_FMD:
+			sna_tc_rcv(skb, l);
+			break;
+
+		case SNA_RH_RU_SC:
+			sna_asm_rcv(skb, l);
+			break;
+
+		case SNA_RH_RU_DFC:
+		case SNA_RH_RU_NC:
+			/* haven't seen these two bad boys used lately, as I
+			 * forget where they should go we will let them die.
+			 */
+		default:
+			sna_debug(5, "Unknown RU catagory %02X\n", rh->ru);
+			kfree_skb(skb);
+			break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	off_t pos = 0, begin = 0;
+	struct sna_pc_pinfo *pc;
+	struct list_head *le;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%-17s%-10s\n",
+                "NetID.Node", "path_control_id", "tg_number");
+	list_for_each(le, &pc_clients) {
+		pc = list_entry(le, struct sna_pc_pinfo, list);
+                len += sprintf(buffer + len, "%-18s%"
+			"02X%02X%02X%02X%02X%02X%02X%02X %10d\n", 
+			sna_pr_netid(&pc->fqcp), 
+			pc->pc_id[0], pc->pc_id[1], pc->pc_id[2],
+			pc->pc_id[3], pc->pc_id[4], pc->pc_id[5], pc->pc_id[6],
+			pc->pc_id[7], pc->tg_number);
+
+		/* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
+
+#ifdef NOT
+/* Internode. */
+static int sna_pc_alert_handler(struct sna_mu *mu, __u32 sense)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "received alert signal.\n");
+	msg->mu = mu;
+	msg->sense = sense;
+//	sna_ms(msg);
+	return 0;
+}
+
+/* Internode. */
+static int sna_pc_flush_handler(void)
+{
+	sna_debug(5, "init\n");
+	return 0;
+}
+
+static int sna_pc_hs_adder(struct sna_pc_hs_table *newhs)
+{
+	struct sna_pc_hs_table *next, *prev;
+
+	sna_debug(5, "init\n");
+	next = sna_hs_table;
+	prev = next->prev;
+	newhs->next = next;
+	newhs->prev = prev;
+	next->prev = newhs;
+	prev->next = newhs;
+	return 0;
+}
+
+static struct sna_pc_hs_table *sna_pc_hs_finder(__u8 lfsid)
+{
+	struct sna_pc_hs_table *i;
+
+	for(i = sna_hs_table; i->next != NULL; i = i->next)
+        {
+                if(i->lfsid == lfsid)
+                        return (i);
+        }
+
+	return (NULL);
+}
+
+static int sna_pc_hs_deleter(__u8 lfsid)
+{
+	struct sna_pc_hs_table *prev, *next, *result;
+
+	sna_debug(5, "init\n");
+	prev = sna_pc_hs_finder(lfsid);
+	if(prev == NULL)
+		return (-1);
+
+        next = prev->next;
+        result = NULL;
+        if(next != prev)
+	{
+                result = next;
+                next = next->next;
+                next->prev = prev;
+                prev->next = next;
+                result->next = NULL;
+                result->prev = NULL;
+        }
+	kfree(result);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+	msg->cmd = SNA_BIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+        msg->cmd = SNA_BIND_RSP_RCV;
+//        sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_flush_ls(void)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	msg->cmd = SNA_LS_FLUSHED;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	msg->mu = mu;
+	msg->cmd = SNA_UNBIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	msg->mu = mu;
+        msg->cmd = SNA_UNBIND_RSP_RCV;
+    //    sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_send_free_lfsid(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	sna_debug(5, "init\n");
+	msg->mu = mu;
+	msg->cmd = SNA_FREE_LFSID;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_enqueuer(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+
+	switch(mu->tx_priority)
+	{
+		case (SNA_TP_NETWORK):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_network);
+			break;
+
+		case (SNA_TP_HIGH):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_high);
+			break;
+
+		case (SNA_TP_MEDIUM):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_medium);
+			break;
+
+		case (SNA_TP_LOW):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_low);
+			break;
+	}
+
+	mark_bh(PC_UPM_BM);
+	return (0);
+}
+
+static int sna_pc_fsm_send_mu(void)
+{
+	return (0);
+}
+
+static __u16 sna_pc_get_mu_pcid(__u8 lfsid)
+{
+	struct sna_pc_hs_table *hs_table_entry;
+
+	hs_table_entry = sna_pc_hs_finder(lfsid);
+
+	return (hs_table_entry->pc_id);
+}
+
+static int sna_pc_remote_send_mu_processing(struct sna_mu *mu)
+{
+	if(mu->dcf > 600) // sna_pc_max_btu_size)
+		sna_pc_segment_generator(mu);
+	else
+		sna_pc_enqueuer(mu);
+
+	return (0);
+}
+
+static int sna_pc_segment_generator(struct sna_mu *mu)
+{
+	struct sna_mu *newmu = NULL, *cmu = NULL;
+	int over_size, len = 0;
+	int sna_pc_max_btu_size = 600;
+
+//	sna_copy_mu(cmu, mu);
+
+//	sna_cut_mu_tail(mu, over_size);
+	sna_pc_enqueuer(mu);
+
+	for(over_size = cmu->dcf - sna_pc_max_btu_size;
+		over_size >= sna_pc_max_btu_size;
+		len = over_size - sna_pc_max_btu_size, over_size -= len)
+	{
+//		newmu = sna_bm_get_buff(len);
+		newmu->pc_id		= cmu->pc_id;
+		newmu->hs_id		= cmu->hs_id;
+		newmu->lfsid		= cmu->lfsid;
+		newmu->tx_priority	= cmu->tx_priority;
+		newmu->dcf		= len;
+		newmu->biu->rh 		= cmu->biu->rh;
+		newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+		newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_MID_MIU;
+//		newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+		newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+		newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+		newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+		newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+		sna_pc_enqueuer(newmu);
+	}
+
+//	newmu = sna_bm_get_buff(len);
+        newmu->pc_id    	= cmu->pc_id;
+        newmu->hs_id    	= cmu->hs_id;
+        newmu->lfsid    	= cmu->lfsid;
+	newmu->tx_priority      = cmu->tx_priority;
+        newmu->dcf      	= len;
+        newmu->biu->rh  	= cmu->biu->rh;
+        newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+	newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_EBIU;
+//	newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+	newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+        newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+        newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+        newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+	sna_pc_enqueuer(newmu);
+
+	return (0);
+}
+
+static int sna_pc_send_mu_to_dlc(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+	msg->cmd = SNA_PC_TO_DLC;
+//	sna_dlc(msg);
+
+	return (0);
+}
+
+/* Process the four different tx priority queues in a fair way. */
+static void sna_pc_upm_queue_aging_manager(void)
+{
+	unsigned long start_time = jiffies;
+	struct sna_msg_queue *msg;
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_high))
+	{
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_high);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+	}
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_network))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_network);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_medium))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_medium);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_low))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+		msg = sna_dequeue_msg(&sna_trpr_qs_low);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+        }
+	return;
+
+sna_pc_upm_queue_age_break:
+	mark_bh(PC_UPM_BM);
+	return;
+}
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_ps_conv.c linux/net/sna/sna_ps_conv.c
--- linux-2.4.18-clean/net/sna/sna_ps_conv.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ps_conv.c	Sat Jun  8 15:41:24 2002
@@ -0,0 +1,2418 @@
+/* sna_ps_conv.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Conversations (PS.CONV)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static int sna_ps_fmh5_options(struct sk_buff *skb, int tp_len, char *tp, 
+	int luw_len, int nqlu_len, char *nqlu, char *luw_i,
+	char *luw_s, int cc_len, char *cc)
+{
+	struct fmhdr *fm = skb->f.fm;
+	__u8 *ptr = &fm->fm.f5.raw;
+	int len = 0;
+
+	sna_debug(5, "sna_ps_fmh5_options\n");
+
+	/* Transaction program name field */
+	if (tp_len >= 1 && tp_len <= 64) {
+		memcpy(ptr, &tp_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, tp, tp_len);
+		len += tp_len;
+	} else 
+		return -1;
+
+	/* Logical-Unit-of-Work Identifier field */
+	if((luw_len <= 26 && luw_len >= 10)
+		&& (nqlu_len >= 1 && nqlu_len <= 17))
+	{
+		memcpy(ptr + len, &luw_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, &nqlu_len, sizeof(__u8));
+		len += 1;
+
+		memcpy(ptr + len, nqlu, nqlu_len);
+		len += nqlu_len;
+
+        	memcpy(ptr + len, luw_i, luw_len - 1);
+		len += luw_len - 1;
+        	memcpy(ptr + len, luw_s, 1);
+		len += 1;
+	}
+	else
+	{
+		if(luw_len != 0 || nqlu_len != 0)
+			return (-1);
+	}
+
+	/* Conversation correlator field */
+	if(cc_len >= 1 && cc_len <= 8)
+	{
+		memcpy(ptr + len, &cc_len, 1);
+		len += 1;
+		memcpy(ptr + len, cc, cc_len);
+		len += cc_len;
+	}
+	else
+	{
+		if(cc_len != 0)
+			return (-1);
+	}
+
+	return (len);
+}
+
+static int sna_ps_build_fmh5(struct sna_tcb *tcb, struct sna_rcb *rcb,
+	struct sk_buff *skb)
+{
+	struct fmhdr *fm = skb->f.fm;
+	char cc[9];
+	int len = 0;
+	unsigned char luw_s;
+
+	sna_debug(5, "sna_ps_build_fmh5\n");
+	fm->type	= FMH_5;
+	fm->fm.f5.cmd	= 0x02FF;
+	fm->fm.f5.vid	= 0;
+	fm->fm.f5.pvid	= 0;
+	fm->fm.f5.spwdi	= 0;
+	fm->fm.f5.pipi	= 0;
+	fm->fm.f5.xaid	= 0;
+	fm->fm.f5.fxct	= 3;
+
+	fm->fm.f5.resrc_type	= 0xD1;
+	fm->fm.f5.sync_level	= 0x01;
+
+	sprintf(cc, "%04X", tcb->tcb_id);
+	luw_s = 9;
+	len = sna_ps_fmh5_options(skb, tcb->tp_name_length, 
+		tcb->tp_name, 10, tcb->partner_lu_name_length, 
+		tcb->partner_lu_name, cc, &luw_s, 8, cc);
+	fm->len = sizeof(struct sna_fmh5) + len;
+	sna_debug(5, "fmh5 len is %d %d\n", fm->len, (sizeof(struct sna_fmh5) + len));
+
+	return (0);
+}
+
+static int sna_ps_rcb_allocated(struct sna_tcb *tcb, struct sna_rcb *rcb)
+{
+	struct sk_buff *skb;
+	int size;
+
+	sna_debug(5, "init\n");
+	size = 250;	/* Enough for a FM5 */
+	skb = alloc_skb(size, GFP_ATOMIC);
+	skb_reserve(skb, sizeof(struct snarhdr));
+	skb_reserve(skb, sizeof(struct sna_fid2));
+	skb->f.raw = skb_put(skb,50);
+
+	sna_ps_build_fmh5(tcb, rcb, skb);
+	rcb->l.ps_to_hs.fmh = 1;
+
+	sna_debug(5, "after build_fmh5 %d %d\n", rcb->oaf, rcb->daf);
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        switch(rcb_allocated->rcode)
+        {
+                case (OK):
+                        allocate_verb->rcode = OK;
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        allocate_verb->resource = rcb->rcb_id;
+                        sna_set_init_rcb(rcb);
+
+                        switch(allocate_verb->rcntrl)
+                        {
+                                case (WHEN_SESSION_ALLOCATED):
+                                        rcb->session_req = ANY;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONWINNER_ALLOCATED):
+                                        rcb->session_req = CONWINNER;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONV_GROUP_ALLOCATED):
+                                        rcb->session_req = SPECIFIC;
+                                        rcb->conv_group_id = allocate_verb->conversaion_group_id;
+                                        break;
+
+                                case (IMMEDIATE):
+                                        /* Do nothing */
+                                        break;
+                        }
+
+                        if(allocate_verb->rcntrl == IMMEDIATE)
+                        {
+                                sna_create_and_init_limited_mu(rcb, mu);
+                                mu->ps_to_hs.allocate = YES;
+                        }
+                        else
+                                sna_obtain_session_proc(rcb, allocate_verb);
+
+                        if(allocate_verb->rcode == OK)
+                                sna_build_fmh5(mu);
+                        else
+                                fsm_conversation(r, allocation_error_rc, rcb);
+                        break;
+
+                case (UNSUCCESSFUL):
+                        allocate_verb->rcode = UNSUCCESSFUL;
+                        break;
+
+                case (SYNC_LEVEL_NOT_SUPPORTED):
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        init_allocated_rcb();
+                        fsm_conversation(r, allocation_error_rc, rcb);
+                        allocate_verb->rcode = ALLOCATION_ERROR;
+                        allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED_BY_LU;                        break;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_allocate(struct sna_tcb *tcb)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_ps_allocate %d %d\n", tcb->oaf, tcb->daf);
+	rcb_id = sna_rm_allocate_rcb(tcb);
+	rcb = sna_rm_find_rcb_by_id(rcb_id);
+	if(rcb == NULL)
+		return (-1);
+
+	sna_debug(5, "now in ps alloc %d %d\n", rcb->oaf, rcb->daf);
+	sna_ps_rcb_allocated(tcb, rcb);
+
+	return (0);
+}
+
+static int sna_ps_send_data_buffer_management(struct sk_buff *skb, 
+	struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "sna_ps_send_data_buffer_management\n");
+	rcb = sna_rm_find_rcb_by_id(tcb->rcb_id);
+	if(rcb == NULL)
+	{
+		sna_debug(5, "no rcb located\n");
+		return (-1);
+	}
+	memset(&rcb->l.ps_to_hs, 0, sizeof(struct sna_ps_to_hs));
+
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        mu = get_buf_send_pool();
+        if(mu == NULL)
+                sna_create_and_init_limited_mu(rcb, mu);
+        else
+        {
+                if(mu is full and more data to send)
+                        send_to_hs(mu);
+                sna_create_and_init_limited_mu(rcb, mu);
+        }
+
+        while(data != NULL)
+        {
+                mu = data_up_to_size_of_mu;
+                if(mu is full and more data to send)
+                {
+                        send_to_hs(mu);
+                        if(more data to send)
+                                sna_create_and_init_limited_mu(rcb, mu);
+                }
+                else
+                        save_mu_to_send_later(mu);
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_send_data(struct sna_tcb *tcb)
+{
+        struct sk_buff *skb;
+
+	sna_debug(5, "sna_ps_send_data %d\n", tcb->tcb_id);
+	skb = skb_dequeue(&tcb->transmit_queue);
+        if (!skb) {
+		sna_debug(5, "No more data on tcb transmit queue\n");
+		return -1;
+	}
+
+	sna_ps_send_data_buffer_management(skb, tcb);
+
+#ifdef NOT
+	struct sna_rcb *rcb;
+
+        rcb = search_rcb(send_data_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                send_data_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                switch(fstate = sm_error_or_failure())
+                {
+                        case (CONV_FAILURE_PROTOCOL_ERROR):
+                        case (CONV_FAILURE_SON):
+                                if(state == CONV_FAILURE_SON)
+                                        send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                                break;
+
+                        case (RCVD_ERROR):
+                                if(mu == NULL)
+                                        sna_create_and_init_limited_mu(rcb, mu);                                mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+                                send_to_hs(mu);
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+                                state = fsm_error_or_failure();
+                                if(state == CONV_FAILURE_SON
+                                        || state == CONV_FAILURE_PROTOCOL_ERROR)                                {
+                                        if(state == CONV_FAILURE_SON)
+                                                send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                        else
+                                                send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                        fsm_conversation(r, resource_failure_rc, rcb);
+                                }
+                                else
+                                        sna_dequeue_fmh7_proc(send_data_verb, rcb);
+                                break;
+
+                        case (NO_REQUESTS):
+                                send_data_verb->rcode = OK;
+                                if(send_data_verb->max_length > 0)
+                                {
+                                        err = process_LL();
+                                        if(err != 0x0001)
+                                                send_data_verb->rcode = PROGRAM_PARAM_CHECK;
+                                        else
+                                                sna_send_data_buffer_management(send_data_verb->data, rcb);
+                                }
+                                break;
+
+                        default:
+                                /* Error */
+                }
+
+                send_data_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+                rcb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_rcv_wait(struct sna_tcb *tcb)
+{
+	sna_debug(5, "init\n");
+
+	/* handle signals */
+        if(signal_pending(current))
+        	return (-ERESTARTSYS);
+
+	if (skb_peek(&tcb->receive_queue) != NULL) {
+		sna_debug(5, "Queue already has data on it, retuning now!\n");
+		return (0);
+	}
+
+	interruptible_sleep_on(&tcb->sleep);
+
+	return (0);
+}
+
+static int sna_ps_rcv_immediate(struct sna_tcb *tcb)
+{
+	sna_debug(5, "init: %d\n", tcb->tcb_id);
+
+#ifdef NOT
+        struct sna_rcb *rcb;
+
+        rcb = search_rcb(receive_immediate_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                receive_immediate_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                state = fsm_error_or_failure();
+                if(state == RCVD_ERROR)
+                {
+                        if(find_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                        if(state == CONV_FAILURE_SON
+                                || state == CONV_FAILURE_PROTOCOL_ERROR)
+                        {
+                                if(state == CONV_FAILURE_SON)
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                        }
+                        else
+                                sna_dequeue_fmh7_proc(receive_immediate_verb, rcb);
+                }
+                else
+                {
+                        fsm_conversation(s, receive_immediate, rcb);
+                        rcb->post_conditions.max_length = receive_immediate_verb->max_length;
+                        rcb->post_conditions.fill = receive_immediate_verb->fill;
+                        receive_immediate_verb->data = NULL;
+                        sna_perform_receive_proc(rcv, receive_immediate_verb);
+                        fsm_post(receive_immediate);
+                }
+
+                receive_immediate_verb->max_length = length_data_returned;
+                receive_immediate_verb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+	return (0);
+}
+
+int sna_ps_conv(int verb, struct sna_tcb *tcb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_ps_conv\n");
+        switch(verb)
+        {
+                case (ALLOCATE):
+                        err = sna_ps_allocate(tcb);
+                        break;
+
+#ifdef NOT
+		case (CONFIRM):
+                        sna_confirm_proc(confirm_verb);
+                        break;
+
+                case (TEST):
+                        sna_test_proc(test_verb);
+                        break;
+
+                case (CONFIRMED):
+                        sna_confirmed_proc(confirmed_verb);
+                        break;
+
+                case (DEALLOCATE):
+                        sna_deallocate_proc(deallocate_verb);
+                        break;
+
+                case (FLUSH):
+                        sna_flush_proc(flush_verb);
+                        break;
+
+                case (GET_ATTRIBUTES):
+                        sna_get_attributes_proc(get_attributes_verb);
+                        break;
+
+                case (POST_ON_RECEIPT):
+                        sna_post_on_receipt_proc(post_on_receipt_verb);
+                        break;
+
+                case (SEND_ERROR):
+                        sna_send_error_proc(send_error_verb);
+                        break;
+
+		case (PREPARE_TO_RECEIVE):
+                        sna_prepare_to_receive_proc(prepare_to_receive_verb);
+                        break;
+
+                case (REQUEST_TO_SEND):
+                        sna_request_to_send_proc(request_to_send);
+                        break;
+#endif
+		case (RECEIVE_AND_WAIT):
+			err = sna_ps_rcv_wait(tcb);
+			break;
+
+		case (RECEIVE_IMMEDIATE):
+			err = sna_ps_rcv_immediate(tcb);
+                        break;
+
+                case (SEND_DATA):
+                        err = sna_ps_send_data(tcb);
+                        break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (err);
+}
+
+#ifdef NOT
+
+static int sna_confirm_proc(struct sna_confirm_verb *confirm_verb)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirm_verb->resource);
+	if(rcb->sync_level == NONE || send data != logical bounds)
+	{
+		if(rcb->sync_level == NONE)
+			confirm_verb->rcode = PROGRAM_PARAM_CHECK;
+		else
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		if(fsm_conversation(s, confirm, rcb) cause state check)
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+		else
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			switch(fsm_error_or_failure())
+			{
+				case (CONV_FAILURE_PROTOCOL_ERROR):
+					confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (CONV_FAILURE_SON):
+					confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (RCVD_ERROR):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+					state = fsm_error_or_failure();
+					if(state == CONV_FAILURE_SON
+						|| state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						if(state == CONV_FAILURE_SON)
+							confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+						else
+							confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+					}
+					else
+						sna_dequeue_fmh7_proc(confirm_verb, rcb);
+					break;
+
+				case (NO_REQUESTS):
+					sna_complete_confirm_proc(confirm_verb, rcb);
+			}
+
+		confirm_verb->request_to_send_received = rcb->rq_to_send_rcvd;
+		rcb->request_to_send_received = NO;
+	}
+
+	return (0);
+}
+
+static int sna_comfirmed_proc(struct sna_confirmed_verb *confirmed_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirmed->resource);
+	if(fsm_conversation(s, confirmed, rcb) > cause state_condition)
+	{
+		confirmed_verb->rcode = PROGRAM_STATE_CHECK;
+	{
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(fsm_error_or_failure())
+		{
+			case (NO_REQUESTS):
+				sna_send_confirmed_proc(rcb);
+				break;
+
+			case (RCVD_ERROR):
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				break;
+
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				/* Do nothing */
+				break;
+		}
+
+		fsm_conversation(s, confirmed, rcb);
+		confirmed_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_proc(struct sna_deallocate_verb *deallocate_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(deallocate_verb->resource);
+	switch(deallocate_verb->type)
+	{
+		case (FLUSH):
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == NONE)
+			{
+				if(fsm_conversatio(s, deallocate_flush, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					deallocate_flush_proc(deallocate_verb, rcb);
+			}
+			break;
+
+		case (CONFIRM):
+			if(fsm_conversation(s, deallocate_confirm, rcb) > state_check)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				if(rcb->sync_level == CONFIRM
+					|| rcb->sync_level == SYNCPT)
+				{
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				}
+				else
+					deallocate_verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			break;
+
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == CONFIRM)
+			{
+				if(fsm_conversation(s, deallocate_confirm_rc, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				break;
+			}
+
+			if(rcb->sync_level == SYNCPT)
+			{
+				if(fsm_conversation(s, deallocate_defer, rcb) > state_condiation)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(tp == logical_bounds())
+					{
+						fsm_conversation(s, deallocate_defer, rcb);
+						deallocate_verb->rcode = OK;
+					}
+					else
+						deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+
+				break;
+			}
+
+		case (ABEND_PROG):
+		case (ABEND_SVC):
+		case (ABEND_TIMER):
+			if(fsm_conversation(s, deallocate_abend, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+				sna_deallocate_abend_proc(deallocate_verbm rcb);
+			break;
+
+		case (LOCAL):
+			if(fsm_conversation(s, deallocate_local, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				deallocate_verb->rcode = OK;
+				fsm_conversation(s, deallocate_local, rcb);
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_flush_proc(struct sna_flush_verb *flush_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	rcb = search_rcb(flush_verb->resource);
+	if(fsm_conversation(s, flush, rcb) > state_condition)
+		flush_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			switch(fsm_conversation())
+			{
+				case (SEND_STATE):
+					if(mu != NULL)
+						send_to_hs(mu);
+					break;
+
+				case (PREP_TO_RCV_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+					break;
+
+				case (DEALL_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					send_to_hs(mu);
+					break;
+
+			}
+
+			if(fsm_conversation() == DEALL_DEFER)
+				sna_end_conversation_proc(rcb);
+			fsm_conversation(s, flush, rcb);
+		}
+
+		flush_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_get_attributes_proc(struct sna_get_attributes_verb *get_attributes_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_partner_lu *plu;
+
+	rcb = search_rcb(get_attributes_verb->resources);
+	get_attributes_verb->conversation_group_id = rcb->conversation_group_id;
+	get_attributes_verb->partner_fq_lu_name = plu->fq_lu_name;
+	get_attributes_verb->partner_lu_name = rcb->lu_name;
+	get_attributes_verb->mode_name = rcb->mode_name;
+	get_attributes_verb->sync_level = rcb->sync_level;
+	get_attributes_verb->rcode = OK;
+
+	fsm_conversation(s, get_attributes, rcb);
+
+	return (0);
+}
+
+static int sna_post_on_receipt_proc(struct sna_post_on_receipt_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(post_on_receipt_verb->resource);
+	if(fsm_conversation(s, post_on_receipt, rcb) > state_condition)
+	{
+		post_on_receipt_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		fsm_conversation(s, post_on_receipt, rcb);
+		fsm_post(post_on_receipt);
+		rcb->post_conditions.fill = post_on_receipt_verb->fill;
+		rcb->post_conditions.max_length = post_receipt_verb->max_length;
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		post_on_receipt_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_prepare_to_receive_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(prepare_to_receive_verb->resource);
+	if(tp->data_sent != logical_bounday)
+		prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		switch(prepare_to_receive_verb->type)
+		{
+			case (FLUSH):
+			case (SYNC_LEVEL):
+				if(prepare_to_receive_verb->sync_level == NONE)
+				{
+					if(fsm_conversation(s, prepare_to_receive_flush, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_flush_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+			case (CONFIRM):
+				if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+				{
+					prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(sync_level == CONFIRM
+						|| sync_level == SYNCPT)
+					{
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					}
+					else
+						prepare_to_receive_verb->rcode = PROGRAM_PARAM_CHECK;
+				}
+				break;
+
+			case (SYNC_LEVEL):
+				if(sync_level == CONFIRM)
+				{
+					if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+				if(sync_level == SYNCPT)
+				{
+					if(fsm_conversation(s, prepare_to_receive_defer, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+					{
+						fsm_conversation(s, prepare_to_receve_defer, rcb);
+						rcb->locks = prepare_to_receive_verb->locks;
+						prepare_to_receive_verb->rcode = OK;
+					}
+
+					break;
+				}
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_receive_and_wait_proc(struct sna_receive_and_wait_verb *receive_and_wait_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	if(fsm_conversation(s, receive_and_wait, rcb) > state_condition)
+		receive_and_wait_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		if(fsm_error_or_failure() == RCVD_ERROR)
+		{
+			if(fsm_conversation() == SEND_STATE)
+			{
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+			}
+
+			if(check_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+			{
+				sna_receive_rm_or_hs_to_ps_buffer_list(suspend_list);
+			}
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(receive_and_wait_verb, rcb);
+		}
+		else
+		{
+			fsm_conversation(s, receive_and_wait, rcb);
+			recevie_and_wait_verb->data = NULL;
+			sna_receive_and_test_posting(rcb, receive_and_wait_verb);
+		}
+
+		receive_and_wait_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_request_to_send_proc(struct sna_request_to_send_verb *request_to_send_verb)
+{
+	struct sna_rcb *rcb
+
+	rcb = search_rcb(request_to_send_verb->resource);
+	if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+		request_to_send_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == NO_REQUESTS || state == RCVD_ERROR)
+		{
+			if(rcb->ec_type != DEALLOCATE_FLUSH)
+			{
+				sna_send_request_to_send_proc(rcb);
+				sna_wait_for_rsp_to_rq_to_send_proc(rcb);
+			}
+		}
+		request_to_send_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_send_err_proc(struct sna_send_error_verb *send_error_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(send_error_verb->resource);
+	if(fsm_conversation(s, send_error, rcb) > state_condition)
+		send_error_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(state = fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				fsm_conversation(s, send_error, rcb);
+				if(state == CONV_FAILURE_SON)
+					send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (NO_REQUESTS):
+			case (RCVD_ERROR):
+				switch(fsm_conversation())
+				{
+					case (SEND_STATE):
+						sna_send_error_in_send_state(send_error_verb, rcb);
+						break;
+
+					case (RCVD_CONFIRM):
+					case (RCVD_CONFIRM_SEND):
+					case (RCVD_CONFIRM_DEALL):
+						sna_send_error_to_hs_proc(rcb);
+						fsm_conversation(s, send_error, rcb);
+						sna_send_error_done_proc(send_error_verb, rcb);
+						break;
+
+					case (RCV_STATE):
+						sna_send_error_in_receive_state(send_error_verb, rcb);
+						break;
+
+					default:
+						/* Error */
+				}
+			}
+		}
+
+		send_error_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_test_proc(struct sna_test_verb *test_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(test_verb->resource);
+	test_verb->rcode = OK;
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(test_verb->param)
+	{
+		case (POSTED):
+			if(fsm_conversation(s, test_posted, rcb) > state_condition)
+			{
+				test_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FAILURE_SON):
+						test_verb->rcode = RESOURCE_FAILURE_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (CONV_FAILURE_PROTOCOL_ERROR):
+						test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (RCVD_ERROR):
+						if(fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+						{
+							sna_receive_rm_or_hs_to_ps_records(suspend_list);
+						}
+						state = fsm_error_or_failure();
+						if(state == CONV_FAILURE_SON
+							|| state == CONV_FAILURE_PROTOCOL_ERROR)
+						{
+							if(state == CONV_FAILURE_SON)
+								test_verb->rcode = RESOURCE_FAILURE_RETRY;
+							else
+								test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+							fsm_conversation(r, resource_failure_rc, rcb);
+						}
+						else
+							sna_dequeue_fmh7_proc(test_verb, rcb);
+						break;
+
+					case (NO_REQUESTS):
+						sna_test_for_post_statisfied(rcb);
+						switch(fsm_port)
+						{
+							case (PEND_POST):
+								test_verb->rcode = UNSUCCESSFUL;
+								break;
+
+							case (POSTED):
+								if(fmh7 next to process)
+									sna_dequeue_fmh7_proc(test_verb, rcb);
+								else
+									test_verb->subcode = NOT_DATA || DATA;
+						}
+
+						if(fsm_conversation() != END_CONV)
+							fsm_conversation(s, test, rcb);
+						fsm_post(test);
+						break;
+
+					case (REQUEST_TO_SEND_RECEIVED):
+						if(fsm_conversation(s, test_rq_to_send_rcvd, rcb) > state_condition)
+							test_verb->rcode = PROGRAM_STATE_CHECK;
+						else
+						{
+							if(rcb->rq_to_send_rcvd == YES)
+								rcb->rq_to_send_rcvd = NO;
+							else
+								test_verb->rcode = UNSUCCESSFUL;
+							fsm_conversation(s, test_rq_to_send_rcvd, rcv);
+						}
+						break;
+
+					default:
+						/* error */
+				}
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+
+/************************************************************************
+* Low level procedures							*
+************************************************************************/
+
+static int sna_complete_confirm_proc(struct sna_confirm *confirm, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_MU_BUFF);
+	if(mu == NULL)
+		sna_create_and_init_limited_mu(rcb, mu);
+
+	switch(fsm_conversation())
+	{
+		case (SEND_STATE):
+			mu->ps_to_hs.type = CONFIRM;
+			send_to_hs(mu);
+			break;
+
+		case (PREP_TO_RCV_DEFER):
+			if(rcb->locks == SHORT?)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT;
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+
+			send_to_hs(mu);
+			break;
+
+		case (DEALL_DEFER):
+			mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+			send_to_hs(mu);
+			break;
+
+	}
+
+	fsm_conversation(s, confirm, rcb);
+	sna_wait_for_confirmed_proc(confirm, rcb);
+
+	return (0);
+{
+
+static int sna_complete_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(deallocate->type)
+	{
+		case (ABEND_PROG):
+			sense = 0x08640000;
+			break;
+
+		case (ABEND_SVC):
+			sense = 0x08640001;
+			break;
+
+		case (ABEND_TIMER):
+			sense = 0x08640002;
+			break;
+	}
+
+	mu = bm(GET_SEND_BUF);
+	if(mu != NULL)
+		send_to_hs(mu);
+
+	sna_create_and_init_limited_mu(rcb, mu);
+	if(log_data != NULL)
+	{
+		mu->log_data = log_data;
+		mu->sense = sense;
+
+		err_log_gds = create();
+		sna_send_data_buffer_management(err_log_gds, rcb);
+		Log_err(err_log_gds);
+	}
+	else
+		store_mu(no_log_data);
+
+	mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_conversation_failure_proc(struct sna_conversation_failure *conv_failure)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(conv_failure->resource);
+	if(rcb != NULL)
+	{
+		if(conv_failure->reason == PROTOCOL_VIOLATION)
+			fsm_error_or_failure(conv_fail_protocol);
+		else
+			fsm_error_or_failure(conv_fail_son);
+
+		if(fsm_post == PEND_POSTED)
+			fsm_port(post);
+	}
+
+	return (0);
+}
+
+static int sna_create_and_init_limited_mu(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->limit_buf_pool_id, wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, rcb->send_ru_size, wait);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= send_data_record;
+	mu->ps_to_hs.allocate 		= NO;
+	mu->ps_to_hs.fmh 		= NO;
+	mu->ps_to_hs.type 		= FLUSH;
+	mu->dcf 			= (data->size + rh->size);
+
+	return (0);
+}
+
+static int sna_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	sna_receive_rm_or_hs_to_ps_records(susped_list);
+
+	state = fsm_error_or_failure();
+	if(state == NO_REQUEST || state == RCVD_ERROR)
+	{
+		switch(fsm_conversation())
+		{
+			case (RCV_STATE):
+				if(DEALLOCATE_FLUSH != received)
+				{
+					sna_send_eror_to_hs_proc(rcb);
+					sna_wait_for_send_error_done_proc(deallocate, rcb);
+				}
+				break;
+
+			case (RCVD_CONFIRM):
+			case (RCVD_CONFIRM_SEND):
+			case (RCVD_CONFIRM_DEALL):
+				sna_send_error_to_hs_proc(rcb);
+				sna_wait_for_send_error_done_proc(deallocate, rcb);
+				break;
+
+			case (SEND_STATE):
+			case (PREP_TO_RCV_DEFER):
+			case (DEALL_DEFER):
+				sna_complete_deallocate_abend_proc(deallocate,rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	deallocate->rcode = OK;
+	sna_fsm_conversation(s, dellocate, rcb);
+	sna_end_conversation_proc(rcb);
+
+	return (0);
+}
+
+static int sna_deallocate_confirm_proc(struct sna_deallocate *deallocate)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	if(tp->data != at_logical_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		fsm_conversation(s, deallocate_confim, rcb);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (CONV_FAILURE_SON)
+				deallocate->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (RCVD_ERROR):
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+
+				if(fmh7 !in rcb->hs_to_ps_buffer_list)
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				else
+					sna_receive_rm_or_hs_to_ps_records(suspend_list); /* Empty */
+
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON
+					{
+						deallocate->rcode = RESOURCE_FAILURE_RETRY;
+					}
+
+					if(state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+					}
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_deqeue_fmh7_proc(deallocate, rcb);
+
+			case (NO_REQUESTS):
+				if(mu == NULL)
+					mu = sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+				sna_wait_for_confirmed_proc(deallocate, rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_flush_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(tp->data != logical_record_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspends_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+		}
+
+		deallocate->rcode = OK;
+		fsm_conversation(s, deallocate_flush, rcb);
+		sna_end_conversation_proc(rcb);
+	}
+
+	return (0);
+}
+
+static int sna_dequeue_fmh7_proc(*tp, struct sna_rcb *rcb)
+{
+
+	fsm_post(receive_immediate);
+	if(rcb->hs_to_ps_buffer_list == fmh-7)
+	{
+		remove_first_from_list(rcb->hs_to_ps_buffer_list);
+		sna_process_fmh7_proc(rcb, tp);
+	}
+	else
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+		tp->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_end_conversation_proc(struct sna_rcb *rcb, struct sna_rcb_deallocated *rcb_deallocated)
+{
+	struct sna_mu *mu;
+	struct sna_deallocate_rcb *deallocate_rcb;
+
+	for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		bm(FREE, mu);
+
+	if(rcb->send_buffer != NULL)
+		bm(FREE, rcb->send_buffer);
+
+	new(deallocate_rcb, GFP_ATOMIC);
+	rcb_deallocated = sna_wait_for_rm_reply(rcb);
+	destroy(rcb_deallocated);
+
+	return (0);
+}
+
+static int sna_get_dallocate_from_hs(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	chain_type = sna_get_end_chain_from_hs(rcb);
+	if(chain_type == DEALLOCATE_FLUSH || chain_type == DEALLOCATE_CONFIRM)
+		do_nothing(); ??
+
+	state = fsm_error_or_failure();
+	if(state == CONV_FAILURE_PROTOCOL_ERROR || state == CONV_FAILURE_SON)
+		do_nothing(); ??
+
+	/* Otherwise */
+	sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+	tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+	rcb->fsm_conversation(r, resource_failure_rc, rcb);
+
+	return (0);
+}
+
+static int sna_get_end_chain_from_hs(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(end_of_chain != recieved_for_this_conv)
+	{
+		for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		{
+			if(mu->hs_to_ps.type == END_OF_CHAIN)
+				type = mu;
+
+			bm(FREE, mu);
+		}
+	}
+
+	while(end_of_chain != recieved)
+	{
+		record = grab_record(rcb);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				destroy(record);
+				break;
+
+			case (MU):
+				if(mu->hs_to_ps.type == END_OF_CHAIN)
+					type = mu;
+				bm(FREE, mu);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	/* Update rcb to show receipt of eoc type */
+	rcb->end_of_chain = eoc;
+
+	return (0);
+}
+
+static int sna_obtain_session_proc(struct sna_rcb *rcb, sna_allocate_verb *allocate_verb, __u8 session_req, __u8 conv_group_id)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *session_allocated;
+
+	new(get_session, GFP_ATOMIC);
+	if (!get_session)
+		return -ENOMEM;
+	get_session->tcb_id 	= rcb->tcb_id;
+	get_session->rcb_id 	= rcb->rcb_id;
+	get_session->type	= session_req;
+	get_session->conv_group_id = conv_group_id;
+	send_to_rm(get_session);
+
+	session_allocated = sna_wait_for_rm_reply();
+	switch(session_allocated->rcode)
+	{
+		case (OK):
+			rcb->send_ru_size = session_allocated->send_ru_size;
+			rcb->limit_buf_pool_id = session_allocated->limit_buf_pool_id;
+			rcb->perm_buf_pool_id = session_allocated->perm_buf_pool_id;
+			sna_create_and_init_limited_mu(rcb, mu);
+			if(session_allocated->in_conversation == YES)
+				mu->ps_to_hs.allocate = NO;
+			else
+				mu->ps_to_hs.allocate = YES;
+			break;
+
+		default:
+			allocate_verb->rcode = ALLOCATION_ERROR;
+			switch(sesion_allocated->rcode);
+			{
+				case (UNSUCCESSFUL_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_RETRY;
+					break;
+
+				case (UNSUCCESSFUL_NO_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_NO_RETRY;
+					break;
+
+				case (SYNC_LEVEL_NOT_SUPPORTED):
+					allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED;
+					break;
+			}
+			break;
+	}
+
+	destroy(session_allocated);
+
+	return (0);
+}
+
+static int sna_perform_receive_ec_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	if(tp->data_sent != logical_record_boundary)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	if(rcb->sync_level == NONE
+		&& rcb->ec_type == CONFIRM
+		|| rcb->ec_type == PREPARE_TO_RCV_CONFIRM
+		|| rcb->ec_type == DEALLOCATE_CONFIRM)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	/* Otherwise */
+	switch(rcb->ec_type)
+	{
+		case (CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM;
+			fsm_conversation(r, confirm_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_SEND;
+			fsm_conversation(r, confirm_send_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_FLUSH):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = SEND;
+			fsm_conversation(r, send_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_DEALLOCATE;
+			fsm_conversation(r, confirm_deallocate_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_FLUSH):
+			receive_verb->rcode = DEALLOCATE_NORMAL;
+			fsm_conversation(r, deallocate_normal_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perform_receive_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(mu_ptr != NULL || rcb->ec_indicator != NOT_END_OF_DATA)
+	{
+		for(mu = mu_ptr; (mu != NULL && post_not_satisfied); mu = mu->next)
+		{
+			if(mu->type == FMH_7)
+			{
+				if(no_data_copied_to_pass_to_tp)
+				{
+					sna_process_fmh7_proc(rcb,receive_verb);
+					continue;
+				}
+			}
+			else
+			{
+				if(mu->end_of_data != TRUE)
+					sna_process_data_proc(rcb, receive_verb, DATA_NEEDED);
+				else	/* All data received */
+				{
+					if(mu->hs_to_ps.type == NOT_END_OF_DATA)
+					{
+						bm(FREE, mu);
+						continue;
+					}
+					else
+					{
+						ec_received_post_ok;
+						break;
+					}
+				}
+			}
+		}
+
+		if(no_data_returned && fmh7 != processed
+			&& rcb->ec_type != NOT_END_OF_DATA)
+		{
+			sna_preform_receive_ec_processing(rcb, receive_verb);
+			return_to_tp (rcb->ec_type);
+		}
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (CONV_FAILURE_SON):
+				receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			default:
+				if(receive_verb->type == RECEIVE_IMMEDIATE)
+					receive_verb->rcode = UNSUCCESSFUL;
+				else
+					receive_verb->rcode = OK;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_perform_more_rcv_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		default:
+			if(receive_verb->type == RECEIVE_IMMEDIATE)
+				receive_verb->rcode = UNSUCCESSFUL;
+			else
+				receive_verb->rcode = OK;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_confirm_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	fsm_conversation(s, prepare_to_receive_confirm, rcb);
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (RCVD_ERROR):
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FALIURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		case (NO_REQUESTS):
+			if(rcb->locks == SHORT)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+			sna_wait_for_confirmed_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_flush_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	state = fsm_error_or_failure();
+	if(state == RCVD_ERROR || state == NO_REQUESTS)
+	{
+		if(mu == NULL)
+			sna_create_and_init_limited_mu(rcb, mu);
+		mu->ps_to_hs.type = PREPARE_TO_RECEIVE_FLUSH;
+		send_to_hs(mu);
+	}
+
+	prepare_to_receive_verb->rcode = OK;
+	fsm_conversation(s, prepare_to_receive_flush, rcb);
+
+	return (0);
+}
+
+static int sna_process_data_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_receive_verb *receive_verb)
+{
+
+	return 0;
+}
+
+static int sna_process_fmh7_log_data_proc(struct sna_rcb *rcb, __u8 fmh_sense_data, struct sna_tp_verb *tp_verb)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	/* Get log data */
+	new(receive_and_wait, GFP_ATOMIC);
+	if (!receive_and_wait)
+		return -ENOMEM;
+	receive_and_wait->resource 	= rcb->rcb_id;
+	receive_and_wait->fill 		= LL;
+	receive_and_wait->max_length 	= 0x7FFF;
+	receive_and_wait->data 		= NULL;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	if(receive_and_wait->rcode == OK
+		&& receive_and_wait->what_received == DATA_COMPLETE)
+	{
+		if(gds_id == 0x12E1)
+			Log_err();
+		else
+		{
+			Log_err();
+			sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+			fsm_error_or_failure_signal(CONV_FAIL_PROTOCOL);
+		}
+	}
+	else
+	{
+		if(receive_and_wait->rcode == RESOURCE_FAILURE_RETRY)
+			Log_err(son);
+		else
+			Log_err(proto);
+	}
+
+	destroy(receive_and_wait);
+
+	/* Set the states of the FSMs */
+	if(fmh_sense_data == 0x08640000
+		|| fmh_sense_data == 0x08640001
+		|| fmh_sense_data == 0x08640002)
+	{
+		if(fsm_error_or_failure() == NO_REQUESTS)
+			sna_get_deallocate_from_hs(tp_verb, rcb);
+		sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+				break;
+
+			case (CONV_FAILURE_SON):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_SON);
+				break;
+
+			default:
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+		}
+	}
+
+	sna_set_rcb_rcv_defaults(rcb);
+
+	return (0);
+}
+
+static int sna_process_fmh7_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_tp_verb *tp_verb)
+{
+	struct sna_mu *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	/* Validate FMH-7 */
+	err = sna_check_fmh7(mu);
+	if(err)
+	{
+		sna_ps_protocol_error(rcb->hs_id, err);
+		tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+		rcb->post_condiations.max_length = 0;
+	}
+	else
+	{
+		sna_set_init_rcb_rcv(rcb);
+		if(mu->data_received == ALL)
+		{
+			/* Remember if fmh7 has sense and log data */
+			type = mu->ec_type;
+			bm(FREE, mu);
+		}
+		mu_ptr = rcb->hs_to_ps_buffer_list;
+
+		/* Get log data if present */
+		if(fmh7->log_data == TRUE)
+		{
+			sna_process_fmh7_log_data_proc(rcb, fmh7_sense_data, tp_verb);
+		}
+		else
+		{
+			if(fmh_sense_data == 0x08640000
+				|| fmh_sense_data == 0x08640001
+				|| fmh_sense_data == 0x08640002)
+			{
+				sna_get_deallocate_from_hs(tp_verb, rcb);
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FALIURE_PROTOCOL_ERROR):
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+						break;
+
+					case (CONV_FAILURE_SON):
+						sna_set_fmh7_rcb(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_SON);
+						break;
+
+					default:
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						break;
+				}
+			}
+		}
+	}
+	
+	return (0);
+}
+
+static int sna_receive_and_test_posting(struct sna_rcb *rcb, struct sna_receive_and_wait *receive_and_wait)
+{
+	/* Test post */
+	fsm_post(POST_ON_RECEIPT);
+	rcb->post_conditions.fill = receive_and_wait->fill;
+	rcb->post_conditions.max_length = receive_and_wait->max_length;
+	sna_test_for_post_satisfied(rcb);
+	sna_perform_receive_processing(rcb, receive_and_wait);
+
+	if(fsm_post() == PEND_POSTED)	/* Remove if, its not needed, IBM... */
+	{
+		while(fsm_port() == PEND_POST)
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			sna_test_for_post_satisfied(rcb);
+			sna_performa_receive_processing(rcb, receive_and_wait);
+		}
+	}
+
+	sna_receive_and_wait->max_length = tp->data_returned;
+	fsm_post(RECEIVE_IMMEDIATE);
+
+	return (0);
+}
+
+static int sna_receive_rm_or_hs_to_ps_records(struct sna_suspend_list *suspend_list)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	more_records = 1;
+	if(suspend_list == NULL)
+		suspend_flag = NO_SUSPEND;
+	else
+		suspend_flag = SUSPEND;
+
+	while(more_records)
+	{
+		/* Shrink */
+		if(suspend_flag == SUSPEND)
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+			{
+				mu = find_record_hs_to_ps_q();
+				if(mu == NULL)
+					mu = find_record_suspend();
+			}
+		}
+		else	/* NO_SUSPEND */
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+				mu = find_record_hs_to_ps_q();
+		}
+
+		if(mu != NULL)
+		{
+			if(mu->type == CONVERSATION_FAILURE)
+			{
+				dequeue_rm_to_ps_q(mu);
+				rcb = search_rcb(mu->rcb_id);
+				if(rcb != NULL)
+					sna_conversation_failure_proc(mu);
+				else
+					destroy(mu);
+			}
+			else
+			{
+				dequeue_hs_to_ps_q(mu);
+				switch(mu->type)
+				{
+					case (REQUEST_TO_SEND):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							rcb->rq_to_send_rcvd = YES;
+						destroy(mu);
+						break;
+
+					case (RECEIVE_ERROR):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							fsm_error_or_failure(RECEIVE_ERROR, rcb);
+						destroy(mu);
+						break;
+
+					case (RSP_TO_REQUEST_TO_SEND):
+					case (CONFIRMED):
+						destroy(mu);
+						break;
+
+					case (MU):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+						{
+							if(fsm_conversation() == RCB_STATE || fsm_error_or_failure() == RCVD_ERROR)
+							{
+								queue_hs_to_ps_buffer_list(rcb->hs_to_ps_buffer_list, mu);
+							}
+							else
+							{
+								bm(FREE, mu);
+								if(fsm_conversation() == END_CONV)
+								{
+									sna_ps_protocol_error(rcb->hs_id, 0x20040000);
+								}
+							}
+						}
+						else
+							bm(FREE, mu);
+						break;
+				}
+			}
+
+			if(suspend_flag == SUSPEND 
+				&& found_rcb_id_in_suspend == TRUE)
+			{
+				suspend_flag = NO_SUSPEND;
+			}
+		}
+		else
+			more_records = 0;
+	}
+
+	return (0);
+}
+
+static int sna_send_confirmed_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->perm_buf_pool_id, no_wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, size, no_wait);
+
+	mu->header_type = PS_TO_HS;
+	mu->ps_to_hs.bracket_id = rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant = CONFIRMED;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_err_done_proc(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(send_error_verb->type)
+	{
+		case (PROG):
+			state = fsm_conversation();
+			if(state == SEND_STATE)
+			{
+				if(data sent by tp is at logical bounds)
+					sense = 0x08890000;
+				else
+					sense = 0x08890001;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		case (SVC):
+			state = fsm_conversation();
+
+			if(state == SEND_STATE)
+			{
+				if(data is at logical bounds)
+					sense = 0x08890100;
+				else
+					sense = 0x08890101;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		default:
+			/* Error */
+	}
+
+	if(send_error_verb->log_data != NULL)
+	{
+		create_fmh7_with_log_data();
+		create_log_gds(log_data);
+		sna_send_data_buffer_management(log_gds, rcb);
+		Log_err(sys);
+	}
+	else
+		create_fmh7_with_log_data();
+
+	if(FLUSH == NOT_IMPLEMENTED || fmh7->flush_immediately == TRUE)
+		send_to_hs(mu);
+
+	send_error_verb->rcode = OK;
+
+	return (0);
+}
+
+static int sna_send_err_in_receive_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(rcb->ec_type == DEALLOCATE_FLUSH)
+	{
+		if(mu_ptr != NULL)
+			bm(FREE, mu_ptr);
+		send_error_verb->rcode = DEALLOCATE_NORMAL;
+		fsm_conversation(r, deallocate_normal_rc, rcb);
+	}
+	else
+	{
+		sna_send_error_to_hs_proc(rcb);
+		sna_wait_for_send_error_done_proc(send_error_verb, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_send_err_in_send_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(fsm_error_or_failure() == NO_REQUESTS)
+	{
+		if(send_mu_buffer_present)
+			send_to_hs(mu);
+		fsm_conversation(s, send_error, rcb);
+		sna_send_error_done_proc(send_error_verb, rcb);
+	}
+	else
+	{
+		mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+		send_to_hs(mu);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		state = fsm_error_or_failure();
+		if(state == CONV_FAILURE_SON 
+			|| state == CONV_FAILURE_PROTOCOL_ERROR)
+		{
+			if(state == CONV_FAILURE_SON)
+				send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+			else
+				send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+		}
+		else
+			sna_dequeue_fmh7_proc(send_error_verb, rcb);
+	}
+
+	set_rcb_send_fields_to_init(rcb);
+
+	return (0);
+}
+
+static int sna_send_err_to_hs_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= SEND_ERROR;	/* verb?? */
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_request_to_send_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant	= REQUEST_TO_SEND;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_set_fmh7_rc(struct sna_rcb *rcb, __u8 fmh7_sense, struct sna_tp_verb *tp_verb)
+{
+	switch(fmh7_sense)
+	{
+		case (ALLOCATION_ERROR):
+			get_deallocate(rcb->hs_to_ps_buffer_list);
+			if(fsm_conversation() == END_CONV)
+			{
+				tp_verb->rcode = corresponding_rcode(END_CONV);?
+				fsm_conversation(r, allocation_error, rcb);
+			}
+			break;
+
+		case (RESOURCE_FAILURE_NO_RETRY):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (PROG_ERROR_NO_TRUNC):
+		case (PROG_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = PROG_ERROR_PURGING;
+			else
+				tp_verb->rcode = PROG_ERROR_NO_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (PROG_ERROR_TRUNC):
+			tp_verb->rcode = PROG_ERROR_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_NO_TRUNC):
+		case (SVC_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = SVC_ERROR_PURGING;
+			else
+				tp_verb->rcode = SVC_ERROR_NO_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_TRUNC):
+			tp_verb->rcode = SVC_ERROR_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (DEALLOCATE_ABEND):
+			tp_verb->rcode = many_diff_choices();
+			fsm_conversation(r, deallocate_abend_rc, rcb);
+			break;
+
+		default:
+			ps_protocol_error(rcb->hs_id, fmh7_sense);
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_test_for_post_satisfied(struct sna_rcb *rcb)
+{
+
+	return 0;
+}
+
+static int sna_wait_for_confirmed_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	struct sna_confirmed *confirmed;
+
+	while((confirmed = recv_confirmed()) == NULL)
+	{
+		record = get_record(1st);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				if(fsm_error_or_failure() == CONV_FAILURE_SON)
+					tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				while(rcb->hs_to_ps_buffer_list == NULL
+					&& fsm_error_or_failure() == RCVD_ERROR)
+				{
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				}
+
+				state = fsm_error_or_failure();
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON)
+						tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+					else
+						tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_dequeue_fmh7_proc(confirm_verb, rcb);
+				destroy(record);
+				break;
+
+			case (CONFIRMED):
+				tp_verb->rcode = OK;
+				if(fsm_conversation() == PEND_DEALL)
+				{
+					fsm_conversation(r, DEALLOCATION_INDICATOR, rcb);
+					sna_end_conversation_proc(rcb);
+				}
+				destroy(record);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(r, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_rm_reply(struct sna_mu *mu)
+{
+	mu = NULL
+
+	while(mu == NULL)
+	{
+		sleep()
+		mu = get_record();
+
+		if(mu->type == CONVERSATION_FAILURE)
+			sna_conversation_failure_proc(mu);
+		else
+			return (0);
+	}	
+
+	return (0);
+}
+
+static int sna_wait_for_rsp_to_rq_to_send_proc(struct sna_rcb *rcb, struct sna_hs_to_ps_records *hs_to_ps_records)
+{
+	struct sna_mu *mu = NULL;
+
+	while(mu == NULL)
+	{
+		mu = get_record(1st);
+		switch(mu->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(mu);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(mu);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				destroy(mu);
+				break;
+
+			case (RSP_TO_REQUEST_TO_SEND):
+				destroy(mu);
+				break;
+
+			case (MU):
+				queue_mu(rcb->hs_to_ps_buffer_list, mu);
+				queue_tail(hs_to_ps_buffer_list, mu);
+				if(rcb->ec_type == DEALLOCATE_FLUSH)
+					break;
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, fmh7_sense);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_send_err_done_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+
+	sna_get_end_chain_from_hs(rcb);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_SON):
+			tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(s, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+
+		default:
+			switch(rcb->ec_type)
+			{
+				case (DEALLOCATE_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						tp_verb->rcode = DEALLOCATE_NORMAL;
+						fsm_conversation(r, deallocate_normal_rc, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						tp_verb->rcode = OK;
+						break;
+					}
+
+					break;
+
+				case (DEALLOCATE_CONFIRM):
+				case (CONFIRM):
+				case (PREPARE_TO_RCV_CONFIRM):
+				case (PREPARE_TO_RCV_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						purge_ec_type();
+						sna_send_error_done_proc(send_error, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						sna_complete_deallocate_abend_proc(deallocate, rcb);
+						break;
+					}
+
+					break;
+			}
+	}
+
+	fsm_error_or_failure(reset);
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_ps_copr.c linux/net/sna/sna_ps_copr.c
--- linux-2.4.18-clean/net/sna/sna_ps_copr.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ps_copr.c	Sat Jun  8 16:03:55 2002
@@ -0,0 +1,479 @@
+/* sna_ps_copr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Control Operator (PS.CORP)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_copr(int verb, struct sna_tcb *tcb)
+{
+#ifdef NOT
+	switch(cnos_verb->type)
+	{
+		case (INITIALIZE_SESSION_LIMIT):
+			sna_init_session_limit_proc(cnos_verb);
+			break;
+
+		case (CHANGE_SESSION_LIMIT):
+			sna_change_sesion_limit_proc(cnos_verb);
+			break;
+
+		case (RESET_SESSION_LIMIT):
+			sna_reset_session_limit_proc(cnos_verb);
+			break;
+
+		case (PROCESS_SESSION_LIMIT):
+			sna_process_session_limit_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_CONVERSATION_GROUP):
+			sna_deact_conversation_group_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_deactivate_session_proc(cnos_verb);
+			break;
+
+		case (ACTIVATE_SESSION):
+			sna_activate_session_proc(cnos_verb);
+			break;
+
+		case (DEFINE_LOCAL_LU):
+		case (DEFINE_REMOTE_LU):
+		case (DEFINE_MODE):
+		case (DEFINE_TP):
+			sna_define_proc(cnos_verb);
+			break;
+
+		case (DELETE):
+			sna_delete_proc(cnos_verb);
+			break;
+
+		default:
+			/* Error */
+	}
+#endif
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_init_session_limit_proc(struct sna_init_session_limit_verb *verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu->lu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG))
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_reset_session_limit_proc(verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_CHECK;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+				if(verb->force == YES)
+				{
+					if(rcode == ALLOCATION_ERROR
+						|| rcode == LU_MODE_SESSION_LIMIT
+						|| rcode == RESOURCE_FAILURE_NO_RETRY
+						|| rcode == UNRECOGNIZED_MODE_NAME)
+					{
+						sna_change_action(verb);
+						rcode = OK_FORCED;
+					}
+				}
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_change_session_limit_proc(verb, rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp != AUTH_OK)
+		rcode = PROGRAM_PARAMETER_CHECK;
+	else
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == INTERLU_PARALLEL
+				&& lucb->mode_name != SNASVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+			{
+				if(type == INTRALU_PARALLEL
+					&& (lucb->mode_name != SNASVCMG
+					|| lucb->mode_name != CPSVCMG)
+				{
+					sna_local_session_limit_proc(verb);
+				}
+				else
+					rcode = PROGRAM_PARAM_CHECK;
+			}
+		}
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_proc(verb, rcode)
+{
+	err = check_verb(activate_session);
+	switch(err)
+	{
+		case (NO_AUTH):
+			rcode = PROGRAM_PARAMETER_CHECK;
+			break;
+
+		case (ERROR_FOUND):
+			rcode = err;
+			break;
+
+		case (OK):
+			new(activate, GFP_ATOMIC);
+			activate->tcb_id = ps_process_data->tcb_id;
+			activate->lu_name = verb->lu_name;
+			activate->mode_name = verb->mode_name;
+			send_to_rm(activate);
+
+			activated = recv_from_rm();
+			rcode = activated->rcode;
+			if(single sess && conwinner)
+				sec_code = OK.AS_SPECIFIED;
+			else
+				sec_code = OK.AS_NEGOTIATED;
+		}
+	}
+
+	destroy(activated);
+
+	return (0);
+}
+
+static int deact_conversation_group_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		new(deact_group, GFP_ATOMIC);
+		deact_group->conv_group_id = verb->conv_group_id;
+		deact_group->type = verb->type;
+		if(deact_group->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deact_group->sense = verb->sense
+			else
+				deact_group->sense = 0x08A00002;
+		}
+		else
+			deact_group->sense = 0x00000000;
+		send_to_rm(deact_group);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int deactivate_session_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		new(deactivate, GFP_ATOMIC);
+		deactivate->tcb_id = ps_process_data->tcb_id;
+		deactivate->session_id = verb->session_id;
+		deactivate->type = verb->type;
+		if(deactivate->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deactivate->sense = verb->sense;
+			else
+				deactivate->sense = 0x08A00002;
+		}
+		else
+			deactivate->sense = 0x00000000;
+		send_to_rm(deactivate);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int sna_define_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		assign values to data_structs..?
+
+	return (0);
+}
+
+static int sna_display_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Display request data, just copy to user space for us */
+
+	return (0);
+}
+
+static int sna_delete_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Delete attribs in delete verb */
+
+	return (0);
+}
+
+static int sna_local_session_limit_proc(verb)
+{
+
+	switch(session_type)
+	{
+		case (SINGLE):
+			err = sna_local_verb_parameter_check(verb);
+			break;
+
+		case (PARALLEL):
+			if(mode_name == SNASVCMG || mode_name == CPSVCMG)
+				err = sna_svcmg_verb_param_check(verb);
+			break;
+
+		case (INTRA_PARALLEL):
+			if(mode_name != SNASVCMG || mode_name != CPSVCMG)
+				err = sna_intra_lu_local_verb_param_check(verb);
+			break;
+
+	}
+
+	if(err = OK)
+		sna_change_action(verb);
+
+	return (0);
+}
+
+static int sna_local_verb_param_check(verb, struct sna_parnter_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+
+	/* Swich is bad here */
+	switch(err)
+	{
+		case (OK):
+			rcode = OK.AS_SPECIFIED;
+			break;
+
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (MODE):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		if(mode->local_max_session_limit != NULL)
+		{
+			case (MAX_ALLOWED):
+				rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_intra_lu_local_verb_parm_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *plu;
+
+	err = check_verb(verb);
+
+	rcode = OK.AS_NEGOTIATED;
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_ZERO;
+			break;
+
+		case LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		case (MAX_ALLOWED):
+			rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_svcmg_verb_param_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+	}
+
+	return (0);
+}
+
+struct sna_change_action(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_ps_main.c linux/net/sna/sna_ps_main.c
--- linux-2.4.18-clean/net/sna/sna_ps_main.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ps_main.c	Sat Jun  8 15:42:38 2002
@@ -0,0 +1,552 @@
+/* sna_ps_main.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Services (PS)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_ps_process_fmh5\n");
+	sna_attach_execute_tp(tcb_id, skb);
+
+#ifdef NOT
+        struct sna_tcb *tcb;
+        struct sna_rcb *rcb;
+        __u8 code;
+
+        code = sense;
+
+        rcb = search_rcb(mu->rcb_id?);
+        sna_init_attached_rcb(rcb, mu_with_attach);
+
+        move_to_head(rcb->hs_to_ps_buffer_list, mu_with_attach);
+
+        if(code == OK)
+        {
+                sna_ps_attach_chk(rcb, code);
+                if(pip != NULL)
+                        sna_receive_pip_field_from_hs(rcb, pip, code);
+                sna_ps_pip_chk(pip, code);
+        }
+
+        if(code == OK)
+                sna_upm_execute(tcb->tp_name, rcb->rcb_id, pip);
+        else
+                sna_attach_error_proc(rcb, code);
+#endif
+
+        return (0);
+}
+
+#ifdef NOT
+
+static int sna_ps(unsigned char *record)
+{
+	struct sna_ps_process_data *ps_process_data;
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+
+	/* Establish the enviroment ?? move to init */
+	ps_create_parms = (struct sna_ps_create_params)record;
+	ps_process_data			= ps_create_params;
+
+	lucb = search_lucb(ps_create_params->lu_id);
+	ps_process_data->lucb_ptr	= lucb;
+
+	tcb = search_tcb(ps_create_params->tcb_id);
+	ps_process_data->tcb_ptr	= tcb;
+
+	/* PS_initilize ?? */
+	
+	switch(record_type)
+	{
+		case (MU):
+			sna_process_fmh5(mu);
+			break;
+
+		case (START_TP):
+			sna_process_start_tp(start_tp);
+			break;
+
+		default:
+			Log_err();
+	}
+
+	sna_deallocation_cleanup_proc();	/* Everytime ? */
+
+	return (0);
+}
+
+static int sna_process_start_tp(struct sna_start_tp *start_tp, unsigned char *tp_name)
+{
+	struct sna_tcb *tcb;
+	struct sna_pip *pip; ???
+
+	pip = start_tp->pip;
+	destroy(pip);
+	sna_upm_execute(tp_name, NULL, pip);
+
+	return (0);
+}
+
+static int sna_receive_pip_field_from_hs(struct sna_rcb *rcb, struct sna_pip *pip, __u8 code)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	new(receive_and_wait, GFP_ATOMIC);
+	receive_and_wait->post_conditions.fill		= LL;
+	receive_and_wait->post_conditions.max_length	= 0x7FFF;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	err = sna_chk_pip(receive_and_wait->pip);
+	if(!err)
+		return(receive_and_wait->pip);
+	else
+		code = 0x1008201D;
+
+	return (0);
+}
+
+static int sna_ps_attach_chk(struct sna_attach *attach, __u8 code, struct sna_pip *pip)
+{
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_mu *mu;
+
+	mu = sna_get_buf_from_list(rcb->hs_to_ps_buffer_list);
+	mu->tp_name = tcb->tp_name;
+
+	/* Check attach fields for the following */
+	if(lu_work_id fields are bad)
+		code = 0x10086011;
+
+	if(tp->conversation_type != BASIC || tp->conversation_type != MAPPED)
+		code = 0x10086034;
+
+	if(mu has been processed)
+	{
+		type_field = mu->end_of_chain_type;
+		bm(FREE, mu);
+	}
+
+	return (0);
+}
+
+static int sna_ps_pip_chk(struct sna_pip *pip, __u8 code)
+{
+	struct sna_tcb *tcb;
+	struct sna_tp *tp;
+
+	tp->tp_name = attach->tp_name;	/* Screwed Big time */
+
+	if(code != OK)
+		return (-??);
+
+	if(tp->pip_numbers != NULL)
+	{
+		if(tp->number_of_pip_subfields == 0
+			&& attach->pip != NULL)
+		{
+			code = 0x10086031;
+		}
+		else
+		{
+			if(tp->number_of_pip_subfields
+				!= attach->number_of_pip_subfields)
+			{
+				code = 0x10086032;
+			}
+			else
+			{
+				err = check_pip_format(pip);
+				if(err)
+					code = 0x1008201D;
+			}
+		}
+	}
+
+	if(tp->pip == NULL)
+	{
+		if(pip_data == BAD ;)
+			code = 0x1008201D;
+	}
+
+	return (0);
+}
+
+static int sna_attach_error_proc(struct sna_rcb *rcb, __u8 code/sense)
+{
+	struct sna_mu *mu;
+
+	switch(code)
+	{
+		case (0x1008200E):
+		case (0x10086000):
+		case (0x10086005):
+		case (0x10086009):
+		case (0x10086011):
+		case (0x10086040):
+		case (0x1008201D):
+			sna_ps_protocol_error(rcb->hs_id, code);
+			sna_end_conversation_proc(rcb);
+			break;
+
+		default:
+			sna_send_error_to_hs_proc(rcb);
+			sna_end_chain_from_hs(rcb);
+			if(fsm_error_or_failure() == CONV_FAILURE_SON
+				|| fsm_error_or_failure == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				Log_error();
+			}
+			else
+			{
+				switch(end-of-chain type)
+				{
+					case (DEALLOCATE_FLUSH):
+						Log_error();
+						break;
+
+					case (DEALLOCATE_CONFIRM):
+					case (CONFIRM):
+					case (PREPARE_TO_RCV_CONFIRM):
+					case (PREPARE_TO_RCV_FLUSH):
+						sna_upm_attach_log(code, log_data);
+						if(log_data != NULL)
+						{
+							Log_err();
+							attach_fmh-7();
+							sna_send_data_bm(log_data, rcb);
+						}
+					else
+						put_fmh7_into_send_mu();
+
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					break;
+				}
+
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+#endif
+
+int sna_ps_verb_router(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_verb_router(%d)\n", verb);
+	switch(verb)
+	{
+		case (ALLOCATE):
+			sna_ps_conv(verb, tcb);
+			break;
+		case (CONFIRM):
+		case (CONFIRMED):
+		case (DEALLOCATE):
+		case (FLUSH):
+		case (GET_ATTRIBUTES):
+		case (POST_ON_RECEIPT):
+		case (PREPARE_TO_RECEIVE):
+		case (RECEIVE_AND_WAIT):
+		case (RECEIVE_IMMEDIATE):
+		case (REQUEST_TO_SEND):
+		case (SEND_DATA):
+		case (SEND_ERROR):
+		case (TEST):
+			sna_ps_conv(verb, tcb);
+			break;
+
+#ifdef NOT
+		case (MC_ALLOCATE):
+			sna_ps_mc(verb);
+			break;
+
+		case (MC_CONFIRM):
+		case (MC_CONFIRMED):
+		case (MC_DEALLOCATE):
+		case (MC_FLUSH):
+		case (MC_GET_ATTRIBUTES):
+		case (MC_POST_ON_RECEIPT):
+		case (MC_PREPARE_TO_RECEIVE):
+		case (MC_RECEIVE_AND_WAIT):
+		case (MC_REQUEST_TO_SEND):
+		case (MC_SEND_DATA):
+		case (MC_SEND_ERROR):
+		case (MC_TEST):
+			if(verb->resource =?= tcb->resource_list)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				if(rcb->conversation_type == MAPPED)
+				{
+					tcb->cntrl_component = SERVICE_COMPONENT;
+					sna_ps_mc(verb);
+					tcb->cntrl_component = TP;
+				}
+				else
+					verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (INITIALIZE_SESSION_LIMIT):
+		case (CHANGE_SESSION_LIMIT):
+		case (RESET_SESSION_LIMIT):
+		case (SET_LUCB):
+		case (SET_PARTNER_LU):
+		case (SET_MODE):
+		case (SET_MODE_OPTIONS):
+		case (SET_TRANSACTION_PROGRAM):
+		case (SET_PRIVILAEGED_FUNCTION):
+		case (SET_RESOURCE_SUPPORTED):
+		case (SET_SYNC_LEVEL_SUPPORTED):
+		case (SET_MC_FUNCTION_SUPPORTED_TP):
+		case (GET_LUCB):
+		case (GET_PARTNER_LU):
+		case (GET_MODE):
+		case (GET_LU_OPTION):
+		case (GET_MODE_OPTION):
+		case (GET_TRANSACTION_PROGRAM):
+		case (GET_PRIVILEGED_FUNCTION):
+		case (GET_RESOURCE_SUPPORTED):
+		case (GET_SYNC_LEVEL_SUPPORTED):
+		case (GET_MC_FUNCTION_SUPPORTED_LU):
+		case (GET_MC_FUNCTION_SUPPORTED_TP):
+		case (LIST_PARTNER_LU):
+		case (LIST_MODE):
+		case (LIST_LU_OPTION):
+		case (LIST_MODE_OPTION):
+		case (LIST_TRANSACTION_PROGRAM):
+		case (LIST_PRIVILEGED_FUNCTION):
+		case (LIST_RESOURCE_SUPPORTED):
+		case (LIST_SYNC_LEVEL_SUPPORTED):
+		case (LIST_MC_FUNCTION_SUPPORTED_LU):
+		case (LIST_MC_FUNCTION_SUPPORTED_TP):
+		case (PROCESS_SESSION_LIMIT):
+		case (ACTIVATE_SESSION):
+		case (DEACTIVATE_CONVERSATION_GROUP):
+		case (DEACTIVATE_SESSION):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_copr(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (SYNCPT):
+		case (BACKOUT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_sync(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (GET_TP_PROPERTIES):
+			sna_get_tp_properties_proc(verb);
+			break;
+
+		case (GET_TYPE):
+			verb->rcode = OK;
+			if(verb->resource == conversation_this_tp)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				verb->type = rcb->conversation_type;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (WAIT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_wait_proc(verb);
+			tcb->cntrl_component = TP;
+			break;
+#endif
+		default:
+			return (-EINVAL);
+	}
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_deallocation_cleanup_proc(struct sna_rcb *rcb)
+{
+	struct sna_terminate_ps *terminate_ps;
+	struct sna_tcb *tcb;
+
+	for(tcb = tcb_list; tcb != NULL; tcb = tcb->next)
+	{
+		if(tcb->rcb_id == rcb->rb_id)
+			sna_upm_return_processing(rcb);
+	}
+
+	send_to_rm(terminate_ps);
+
+	return (0);
+}
+
+static int sna_get_tp_properties_proc(struct sna_get_tp_properties *get_tp_properties)
+{
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+
+	get_tp_properties->own_tp_name		= tcb->tp_name;
+	get_tp_properties->own_tp_instance	= tcb->tcb_id;
+	get_tp_properties->own_fq_lu_name	= lucb->fq_lu_name;
+	get_tp_properties->security_profile	= tcb->init_security.profile;
+	get_tp_properties->security_user_id	= tcb->init_security.user_id;
+	get_tp_properties->rcode		= OK;
+
+	return (0);
+}
+
+static int sna_wait_proc(struct sna_wait *wait, unsigned char *data)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	err = sna_check_resource_list();
+	if(err)
+	{
+		wait->rcode = PROGRAM_PARAM_CHECK;
+		return (-?);
+	}
+
+	if(no_activated_resource)
+	{
+		wait->rcode = POSTING_NOT_ACTIVE;
+		return (-?);
+	}
+
+	for(each_resource_posting_active)
+	{
+		sna_test_for_resource_posted(rcb, rc);
+		if(rc != UNSUCCESSFULL)
+		{
+			wait->rcode = rc;
+			return (-?);
+		}
+
+	/* Spin until resource becomes posted */
+	rc = UNSUCCESSFULL;
+	while(rc == UNSUCCESSFULL)
+	{
+		sna_receive_rm_or_hs_to_ps_records(temp_resource_list);
+		rcb = rcb_data_active();
+		sna_test_for_resource_posted(rcb, rc);
+	}
+
+	resource_posted = rcb->rcb_id;
+	wait->rcode = rc;
+
+	return (0);
+}
+
+static int sna_ps_protocol_err(__u8 hs_id, __u8 tcb_id, __u8 sense)
+{
+	struct sna_unbind_protocol_error *unbind_proto_err;
+
+	unbind_proto_err->hs_id 	= hs_id;
+	unbind_proto_err->tcb_id	= tcb_id;
+	unbind_proto_err->sense		= sense;
+
+	send_to_rm(unbind_proto_err);
+
+	return (0);
+}
+
+static int sna_init_attached_rcb(struct sna_rcb *rcb, attach)
+{
+	rcb->conversation_type 	= attach->conversation_type;
+	rcb->limit_buf_pool_id 	= attach->limit_buf_pool_id;
+	rcb->perm_buf_pool_id	= attach->perm_buf_pool_id;
+	rcb->send_ru_size	= attach->send_ru_size;
+	rcb->post_conditions.fill	= LL;
+	rcb->post_conditions.max_length	= 0;
+	rcb->locks		= SHORT;
+	rcb->rq_to_send_rcvd	= NO;
+
+	sna_empty_list(rcb->hs_to_ps_buffer_list);
+
+	fsm_conversation	= RCV;
+	fsm_error_or_failure	= NO_REQUESTS;
+	fsm_post		= RESET;
+
+	if(rcb->conversation_type == MAPPED_CONVERSATION)
+	{
+		sna_empty_list(rcb->mc_receive_buffer);
+		rcb->mc_rq_to_send_rcvd	= NO;
+		rcb->mapper_save_area	= /* I decide, Hah! */
+		rcb->mc_max_send_size	= /* I decide this too!! Wee */
+	}
+
+	return (0);
+}
+
+static int sna_test_for_resource_posted(struct sna_rcb *rcb)
+{
+	struct sna_test *test;
+	struct sna_mc_test *mc_test;
+
+	switch(rcb->conversation_type)
+	{
+		case (BASIC):
+			new(test, GFP_ATOMIC);
+			test->resource 	= rcb->rcb_id;
+			test->test	= POSTED;
+			err = sna_test_proc(test);
+			break;
+
+		case (MAPPED):
+			new(mc_test, GFP_ATOMIC);
+			mc_test->resource	= rcb->rcb_id;
+			mc_test->test		= POSTED;
+			err = sna_mc_test_proc(mc_test);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (err);
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_ps_mc.c linux/net/sna/sna_ps_mc.c
--- linux-2.4.18-clean/net/sna/sna_ps_mc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ps_mc.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,45 @@
+/* sna_ps_mc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Mapped Conversations (PS.MC)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_mc(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_mc\n");
+
+	return (0);
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_ps_sync.c linux/net/sna/sna_ps_sync.c
--- linux-2.4.18-clean/net/sna/sna_ps_sync.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ps_sync.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,44 @@
+/* sna_ps_sync.c:
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_sync(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_sync\n");
+
+	return (0);
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_rm.c linux/net/sna/sna_rm.c
--- linux-2.4.18-clean/net/sna/sna_rm.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_rm.c	Sat Jun  8 16:01:55 2002
@@ -0,0 +1,3234 @@
+/* sna_rm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Resource Manager (RM)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+ 
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static LIST_HEAD(mode_list);
+static LIST_HEAD(rcb_list);
+static LIST_HEAD(plu_list);
+static LIST_HEAD(lu_list);
+
+static __u32 sna_mode_system_id = 1;
+static __u32 sna_lu_system_id	= 1;
+static __u32 sna_plu_system_id	= 1;
+static __u32 sna_rcb_system_id	= 1;
+static __u32 sna_bracket_id	= 1;
+static __u32 sna_conversation_correlator = 1;
+static __u32 sys_correlator_cnt = 1;
+
+struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id)
+{
+        struct sna_rcb *rcb;
+	struct list_head *le;
+	
+	list_for_each(le, &rcb_list) {
+		rcb = list_entry(le, struct sna_rcb, list);
+                if (rcb->rcb_id == rcb_id)
+                        return rcb;
+	}
+        return NULL;
+}
+
+int sna_rm_send_attach_to_ps(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "init\n");
+	sna_ps_process_fmh5(tcb_id, rcb_id, skb);
+	return 0;
+}
+
+int sna_rm_create_ps(__u32 *tcb_id, __u32 *rcb_id, struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct snathdr *th = (struct snathdr *)skb->data;
+	int err;
+	
+	sna_debug(5, "sna_rm_create_ps DAF is %02X\n", th->fid.f2.daf);
+	*tcb_id = sna_cpic_create_tcb(&err);
+	if (err < 0)
+		return err;
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if (!tcb) {
+		sna_debug(5, "No TCB found\n");
+		return -1;
+	}
+	*rcb_id = sna_rm_allocate_rcb(tcb);
+	*tcb_id = tcb->tcb_id;
+	return 0;
+}
+
+static int sna_rm_process_attach(struct sk_buff *skb)
+{
+	__u32 tcb_id = 0, rcb_id = 0;
+
+	sna_debug(5, "sna_rm_process_attach\n");
+	sna_rm_create_ps(&tcb_id, &rcb_id, skb);
+	sna_rm_send_attach_to_ps(tcb_id, rcb_id, skb);
+
+#ifdef NOT
+        struct sna_scb *scb;
+        __u8 tcb_id, rcb_id, err;
+
+        tcb_id = 0;
+        rcb_id = 0;
+
+        scb = sna_search_scb();
+
+        if (FSM_SCB_STATUS != PENDING_ATTACH)
+                sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 0x20030000);
+        else {
+                err = sna_attach_chk(fmh5, mu->layer.hs_to_rm.hs_id);
+                switch (err) {
+                        case 0xFFFFFFFF:
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x080F6051);
+                                sna_free_buffer(mu);
+                                break;
+
+
+                        case 0x10086040:
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086040);
+                                sna_free_buffer(mu);
+                                break;
+
+                        case 0x10086011:
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086011);
+                                sna_free_buffer(mu);
+                                break;
+                }
+
+                if (fmh5->fmh5cmd == ATTACH) {
+                        if (err == 0x00000000) {
+                                tp = sna_search_tp();   /* ??? */
+
+                                /* Spell insane for now */
+                                if (err == 0x00000000
+                                        || tp->instance_cnt
+                                        < tp->instance_limit)
+
+                                        err = sna_ps_creation_proc(mu, tcb_id,rcb_id, tp, create_rc);
+                                        if(err == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                if(tp->tp_cnt > 0
+                                                        && err == 0)
+                                                {
+                                                        sna_queue_attach_proc(mu);
+                                                }
+                                                else
+                                                {
+                                                        sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                        bm_free(FREE, mu);
+                                                }
+                                                if(tp->tp_cnt == 0)
+                                                        sna_purge_queued_requests(tp);
+                                        }
+
+                                        sna_queue_attach(mu);
+                                }
+                                else
+                                {
+                                        mu->tp = NULL;
+                                        sna_ps_creation_proc(mu, tcb_id, rcb_id, tp, create_rc);
+                                        if(create_rc == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                bm_free(FREE, mu);
+                                        }
+                                }
+                        }
+                }
+        }
+#endif
+        return 0;
+}
+
+int sna_rm_process_hs_to_rm(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_rm_process_hs_to_rm\n");
+
+	/* if FMH-5 */
+	sna_rm_process_attach(skb);
+
+	return 0;
+}
+
+int sna_rm_destroy(struct sna_delete_node *d)
+{
+	struct list_head *le, *se;
+	struct sna_mode_cb *mode;
+	struct sna_plu_cb *plu;
+	struct sna_lu_cb *lu;
+	
+	list_for_each_safe(le, se, &mode_list) {
+		mode = list_entry(le, struct sna_mode_cb, list);
+		list_del(&mode->list);
+		kfree(mode);
+		sna_mod_dec_use_count();
+	}
+	list_for_each_safe(le, se, &lu_list) {
+		lu = list_entry(le, struct sna_lu_cb, list);
+		list_del(&lu->list);
+		kfree(lu);
+		sna_mod_dec_use_count();
+	}
+	list_for_each_safe(le, se, &plu_list) {
+		plu = list_entry(le, struct sna_plu_cb, list);
+		list_del(&plu_list);
+		kfree(plu);
+		sna_mod_dec_use_count();
+	}
+	return 0;
+}
+
+struct sna_mode_cb *sna_rm_find_mode(char *mode_name)
+{
+	struct sna_mode_cb *mode;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &mode_list) {
+		mode = list_entry(le, struct sna_mode_cb, list);
+		sna_debug(5, "m->mode(%s), mode(%s)\n", 
+			mode->mode_name, mode_name);
+		if (!strcmp(mode->mode_name, mode_name))
+			return mode;
+	}
+	return NULL;
+}
+
+struct sna_lu_cb *sna_rm_find_local_lu(char *lu_name)
+{
+	struct sna_lu_cb *lu;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &lu_list) {
+		lu = list_entry(le, struct sna_lu_cb, list);
+		if (!strcmp(lu->lu_name, lu_name))
+			return lu;
+	}
+	return NULL;
+}
+
+struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id)
+{
+	struct sna_plu_cb *plu;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &plu_list) {
+		plu = list_entry(le, struct sna_plu_cb, list);
+		if (!strcmp(plu->netid_plu.net, id->net)
+			&& !strcmp(plu->netid_plu.name, id->name))
+			return plu;
+	}
+	return NULL;
+}
+
+int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+	struct list_head *le, *se;
+        struct sna_lu_cb *lu;
+
+	list_for_each_safe(le, se, &lu_list) {
+		lu = list_entry(le, struct sna_lu_cb, list);
+                if (!strcmp(lu->lu_name, dlu->lu_name)) {
+			list_del(&lu->list);
+                        kfree(lu);
+                        sna_mod_dec_use_count();
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu)
+{
+	struct list_head *le, *se;
+        struct sna_plu_cb *plu;
+
+	list_for_each_safe(le, se, &plu_list) {
+		plu = list_entry(le, struct sna_plu_cb, list);
+                if (!strcmp(plu->netid_plu.net, dplu->netid_plu.net)
+			&& !strcmp(plu->netid_plu.name, dplu->netid_plu.name)) {
+			list_del(&plu->list);
+                        kfree(plu);
+                        sna_mod_dec_use_count();
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+int sna_rm_delete_mode(struct sna_delete_mode *dm)
+{
+	struct list_head *le, *se;
+	struct sna_mode_cb *mode;
+
+	list_for_each_safe(le, se, &mode_list) {
+		mode = list_entry(le, struct sna_mode_cb, list);
+		if (!strcmp(mode->mode_name, dm->mode_name)) {
+			list_del(&mode_list);
+			kfree(mode);
+			sna_mod_dec_use_count();
+			return 0;
+		}
+	}
+	return -ENOENT;
+}
+
+int sna_rm_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	struct sna_lu_cb *lu;
+
+        lu = sna_rm_find_local_lu(dlu->lu_name);
+        if (lu)
+                return -EEXIST;
+	new(lu, GFP_ATOMIC);
+	if (!lu)
+		return -ENOMEM;
+	memcpy(&lu->netid, &dlu->netid, sizeof(struct sna_netid));
+	strncpy(lu->lu_name, dlu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lu->sync_point	= dlu->sync_point;
+	lu->lu_sess_limit=dlu->lu_sess_limit;
+        lu->flags      	= SNA_UP;
+        lu->proc_id    	= sna_lu_system_id++;
+	list_add_tail(&lu->list, &lu_list);
+        sna_mod_inc_use_count();
+	return 0;
+}
+
+int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "init:  -%s-\n", sna_pr_netid(&lu->netid_plu));
+	plu = sna_rm_find_remote_lu(&lu->netid_plu);
+	if (plu)
+		return -EEXIST;
+	new(plu, GFP_ATOMIC);
+	if (!plu)
+		return -ENOMEM;
+	memcpy(&plu->netid, &lu->netid, sizeof(struct sna_netid));
+	memcpy(&plu->netid_plu, &lu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&plu->netid_fqcp, &lu->netid_fqcp, sizeof(struct sna_netid));
+	plu->parallel_ss= lu->parallel_ss;
+	plu->cnv_security=lu->cnv_security;
+	plu->flags	= SNA_UP;
+	plu->proc_id	= sna_plu_system_id++;
+	list_add_tail(&plu->list, &plu_list);
+	sna_mod_inc_use_count();
+	return 0;
+}
+
+int sna_rm_define_mode(struct sna_define_mode *dm)
+{
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "init\n");
+	mode = sna_rm_find_mode(dm->mode_name);
+	if (mode)
+		return -EEXIST;
+	new(mode, GFP_ATOMIC);
+	if (!mode)
+		return -ENOMEM;
+	memcpy(&mode->netid, &dm->netid, sizeof(struct sna_netid));
+	memcpy(&mode->netid_plu, &dm->netid_plu, sizeof(struct sna_netid));
+	strncpy(mode->mode_name, dm->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mode->cos_name, dm->cos_name, SNA_RESOURCE_NAME_LEN);
+	mode->tx_pacing = dm->tx_pacing;
+	mode->rx_pacing = dm->rx_pacing;
+	mode->max_tx_ru = dm->max_tx_ru;
+	mode->max_rx_ru = dm->max_rx_ru;
+	mode->crypto	= dm->crypto;
+	mode->flags	= SNA_UP;
+	mode->proc_id	= sna_mode_system_id++;
+
+	mode->max_sessions	= SNA_MODE_MAX_SESSIONS;
+	mode->min_conwinners	= SNA_MODE_MIN_CONWINNERS;
+	mode->min_conlosers	= SNA_MODE_MIN_CONLOSERS;
+	mode->active.sessions	= 0;
+	mode->active.conwinners	= 0;
+	mode->active.conlosers	= 0;
+	mode->pending.sessions	= 0;
+	mode->pending.conwinners= 0;
+	mode->pending.conlosers	= 0;
+	list_add_tail(&mode->list, &mode_list);
+	sna_mod_inc_use_count();
+	return 0;
+}
+
+int sna_mode_ginfo(struct sna_mode_cb *mode, char *buf, int len)
+{
+        struct modereq mr;
+        int done = 0;
+
+	sna_debug(10, "sna_mode_ginfo\n");
+        if (!buf) {
+                done += sizeof(mr);
+                return done;
+        }
+        if (len < (int)sizeof(mr))
+                return done;
+        memset(&mr, 0, sizeof(struct modereq));
+
+        /* Move the data here */
+	memcpy(&mr.netid, &mode->netid, sizeof(struct sna_netid));
+	memcpy(&mr.plu_name, &mode->netid_plu, sizeof(struct sna_netid));
+	strncpy(mr.mode_name, mode->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mr.cos_name, mode->cos_name, SNA_RESOURCE_NAME_LEN);
+	mr.tx_pacing		= mode->tx_pacing;
+	mr.rx_pacing		= mode->rx_pacing;
+	mr.max_tx_ru		= mode->max_tx_ru;
+	mr.max_rx_ru		= mode->max_rx_ru;
+	mr.crypto		= mode->crypto;
+	mr.proc_id		= mode->proc_id;
+	mr.flags		= mode->flags;
+	mr.auto_activation	= mode->auto_activation;
+	mr.max_sessions		= mode->max_sessions;
+	mr.min_conlosers	= mode->min_conlosers;
+	mr.min_conwinners	= mode->min_conwinners;
+	mr.act_sessions		= mode->active.sessions;
+	mr.act_conwinners	= mode->active.conwinners;
+	mr.act_conlosers	= mode->active.conlosers;
+	mr.pend_sessions	= mode->pending.sessions;
+	mr.pend_conwinners	= mode->pending.conwinners;
+	mr.pend_conlosers	= mode->pending.conlosers;
+
+        if (copy_to_user(buf, &mr, sizeof(struct modereq)))
+                return -EFAULT;
+        buf  += sizeof(struct modereq);
+        len  -= sizeof(struct modereq);
+        done += sizeof(struct modereq);
+        return done;
+}
+
+int sna_lu_ginfo(struct sna_lu_cb *lu, char *buf, int len)
+{
+        struct lureq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_lu_ginfo\n");
+        if (!buf) {
+                done += sizeof(lr);
+                return done;
+        }
+        if (len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lureq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &lu->netid, sizeof(struct sna_netid));
+	strncpy(lr.name, lu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lr.sync_point		= lu->sync_point;
+	lr.lu_sess_limit	= lu->lu_sess_limit;
+	lr.proc_id		= lu->proc_id;
+	lr.flags		= lu->flags;
+
+        if (copy_to_user(buf, &lr, sizeof(struct lureq)))
+                return -EFAULT;
+        buf += sizeof(struct lureq);
+        len -= sizeof(struct lureq);
+        done += sizeof(struct lureq);
+        return done;
+}
+
+int sna_plu_ginfo(struct sna_plu_cb *plu, char *buf, int len)
+{
+        struct plureq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_plu_ginfo\n");
+        if (!buf) {
+                done += sizeof(pr);
+                return done;
+        }
+        if (len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct plureq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&pr.plu_name, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&pr.fqcp_name, &plu->netid_fqcp, sizeof(struct sna_netid));
+	pr.parallel_ss	= plu->parallel_ss;
+	pr.cnv_security	= plu->cnv_security;
+	pr.proc_id	= plu->proc_id;
+	pr.flags	= plu->flags;
+
+        if (copy_to_user(buf, &pr, sizeof(struct plureq)))
+                return -EFAULT;
+        buf  += sizeof(struct plureq);
+        len  -= sizeof(struct plureq);
+        done += sizeof(struct plureq);
+        return done;
+}
+
+int sna_rm_query_mode(char *arg)
+{
+	struct sna_mode_cb *mode;
+	int len, total, done;
+	struct list_head *le;
+	struct modeconf mc;
+	char *pos;
+
+	sna_debug(5, "init\n");
+	if (copy_from_user(&mc, arg, sizeof(mc)))
+                return -EFAULT;
+        pos = mc.modec_buf;
+        len = mc.mode_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &mode_list) {
+		mode = list_entry(le, struct sna_mode_cb, list);
+                if (pos == NULL)
+                	done = sna_mode_ginfo(mode, NULL, 0);
+                else
+                        done = sna_mode_ginfo(mode,pos+total,len-total);
+                if (done < 0)
+                	return -EFAULT;
+                total += done;
+        }
+        mc.mode_len = total;
+        if (copy_to_user(arg, &mc, sizeof(mc)))
+                return -EFAULT;
+        return 0;
+}
+
+int sna_rm_query_lu(char *arg)
+{
+	struct sna_lu_cb *lu;
+	struct list_head *le;
+        int len, total, done;
+	struct luconf lc;
+	char *pos;
+
+	sna_debug(5, "init\n");
+        if (copy_from_user(&lc, arg, sizeof(lc)))
+                return -EFAULT;
+        pos = lc.luc_buf;
+        len = lc.lu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &lu_list) {
+		lu = list_entry(le, struct sna_lu_cb, list);
+                if (pos == NULL)
+                	done = sna_lu_ginfo(lu, NULL, 0);
+                else
+                        done = sna_lu_ginfo(lu,pos+total,len-total);
+                if (done < 0)
+                        return -EFAULT;
+                total += done;
+        }
+        lc.lu_len = total;
+        if (copy_to_user(arg, &lc, sizeof(lc)))
+                return -EFAULT;
+        return 0;
+}
+
+int sna_rm_query_plu(char *arg)
+{
+	struct sna_plu_cb *plu;
+	struct list_head *le;
+	int len, total, done;
+	struct pluconf pc;
+	char *pos;
+
+	sna_debug(5, "init\n");
+        if (copy_from_user(&pc, arg, sizeof(pc)))
+                return -EFAULT;
+        pos = pc.pluc_buf;
+        len = pc.plu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	list_for_each(le, &plu_list) {
+		plu = list_entry(le, struct sna_plu_cb, list);
+                if (pos == NULL)
+	                done = sna_plu_ginfo(plu, NULL, 0);
+                else
+                        done = sna_plu_ginfo(plu, pos+total, len-total);
+                if (done < 0)
+                        return -EFAULT;
+                total += done;
+        }
+        pc.plu_len = total;
+        if (copy_to_user(arg, &pc, sizeof(pc)))
+                return -EFAULT;
+        return 0;
+}
+
+static int sna_rm_session_activation_polarity(struct sna_netid *plu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_plu_cb *plu;
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "init: %s.%s\n",
+		plu_name->net, plu_name->name);
+	plu = sna_rm_find_remote_lu(plu_name);
+	if (!plu)
+		return -ENOENT;
+	mode = sna_rm_find_mode(mode_name);
+	if (!mode)
+		return -ENOENT;
+        if(mode->pending.sessions == mode->max_sessions)
+                return SNA_SESSION_NONE;
+/*
+        if((mode->pending.sessions +  mode->active.sessions) > 0
+                && partner->parallel == SUPPORTED)
+                return (SNA_SESSION_NONE);
+*/
+        if ((mode->max_sessions - mode->min_conlosers)
+                > (mode->active.conwinners + mode->pending.conwinners))
+                return SNA_SESSION_FIRST_SPEAKER;
+        else
+                return SNA_SESSION_BIDDER;
+	return 0;
+}
+
+static int sna_rm_send_activate_session(struct sna_netid *plu_name,
+        unsigned char *mode_name, int polarity)
+{
+	struct sna_sm_act_session_rq *as;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "init\n");
+	mode = sna_rm_find_mode(mode_name);
+	if (!mode)
+		return -ENOENT;
+	new(as, GFP_ATOMIC);
+	if (!as)
+		return -ENOMEM;
+        as->correlator	= sys_correlator_cnt++;
+	as->polarity	= (__u8)polarity;
+	memcpy(&as->plu_netid, plu_name, sizeof(struct sna_netid));
+	memcpy(as->mode_name, mode_name, SNA_RESOURCE_NAME_LEN);
+        mode->pending.sessions++;
+        if (polarity == SNA_SESSION_FIRST_SPEAKER)
+                mode->pending.conwinners++;
+        else
+                mode->pending.conlosers++;
+	sna_sm_process_activation_session(as);
+        return 0;
+}
+
+int sna_rm_activate_session(struct sna_rm_act_session_rq *as)
+{
+	int err = 0;
+
+	sna_debug(5, "init\n");
+        switch (sna_rm_session_activation_polarity(&as->plu_netid, as->mode_name)) {
+                case SNA_SESSION_FIRST_SPEAKER:
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_FIRST_SPEAKER);
+                        break;
+
+                case SNA_SESSION_BIDDER:
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_BIDDER);
+                        break;
+
+		case SNA_SESSION_NONE:
+		default:
+			sna_debug(5, "error or seession limit exceeded.\n");
+			err = -1;    /* LU_MODE_SESSION_LIMIT_EXCEEDED */
+			break;
+        }
+	kfree(as);
+        return err;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+	off_t pos = 0, begin = 0;
+	struct sna_lu_cb *lu;
+	struct list_head *le;
+        int len = 0;
+
+        len += sprintf(buffer, "%-6s%-18s%-9s%-11s%-14s%-5s\n",
+                "lu_id", "netid.node", "lu_name", "sync_point",
+		"lu_sess_limit", "flags");
+	list_for_each(le, &lu_list) {
+		lu = list_entry(le, struct sna_lu_cb, list);
+                len += sprintf(buffer + len, "%-6d%-18s%-9s%-11d%-14d%04X\n",
+                        lu->proc_id, sna_pr_netid(&lu->netid), 
+			lu->lu_name, lu->sync_point,
+			lu->lu_sess_limit, lu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+	return len;
+}
+
+int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+        off_t pos = 0, begin = 0;
+	struct sna_plu_cb *plu;
+	struct list_head *le;
+        int len = 0;
+
+        len += sprintf(buffer, "%-7s%-18s%-18s%-18s%-12s%-12s%-5s\n",
+                "plu_id", "netid.node", "netid.plu", "netid.fqcp",
+		"parallel_ss", "cnv_security", "flags");
+	list_for_each(le, &plu_list) {
+		plu = list_entry(le, struct sna_plu_cb, list);
+                len += sprintf(buffer + len, "%-7d%-17s%-17s%-17s%-12d%-12d%04X\n",
+			plu->proc_id, sna_pr_netid(&plu->netid), 
+			sna_pr_netid(&plu->netid_plu), 
+			sna_pr_netid(&plu->netid_fqcp),
+			plu->parallel_ss, plu->cnv_security, plu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+
+int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_mode_cb *mode;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+        len += sprintf(buffer, "%-8s%-18s%-18s%-10s%-10s%-10s%-10s%-10s%-7s%-5s\n", 
+		"mode_id", "netid.node", 
+		"netid.plu", "mode_name", "tx_pacing", "rx_pacing",
+		"max_tx_ru", "max_rx_ru", "crypto", "flags");
+	list_for_each(le, &mode_list) {
+		mode = list_entry(le, struct sna_mode_cb, list);
+                len += sprintf(buffer + len, "%-8d%-17s%-17s%-8s%-10d%-10d%-10d%-10d%-7d%04X\n",
+			mode->proc_id, sna_pr_netid(&mode->netid), 
+			sna_pr_netid(&mode->netid_plu), mode->mode_name, 
+			mode->tx_pacing,
+			mode->rx_pacing, mode->max_tx_ru, mode->max_rx_ru,
+			mode->crypto, mode->flags);
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
+
+__u8 sna_rm_create_rcb(struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "init\n");
+	new(rcb, GFP_ATOMIC);
+	if (!rcb)
+		return 0;
+	rcb->tcb_id	= tcb->tcb_id;
+	rcb->rcb_id	= sna_rcb_system_id++;
+	tcb->rcb_id     = rcb->rcb_id;
+	rcb->hs_id	= 0;
+	rcb->bracket_id	= sna_bracket_id++;
+	rcb->session_id	= 0;
+	rcb->conversation_correlator = sna_conversation_correlator++;
+
+#ifdef NOT
+	/* This is really in the wrong place but works for now. */
+        sna_asm_assign_lfsid(rcb);
+	rcb->oaf	= tcb->oaf;
+	rcb->daf	= tcb->daf;
+#endif
+
+#ifdef NOT
+        rcb->sync       = alloc_rcb->sync;
+        rcb->security_select = alloc_rcb->security_select;
+        sna_fsm_rsb_status(S, ALLOCATE_RCB, UNDEFINED);
+#endif
+
+	memcpy(rcb->lu_name, tcb->partner_lu_name, tcb->partner_lu_name_length);
+	rcb->lu_name_length = tcb->partner_lu_name_length;
+
+	memcpy(rcb->mode_name, tcb->mode_name, tcb->mode_name_length);
+	rcb->mode_name_length = tcb->mode_name_length;
+
+	memcpy(rcb->tp_name, tcb->tp_name, tcb->tp_name_length);
+	rcb->tp_name_length = tcb->tp_name_length;
+
+	rcb->state	= FSM_RCB_STATUS_FSP;
+	list_add_tail(&rcb->list, &rcb_list);
+	return rcb->rcb_id;
+}
+
+__u8 sna_rm_allocate_rcb(struct sna_tcb *tcb)
+{
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_rm_allocate_rcb\n");
+	rcb_id = sna_rm_create_rcb(tcb);
+        return rcb_id;
+}
+
+#ifdef CONFIG_RM
+
+#include <net/sna/sna_th.h>
+#include <net/sna/sna_rh.h>
+#include <net/sna/sna_ru.h>
+#include <net/sna/sna_asm.h>
+#include <net/sna/sna_mu.h>
+#include <net/sna/sna_ipc.h>
+#include <net/sna/sna_sm.h>
+#include <net/sna/sna_dfc.h>
+#include <net/sna/sna_tc.h>
+#include <net/sna/sna_hs.h>
+
+static __u8 sys_rcb_id_cnt;
+static __u8 sys_tcb_id_cnt;
+static __u8 sys_scb_id_cnt;
+static __u8 sys_bracket_id_cnt;
+static __u8 sys_correlator_cnt;
+
+static struct sna_lucb *sna_lucb_list = NULL;	/* LU CB list */
+struct sna_scb *sna_scb_list = NULL;
+struct sna_rcb *sna_rcb_list = NULL;
+struct sna_tcb *sna_tcb_list = NULL;
+
+static int sna_process_initiator_to_rm(struct sna_mu *mu);
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name);
+static int sna_activate_session_rsp_proc(struct sna_mu *mu);
+static int sna_allocate_rcb_proc(struct sna_mu *mu);
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5);
+static int sna_attach_length_chk();
+static int sna_security_chk();
+static int sna_bid_proc(struct sna_mu *mu);
+static int sna_bid_rsp_proc(struct sna_mu *mu);
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id);
+static int sna_bis_race_loser(__u8 hs_id);
+static int sna_change_sessions_proc(struct sna_mu *mu);
+static int sna_check_for_bis_reply(__u8 hs_id);
+static int sna_complete_luw_id();
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id);
+static int sna_create_rcb(struct sna_allocate_rcb *alloc_rcb,
+        struct sna_rcb_allocated *rcb_allocd);
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+        struct sna_session_info *session_info);
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp,
+        struct sna_tp *tp);
+static int sna_deactivate_free_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_deactivate_pending_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_dequeue_waiting_request(__u8 hs_id);
+static int sna_enqueue_free_scb(__u8 hs_id);
+static int sna_first_speaker_proc(struct sna_get_session *get_session,
+        __u8 hs_id);
+static int sna_free_session_proc(struct sna_mu *mu);
+static int sna_get_session_proc(struct sna_get_session *get_session);
+static int sna_ps_abend_proc(struct sna_mu *mu);
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id,
+        struct sna_tp *target_tp);
+static int sna_ps_termination_proc(struct sna_mu *mu);
+static int sna_purge_queued_requests(struct sna_tp *tp);
+static int sna_queue_attach_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate);
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop);
+static int sna_rtr_rq_proc(struct sna_mu *mu);
+static int sna_rtr_rsp_proc(struct sna_mu *mu);
+static int sna_security_proc(struct sna_mu *mu);
+static int sna_send_bis(__u8 hs_id);
+static int sna_send_bis_reply(__u8 hs_id);
+static int sna_send_bis_rq(__u8 hs_id);
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type,
+	__u32 sense);
+static int sna_send_rtr_proc(struct sna_mu *mu);
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id);
+static int sna_session_activated_proc(struct sna_mu *mu);
+static int sna_session_activation_polarity(unsigned char *lu_name, unsigned char *mode_name);
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated);
+static int sna_session_deactivation_polarity(unsigned char *lu_name, 
+	unsigned char *mode_name);
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id);
+static int sna_should_send_bis(__u8 hs_id);
+static int sna_start_tp_proc(struct sna_start_tp *start_tp);
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp);
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_info *info);
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, 
+	struct sna_rcb_allocated *rcb_allocd);
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, int err);
+static int sna_fsm_scb_status(int signal);
+static int sna_fsm_bis(int signal);
+static int sna_fsm_rcb_status(int signal);
+
+static int sna_process_hs_to_rm(struct sna_mu *mu)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(some_type_of_id);
+	if(scb == NULL)
+	{
+		kfree(mu);
+		return (-1);
+	}
+
+	if(fsm_bis == CLOSED)
+	{
+		switch(mu->record_type)
+		{
+			case (SNA_REC_BID):
+				sna_bid_proc(mu);
+				break;
+
+			case (SNA_REC_BID_RSP):
+				sna_bid_rsp_proc(mu);
+				break;
+
+			case (MU):
+				if(MU == FMH5)
+					sna_attach_proc(mu);
+				if(MU == FMH12)
+					sna_security_proc(mu);
+					break;
+
+			case (SNA_REC_FREE_SESSION):
+				sna_free_session_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RQ):
+				sna_rtr_rq_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RSP):
+				sna_rtr_rsp_proc(mu);
+				break;
+
+			case (SNA_REC_BIS_RQ):
+				sna_fsm_bis(r, bis_reply, bis_reply->hs_id);
+				kfree(IPS);
+				break;
+
+			default:
+				kfree(mu);
+		}
+	}
+	else
+	{
+		if(MU)
+			bm_free(FREE, mu);
+		else
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_ps_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ALLOCATE_RCB):
+			sna_allocate_rcb_proc(mu);
+			break;
+
+		case (SNA_REC_GET_SESSION):
+			sna_get_session_proc(mu);
+			break;
+
+		case (SNA_REC_DEALLOCATE_RCB):
+			rcb = sna_search_rcb(deallocate_rcb->rcb_id);
+			if (scb == NULL) {
+				new(bracket_freed, GFP_ATOMIC);
+				bracket_freed->bracket_id = rcb->bracket_id;
+				sna_hs(bracket_freed);
+			}
+			discard(rcb);
+			new(rcb_deallocated, GFP_ATOMIC);
+			sna_ps(rcb_deallocated);
+			break;
+
+		case (SNA_REC_TERMINATE_PS):
+			sna_ps_termination_proc(mu);
+			break;
+
+		case (SNA_REC_CHANGE_SESSIONS):
+			sna_change_sessions_proc(mu);
+			break;
+
+		case (SNA_REC_RM_ACTIVATE_SESSION):
+			sna_rm_activate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_SESSION):
+			sna_rm_deactivate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_CONV_GROUP):
+			sna_rm_deactivate_conv_group_proc(mu);
+			break;
+
+		case (SNA_REC_UNBIND_PROTOCOL_ERROR):
+			sna_send_deactivate_session(active, unbind_protocol_error->hs_id, abnormal, unbind_protocol_error->sense);
+			break;
+
+		case (SNA_REC_ABEND_NOTIFICATION):
+			sna_ps_abend_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_sm_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ACTIVATE_SESSION_RSP):
+			sna_activate_session_rsp_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_ACTIVATED):
+			sna_session_activated_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_DEACTIVATED):
+			sna_session_deactivated_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* We will cast data to appropiate struct type below */
+static int sna_process_initiator_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_START_TP):
+			sna_start_tp_proc(mu);
+			break;
+
+		case (SNA_REC_SEND_RTR):
+			sna_send_rtr_proc(mu);
+			break;
+
+		case (SNA_REC_RM_TIMER_POP):
+			sna_rm_timer_deactivate_sess_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* The only etrance point for RM, we cast data into appropiate record later */
+static int sna_rm_create(int caller, struct sna_mu *mu)
+{
+	struct sna_previous_time *ptime;
+
+	ptime = sna_time();
+
+	switch(caller)
+	{
+		case (SNA_SM):
+			sna_process_sm_to_rm(mu);
+			break;
+
+		case (SNA_HS):
+			sna_process_hs_to_rm(mu);
+			break;
+
+		case (SNA_INIT):
+			sna_process_initiator_to_rm(mu);
+			break;
+
+		case (SNA_PS):
+			sna_process_ps_to_rm(mu);
+			break;
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
+
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	__u8 polarity;
+
+	lucb = sna_search_lucb(lu_name);		/* ??? */
+	mode = sna_search_mode(lucb, mode_name);	/* ??? */
+
+	while((polarity = sna_session_activation_polarity(lu_name, mode_name)) 
+		!= NULL)
+	{
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+		else	/* Bidder */
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_BIDDER);
+
+	}
+
+	while((mode->active.conwinners + mode->pending.conwinners)
+		< min(mode->auto_act_limit, mode->min_conwinners))
+	{
+		polarity = sna_session_activation_polarity(lu_name, mode_name);
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_act_sess_rsp *rsp =(struct sna_act_sess_rsp *)mu->record_ptr;
+
+	if(pending_act->correlator == act_sess_rsp->sorrelator)
+	{
+		mode = pending_act->mode;
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->pending->conwinners--;
+		else
+			mode->pending->conlosers--;
+
+		mode->pending->sessions--;
+		if(act_sess_rsp->type == POS)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->active->conwinners++;
+			else
+				mode->active->conlosers++;
+			mode->active->sessions++;
+
+			sna_successful_session_activation(pending_act->lu_name, 
+				pending_act->mode_name,act_sess_rsp->sess_info);
+		}
+		else
+		{
+			sna_unsuccessful_session_activation(pending_act->lu_name,
+				pending_act->mode_name, act_sess_rsp->err_type);
+			remove_and_toss_pending_activation;
+		}
+	}
+
+	return (0);
+}
+
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5)
+{
+	__u8 err;
+
+	if(fmh5->fmh5cmd != ATTACH)
+		return (0x1008600B);
+
+	err = sna_attach_length_chk(fmh5);
+	if(err)
+		return (err);
+
+	if(fmh5->luw_id)	/* ??? */
+	{
+		/* This is wrong/bad */
+		if(fmh5->luw_net == NULL && fmh5->lu_net != NULL)
+			return (0x10086011);
+	}
+	else
+	{
+		if(fmh5->sync_leve == SYNCPT)
+			return (0x10086011);
+	}
+
+	if(TP_is_a_local_TP)
+	{
+		switch(fmh5->sync)
+		{
+			case (NONE):
+			case (CONFIRM):
+				break;
+			case (CONFIRM | SYNCPT | BACKOUT):
+				if(RemoteLU != supportabove)
+					return (0x10086040);
+			default:
+				return (0x10086040);
+		}
+
+		if(fmh5->sync != supported_by_TP)
+			return (0x10086041);
+		if(TP_temp_disabled)
+			return (0x084B6031);
+		if(TP_perm_disabled)
+			return (0x084C0000);
+
+		err = sna_attach_security_chk(fmh5);
+		if(err)
+			return (err);
+	}
+	else
+		return (0x1008600B);
+
+	return (0x00000000);
+}
+
+/* Need better Docs to do this one */
+static int sna_attach_length_chk()
+{
+
+	return 0;
+}
+
+static int sna_security_chk()
+{
+
+	return 0;
+}
+
+static int sna_bid_proc(struct sna_mu *mu)
+{
+	struct sna_bid *bid = (struct sna_bid *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_bid_rsp *bid_rsp;
+
+	scb = sna_search_scb(bid->hs_id);	/* ??? */
+	if(FSM_BIS == BIS_RCVD || FSM_BIS == CLOSED)
+		send_deactivate_session(active, bid->hs_id, abnormal, 0x20080000);
+	else
+	{
+		mode = sna_search_mode(bid);
+		if(mode->parallel == SNA_RM_FALSE
+			&& mode->session_limit == 0
+			&& mode->drain_partner == SNA_RM_FALSE
+			&& FSM_BIS == BIS_SENT)
+		{
+			bid_rsp->rti	= NEG;
+			bid_rsp->sense	= 0x088B0000;
+			sna_hs(bid_rsp);
+		}
+		else
+		{
+			if(FSM_SCB_STATUS == FREE)
+			{
+				FSM_SCB_STATUS(R, bid, UNDEFINED);
+				if(session_is_in_free_sessino_pool)
+					scb = pull_scb_pool();
+				bid_rsp->rti	= POS;
+				bid_rsp->sense	= 0;
+				sna_hs(bid_rsp);
+				if(scb->timer_unique_id != NULL)
+				{
+					stop_timer();
+					scb->timer_unique_id = NULL;
+				}
+			}
+			else
+			{
+				if(first_speaker)
+				{
+					bid_rsp->rti 	= NEG;
+					bid_rsp->sense 	= 0x08130000;
+					sna_hs(bid_rsp);
+					if(sense_code == 0x08140000)
+					{
+						Remember_LU_stuff;
+					}
+				}
+				else
+					send_deactivate_session(active, 
+						bid->hs_id,abnormal,0x20030000);
+			}
+		}
+	}
+
+	bm_free(FREE, bid);
+
+	return (0);
+}
+
+static int sna_bid_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_bid_rsp *rsp = (struct sna_bid_rsp *)mu->record_ptr;
+	struct sna_session_allocated *sallocated;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	if(rsp->rti == NEG && rsp->sense == 0x88B0000)
+	{
+		if(parallel != supported)
+		{
+			mode->conwinners 	= 0;
+			mode->conlosers 	= 0;
+			mode->sessions 		= 0;
+			send_deactivate_session(active, rsp->hs_id, cleanup, 0);
+		}
+		else
+			send_deactivate_session(active, rsp->hs_id, abnormal, 0x20100000);
+	}
+	else
+	{
+		rcb = sna_search_rcb(PENDING_SCB, rsp->hs_id);
+		if(rsp->rti == POS)
+		{
+			sna_set_rcb_and_scb_fields(rcb->rcb_id, rsp->hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, rsp->hs_id, reply);
+			scb = sna_search_scb(hs);
+
+			sallocated->rcode 		= OK;
+			sallocated->send_ru_size 	= scb->send_ru_size;
+			sallocated->limit_buf_pool_id 	=scb->limit_buf_pool_id;
+			sallocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+			sallocated->in_conver		= SNA_RM_TRUE;
+
+			sna_ps(sallocated);
+		}
+		else
+		{
+			rcb->hs_id = NULL;
+			sna_fsm_rcb_status(R, NEG_BID_RSP, UNDEFINED);
+			if(rsp->sense == 0x08140000)
+				remember_LU_owes_rtr;
+			
+			get_session = rcb->get_session;
+			sna_get_session_proc(get_session);
+		}
+	}
+
+	return (0);
+}
+
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id)
+{
+	struct sna_rcb *rcb;
+	struct sna_bid_without_attach *bid_wo_attach;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	rcb->hs_id = hs_id;
+
+	sna_fsm_rcb_status = FSM_RCB_STATUS_BIDDER;
+	rcb->session_parms_ptr = get_session;
+
+	sna_hs(bid_wo_attach);
+
+	return (0);
+}
+
+static int sna_bis_race_loser(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->pending.conwinners--;
+	else
+		mode->pending.conlosers--;
+
+	sna_hs(bis_reply);
+	close = sna_session_deactivation_polarity(mode->lu_name,
+		mode->mode_name);
+
+	if(close == EITHER)
+	{
+		sna_send_bis_rq(hs_id);
+		remove_from_free_sess_pool;
+	}
+
+	return (0);
+}
+
+static int sna_change_sessions_proc(struct sna_mu *mu)
+{
+	struct sna_change_sessions *chg_sess = (struct sna_change_sessions *)mu->record_ptr;
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *sess_allocd;
+
+	if(chg_sess->rsp == SNA_RM_TRUE)
+	{
+		mode = sna_search_mode(chg_sess->lu_name, chg_sess->mode_name);
+		conwinners = mode->active.conwinners + mode->pending.conwinners;
+		conlosers = mode->active.conlosers + mode->pending.conlosers;
+		old_slimit = mode->max_sessions - chg_sess->delta;
+		plateau = min(mode->active.sessions + mode->pending.sessions, old_slimit);
+		conwinner_incr = max(0, mode->min_conwinners - conwinners);
+		session_decr = max(0, plateau - mode->max_sessions);
+		conloser_incr = max(0, mode->min_conlosers - conlosers);
+		need_to_activate = conwinner_incr + conloser_incr;
+		room_for_activation = max(0, mode->max_sessions - plateau);
+		decrement_for_polarity = max(0, need_to_activate - room_for_activation);
+		mode->termination_cnt = mode->termination_cnt + session_decr + decrement_for_polarity;
+
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_pending_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_free_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+	}
+
+	if((mode->sessions == 0 && mode->drain_self == SNA_RM_FALSE)
+		|| (mode->active.sessions - (mode->pending.conwinners + mode->pending.conlosers) == 0))
+	{
+		struct sna_get_session *get_session;
+
+		while((get_session = sna_get_waiting_sessions(chg_sess->lu_name, chg_sess->mode_name)) != NULL)
+		{
+			struct sna_session_allocated *sallocated;
+			sallocated->rcode = UNSUCCESSFUL_NO_RETRY;
+			sna_ps(sallocated);
+			bm_free(FREE, get_session);
+		}
+	}
+
+	sna_activate_needed_sessions(chg_sess->lu_name, chg_sess->mode_name);
+
+	return (0);
+}
+
+static int sna_check_for_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if(mode->drain_self == SNA_RM_FALSE 
+		|| (sna_get_waiting_gsess(mode->lu_name,mode->mode_name)==NULL))
+	{
+		if(sess_free_brackets(hs_id))
+		{
+			sna_send_bis_reply(hs_id);
+			remove_from_free_sess_pool;
+		}
+	}
+
+	return (0);
+}
+
+/* Need to create an IBM S/370 time structure to complete function */
+static int sna_complete_luw_id()
+{
+
+	return 0;
+}
+
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	rcb = sna_search_rcb(rcb_id);
+
+	rcb->session_id = scb->session_id;
+	scb->bracket_id = rcb->bracket_id;
+
+	hs_ps_connected->bracket_id 	= rcb->bracket_id;
+	hs_ps_connected->ps_id 		= rcb->tcb_id;
+
+	sna_hs(hs_ps_connected);
+
+	return (0);
+}
+
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+				struct sna_session_info *session_info)
+{
+	struct sna_scb *scb;
+
+	new(scb, GFP_ATOMIC);
+	scb->hs_id 		= session_info->hs_id;
+	scb->lu_name 		= lu_name;
+	scb->mode_name		= mode_name;
+	scb->rcb_id		= 0;
+	scb->session_id		= session_info->session_id;
+	scb->send_ru_size 	= session_info->send_ru_size;
+	scb->limit_buf_pool_id	= session_info->limit_buf_pool_id;
+	scb->perm_buf_pool_id 	= session_info->perm_buf_pool_id;
+	scb->bracket_id		= 0;
+	scb->random		= session_info->random;
+	scb->limit_resource 	= session_info->limit_resource;
+	scb->timer_unique_id 	= 0;
+	scb->conversation.gid	= conv_gid++;
+
+	if(session_info->bracket_type == SNA_SESSION_FIRST_SPEAKER)
+	{
+		sna_fsm_bis(FSM_BIS_FSP);
+		sna_fsm_scb_status(FSM_SCB_STATUS_FSP);
+		scb->first_speaker = SNA_RM_TRUE;
+	}
+
+	if(session_info->bracket_type == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_bis(FSM_BIS_BIDDER);
+		sna_fsm_scb_status(FSM_SCB_STATUS_BIDDER);
+		scb->first_speaker = SNA_RM_FALSE;
+	}
+
+	return (0);
+}
+
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp, 
+	struct sna_tp *tp)
+{
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+	int err;
+
+	new(tcb, GFP_ATOMIC);
+	if (!tcb)
+		return -ENOMEM;
+	tcb->tcb_id		= tcb_id++;
+	tcb->tp_name		= start_tp->tp_name;
+	tcb->own_lu_id		= lucb->lu_id;
+	tcb->luw_id.fq_lu_name 	= start_tp->fq_lu_name;
+	sna_complete_luw_id(tcb);
+	tcb->ctrl_cmpnt	= tp;
+
+	/* Shrink these once I know which way is up */
+	if(start_tp->security.user_id != NULL)
+		tcb->security.user_id = start_tp->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+	if(start_tp->security.profile != NULL)
+		tcb->security.profile = start_tp->security.profile;
+	else
+		rcb->security.profile = NULL;
+
+	new(ps_create_parms, GFP_ATOMIC);
+	if (!ps_create_parms)
+		return -ENOMEM;
+
+	/* INITILIZE PS_CREATE_PARMS !!! */
+	err = sna_ps_creation_proc(ps_create_parms);
+	if(err)
+	{
+		bm_free(FREE, tcb);
+		start_tp->tcb_id = NULL;
+	}
+
+	tp->tp_cnt++;
+	start_tp->tcb_id = tcb->tcb_id;
+
+	return (0);
+}
+
+static int sna_deactivate_free_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_scb *scb;
+
+	/* XXXX */
+	while(free_session)
+	{
+		polarity = sna_session_deactivation_polarity(lu_name,mode_name);
+		scb = sna_search_scb(lu_name, mode_name);
+		remove_from_free_session_pool;
+		sna_send_bis(scb->hs_id);
+	}
+
+	return (0);
+}
+
+/* Saving it for a little later, when fsp functions firm up */
+static int sna_deactivate_pending_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(mode_name);
+
+	return (0);
+}
+
+static int sna_dequeue_waiting_request(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if((get_session = sna_get_waiting_gsess(hs_id)) != NULL)
+	{
+		/* Remove from waiting queue */
+
+		sna_get_session_proc(get_session);
+	}
+
+	return (0);
+}
+
+static int sna_enqueue_free_scb(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(hs_id);
+	if(nobody_is_using_this_scb)
+	{
+		if(timer_is_to_be_set)
+			start_timer(scb->timer);
+		scb->timer_unique_id = timer_id++;
+	}
+	put_scb_in_free_pool(scb);	/* ??? */
+
+	return (0);
+}
+
+static int sna_first_speaker_proc(struct sna_get_session *get_session, 
+	__u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *session_allocd;
+
+	sna_set_rcb_and_scb_fields(get_session->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get_session->rcb_id, hs_id);
+
+	new(session_allocd, GFP_ATOMIC);
+	if (!session_allocd)
+		return -ENOMEM;
+	session_allocd->rcode = OK;
+
+	scb = sna_search_scb(hs_id);
+	session_allocd->send_ru_size		= scb->send_ru_size;
+	session_allocd->limit_buf_pool_id	= scb->limit_buf_pool_id;
+	session_allocd->perm_buf_pool_id	= scb->perm_buf_pool_id;
+	session_allocd->in_conver 		= SNA_RM_FALSE;
+
+	sna_ps(session_allocd);
+
+	return (0);
+}
+
+static int sna_free_session_proc(struct sna_mu *mu)
+{
+	struct sna_free_session *free = (struct sna_free_session *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_rtr_rq *rtr_rq;
+	struct sna_bracket_freed *bracket_freed;
+	struct sna_get_session *get_session;
+	int send_now;
+
+	scb = sna_search_scb(free->hs_id);
+	rcb = sna_search_rcb(scb->rcb_id);
+
+	if(rcb == NULL)
+	{
+		new(bracket_freed, GFP_ATOMIC);
+		bracket_freed->bracket_id = scb->bracket_id;
+		sna_hs(bracket_freed);
+	}
+
+	scb->rcb_id = NULL;
+	if(sna_fsm_scb_status() == PENDING_FMH12)
+	{
+		sna_send_deactivate_session(active, scb->hs_id, abnormal, 0x080F6051);
+		return (-1);
+	}
+	else
+		sna_fsm_scb_status(R, FREE_SESSION, UNDEFINED);
+
+	if(sna_fsm_rcb_status() == PENDING_SCB && rcb->hs_id == scb->hs_id)
+		return (0);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE)
+		{
+			if(no_get_session_rqs_waiting)
+			{
+				if(rtr_is_to_be_sent_now)
+				{
+					sna_hs(rtr_rq);
+					scb->rtr_owed = SNA_RM_FALSE;
+				}
+				else
+					sna_enqueue_free_scb(scb->hs_id);
+				return (0);
+			}
+			else
+				return (0);
+		}
+	}
+
+	send_now = sna_should_send_bis(scb->hs_id);
+	if(send_now)
+		sna_send_bis(scb->hs_id);
+	if(sna_fsm_bis() == BIS_SENT || sna_fsm_bis() == CLOSED)
+		return (0);
+	else
+	{
+		sna_enqueue_free_scb(scb->hs_id);
+		if(get_sessions_waiting)
+			sna_dequeue_waiting_request(scb->hs_id);
+	}
+
+	bm_free(FREE, free_session);
+
+	return (0);
+}
+
+static int sna_get_session_proc(struct sna_get_session *get_session)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_partner_lu *partner_lu;
+	struct sna_session_allocated *session_allocd;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	partner_lu = search_plu(rcb->lu_name);
+	mode = search_mode(rcb->lu_name, rcb->mode_name);
+
+	if(mode == NULL)	/* ??? */
+	{
+		new(session_allocd, GFP_ATOMIC);
+		session_allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+		sna_ps(session_allocd);
+		bm_free(FREE, get_session);
+	}
+	else
+	{
+		if(sync_level_not_supported)
+		{
+			new(session_allocd, GFP_ATOMIC);
+			session_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+			sna_ps(session_allocd); /* ??? */
+			bm_free(get_session);
+		}
+
+		if(free_session_exists)
+		{
+			scb = sna_search_scb(free_session);
+			if(scb->first_speaker == SNA_RM_TRUE)
+			{
+				sna_first_speaker_proc(get_session, scb->hs_id);
+				bm_free(FREE, get_session);
+			}
+			else
+				sna_bidder_proc(get_session, scb->hs_id);
+			Remove_session_from_free_sess_pool;
+
+			if(scb->timer_unique_id != NULL)
+			{
+				remove_timer(scb->timer);
+				scb->timer_unique_id = NULL;
+			}
+		}
+		else
+		{
+			if(get_session_requests >= pending_active_sess_requests)
+			{
+				polarity = sna_session_activation_polarity(rcb->lu_name, rcb->mode_name);
+				switch(polarity)
+				{
+					case (SNA_SESSION_NONE):
+						if(partner_lu->parallel == SNA_RM_FALSE
+							&& active_session_for_another_mode == SNA_RM_TRUE)
+						{
+							if(session_is_free)
+							{
+								scb = sna_search_scb(free_session);
+								remove_from_free_session_pool;
+								sna_send_bis(scb->hs_id);
+								if(scb->timer_unique_id != NULL)
+								{
+									remove_timer(scb->timer);
+									scb->timer_unique_id = NULL;
+								}
+							}
+						}
+						break;
+
+					case (SNA_SESSION_FIRST_SPEAKER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_FIRST_SPEAKER);
+						break;
+
+					case (SNA_SESSION_BIDDER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_BIDDER);
+						break;
+				}
+			}
+
+			sna_queue_get_session(get_session);	/* ??? */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_ps_abend_proc(struct sna_mu *mu)
+{
+	struct sna_abend_notify *abend 
+		= (struct sna_abend_notify *)mu->record_ptr;
+	struct sna_tcb *tcb;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+	struct sna_start_tp *tp;
+	struct sna_mode *mode;
+	struct sna_deactivate_session *deactivate_session;
+
+	tcb = sna_search_tcb(abend);
+	sna_destroy_queued_get_sessions(abend);
+	if(tcb != NULL)
+	{
+		for(each_rcb_associated_w_abended_PS;;)
+		{
+			if(sna_fsm_rcb_status() == FREE)
+				mode = sna_search_mode(rcb->lu_name, rcb->mode_name);
+			if(sna_fsm_rcb_status() == IN_USE 
+				|| sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				scb = sna_search_scb(rcb->hs_id);
+				bm_free(FREE, rcb);
+				if(scb != NULL)
+				{
+					new(deactivate_session, GFP_ATOMIC);
+					deactivate_session->status = ACTIVE;
+					deactivate_session->hs_id = scb->hs_id;
+					deactivate_session->type = ABNORMAL;
+					deactivate_session->sense = 0x08640000;
+					sna_sm(deactivate_session);	/* ?? */
+
+					new(session_deactivated, GFP_ATOMIC);
+					session_deactivated->hs_id = scb->hs_id;
+					session_deactivated->reason = ABNORMAL;
+					session_deactivated->sense = 0x08640000;
+					sna_session_deactivated_proc(session_deactivated);
+				}
+			}
+		}
+
+		tp = sna_search_tp(tcb->tp_name);
+		if(tp != NULL)
+		{
+			tp->tp_cnt--;
+			if(init_req_queued_for_tp && tp->tp_cnt < tp->max_tp)
+			{
+				remove_init_req_from_queue;
+				if(init_req_is_an_mu(containing_attach)
+				{
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					mu->layer.hs_to_rm.hs_id = rcb->hs_id;
+					scb = sna_search_rcb(rcb->hs_id);
+					sna_fsm_scb_status(r, free_session, undefined);
+					sna_fsm_scb_status(r, bid, undefined);
+					scb->bracket_id = NULL;
+					scb->rcb_id = NULL;
+					destroy_rcb(rcb);
+					sna_attach_proc(mu);
+				}
+
+				if(queued_init_req == START_TP)
+					sna_start_tp_proc(start_tp);
+			}
+		}
+	}
+
+	destroy_tcb(tcb);
+
+	return (0);
+}
+
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id, 
+	struct sna_tp *target_tp)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_lucb *lucb;
+
+	new(tcb, GFP_ATOMIC);
+	if (!tcb)
+		return -ENOMEM;
+	tcb->tcb_id 	= sys_tcb_id_cnt++;
+	tcb->tp_name 	= mu->attach.tp_name;
+	tcb->ctrl_cmpnt = tp;
+	tcb->own_lu_id	= lucb->lu_id;
+
+	/* Colapse these later */
+	if(attach->security.user_id != NULL)
+		tcb->security.user_id = attach->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+
+	if(attach->security.profile != NULL) 
+		tcb->security.profile = attach->security.profile;
+	else
+		tcb->security.profile = NULL;
+
+	if(attach->luw_id != NULL)
+		tcb->luw_id = attach->luw_id;
+	else
+	{
+		tcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+		sna_complete_luw_id(tcb);
+	}
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	new(rcb, GFP_ATOMIC);
+	rcb->rcb_id 	= sys_rcb_id_cnt++;
+	rcb->tcb_id 	= tcb->tcb_id;
+	rcb->lu_name 	= scb->lu_name;
+	rcb->mode_name 	= scb->mode_name;
+	rcb->tp_name 	= attach->tp_name;
+	rcb->bracket_id = sys_bracket_id_cnt++;
+	rcb->sync_level = attach->sync;
+	rcb->hs_to_ps_buffer_list = NULL;
+
+	if(attach->conversation != NULL)
+		rcb->conversation = attach->conversation;
+	else
+		rcb->conversation = NULL;
+
+	if(first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+
+	sna_fsm_rcb_status(r, attach, hs);
+	rcb->hs_id = mu->layer.hs_to_rm.hs_id;
+
+	/* Initlize PS_CREATE_PARMS */
+
+	if(ps != NULL)
+	{
+		create_rc = SUCCESS;
+		if(tp != NULL)
+			tp->tp_cnt++;
+	}
+	else
+	{
+		create_rc = FAILURE;
+		bm_free(FREE, tcb);
+		bm_free(FREE, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_ps_termination_proc(struct sna_mu *mu)
+{
+	struct sna_terminate_ps *term_ps = (struct sna_terminate_ps *)mu->record_ptr;
+	struct sna_lucb *lucb;
+	struct sna_tp *tp;
+	struct sna_mu *mu;
+	struct sna_start_tp *start_tp;
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	tcb = sna_search_tcb(term_ps);
+	tp  = sna_search_tp(term_ps);
+	if(tp != sna_NULL)
+	{
+		if(queued_init_req(tp) == SNA_RM_TRUE 
+			&& tp->max_tp != tp->tp_cnt)
+		{
+			switch(first_queued_req_rec_type)
+			{
+				case (MU_ATTACH):
+					mu->layer.rm_to_ps.tcb_id = tcb->tcb_id;
+					tcb->ctrl_cmpnt = tp;
+					if(attach->security != NULL)
+						tcb->security = attach->security;
+					if(attach->luw_id != NULL)
+						tcb->luw_id = attach->luw_id;
+					else
+					{
+						rcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+						sna_complete_luw_id(tcb);
+					}
+
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					rcb->tcb_id = tcb->tcb_id;
+					new(hs_ps_connected, GFP_ATOMIC);
+					hs_ps_connected->bracket_id = rcb->bracket_id;
+					hs_ps_connected->ps_id = rcb->tcb_id;
+
+					sna_hs(hs_pd_connected);
+					err = sna_ps(mu);
+					if(err < 0)
+						bm_free(FREE, mu);
+					break;
+
+				case (START_TP):
+					start_tp->tcb_id = tcb->tcb_id;
+					tcb->luw_id.fq_lu_name = start_tp->fq_lu_name;
+					sna_complete_luw_id(tcb);
+					tcb->ctrl_cmpnt = tp;
+					if(start_tp->security_select 
+						== SNA_SECURITY_PGM)
+					{
+						tcb->security = start_tp->security;
+					}
+					else
+						tcb->security = NULL;
+
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						new(start_tp_reply, GFP_ATOMIC);
+						start_tp_reply->rcode = OK;
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+						send_to_caller(start_tp_reply);
+					}
+					break;
+			}
+		}
+	}
+	else
+	{
+		tp->tp_cnt--;
+		destroy_tcb(tcb);
+		destroy_ps(terminate_ps);
+	}
+
+	bm_free(terminate_ps);
+
+	return (0);
+}
+
+static int sna_purge_queued_requests(struct sna_tp *tp)
+{
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_start_tp *start_tp;
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_deactivate_session *deactivate_session;
+	struct sna_session_deactivated *session_deactivated;
+
+	if(tp != NULL)
+	{
+		while((request_type = get_wait_reqs(tp)) != NULL)
+		{
+			switch(request_type)
+			{
+				case (MU_ATTACH):
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					scb = sna_search_scb(rcb->hs_id);
+
+					destroy_rcb(rcb);
+					bm_free(FREE, mu);
+					if(scb != NULL)
+					{
+						new(deactivate_session, GFP_ATOMIC);
+						deactivate_session->status = ACTIVE;
+						deactivate_session->hs_id = scb->hs_id;
+						deactivate_session->type = ABNORMAL;
+						deactivate_session->sense = 0x08640000;
+
+						sna_sm(deactivate_session);
+						new(session_deactivated, GFP_ATOMIC);
+						session_deactivated->hs_id = scb->hs_id;
+						session_deactivated->reason = ABNORMAL_RETRY;
+						session_deactivated->sense = 0x08640000;
+						sna_session_deactivated_proc(session_deactivated);
+					}
+					break;
+
+				case (START_TP):
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						new(start_tp_reply, GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						start_tp_reply->tcb_id = NULL;
+						send_tp_init_proc(start_tp_reply);
+					}
+
+					destroy_start_tp(start_tp);
+					break;
+			}
+		}
+	}
+
+
+	return (0);
+}
+
+static int sna_queue_attach_proc(struct sna_mu *mu)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	new(rcb, GFP_ATOMIC);
+	rcb->rcb_id 		= sys_rcb_id_cnt++;
+	rcb->tcb_id 		= NULL;
+	rcb->tp_name 		= mu->fmh5->tp_name;
+	rcb->hs_id 		= mu->layer.hs_to_rm.hs_id;
+	rcb->bracket_id 	= sys_bracket_id_cnt++;
+	rcb->sync 		= mu_fmh5->sync;
+	rcb->hs_buffer_list 	= NULL;
+
+	if(mu->fsmh5.conversation != NULL)
+		rcb->conversation = mu->fmh5.conversation;
+	else
+		rcb->conversation = NULL;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	rcb->lu_name 		= scb->lu_name;
+	rcb->mode_name 		= scb->mode_name;
+
+	if(scb->first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+	sna_fsm_rcb_status(r, attach, hs);
+
+	scb->bracket_id 	= rcb->bracket_id;
+	scb->rcb_id		= rcb->rcb_id;
+	rcb->conversation.gid	= scb->conversation.gid;
+	rcb->session_id		= scb->session_id;
+	sna_fsm_scb_status(r,
+
+	mu->layer.rm_to_ps.rcb_id		=
+	mu->layer.rm_to_ps.send_ru_size
+	mu->layer.rm_to_ps.limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	mu->layer.rm_to_ps.perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	mu->layer.rm_to_ps.sense		= 0;
+
+	queue_attach_mu(mu);	/* What about rcb ?? */
+
+	return (0);
+}
+
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu)
+{
+	struct sna_rm_deactivate_conv_group *rm_dact_conv_group
+		= (struct sna_rm_deactivate_conv_group *)mu->record_ptr;
+	struct sna_rm_deactivate_session *rm_deactivate;
+	struct sna_scb *scb;
+
+	while((scb = sna_search_scb_gid(rm_dact_conv_group->gid)) != NULL)
+	{
+		new(rm_deactivate, GFP_ATOMIC);
+		rm_deactivate->tcb_id 		= NULL;
+		rm_deactivate->session_id 	= scb->hs_id;
+		rm_deactivate->type 		= rm_dact_conv_group->type;
+		rm_deactivate->sense		= rm_dact_conv_group->sense;
+
+		sna_rm_deactivate_session_proc(rm_deactivate);
+	}
+
+	destroy_rm_dact_conv_group(rm_dact_conv_group);
+
+	return (0);
+}
+
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rm_deactivate->session_id);
+	if(scb != NULL)
+	{
+		switch(rm_deactivate->type)
+		{
+			case (CLEANUP):
+				sna_send_deactivate_session(ACTIVE, rm_deactivate->session_id, CLEANUP, rm_deactivate);
+				kfree(rm_deactivate);
+				break;
+
+			case (NORMAL):
+				if(session_in_free_session_pool)
+				{
+					if(sna_fsm_bis() != BIS_SENT)
+						queue_deact(rm_deactivate);
+					else
+						kfree(rm_deactivate);
+				}
+				else
+				{
+					queue_deact(rm_deactivate);
+					sna_send_bis_rq(hs_id);
+					remove_from_free_pool(hs_id);
+				}
+				break;
+		}
+	}
+	else
+		kfree(rm_deactivate);
+
+	return (0);
+}
+
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop)
+{
+	struct sna_scb *scb;
+	struct sna_mode *mode;
+	struct sna_rm_deactivate_session *rm_deactivate;
+
+	mode = sna_search_mode(rm_timer_pop->lu_name, rm_timer_pop->mode_name);
+	scb = sna_search_scb(rm_timer_pop->unique_id);
+	if(scb != NULL)
+	{
+		if(scb_in_free_ses_pool && scb->first_speaker == SNA_RM_TRUE
+			&& mode->active.conwinners + mode->pending.conwinners 
+			> mode->auto_activate_limit)
+		{
+			new(rm_deactivate, GFP_ATOMIC);
+			rm_deactivate_session_proc(rm_deactivate);
+		}
+	}
+
+	kfree(rm_timer_pop);
+
+	return (0);
+}
+
+static int sna_rtr_rq_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rq *rtr_rq = (struct sna_rtr_rq *)mu->record_ptr;
+	struct sna_get_session *get_session;
+	struct sna_rtr_rsp *rtr_rsp;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rtr_rq);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if((get_session = get_waiting_get_session()) != NULL)
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			new(rtr_rsp, GFP_ATOMIC);
+			rtr_rsp->rti = POS;
+			rtr_rsp->sense = 0x00000000;
+			sna_hs(rtr_rsp);
+			remove_get_session_wait(get_session);
+			sna_get_session_proc(get_session);
+		}
+		else
+		{
+			new(rtr_rsp, GFP_ATOMIC);
+			rtr_rsp->rti = NEG;
+			rtr_rsp->sense = 0x8190000;
+			send_to_hs(rtr_rsp);
+			bis_send = sna_should_send_bis(rtr_rq->hs_id);
+			if(bis_send != NULL)
+				sna_send_bis(rtr_rq->hs_id);
+			else
+				sna_enqueue_free_scb(scb->hs_id);
+		}
+		scb->rtr_owed = SNA_RM_FALSE;
+	}
+	else
+		sna_send_deactivate_session(ACTIVE, rtr_rq->hs_id, ABNORMAL, 0x2003000);
+
+	return (0);
+}
+
+static int sna_rtr_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rsp *rtr_rsp = (struct sna_rtr_rsp *)mu->record_ptr;
+
+	if(rtr_rsp->rti == NEG && fsm_bis == RESET)
+	{
+		bis_send = sna_should_send_bis(rtr_rsp->hs_id);
+		if(bis_send != NULL)
+			sna_send_bis(rtr_rsp->hs_id);
+		else
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			sna_dequeue_waiting_req(rtr_rsp->hs_id);
+		}
+	}
+
+	kfree(rtr_rsp);
+
+	return (0);
+}
+
+static int sna_security_proc(struct sna_mu *mu)
+{
+	struct sna_lucb *lucb;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	remove_random_data();
+
+	if(sna_fsm_scb_status() != PENDING_FMH12
+		|| fmh12->length != 10
+		|| fmh12->security_reply != expected)
+	{
+		sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 
+			0x080F6051);
+	}
+	else
+		sna_fsm_scb_status(R, FMH_12, UNDEFINED);
+
+	bm_free(FREE_BUFFER, mu);
+
+	return (0);
+}
+
+static int sna_send_bis(__u8 hs_id)
+{
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			sna_send_bis_rq(hs_id);
+			break;
+
+		case (BIS_RCVD):
+			sna_send_bis_reply(hs_id);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	sna_fsm_bis(s, BIS_REPLY, hs_id);
+
+	new(bis_reply, GFP_ATOMIC);
+	send_to_hs(bis_reply);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == FREE_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlosers++;
+
+	return (0);
+}
+
+static int sna_send_bis_rq(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_rq *bis_rq;
+
+	new(bis_rq, GFP_ATOMIC);
+	sna_send_to_hs(bis_rq);
+
+	sna_fsm_bis(s, bis_rq, hs_id);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlossers++;
+
+	if(pending_cnos(hs_id))
+		discard_all_queued(rm_deactivate_session);
+	else
+		mode->termnination.sessions--;
+
+	return (0);
+}
+
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type, 
+	__u32 sense)
+{
+	struct sna_pending_activation *pending;
+	struct sna_deactivate_session *deactivate;
+	struct sna_session_deactivated *deactivated;
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	switch(status)
+	{
+		case (PENDING):
+			pending = sna_search_pending(correlator);
+			if(pending != NULL)
+			{
+				new(deactivate, GFP_ATOMIC);
+				deactivate->status 	= PENDING;
+				deactivate->correlator 	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+				send_to_sm(deactivate);
+
+				mode = sna_search_mode();
+				mode->pending.sessions--;
+
+				kfree(pending_activation);
+
+				if((mode->active.sessions + mode->pending.sessions) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						new(session_allocated, GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+
+				if((mode->active.conwinners + mode->pending.conwinners) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						if(get_session->type != CONWINNER)
+						{
+							continue;
+						}
+
+						new(session_allocated, GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+			}
+			break;
+
+		case (ACTIVE):
+			scb = sna_search_scb(correlator);
+			if(scb != NULL)
+			{
+				new(deactivate, GFP_ATOMIC);
+				deactivate->hs_id	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+
+				send_to_sm(deactivate_session);
+
+				new(deactivated, GFP_ATOMIC);
+				if(type == NORMAL)
+					deactivated->reason = NORMAL;
+				else
+				{
+					deactivated->reason = ABNORMAL_NO_RETRY;
+					deactivated->sense = sense;
+				}
+				sna_session_deactivated_proc(deactivated);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_rtr_proc(struct sna_mu *mu)
+{
+	struct sna_send_rtr *send_rtr = (struct sna_send_rtr *)mu->record_type;
+	struct sna_scb *scb;
+	struct sna_rtr_rq *rtr_rq;
+
+	scb = sna_search_scb(send_rtr->hs_id);
+	if(scb != NULL)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE && scb_is_free)
+		{
+			new(rtr_rq, GFP_ATOMIC);
+			sna_send_to_hs(rtr_rq);
+
+			scb->rtr_owed = SNA_RM_FALSE;
+			remove_from_free_pool(scb);
+		}
+	}
+
+	kfree(send_rtr);
+
+	return (0);
+}
+
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *allocated;
+
+	if(session == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_rcb_status(s, get_session, UNDEFINED);
+	}
+
+	sna_set_rcb_and_scb_fields(get->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get->rcb_id, hs_id, NORMAL);
+
+	scb = sna_search_scb(hs_id);
+	new(allocated, GFP_ATOMIC);
+	allocated->rcode 		= OK;
+	allocated->send_ru_size 	= scb->send_ru_size;
+	allocated->limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	allocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	allocated->in_conver 		= SNA_RM_TRUE;
+
+	send_to_ps(allocated);
+
+	return (0);
+}
+
+static int sna_session_activated_proc(struct sna_mu *mu)
+{
+	struct sna_session_activated *activated
+		= (struct sna_session_activated *)mu->record_ptr;
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(activated->lu_name, activated->mode_name);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->active.conwinners++;
+	else
+		mode->active.conlosers++;
+
+	mode->active.sessions++;
+
+	sna_successful_session_activation(activated->lu_name, 
+		activated->mode_name, activated->session_info);
+
+	kfree(activated);
+
+	return (0);
+}
+
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *partner;
+	struct sna_conv_failure *conv_fail;
+
+	scb = sna_search_scb(deactivated->hs_id);
+	if(scb != NULL)
+	{
+		mode = sna_search_mode(deactivated->lu_name, deactivated->mode_name);
+		if(sna_fsm_scb_status() == IN_USE)
+		{
+			if((rcb = sna_search_rcb(scb->rcb_id)) != NULL)
+			{
+				if(rcb->tcb_id != NULL)
+				{
+					new(conv_fail, GFP_ATOMIC);
+					conv_fail->rcb_id = scb->rcb_id;
+					switch(deactivated->reason)
+					{
+						case (NORMAL):
+						case (ABNORMAL_RETRY):
+							conv_fail->reason = SON;
+							break;
+
+						case (ABNORMAL_NO_RETRY):
+							conv_fail->reason = PROTO_VIOLATION;
+							break;
+					}
+					send_to_ps(conv_fail);
+				}
+				else
+				{
+					mu = search_mu(rcb->tp_name, rcb->rcb_id);
+					kfree(rcb);
+					remove_queue(mu);
+					bm_free(FREE, mu);
+				}
+			}
+		}
+		else
+			remove_from_free_sess(session);
+
+		rcb = sna_search_rcb(deactivated->hs_id);
+		if(rcb != NULL)
+		{
+			if(sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				rcb->hs_id = NULL;
+				sna_fsm_rcb_status(r, NEG_BID_RSP, UNDEFINED);
+				new(get_session, GFP_ATOMIC);
+				sna_get_session_proc(get_session);
+			}
+		}
+
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->active.conwinners--;
+		else
+			mode->active.conlosers--;
+		mode->active.sessions--;
+
+		if(session->pending.deactivation == SNA_RM_TRUE)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->termination.conwinners--;
+			else
+				mode->termination.conlosers--;
+		}
+
+		if(deactivated->reason != ABNORMAL_NO_RETRY)
+			sna_activate_needed_sessions(scb->lu_name, scb->mode_name);
+
+		if((mode->active.sessions + mode->pending.sessions) == 0)
+		{
+			if(partner->parallel == SNA_RM_FALSE)
+			{
+				if(waiting_request)
+					sna_activate_needed_sessions(partner->local_lu_name, mode->name);
+			}
+
+			while((get_session = get_sessions()) != NULL)
+			{
+				new(allocated, GFP_ATOMIC);
+				allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+				send_to_ps(allocated);
+				kfree(get_session);
+			}
+
+			while((rm_activate = get_rm_activate_pend()) != NULL)
+			{
+				new(rm_activated, GFP_ATOMIC);
+				rm_activated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+				send_to_ps(rm_activated);
+				kfree(rm_activate);
+			}
+		}
+
+		kfree(scb);
+	}
+
+	kfree(deactivated);
+
+	return (0);
+}
+
+static int sna_session_deactivation_polarity(unsigned char *lu_name, unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->term_count == 0)
+		return (DEACTIVATE);
+	conwinner_cnt = mode->active.conwinners + mode->pending.conwinners 
+		- mode->terminator.conwinners;
+	conloser_cnt = mode->active.conlosers + mode->pending.conlosers 
+		- mode->termination.conlosers;
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		mode->term_count = 0;
+		return (SNA_SESSION_NONE);
+	}
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_BIDDER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinner
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		return (SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_EITHER);
+	}
+	
+	return (0);
+}
+
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	scb->rcb_id = rcb_id;
+
+	rcb = sna_search_rcb(rcb_id);
+	rcb->hs_id = hs_id;
+
+	if(rcb->first_speaker)
+	{
+		sna_fsm_scb_status(s, get_session, undefined);
+		sna_fsm_rcb_status(s, get_session, undefined);
+	}
+	else
+	{
+		sna_fsm_scb_status(r, pos_bid_rsp, undefined);
+		sna_fsm_rcb_status(r, pos_bid_rsp, undefined);
+	}
+
+	return (0);
+}
+
+static int sna_should_send_bis(__u8 hs_id)
+{
+	struct sna_partner *plu;
+	struct sna_mode *mode;
+	int polarity;
+
+	mode = sna_search_mode(hs_id);
+	plu = mode->partner;
+
+	if(!waiting_req(mode) && plu->parallel == NOT_SUPPORTED)
+	{
+		if(waiting_req(plu))
+			return (SNA_RM_TRUE);
+	}
+
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			polarity = sna_session_deactivation_polarity(lu_name, mode_name);
+			if(polarity == SNA_SESSION_EITHER 
+				|| polarity_mode->polarity)
+			{
+				if(mode->drain_self == SNA_RM_FALSE 
+					|| !waiting_req())
+					return (SNA_RM_TRUE);
+				if(pending_rm_deactivate_session)
+					return (SNA_RM_FALSE);
+				return (SNA_RM_FALSE);
+			}
+			break;
+
+		case (BIS_RCVD):
+			if(mode->drain_self == SNA_RM_FALSE || !waiting_req())
+				return (SNA_RM_TRUE);
+			else
+				return (SNA_RM_FALSE);
+
+		case (BIS_SENT):
+			return (SNA_RM_FALSE);
+
+		default:
+			return (-ERROR);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_proc(struct sna_start_tp *start_tp)
+{
+	struct sna_tp *tp;
+	struct sna_lucb *lucb;
+	struct sna_start_tp_reply *start_tp_reply;
+	int response_code;
+
+	response_code = OK;
+	tp = sna_search_tp(start_tp->target_tp_name);
+	if(tp == NULL)
+		response_code = TPN_NOT_RECOGNIZED;
+	else
+	{
+		if(tp->status == DISABLED_TEMPORARY)
+			response_code = TRANS_PGM_NOT_AVAILABLE_RETRY;
+		if(tp->status == DISABLED_PERMANENT)
+			response_code = TRANS_PGM_NOT_AVAIL_NO_RETRY;
+		if(tp->verify_pip == SNA_RM_TRUE && response_code == OK)
+		{
+			if(start_tp->pip_subs != tp->pip_subs)
+			{
+				if(tp->pip_subs == 0)
+					response_code = PIP_NOT_ALLOWED;
+				else
+					response_code = PIP_NOT_SPECIFIED_CORRECTLY;
+			}
+		}
+
+		if(response_code == OK)
+		{
+			err = start_tp_security_valid(start_tp, tp);
+			if(err < 0)
+				response_code = SECURITY_NOT_VALID;
+		}
+
+		if(response_code == OK && start_tp->fqlu_name != NULL
+			&& start_tp->fqlu_name == Not_proper_format)
+		{
+			response_code = INVALID_FULLY_QUALIFIED_LU_NAME;
+		}
+	}
+
+	if(reponse_code == OK)
+	{
+		if(start_tp->fq_lu_name == NULL)
+			start_tp->fq_lu_name = lucb->fq_lu_name;
+
+		if(tp->tp_cnt < tp->max_tp)
+		{
+			sna_create_tcb_and_ps(start_tp, tp);
+			if(start_tp->tcb_id != NULL)
+			{
+				send_to_ps(start_tp);
+				if(start_tp->reply == SNA_RM_TRUE)
+				{
+					new(start_tp_reply, GFP_ATOMIC);
+					start_tp_reply->rcode = response_code;
+					if(response_code == OK)
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+					send_tp_caller(start_tp_reply);
+				}
+				kfree(start_tp);
+			}
+			else
+			{
+				if(tp->tp_cnt > 0)
+					queue(start_tp);
+				else
+				{
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						new(start_tp_reply, GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						send_to_init(start_tp_reply);
+					}
+					kfree(start_tp);
+					sna_purge_queued_requests(tp);
+				}
+			}
+		}
+		else
+			queue(start_tp);
+	}
+	else
+	{
+		if(start_tp->reply == SNA_RM_TRUE)
+		{
+			new(start_tp_reply, GFP_ATOMIC);
+			start_tp_reply->rcode = response_code;
+			start_tp_reply->tcb_id = NULL;
+			send_to_init(start_tp_reply);
+		}
+		kfree(start_tp);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp)
+{
+	if(start_tp->security_select == NULL)
+	{
+		if(tp_requires_security)
+			return (SNA_RM_FALSE);
+		else
+			return (SNA_RM_TRUE);
+	}
+
+	if(start_tp->security.profile != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security.passwd != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security_select ==SNA_SECURITY_PGM)
+	{
+		if(start_tp->security.user_id != NULL
+			&& start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(start_tp->security.user_id == NULL
+			|| (start_tp->security.passwd == NULL
+			&& tp_requires_security))
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(!tp requires security
+			&& (start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL))
+		{
+			return (SNA_RM_TRUE);
+		}
+
+		if(start_tp->security is bad combination)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+	else
+	{
+		if(start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+
+	if(limit_access_to_tp)
+	{
+		if(sna_access_ok(start_tp->security.user_id, 
+			start_tp->security.profile)
+		{
+			return (SNA_RM_TRUE);
+		}
+		else
+		{
+			return (SNA_RM_FALSE);
+		}
+	}
+		
+	return (SNA_RM_TRUE);
+}
+
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_information *info)
+{
+	struct sna_scb *scb;
+	struct sna_get_session *session;
+	struct sna_session_allocated *allocd;
+	struct sna_rm_hs_connected *connected;
+	struct sna_rm_activate_sesion *activate;
+	struct sna_rm_session_activated *activated;
+
+	sna_create_scb(lu_name, mode_name, info);
+	new(connected, GFP_ATOMIC);
+	sna_send_to_hs(connected);
+
+	if(info->first_speaker != SNA_RM_TRUE && plu->parallel != SNA_RM_TRUE)
+	{
+		while((session = get_wait_sessions(CONWINNER)) != NULL)
+		{
+			new(allocd, GFP_ATOMIC);
+			allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			remove_from_list(allocd);
+		}
+	}
+
+	if(info->primary_hs == SNA_RM_TRUE)
+	{
+		sna_fsm_scb_status(r, activated, PRI);
+		while(activated)
+		{
+			if(session == waiting)
+			{
+				if(session->security.level != waiting_req->security.level)
+				{
+					session->security.level = NONE;
+				}
+
+				if(session->sync_level != waiting_req->sync_level)
+				{
+					new(allocd, GFP_ATOMIC);
+					allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+					send_to_ps(allocd);
+					kfree(session);
+				}
+				else
+				{
+					if(scb->random != NULL)
+					{
+						new(sec2, GFP_ATOMIC);
+						sec2->send_parm.allocate = NO;
+						sec2->send_parm.fmh = YES;
+						sec2->send_parm.type = FLUSH;
+						sna_send_to_hs(sec2);
+						sna_session_activated_alloc(session, scb->hs_id);
+						kfree(session);
+					}
+				}
+			}
+			else
+			{
+				sna_fsm_scb_status(s, YEILD_SESSION, undefined);
+				if(scb->random_data != NULL)
+				{
+					new(sec2, GFP_ATOMIC);
+					sec2->send_parm.allocate = NO;
+					sec2->send_parm.fmh = YES;
+					sec2->send_parm.type = DEALLOCATE_FLUSH;
+					sna_send_to_hs(sec2);
+				}
+				else
+				{
+					new(yield, GFP_ATOMIC);
+					sna_send_to_hs(yield);
+				}
+			}
+		}
+	}
+	else
+	{
+		if(scb->random_data != NULL)
+			sna_fsm_scb_status(r, activated, secure);
+		else
+			sna_fsm_scb_status(r, activated, sec);
+	}
+
+	activate = sna_rm_activate_pending();
+	if(activate != NULL)
+	{
+		new(activated, GFP_ATOMIC);
+		activated->rcode = OK;
+		kfree(activate);
+	}
+
+	return (0);
+}
+
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, struct sna_rcb_allocated *rcb_allocd)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	if((find_fsp(rcb_alloc->lu_name, rcb_alloc->mode_name)) != NULL)
+	{
+		create_scb(rcb_alloc, rcb_allocd);
+		if(rcb->security_select != plu->security_select)
+		{
+			rcb->security_select = NONE;
+		}
+		if(rcb_alloc->sync_level != plu->sync_level)
+		{
+			rcb_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+		}
+		else
+		{
+			sna_set_rcb_and_scb_field(rcb->rcb_id, hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, hs_id);
+			rcb_allocd->rcode = OK;
+			rcb_allocd->send_ru_size = scb->send_ru_size;
+			rcb_allocd->limit_buf_pool_id = scb->limit_buf_pool_id;
+			rcb_allocd->perm_buf_pool_id = scb->perm_buf_pool_id;
+			dequeue_fs_pool();
+		}
+	}
+	else
+		rcb_allocd->rcode = UNSUCCESSFUL;
+
+	return (0);
+}
+
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, unsigned char *mode_name, int err)
+{
+	struct sna_mode *mode;
+	struct sna_session_allocated *allocd;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->active.sessions == 0 && mode->pending.sessions == 0)
+	{
+		while((waiting = waiting_req(lu_name, mode_name)) != NULL)
+		{
+			new(allocd, GFP_ATOMIC);
+
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+
+			send_to_ps(allocd);
+			kfree(waiting);
+		}
+
+		sessions = get_wait_sessions();
+		if(plu->parallel != SNA_RM_TRUE && sessions != NULL)
+		{
+			sna_activate_needed_sessions(lu_name, mode_name);
+		}
+	}
+
+	while(pending_rm_activate_reqs > mode->pending.sessions)
+	{
+		new(activated, GFP_ATOMIC);
+
+		if(err == CAN_RETRY)
+			activated->rcode = ACTIVATION_FAILURE_RETRY;
+		else
+			acitvated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+
+		send_to_ps(activated);
+		kfree(activate);
+	}
+
+	if((mode->active.conwinners + mode->pending.conwinners) == 0)
+	{
+		while((get_session = get_wait_sessions()) != NULL)
+		{
+			new(allocd, GFP_ATOMIC);
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			kfree(get_session);
+		}
+	}
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session. */
+static int sna_fsm_scb_status(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session with respect to BIS_RQ and
+ * BIS_REPLY.
+ */
+static int sna_fsm_bis(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a conversation resource associated with a bidder
+ * half-session.
+ */
+static int sna_fsm_rcb_status(int signal)
+{
+
+	return (0);
+}
+
+struct sna_rcb *sna_search_rcb(__u8 id)
+{
+	struct sna_rcb *result = NULL;
+
+	return (result);
+}
+
+struct sna_scb *sna_search_scb(__u8 id)
+{
+	struct sna_scb *result = NULL;
+
+	return (result);
+}
+
+struct sna_tcb *sna_search_tcb(__u8 id)
+{
+	struct sna_tcb *result = NULL;
+
+	return (result);
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_rss.c linux/net/sna/sna_rss.c
--- linux-2.4.18-clean/net/sna/sna_rss.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_rss.c	Sat Jun  8 15:48:17 2002
@@ -0,0 +1,105 @@
+/* sna_rss.c: Linux Systems Network Architecture implementation
+ * Route Selection Services.
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+/*
+ * Bugs:
+ * - We do no weight calculations or tree building.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_rss_request_route(struct sna_rss_route *r)
+{
+	return 0;
+}
+
+int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r)
+{
+	struct sna_rq_tg_vectors *tg;
+	int err;
+
+	sna_debug(5, "init: %s.%s\n",
+		r->dst_cp_name.net, r->dst_cp_name.name);
+	new(tg, GFP_ATOMIC);
+	if (!tg)
+		return -ENOMEM;
+	memcpy(&tg->org_cp_name, &r->dst_cp_name, sizeof(struct sna_netid));
+	err = sna_tdm_request_tg_vectors(tg);
+	if (err < 0)
+		return err;
+	memset(&r->rs, 0, sizeof(struct sna_cv_rs));
+	memcpy(&r->rs.tg_desc, &tg->tg_vectors->desc, 
+		sizeof(struct sna_tg_desc));
+	return 0;
+}
+
+int sna_rss_obtain_tg_vectors(void)
+{
+	return 0;
+}
+
+int sna_rss_select_tg_vector(void)
+{
+	return 0;
+}
+
+int sna_rss_build_rscv(void)
+{
+	return 0;
+}
+
+int sna_rss_obtain_trees(void)
+{
+	return 0;
+}
+
+int sna_rss_update_trees(void)
+{
+	return 0;
+}
+
+int sna_rss_update_resource_weights(void)
+{
+	return 0;
+}
+
+int sna_rss_create(struct sna_start_node *start)
+{
+	return 0;
+}
+
+int sna_rss_destroy(struct sna_delete_node *delete)
+{
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_sm.c linux/net/sna/sna_sm.c
--- linux-2.4.18-clean/net/sna/sna_sm.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_sm.c	Sat Jun  8 15:52:35 2002
@@ -0,0 +1,1933 @@
+/* sna_sm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Session Manager (SM)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/list.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+#include <linux/sna.h>
+
+static bind_state bstate = BIND_RESET;
+
+static LIST_HEAD(lulu_list);
+
+struct sna_lulu_cb *sna_sm_find_lulu_fqpcid(unsigned char *pcid)
+{
+	struct sna_lulu_cb *lulu;
+	struct list_head *le;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &lulu_list) {
+		lulu = list_entry(le, struct sna_lulu_cb, list);
+		if (!strncmp(lulu->fqpcid, pcid, 8))
+			return lulu;
+	}
+	return NULL;
+}
+
+static int sna_sm_build_bind_user_data(__u8 *start)
+{
+	int len = 0;
+	unsigned char name[17];
+	unsigned char unknown[9]={0x00,0x50,0xAA,0x12,0x46,0x2D,0xCA,0x75,0xEA};
+        __u8 l, s;
+	__u16 i;
+
+	sna_debug(5, "sna_sm_build_bind_user_data\n");
+	i = 0;
+	memcpy(start + len, &i, sizeof(__u16));
+	len += 2;
+	l = 12;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 45;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 8;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x02;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "CPSVCMG", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 9;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x03;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	s = 0x01;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "1234567", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 13;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x04;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 19;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	memcpy(start + len, unknown, 9);
+	len += 9;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.IBM", 10);
+	memcpy(start + len, name, 10);
+	len += 10;
+	return len;
+}
+
+static int sna_sm_build_bind_cv(__u8 type, __u8 *cv_start)
+{
+	int len = 0;
+	__u8 s, l;
+	unsigned char name[17], pcid[8];
+
+	sna_debug(5, "sna_sm_build_bind_cv\n");
+	switch (type) {
+		case CV_ROUTE_SEL:
+			s = CV_ROUTE_SEL;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 19;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 17;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x46;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 15;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x80;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x00;	/* TG Number */
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 10;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.IBM", 10);
+			memcpy(cv_start + len, name, 10);
+			len += 10;
+			s = 0x00;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			break;
+
+		case CV_COS_TPF:
+			s = 0x2C;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 9;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x04;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 7;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "CPSVCMG", 7);
+			memcpy(cv_start + len, name, 7);
+			len += 7;
+			break;
+
+		case CV_FQ_PCID:
+			s = 0x60;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 21;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+
+			/* Copy pcid from lulu_cb here now */
+
+			memcpy(cv_start + len, pcid, 8);
+			len += 8;
+			l = 12;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+			memcpy(cv_start + len, name, 12);
+			len += 12;
+			break;
+	}
+
+	return len;
+}
+
+/* Build +RSP(BIND). */
+static int sna_sm_build_bind_rsp_pos(struct sk_buff *skb, int t)
+{
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct net_device *dev = skb->dev;
+	struct sna_rcb *rcb = NULL;
+	struct sk_buff *newskb;
+	struct sna_bind *bind;
+	int size, len = 0;
+
+	sna_debug(5, "sna_sm_build_bind_rsp\n");
+
+#ifdef CONFIG_SNA_LLC
+#ifdef OLD_LLC
+        /* Device + Datalink + XID */
+        size = dev->hard_header_len + LLC_TYPE2_SIZE + 250;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+
+        skb_reserve(newskb, 200);
+	skb_reserve(newskb, sizeof(struct snarhdr));
+	skb_reserve(newskb, sizeof(struct sna_fid2));
+
+        skb_reserve(newskb, LLC_TYPE2_SIZE);
+        skb_reserve(newskb, dev->hard_header_len);
+        newskb->dev = dev;
+
+	if (t == BIND_S_BIND || t == BIND_S_PR_BIND
+		|| t == BIND_S_PR_BIND_W_AF) {
+		if (t == BIND_S_BIND_W_AF)
+			bind = (struct sna_bind *)skb_push(newskb,
+                                sizeof(struct sna_bind) + 61 + 45 + 21);
+		else
+			bind = (struct sna_bind *)skb_push(newskb, 
+				sizeof(struct sna_bind) + 61 + 45);
+
+		memset(bind, 0, sizeof(struct sna_bind));
+		bind->request_code	= BIND_RQ;
+		bind->fm_profile	= FMH_19;
+		bind->ts_profile	= TSH_7;
+		bind->pri_flags		= 0xB0;
+		bind->sec_flags		= 0xB0;
+		bind->cm1_flags		= 0x50;
+		bind->cm2_flags		= 0xB3;
+		if (t == BIND_S_PR_BIND) {
+			bind->sec_tx_win_size	= 0;
+			bind->sec_rx_win_size	= 0x80;
+		} else {
+//			if (t == BIND_S_PR_BIND_W_AF) {
+//				bind->sec_tx_win_size   = 0x01;
+ //                       	bind->sec_rx_win_size   = 0x81;
+//			} else {
+				bind->sec_tx_win_size 	= 0x07;
+				bind->sec_rx_win_size	= 0x87;
+//			}
+		}
+
+		if (t == BIND_S_PR_BIND_W_AF) {
+			bind->shs_max_ru_size   = 0x86;
+                        bind->phs_max_ru_size   = 0x86;
+		} else {
+			bind->shs_max_ru_size	= 0x87;
+			bind->phs_max_ru_size	= 0x87;
+		}
+
+		if (t == BIND_S_PR_BIND) {
+			bind->pri_tx_win_size	= 0x80;
+			bind->pri_rx_win_size	= 0;
+		} else {
+//			if (t == BIND_S_PR_BIND_W_AF) {
+//				bind->pri_tx_win_size   = 0x81;
+  //                              bind->pri_rx_win_size   = 0x01;
+//			} else {
+				bind->pri_tx_win_size	= 0x87;
+				bind->pri_rx_win_size	= 0x07;
+//			}
+		}
+		bind->lu_type		= 0x6;
+		bind->lu6_level		= 0x02;
+		bind->ps1_flags		= 0x16;
+		bind->ps2_flags		= 0x23;
+	
+		len += sna_sm_build_bind_user_data(&bind->raw);
+
+		if (t == BIND_S_PR_BIND_W_AF)
+			len += sna_sm_build_bind_cv(CV_ROUTE_SEL, 
+				&bind->raw + len); /*
++20 */
+
+		len += sna_sm_build_bind_cv(CV_COS_TPF, &bind->raw + len); /* +11 */
+       	 	len += sna_sm_build_bind_cv(CV_FQ_PCID, &bind->raw + len); /* +21 */
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		if (t == BIND_S_PR_BIND) {
+			newskb->h.raw[0] = 0xEB;
+                	newskb->h.raw[1] = 0x80;
+                	newskb->h.raw[2] = 0x00;
+		}
+
+		if (t == BIND_S_PR_BIND_W_AF) {
+			newskb->h.raw[0] = 0xEB;
+			newskb->h.raw[1] = 0x80;
+			newskb->h.raw[2] = 0x00;
+			newskb->nh.raw[2] = 0x02;
+                	newskb->nh.raw[3] = 0x01;
+		}
+	} else {
+		skb_push(newskb, 3);
+		newskb->data[0] = 0;
+		newskb->data[1] = 0;
+		newskb->data[2] = 1;
+
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		newskb->h.raw[0] = 0x83;
+		newskb->h.raw[1] = 0x01;
+		newskb->h.raw[2] = 0x00;
+		newskb->nh.raw[0] = 0x2D;
+		newskb->nh.raw[1] = 0x00;
+                if (t == BIND_S_PR_FMD_W_AF) {
+			newskb->nh.raw[2] = 0x00; // 0x02;
+                        newskb->nh.raw[3] = 0x01;
+		} else {
+			newskb->nh.raw[2] = 0x01;
+			newskb->nh.raw[3] = 0x00;
+		}
+		newskb->nh.raw[4] = 0x00;
+		newskb->nh.raw[5] = 0x00;
+	}
+
+	llc_data(0x04, 0x04, eth_hdr->h_source, newskb, dev);
+#endif	/* OLD_LLC */
+#endif	/* CONFIG_SNA_LLC */
+
+        return 0;
+}
+
+/* Check BIND for semantic and state errors, create a half-session process,
+ * reserve required buffers. If no errors occur, build and send a +RSP(BIND),
+ * update and save active session parameters, and initialize the half-session.
+ */
+static int sna_sm_process_bind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rq\n");
+	if (bstate == BIND_RESET) {
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_BIND);
+		bstate = BIND_S_BIND;
+		kfree_skb(skb);
+		return 0;
+	}
+
+	if (bstate == BIND_S_BIND) {
+		/* Send +RSP BIND */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND);
+		bstate = BIND_S_PR_BIND;
+		kfree_skb(skb);
+		return 0;
+	}
+
+	if (bstate == BIND_S_PR_BIND) {
+		/* Send +RSP FMD BIND */
+                sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD);
+		bstate = BIND_S_PR_FMD;
+		kfree_skb(skb);
+		return 0;
+	}	
+
+	if (bstate == BIND_S_PR_FMD) {
+		/* Send BIND w/ real oaf/daf */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND_W_AF);
+		bstate = BIND_S_PR_BIND_W_AF;
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		kfree_skb(skb);
+		return 0;
+	}
+
+#ifdef NOT
+	if (bstate == BIND_S_PR_BIND_W_AF) {
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return 0;
+	}
+
+	if (bstate == BIND_S_PR_BIND_W_AF) {
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return 0;
+	}
+#endif
+	kfree_skb(skb);
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_mu *mu_new;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_check_semantic(mu);
+        if (err < 0) {
+                local->sense = err; 
+                return -1;
+        }
+
+        err = sna_bind_rq_state_error(mu);
+        if (err < 0) {
+                local->sense = err;
+                return (-1);
+        }
+
+        plu->active_session_params.parallel = bind_rq_rcv->parallel;
+	new(lulu_cb, GFP_ATOMIC);
+	if (!lulu_cb)
+		return -ENOMEM;
+        sna_init_lulu_cb_bind(mu, lulu_cb);
+        lulu_cb->hs_id = unique_hs_id();
+        sna_build_bind_rsp_pos(mu, lulu_cb, mu_new);
+        err = sna_reserve_constant_buffers(lulu_cb);
+        if (!err)
+                err = sna_reserver_variable_buffers(lulu_cb, bind_rq_rcv);
+        if (!err) {
+                lulu_cb->session_id = sna_get_session_id();
+                sna_build_and_send_init_hs(lulu_cb, bind_image);
+        }
+
+        if (!err) {
+                send_to_asm(mu_new);
+                fsm_status(mu_new, lulu_cb);
+        } else {
+                if (mu->bind_ru.fqpcid != NULL)
+                        sna_build_and_send_unbind_rq(mu,CLEANUP,local->sense);
+                else {
+                        if (buffer_err == 0)
+                                bm(FREE, mu_new);
+                        sna_build_and_send_bind_rsp_neg(mu);
+                }
+
+                if (lulu_cb != NULL)
+                        sna_cleanup_lu_lu_session(lulu_cb);
+        }
+#endif
+        return 0;
+}
+
+/* Check if the received RSP(BIND) correlator with the previously sent BIND. If
+ * it does, delete pending random data used in LU-LU verification for the
+ * session (if present) and after additional processing (in case of a positive
+ * response) call the FSM. If it does not correlate, the RSP(BIND) is
+ * considered to be a stray one and is ignored (no action taken).
+ */
+static int sna_sm_process_bind_rsp(struct sk_buff *skb, 
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rsp\n");
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_correlate_bind_rsp(mu);
+        if (err >= 0) {
+                plu->active_session_params.parallel = bind_rsp_rcv->parallel;
+                sna_remove_random(this_session);
+
+                if (mu->bind_rsp.type = POS) {
+                        err = sna_check_semantic(mu);
+                        if (err)
+                                local->sense = err;
+
+                        err = sna_bind_rsp_state_error(mu, lulu_cb);
+                        if (err >= 0) {
+                                sna_reserve_variable_buffers(lulu_cb, bind_rsp_rcv);
+                                sna_build_and_send_init_hs(lulu_cb, bind_image);
+			}
+                }
+                fsm_status(mu, lulu_cb);
+        }
+#endif
+        return 0;
+}
+
+/* Process a received UNBIND. SM always receives the entire UNBIND MU, since
+ * the PIU is not longer than 99 bytes and thus no reassembly by the ASM in
+ * needed. If a received UNBIND correlates to one of the active or pending
+ * active sessions, the FSM is called to clean up the session.
+ */
+static int sna_sm_process_unbind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_unbind_rq\n");
+
+#ifdef NOT
+        struct sna_lu_lu_cb *lulu_cb;
+
+        correlate = sna_correlator_unbind_rq(mu);
+        sna_build_and_send_unbind_rsp(mu);
+        if (correlate)
+                fsm_status(mu, lulu_cb);
+#endif
+        return 0;
+}
+
+int sna_sm_xtract_bind_type(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_sm_xtract_bind_type\n");
+	return 0;
+}
+
+/* entry point for incomming binds. */
+int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_mu\n");
+	switch (sna_sm_xtract_bind_type(skb)) {
+                case SNA_BIND_RQ:
+                        sna_sm_process_bind_rq(skb, l);
+                        break;
+
+                case SNA_BIND_RSP:
+                        sna_sm_process_bind_rsp(skb, l);
+                        break;
+
+                case SNA_UNBIND_RQ:
+                        sna_sm_process_unbind_rq(skb, l);
+                        break;
+
+		case SNA_UNBIND_RSP:
+                default:
+			kfree_skb(skb);
+			return -1;
+        }
+        return 0;
+}
+
+/* Build and send a BIND. */
+static int sna_sm_build_and_send_bind_rq(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_mu *mu;
+        struct sna_bind_ru *bind_ru;
+
+        mu = bm(GET_BUFFER, demand, size, no_wait);     /* ??? */
+
+        mu->header_type                 = BIND_RQ_SEND;
+        mu->bind_rq_send.lu_id          = lulu_cb->lu_id;
+        mu->bind_rq_send.sender.type    = SM;
+        mu->bind_rq_send.lfsid          = lulu_cd->lfsid;
+        mu->bind_rq_send.tx_priority    = NETWORK;
+        mu->bind_rq_send.pc_id          = lulu_cd->pc_id;
+        mu->bind_rq_send.hs_id          = lulu_cd->hs_id;
+        mu->th.snf                      = find_unique(snf);
+
+        /* Set rest to default values in SNA Formats */
+
+        /* Set Bind_RU to defaults */
+
+        /* Insert random data into lucd->pending.random_data_list */
+
+        mu->dcf = (RH->size + RU->size);
+
+        send_to_asm(mu);
+#endif
+        return 0;
+}
+
+/* Get the address (LFSID structure) for the session. Create a half-session
+ * process. Reserve buffers for the session.
+ */
+static int sna_sm_prepare_to_send_bind(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_assign_lfsid *assign_lfsid;
+        struct sna_assign_lfsid_rsp *assign_lfsid_rsp;
+        struct sna_local *local;
+
+	new(assign_lfsid, GFP_ATOMIC);
+        assign_lfsid->pc_id = lulu_cb->pc_id;
+        assign_lfsid->sm_process_id = lulu_cb->lu_id;
+        send_to_asm(assign_lfsid);
+
+        assign_lfsid_rsp = recv_from_asm();
+        if (assign_lfsid_rsp->sense != 0x00000000)
+                local->sense = assign_lfsid_rsp->sense;
+        else {
+                lulu_cb->lfsid = assign_lfsid_rsp->lfsid;
+                /* Create a HS for this one ;) */
+                sna_reserve_constant_buffers(lulu_cb);
+                destroy(assign_lfsid_rsp);
+	}
+#endif
+	return 0;
+}
+
+/* Process a receieved CINIT_SIGNAL record. First, this signal must be
+ * correlated with a previously sent INIT_SIGNAL record. The correlation is
+ * based on the value of FQPCID. If the correlation fails, the session has
+ * already been brought down by the RM and a SESSEND_SIGNAL record is built
+ * and sent to SS.
+ */
+int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal)
+{
+	sna_debug(5, "sna_sm_process_cinit_signal\n");
+
+#ifdef NOT
+        struct sna_init_signal *init_signal;
+        struct sna_partner_lu *plu;
+        struct sna_mode *mode;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_local *local;
+        struct sna_sessend_signal *sessend_signal;
+
+        err = sna_correlate_init(cinit_signal->fqpcid); 
+        if(err < 0) {
+		new(sessend_signal, GFP_ATOMIC);
+                sessend_signal->sense = 0x00000000;
+                sessend_signal->fqpcid = cinit_signal->fqpcid;
+                sessend_signal->pc_id = cinit_signal->pc_id;
+                send_to_ss(sessend_signal);
+        } else {
+                err = sna_lu_mode_session_limit_exceeded(plu->fq_lu_name, mode,
+lulu_cb->session_type, AT_LEAST_BIND_SENT);
+                if (err)
+			return -1;
+
+                err = sna_check_buff_size();
+                err = sna_check_active_already();
+                if (err < 0)
+                        local->sense = 0x08050000;
+
+                if (err >= 0) {
+                        err = sna_prepare_to_send_bind(lulu_cb);
+                        if (!err)
+                                sna_build_and_send_bind_rq(lulu_cb);
+                }
+
+                fsm_status(cinit_signal, lulu_cb);
+        }
+#endif
+        return 0;
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of an ACTIVATE_SESSION received from RM.
+ */
+static int sna_sm_init_lulu_cb_act_sess(struct sna_sm_act_session_rq *as,
+        struct sna_lulu_cb *lulu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_sm_init_lulu_cb_act_sess\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+	if (!plu)
+		return -ENOENT;
+	memcpy(&lulu->plu_netid, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&lulu->netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&lulu->mode_name, &as->mode_name, SNA_RESOURCE_NAME_LEN);
+	lulu->polarity = as->polarity;
+        return 0;
+}
+
+/* Build and send an INIT_SIGNAL record to the control point. */
+static int sna_sm_build_and_send_init_sig(struct sna_lulu_cb *lulu)
+{
+        struct sna_init_signal *init;
+
+	sna_debug(5, "init\n");
+	new(init, GFP_ATOMIC);
+	if (!init)
+		return -ENOMEM;
+	init->sm_proc_id	= lulu->proc_id;
+	memcpy(&init->fqpcid, &lulu->fqpcid, 8);
+	memcpy(&init->slu_name, &lulu->plu_netid, sizeof(struct sna_netid));
+	memcpy(&init->plu_name, &lulu->netid, sizeof(struct sna_netid));
+	memcpy(&init->mode_name, &lulu->mode_name, SNA_RESOURCE_NAME_LEN);
+	sna_ss_process_init_signal(init);
+        return 0;
+}
+
+/* Determine whether or not session limits associated with a given (LU,
+ * mode name) pair are exceeded for the given state condition (FSM_STATUS for
+ * this session).
+ */
+static int sna_sm_lu_mode_session_limit_exceeded(struct sna_netid *plu_name,
+        struct sna_mode_cb *mode, int polarity, int state)
+{
+#ifdef NOT
+        if (state == SNA_SESSION_ACTIVE) {
+                bidder.sessions = sna_active_bid_sessions(mode); 
+                fsp.sessions    = sna_active_fsp_sessions(mode); 
+        } else {
+                if (state == SNA_SESSION_AT_LEAST_BIND_SENT) {
+                        bidder.sessions = sna_sent_bid_sessions(mode); 
+                        fsp.sessions    = sna_sent_fsp_sessions(mode); 
+                } else {
+                        bidder.sessions = sna_init_bid_sessions(mode);
+                        fsp.sessions    = sna_init_fsp_sessions(mode);
+                }
+        }
+
+        total_limit     = mode->session_limit;
+        fsp_limit       = mode->min_conwinners_limit;
+        bidder_limit    = mode->min_conlosers_limit;
+
+        if (fsp.sessions + bidder.sessions > total_limit)
+                return 1;
+
+        if (fsp.sessions > total_limit - bidder_limit
+                && session_type == FIRST_SPEAKER
+                && plu->parallel == TRUE)
+                return 1;
+
+        if (bidder.sessions > total_limit - fsp_limit
+                && session_type == BIDDER)
+                return 1;
+#endif
+        return 0;
+}
+
+static int sna_sm_build_and_send_act_sess_rsp_neg(int correlator, int retry)
+{
+	return 0;
+}
+
+/* Get the fully-qualified procedure correlation identifier (FQPCID) from the
+ * session services (SS) component of the control point. Repeat requests if
+ * a duplicate FQPCID was received. An FQPCID is considered duplicate if its
+ * PCID matches that for another active or pending-active session at this LU.
+ */
+static int sna_sm_get_fqpcid(struct sna_lulu_cb *lulu)
+{
+	struct sna_assign_pcid *pcid;
+
+	sna_debug(5, "init\n");
+	new(pcid, GFP_ATOMIC);
+	if (!pcid)
+		return -ENOMEM;
+	pcid->sm_proc_id	= lulu->proc_id;
+        pcid->duplicate_pcid	= 0;
+	sna_ss_assign_pcid(pcid);
+	while (sna_sm_find_lulu_fqpcid(pcid->fqpcid) != NULL) {
+		pcid->duplicate_pcid = 1;
+		sna_ss_assign_pcid(pcid);
+	}
+	memcpy(&lulu->fqpcid, &pcid->fqpcid, 8);
+	kfree(pcid);
+        return 0;
+}
+
+/* Process an ACTIVATE_SESSION record received from RM. That includes checking
+ * for a session limit to be exceeded (since RM does not know whether the
+ * session limit is exceeded when it sends ACTIVATE_SESSION to SM), creating
+ * and initializing of the LULU_CB control block, getting an FQPCID for the
+ * session from SS, and sending an INIT_SIGNAL record to SS.
+ */
+int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as)
+{
+        struct sna_plu_cb *plu;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "init\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+        if (!plu)
+        	return -ENOENT;
+        mode = sna_rm_find_mode(as->mode_name);
+        if (!mode)
+                return -ENOENT;
+
+        if (sna_sm_lu_mode_session_limit_exceeded(&as->plu_netid, mode, 
+		as->polarity, SNA_SESSION_AT_LEAST_INIT_SENT))
+                sna_sm_build_and_send_act_sess_rsp_neg(as->correlator, 
+			SNA_ACT_SESS_RETRY);
+        else {
+		struct sna_lulu_cb *lulu;
+		new(lulu, GFP_ATOMIC);
+		if (!lulu)
+			return -ENOMEM;
+                sna_sm_get_fqpcid(lulu);
+                sna_sm_init_lulu_cb_act_sess(as, lulu);
+
+		sna_sm_build_and_send_init_sig(lulu);
+        }
+        return 0;
+}
+
+#ifdef CONFIG_SM
+/* LU session manager (SM) is responsible for creating the RM process and for
+ * activating and deactivating sessions between this LU and another LU. There
+ * is one SM process per LU in the node, and it is created and destroyed when
+ * the LU is created and destroyed. SM receives records from the resource
+ * manager (RM), the half-session (HS), the address space manager (ASM), and
+ * the session services (SS) processes. When the records are received, they
+ * are routed to the appropriate procedures when they are processed. SM uses
+ * process data (called LOCAL) that can be accessed by any procedure in the
+ * SM process.
+ */
+static int sna_sm_create(unsigned char *data)
+{
+	struct sna_local *local;
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_lulu_cb *lulu_cb;
+	struct sna_rm_create_parms *rm_create_parms;
+	struct sna_rm_created *rm_created;
+	struct sna_sm_create_parms *sm_create_parms;
+
+	/* Creation time logic... need to seperate */
+	sm_create_parms = (struct sna_sm_create_parms *)data;
+	new(rm_create_parms, GFP_ATOMIC);
+	rm_create_parms->lucb_list_ptr = sm_create_parms->lucb_list_ptr;
+	rm_create_parms->lu_id = sm_create_parms->lu_id;
+	err = sna_rm_init(rm_create_parms);
+	if(err >= 0)
+	{
+		new(rm_created, GFP_ATOMIC);
+		rm_created->lu_id = sm_create_parms->lu_id;
+		sent_to_nof(rm_created); /* OhOh troubles abrew */
+	}
+	else
+		sna_sm_abend();
+
+	err = bm(CREATE_BUF_POOL, permanent, MAX_RU, 5);
+	if(err < 0)
+		sna_sm_abend();
+
+	/* Runtime stuff... should be here */
+	while(SM_exists)	/* This will not loop, but be always called */
+	{
+		local->sense = 0x00000000;
+		switch(data_from)
+		{
+			case (RM):
+				sna_process_record_from_rm(rm_to_sm_record);
+				break;
+
+			case (HS):
+				sna_process_record_from_hs(hs_to_sm_record);
+				break;
+
+			case (ASM):
+				sna_process_record_from_asm(asm_to_sm_record);
+				break;
+
+			case (SS):
+				sna_process_record_from_ss(ss_to_sm_record);
+				break;
+
+			default:
+				sna_debug(5, "unknown record\n");
+				toss_record();
+		}
+	}
+
+	return (0);
+}
+
+/* Route records received from RM to appropriate procedures. */
+static int sna_process_record_from_rm(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (ACTIVATE_SESSION):
+			sna_process_activate_session(activate_session);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_process_deactivation_session(deactivate_session);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Route records received from the half-session (HS) process to the
+ * appropriate procedures.
+ */
+static int sna_process_record_from_hs(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (INIT_HS_RSP):
+			sna_process_init_hs_rsp(init_hs_rsp);
+			break;
+
+		case (ABORT_HS):
+			sna_process_abort_hs(abort_hs);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Determine if there is a state error on receipt of a BIND. */
+static int sna_bind_rq_state_err(struct sna_mu *mu)
+{
+	struct sna_parnter_lu *plu;
+	struct sna_mode *mode;
+	struct sna_bind_ru *bind_ru;
+	struct sna_lucb *lucb;
+	struct sna_local *local;
+
+	plu = search_plu(mu->plu_name);
+	if(plu != NULL)
+	{
+		local->sense = (0x0835 | offset_to_plu_name);
+		return (TRUE);
+	}
+
+	if(plu->lu_name != lucb->lu_name)
+	{
+		local->sense = 0x083B0001;
+		return (TRUE);
+	}
+
+	if(lucb->security_select != plu->security_select)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	mode = search_mode(mu->mode_name);
+	if(mode == NULL)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(plu->parallel != TRUE && mode->min_conwinners == 1)
+		local->session_type = FIRST_SPEAKER;
+	else /* Use value in bind */
+	{
+		if(mu->first_speaker == TRUE)
+			local->session_type = FIRST_SPEAKER;
+		else
+			local->session_type = BIDDER;
+	}
+
+	limit = sna_bind_session_limit_exceeded(plu->fqlu_name, mode, local->session_type);
+	if(limit == EXCEEDED)
+		return (TRUE);
+
+	if(plu->parallel != TRUE && another_pending_req() == TRUE)
+	{
+		/* Bind winner is the one with the longer LU name ;) */
+	}
+
+	/*
+	 * Consistency checks on PS usage fields
+	 */
+
+	err = check_sync_levels(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_parallel_level(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_cnos();
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_conv_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	err = check_verif_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(mu->bind.conv_secure == FALSE && mu->bind.alverified == TRUE)
+	{
+		local->sense = 0x0835001A;
+		return (TRUE);
+	}
+
+	if(mu->bind.crypto == TRUE && mu->bind.cryptopts == NULL)
+	{
+		local->sense = 0x08480000;
+		return (TRUE);
+	}
+
+	/*
+	 * One whole If-Else pair here
+	 */
+
+	err = check_session_id();
+	if(err < 0)
+	{
+		local->sense = 0x08520001;
+		return (TRUE);
+	}
+
+	if(plu->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->seg_reassm != TRUE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002B;
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/* Perform state error checking on a received +RSP(BIND). */
+static int sna_bind_rsp_state_err(struct sna_mu *mu, struct sna_lu_lu_cb *lulucb)
+{
+	struct sna_local *local;
+	struct sna_partner_lu *plu;
+	struct sna_bind_ru *bind_ru;
+	struct sna_mode *mode;
+
+	/* Pacing and Max. RU size checks */
+	if(bind->pace != rsp->pace)
+	{
+		local->sense = 0x08350008 or 0x0835000C;
+		return (TRUE);
+	}
+
+	if(rsp->adaptive_pace != TRUE)
+	{
+		if(rsp->second.send_window != bind->second.send_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		/* 0 is infinately large */
+		if(rsp->second.recv_window > bind->second.recv_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		if(rsp->primary.send_window > bind->primary.send_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+
+		if(rsp->primary.recv_window != bind->primary.recv_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+	}
+
+	/* Determine if within bounds for send/recv wins */
+	err = check_ru_bounds();
+	if(err < 0)
+	{
+		if(secondary_out_bounds)
+			local->sense = 0x0835000A;
+		else
+			local->sense = 0x0835000B;
+
+		return (TRUE);
+	}
+
+	/* PS usage checks */
+	if(other_active_sessions(plu) && conv_security != plu->conv_security)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && alrdy_verified != plu->alrdy_verified)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && sync != plu->sync)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+	else
+	{
+		if(rsp->sync == (CONFIRM|SYNCPOINT|BACKOUT)
+			&& bind->sync == (CONFIRM))
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel != TRUE)
+	{
+		if(rsp->sess_reinit == NONOPCTRL
+			&& bind->sess_reinit == OPCTRL)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == SECONDARY
+			&& bind->sess_reinit == PRIMARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == PRIMARY
+			&& bind->sess_reinit == SECONDARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel_opts != bind->parallel_opts
+		&& rsp->chg_sess != bind->chg_sess)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+
+	/* Contention winner checks */
+	if(rsp->parallel == TRUE)
+	{
+		if(rsp->contention_winner != bind->contention_winner)
+		{
+			local->sense = 0x08035007;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(rsp->contention_winner == PRIMARY
+			&& bind->contention_winner == SECONDARY)
+		{
+			local->sense = 0x08350007;
+			return (TRUE);
+		}
+	}
+
+
+	if(rsp->contention_winner == PRIMARY)
+		local->session_type = FIRST_SPEAKER;
+	else
+		local->session_type = BIDDER;
+
+	limit = sna_mode_session_limit_exceeded(plu->fqlu_name, mode, local->session_type, active);
+	if(limit == EXCEEDED)
+	{
+		return(TRUE);
+	}
+
+	/* Crypto checks */
+	if(rsp->cryptopts != bind->cryptopts)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	/* User data subfield checks */
+	if(rsp->mode_name != bind->mode->name)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(lulu_cb->random != NULL)
+	{
+		if(rsp->security == NULL || is_incorrect)
+		{
+			local->sense = 0x080F6051;
+			return (TRUE);
+		}
+	}
+
+	/* User data subfield - session_id checks */
+	if(rsp->session_id != 0x02)
+	{
+		if(rsp->session_id != 0x00 || rsp->session_id != 0xF0
+			|| rsp->session_id != bind->session_id)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(plu->fq_pcid != TRUE)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->session_id != NULL)
+	{
+		if(rsp->sessiond_id == 0x02)
+			lulu_cb->session_id = fq_pcid->pcid;
+		else
+			lulu_cb->session_id = rsp->session_id;
+
+		if(sna_id_unique(SESSION, lulu_cb->session_id) < 0)
+		{
+			local->sense = 0x8520001;
+			return (TRUE);
+		}
+	}
+
+	/* URC Checks */
+	if(rsp->urc != bind->urc)
+		return (TRUE);
+
+	return (FALSE);
+}
+
+/* Betermine whether or not session limits are exceeded for a received BIND. */
+static int sna_bind_session_limit_exceeded(unsigned char *plu_fqlu_name, 
+	struct sna_mode *mode, int type)
+{
+	struct sna_local *local;
+
+	if(mode->cnos_negotiation_in_progress == TRUE
+		&& prop_slimit > curr_slimit)
+	{
+		if(mode->active.sessions ? proposed.slimit)
+		{
+			local->sense = 0x08050000;
+			return (TRUE);
+		}
+		else
+		{
+			if((mode->active.sessions + mode->pending.sessions)
+				? proposed.slimit)
+			{
+				local->sense = 0x08050000;
+				return (TRUE);
+			}
+		}
+	}
+	else
+	{
+		limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, ACTIVE);
+		if(limit == EXCEEDED)
+		{
+			local->rcode = TRUE;
+		}
+		else
+		{
+			limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, AT_LEAST_BIND_SENT);
+			if(limit == EXCEEDED)
+				local->check_winner_flag = TRUE;
+		}
+	}
+
+	/* Check for BIND race conditions */
+	if(local->check_winner_flag == TRUE)
+	{
+		/* Fake for now */
+		if(session->lu_name > plu_fq_lu_name)
+			local->rcode = TRUE;
+		else
+		{
+			local->sense = 0x00000000;
+			local->rcode = FALSE;
+		}
+	}
+
+	return (local->rcode);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (negative) to RM. */
+static int sna_build_and_send_act_sess_rsp_neg(__u8 correlator, int err)
+{
+	struct sna_activate_session_rsp *act_rsp;
+
+	new(act_rsp, GFP_ATOMIC);
+	act_rsp->correlator = correlator;
+	act_rsp->type = NEG;
+	act_rsp->err_type = err;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (positive) to RM. This completes
+ * (from the SM's standpoint) the session initiation activity triggered by
+ * the ACTIVATE_SESSION record received by SM from RM.
+ */
+static int sna_build_and_send_act_sess_rsp_pos(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_actiavte_session_rsp *act_rsp;
+
+	new(act_rsp, GFP_ATOMIC);
+	act_rsp->correlator = lulu_cb->correlator;
+	act_rsp->type = POS;
+
+	act_rsp->session_information.hs_id = lulu_cb->hs_id;
+	act_rsp->session_information.hs_type = PRI;
+	act_rsp->session_information.bracket_type = lulu_cb->session_type;
+
+	act_rsp->session_information.send_ru_size = neg_max_send_ru_size;
+	act_rsp->session_information.perm_buf_pool_id = perm_buf_pool_id;
+	act_rsp->session_information.limit_buf_pool_id = limit_buf_pool_id;
+
+	act_rsp->session_informtaion.session_id = lulu_cb->session_id;
+
+	act_rsp->session_information.random_data = lulu_cb->random_data;
+	act_rsp->session_information.limit_resource = lulu_cb->limit_resource;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send a -RSP(BIND). */
+static int sna_build_and_send_bind_rsp_neg(unsigned char *buf)
+{
+	struct sna_mu *mu;
+
+	mu->header_type = BIND_RSP_SEND;
+	mu->bind_rsp_send.sender.id = lu_id;
+	mu->bind_rsp_send.sener.type = SM;
+	mu->bind_rsp_send.lfsid = bind->lfsid;
+	mu->bind_rsp_send.pc_id = bind->pc_id;
+	mu->bind_rsp_send.tx_priority = LOW;
+	mu->bind_rsp_send.free_lfsid = YES;
+	mu->bind_rsp_send.hs_id = NULL;
+
+	/* Set TH and RH fields to default 3.5.9 SNA formats */
+
+	/* Set RU */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a FREE_LFSID record to the control point. This is
+ * necessary when SM asked ASM to give SM an LFSID for a session, and SM
+ * received ASSIGN_LFSID_RSP, but could not send a BIND (because, for
+ * example, SM cannot get a buffer for it). In this case, SM explicity asks
+ * ASM to free the LFSID by sending the FREE_LFSID record to it. If SM sends
+ * a BIND successfully, it later sends an UNBIND or a RSP(UNBIND) to ASM
+ * and sets the FREE_LFSID variable to YES in them.
+ */
+static int sna_build_and_send_free_lfsid(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_free_lfsid *free_lfsid;
+
+	new(free_lfsid, GFP_ATOMIC);
+	if (!free_lfsid)
+		return -ENOMEM;
+	free_lfsid->pc_id = lulu_cb->pc_id;
+	free_lfsid->lfsid = lulu_cb->lfsid;
+
+	send_to_asm(free_lfsid);
+
+	return (0);
+}
+
+/* Build an INIT_HS (Initialize Half-Session) record and send it to the
+ * half-session designated by the passed LULU_CB.
+ */
+static int sna_build_and_send_init_hs(struct sna_lulu_cb *lulu_cb, 
+	unsigned char *bind_image)
+{
+	struct sna_local *local;
+	struct sna_init_hs *init_hs;
+
+	new(init_hs, GFP_ATOMIC);
+	if (!init_hs)
+		return -ENOMEM;
+	init_hs->pc_id	= lulu_cb->pc_id;
+	init_hs->lfsid			= lulu_cb->lfsid;
+	init_hs->hs_type		= lulu_cb->hs_type;
+	init_hs->dynamic_pool_id	= lulu_cb->dynamic_pool_id;
+	init_hs->dem_lim_pool_id	= lulu_cb->dem_lim_pool_id;
+	init_hs->tx_priority		= lulu_cb->tx_priority;
+	init_hs->short_bind_image	= bind_image;
+
+	if(lulu_cb->adaptive_pace == TRUE)
+	{
+		init_hs->short_bind_image.sec_send_window_size 	= 1;
+		init_hs->short_bind_image.pri_send_window_size 	= 1;
+		init_hs->short_bind_image.sec_rcv_window_size	= 1;
+		init_hs->short_bind_image.pri_rcv_window_size	= 1;
+	}
+
+	err = send_to_hs(init_hs);
+	if(err == ABEND)
+	{
+		destroy(init_hs);
+		local->sense = 0x0812000D;
+	}
+
+	return (0);
+}
+
+/* Build and send a PC_HS_DISCONNECT record to ASM. This is done only after
+ * a PLU receives a -RSP(BIND). If, instead, SM receives an UNBIND, it sends
+ * a RSP(UNBIND), asking ASM to free LFSID, thus disconnecting PC and HS.
+ */
+static int sna_build_and_send_pc_hs_disconnect(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->cmd 	= SNA_PC_HS_DISCONNECT;
+	msg->pc_id	= lulu_cb->pc_id;
+	msg->lfsid	= lulu_cb->lfsid;
+
+	sna_asm(msg);
+
+	return (0);
+}
+
+/* Build and send SESSION_ACTIVATED to RM to indicate that a new session
+ * has become active and to give RM the information about this session.
+ */
+static int sna_build_and_send_sess_activated(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_session_activated *activated;
+
+	new(activated, GFP_ATOMIC);
+
+	activated->session_information.hs_id = lulu_cb->hs_id;
+	activated->session_information.hs_type = SEC;
+	activated->session_information.bracket_type = lulu_cb->session_type;
+
+	activated->session_information.send_ru_size = neg_max_send_ru_size;
+	activated->session_information.perm_buf_pool_id = lulu_cb->perm_pool_id;
+	actiavted->session_information.limit_buf_pool_id = lulu_cb->dem_lim_pool_id;
+	activated->session_information.session_id = lulu_cb->session_id;
+
+	/* Send to RM for FMH-12 info */
+
+	activated->session_information.random_data = lulu_cb->random;
+	activated->lu_name = lulu_cb->local_partner_lu_name;
+	activated->mode_name = lulu_cb->mode_name;
+	activated->session_information.limit_resource = lulu_cb->limit_resource;
+
+	err = send_to_rm(activated);
+	if(err < 0)
+		destroy(activated);
+
+	return (0);
+}
+
+/* Build and send SESSION_DEACTIVATED to RM to indicate that an active session
+ * has been deactivated.
+ */
+static int sna_build_and_send_sess_deactivated(__u8 hs_id, __u8 reason, 
+	__u8 sense)
+{
+	struct sna_session_deactivated *deactivated;
+
+	new(deactivated, GFP_ATOMIC);
+	deactivated->hs_id 	= hs_id;
+	deactivated->reason 	= reason;
+	if(reason != NORMAL)
+		deactivated->sense = sense;
+
+	err = send_to_rm(deactivated);
+	if(err < 0)
+		destroy(deactivated);
+
+	return (0);
+}
+
+/* Build and send a SESSEND_SIGNAL record to the control point. This record
+ * can be sent by both PLU and SLU when the session is brought down. The PLU
+ * sends it, however, only if it has previously received a CINIT_SIGNAL
+ * record. The SLU sends it only if it has already sent a SESSST_SIGNAL
+ * record to SS.
+ */
+static int sna_build_and_send_sessend_sig(struct sna_lulu_cb *lulu_cb, 
+	__u8 sense)
+{
+	struct sna_sessend_signal *sessend_signal;
+
+	new(sessend_signal, GFP_ATOMIC);
+
+	sessend_signal->sense = sense;
+	sessend_signal->fqpcid = lulu_cb->fqpcid;
+	sessend_signal->pc_id = lulu_cb->pc_id;
+
+	send_to_ss(sessend_signal);
+
+	return (0);
+}
+
+/* Build and send a SESSST_SIGNAL record to the control point. This record is
+ * sent by the SLU when it receives the INIT_HS_RSP record from the half-session
+ * process. The PLU does not need to send it, since its local SS sends a
+ * CINIT_SIGNAL to SM and assumes that the session will be activated.
+ */
+static int sna_build_and_send_sessst_sig(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_sessst_signal *sessst_signal;
+
+	new(sesst_signal, GFP_ATOMIC);
+
+	sessst_signal->pc_id = lulu_cd->pc_id;
+
+	send_to_ss(sessst_signal);
+
+	return (0);
+}
+
+/* Build and send an UNBIND. */
+static int sna_build_and_send_unbind_rq(unsigned char *buf, __u8 cleanup, 
+	__u8 sense)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	mu->header_type = UNBIND_RQ_SEND;
+	mu->unbind_rq_send.sender.id = local->lu_id;
+	mu->unbind_rq_send.sender.type = SM;
+	mu->unbind_rq_send.lfsid = lulu_cb->lfsid;
+	mu->unbind_rq_send.pc_id = lulu_cd->pc_id;
+	mu->unbind_rq_send.tx_priority = lulu_cd->tx_priority;
+	mu->unbind_rq_send.free_lfsid = YES;
+	mu->unbind_rq_send.hs_id = lulu_cd->hs_id;
+
+	/* Set TH and RH fields to default */
+
+	/* Set RU of unbind mu to defaults, using sense and type passed */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a RSP(UNBIND). */
+static int sna_build_and_send_unbind_rsp(struct sna_mu *mu)
+{
+	struct sna_lu_lu_cb *lulu_cb
+	struct sna_mu *mu_new;
+	int unbind_type;
+
+	if(determine_how_unbind_was_recieved() == EXR || length_err)
+		unbind_type = NEG;
+	else
+		unbind_type = POS;
+
+	mu_new = bm(GET_BUFFER, demand, size, no_wait);
+	if(mu != NULL)
+	{
+		mu_new->header_type = UNBIND_RSP_SEND;
+		mu_new->unbind_rsp_send.lu_id = lulu_cb->lu_id;
+		mu_new->unbind_rsp_send.sender.type = SM;
+
+		if(unbind correlated to a specific session)
+		{
+			mu_new->unbind_rsp_send.hs_id = lulu_cb->hs_id;
+			mu_new->unbind_rsp_send.tx_priority = lulu_cb->tx_priority;
+		}
+		else
+		{
+			mu_new->unbind_rsp_send.hs_id = NULL;
+			mu_new->unbind_rsp_send.tx_priority = LOW;
+		}
+
+		mu_new->unbind_rsp_send.free_lfsid = YES;
+		mu_new->pc_id = mu->pc_id;
+		mu_new->lfsid = mu->lfsid;
+		mu_new->th.snf = mu->th.snf;
+
+		/* Set TH and RH to defaults */
+
+		if(type == POS)
+			mu_new->ru.type = POS;
+		else
+			mu_new->ru.type = NEG;
+
+		mu->dcf = (RH->size + RU->size);
+
+		send_to_asm(mu);
+	}
+	else
+		/* IBM.. Duh do nothing */
+
+	return (0);
+}
+
+/* Clean up LU-LU session. */
+static int sna_cleanup_lu_lu_session(struct sna_lu_lu_cb *lulu_cb)
+{
+	if(sesst_signal was sent || cinit_signal was recieved)
+		sna_build_and_send_sessend_sig(lulu_cb);
+
+	sna_unreserve_buffers(lulu_cb);
+	hs = sna_hs_unlink(lulu_cb->hs_id);
+	sna_hs_destroy(hs);
+
+	random = sna_random_unlink(lulu_cb->random);
+	sna_random_destroy(random);
+
+	lulu_cb = sna_lulu_cb_unlink(lulu_cb);
+	sna_lulu_cb_destroy(lulu_cb);
+
+	return (0);
+}
+
+/* Check if the received RSP(BIND) correlates with a previously sent BIND. */
+static int sna_correlate_bind_rsp(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Check if the received RSP(UNBIND) correlates with a know session. */
+static int sna_correlate_unbind_rq(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of receiving a BIND.
+ */
+static int init_lulu_cd_bind(struct sna_mu *mu, struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_partner_lu *plu;
+	struct sna_local *local;
+
+	plu = search_plu(mu->bind_ru.plu_name);
+	lulu_cb->local_partner_lu_name = plu->local_lu_name;
+	lulu_cb->fq_partner_lu_name = local->user_data.pluname.name;
+	lulu_cb->mode_name = mu->bind_ru.mode_name;
+	lulu_cb->hs_type = SEC;
+
+	if(plu->parallel != TRUE && mode->min_conwinners_limit == 1)
+		lulu_cb->session_type = FIRST_SPEAKER;
+	else
+	{
+		if(bind->secondary == CONWINNER)
+			lulu_cb->session_type = FIRST_SPEAKER;
+		else
+			lulu_cb->session_type = BIDDER;
+	}
+
+	lulu_cb->pc_id = mu->bind_ru.pc_id;
+	lulu_cb->pc_characteristics = mu->bind_ru.pc_characteristics;
+	lulu_cb->lfsid = mu->bind_ru.lfsid;
+
+	if(mu->bind_ru.cos != NULL)
+		lulu_cb->tx_priority = mu->bind_ru.cos.tx_priority;
+
+	if(mu->bind_ru.fqpcid != NULL)
+		lulu_cb->fqpcid = mu->bind_ru.fqpcid;
+	else
+		lulu_cb->fqpcid = sna_get_fqpcid(lulu_cb);
+
+	return (0);
+}
+
+/* Process an abend notification record from a child process (RM or HS). */
+static int sna_process_abend_notification(struct sna_abend_notification *abend)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	switch(abend->abend_process)
+	{
+		case (RM_PROCESS_VARIABLE):
+			for(lu = local->lulu_cb_list; lu != NULL; lu = lu->next)
+			{
+				fsm_status(abend, lulu_cb);
+			}
+			break;
+
+		case (HS_PROCESS_VARIABLE):
+			lu = search_lulu_cb(abend->hs_id);
+			if(lu != NULL)
+				fsm_status(abend, lulu_cb);
+			break;
+
+		default:
+			sna_debug(5, "unknown\n");
+	}
+
+	return (0);
+}
+
+/* Process an ABORT_HS record received from LU-LU half-session. */
+static int sna_process_abort_hs(struct sna_abort_hs *abort_hs)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(local->hs_id);
+	if(lulu_cb != NULL)
+		fsm_status(abort_hs, lulu_cb);
+
+	return (0);
+}
+
+/* Process a DEACTIVATION_SESSION record received from RM. */
+static int sna_process_deactivation_session(struct sna_deactivate_session *deactivate)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	if(deactivate->status == PENDING)
+		lulu_cb = search_lulu_cb(deactivate->correlator);
+	else
+		lulu_cb = search_lulu_cb(deactivate->hs_id);
+
+	if(lulu_cb)
+		fsm_status(deactivate, lulu_cb);
+
+	return (0);
+}
+
+/* Process an INIT_HS_RSP record received from a half-session. */
+static int sna_process_init_hs_rsp(struct sna_init_hs_rsp *init_hs_rsp)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(init_hs_rsp->hs_id);
+	if(lulu_cb)
+		fsm_status(init_hs_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received INIT_SIGNAL_NEG_RSP record from the SS component of
+ * the control point.
+ */
+static int sna_process_init_signal_neg_rsp(struct sna_init_signal_neg_rsp *init_signal_neg_rsp)
+{
+	struct sna_init_signal *init_signal;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	init_signal = search_init_signal(init_signal_neg_rsp);
+	lulu_cb = search_lulu_cb(init_signal_neg_rsp->fqpcid);
+
+	if(init_signal && lulu_cb)
+		fsm_status(init_signal_neg_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received LFSID_IN_USE record. This record is sent to SM by ASM
+ * so that ASM will know whether a given (LFSID, PC_ID) pair is
+ * currently in use. ASM must know before it sends a BIND to an appropriate
+ * LU. If the pair is in use, ASM will hold the BIND in order to avoid
+ * certain race conditions.
+ */
+static int sna_process_lfsid_in_use(struct sna_lfsid_in_use *lfsid_in_use)
+{
+	struct sna_lfsid_in_use_rsp *lfsid_in_use_rsp;
+
+	/* find activate or pending session ?? */
+	
+	new(lfsid_in_use_rsp, GFP_ATOMIC);
+
+	lfsid_in_use_rsp->pc_id = lfsid_in_use->pc_id;
+	lfsid_in_use_rsp->lfsid = lfsid_in_use->lfsid;
+
+	if(sna_find_session(PEND_ACTIVE, lfsid, pc_id))
+		lfsid_in_use_rsp->answer = YES;
+	else
+		lfsid_in_use_rsp->answer = NO;
+
+	send_to_asm(lfsid_in_use_rsp);
+
+	return (0);
+}
+
+/* Process a SESSION_ROUTE_INOP record received from ASM. */
+static int sna_process_session_route_inop(struct sna_session_route_inop *inop)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	for(lulu_cb = lulu_cb_list; lulu_cb != NULL; lulu_cb = lulu_cb->next)
+	{
+		if(inop->pc_id != lulu_cb->pc_id)
+			continue;
+
+		fsm_status(inop, lulu_cb);
+	}
+
+	return (0);
+}
+
+/* Increment the size of the permanent buffer pool. Get a demand buffer for
+ * an UNBIND.
+ */
+static int sna_reserve_constant_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_local *local;
+
+	err = bm(ADJUST_BUF_POOL, lulu_cb->perm_buf_pool_id, 1);
+
+	if(more_buffs_avail())
+	{
+		lulu_cb->perm_pool_adjusted_up = YES;
+		bm(GET_BUFFER, demand, size, no_wait);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Reserve a dynamic buffer pool, and a limited buffer pool. */
+static int sna_reserve_variable_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+
+	if(bind_rsp_rcv->adaptive_pace == SUPPORTED)
+	{
+		err = bm(CREATE_BUF_POOL, vary_dynamic, lulu_cb->hs_id, capacity, size, num_bufs);
+		if(err > 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size, num_bufs);
+	}
+	else
+	{
+		err = bm(CREATE_BUF_POOL, fixed_dynamic, lulu_cb->hs_id, capacity, size);
+		if(err < 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Unreserve (ie. release previously reserved buffers) appropriate buffers
+ * for the session.
+ */
+static int sna_unreserve_buffers(struct sna_lu_lu_cb *lulu_cb, 
+	__u8 perm_buf_pool_id)
+{
+	int size;
+
+	size = size_of_perm_buf - activted_pool_size;
+
+	if(size)
+		bm(ADJUST_BUF_POOL, perm_buf_pool_id, size);
+
+	if(demand_buf_reserverd_unbind)
+		bm(FREE, unbind);
+
+	return (0);
+}
+
+static int sna_fsm_status()
+{
+
+	/* Finite State Machines are Pass 3 so hold on here */
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.18-clean/net/sna/sna_ss.c linux/net/sna/sna_ss.c
--- linux-2.4.18-clean/net/sna/sna_ss.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_ss.c	Sat Jun  8 15:53:24 2002
@@ -0,0 +1,469 @@
+/* sna_ss.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+
+static LIST_HEAD(ss_clients);
+
+struct sna_ss_pinfo *sna_ss_find(char *name)
+{
+        struct sna_ss_pinfo *ss;
+	struct list_head *le;
+	
+        sna_debug(5, "init\n");
+	list_for_each(le, &ss_clients) {
+		ss = list_entry(le, struct sna_ss_pinfo, list);
+                if (!strncmp(ss->netid.name, name, SNA_NODE_NAME_LEN))
+			return ss;
+	}
+	return NULL;
+}
+
+int sna_ss_shutdown(void)
+{
+	struct list_head *le, *se;
+        struct sna_ss_pinfo *ss;
+
+        sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &ss_clients) {
+		ss = list_entry(le, struct sna_ss_pinfo, list);
+		list_del(&ss->list);
+                kfree(ss);
+        }
+        return 0;
+}
+
+int sna_ss_create(struct sna_start_node *start)
+{
+	struct sna_ss_pinfo *ss;
+
+	sna_debug(5, "init: %s\n", start->netid.name);
+	ss = sna_ss_find(start->netid.name);
+	if (ss)
+		return -EEXIST;
+	new(ss, GFP_ATOMIC);
+	if (!ss)
+		return -ENOMEM;
+	memcpy(&ss->netid, &start->netid, sizeof(struct sna_netid));
+	list_add_tail(&ss->list, &ss_clients);
+	return 0;
+}
+
+int sna_ss_destroy(struct sna_delete_node *delete)
+{
+	struct list_head *le, *se;
+        struct sna_ss_pinfo *ss;
+
+        sna_debug(5, "init\n");
+	list_for_each_safe(le, se, &ss_clients) {
+		ss = list_entry(le, struct sna_ss_pinfo, list);
+                if (!strncmp(ss->netid.name, delete->netid.name, 8)) {
+			list_del(&ss->list);
+                        kfree(ss);
+                        return 0;
+                }
+        }
+        return -ENOENT;
+}
+
+int sna_ss_act_cp_cp_session(void)
+{
+	return 0;
+}
+
+int sna_ss_deact_cp_cp_session(void)
+{
+	return 0;
+}
+
+int sna_ss_act_control_sessions(void)
+{
+	return 0;
+}
+
+int sna_ss_deact_control_sessions(void)
+{
+	return 0;
+}
+
+int sna_ss_update_node_authorization(void)
+{
+	return 0;
+}
+
+int sna_ss_update_search_control_vectors(void)
+{
+	return 0;
+}
+
+int sna_ss_process_sesst_signal(void)
+{
+	return 0;
+}
+
+int sna_ss_process_sessend_signal(void)
+{
+	return 0;
+}
+
+int sna_ss_isr_init(void)
+{
+	return 0;
+}
+
+int sna_ss_isr_sessend(void)
+{
+	return 0;
+}
+
+static __u32 sna_pc_system_id  = 1;
+static unsigned long hash1, hash2;
+
+/*
+  Returns a string of 0 and 1 characters, representing the provided 64bit
+  number in binary.
+*/
+void rl_binary(unsigned char * number, unsigned char * result)
+{
+  	int curbyte;
+  	int resultidx;
+  	unsigned char curbit;
+
+  	resultidx = 63;
+  	result[64] = '\0';
+
+  	for (curbyte=0; curbyte < 8; curbyte++) {
+      		for (curbit = 0; curbit < 8; curbit++) {
+          		result[resultidx] = (number[curbyte] & (1<<curbit)) ? '1' : '0';
+          		resultidx--;
+        	}
+    	}
+	return;
+}
+
+/*
+  Subtracts two 64bit numbers.  The top value must be >= the bottom.
+ */
+void rl_sub(unsigned char *top, unsigned char *bottom)
+{
+  	unsigned int curbyte;
+  	int borrowed;
+  	int curtop;
+
+  	if (top[7] < bottom[7])
+      		return;
+  	borrowed = 0;
+  	for (curbyte = 0; curbyte < 8; curbyte++) {
+      		curtop = top[curbyte];
+
+      		if (borrowed) {
+          		if (curtop == 0) {
+              			curtop = 0xFF;
+              			borrowed = 1;
+            		} else {
+              			curtop = curtop--;
+              			borrowed = 0;
+            		}
+        	}
+
+      		if (curtop < bottom[curbyte]) {
+          		curtop = curtop + 0x100;
+          		borrowed = 1;
+        	}
+      		curtop = curtop - bottom[curbyte];
+      		top[curbyte] = curtop;
+    	}
+	return;
+}
+
+/*
+  Shifts the 64bit number one byte to the left.  Zero is inserted in the lsb.
+*/
+int rl_left(unsigned char *number)
+{
+        int carry;
+        unsigned char mask;
+        int curbyte;
+
+        if (number[7] & 0x80)
+                carry = 1;
+        else
+                carry = 0;
+
+        for (curbyte = 7; curbyte >= 0; curbyte--) {
+                if (curbyte > 0) {
+                        mask = (number[curbyte-1] & 0x80) ? 0x01 : 0x00;
+                        number[curbyte] = (number[curbyte] << 1) | mask;
+                } else
+                        number[curbyte] <<= 1;
+        }
+        return carry;
+}
+
+/*
+  Shifts the 64bit number one bit to the right.  Zero is inserted as the msb
+ */
+void rl_right(unsigned char * number)
+{
+  	unsigned char mask;
+  	int curbyte;
+
+  	for (curbyte = 0; curbyte < 8; curbyte++) {
+      		if (curbyte < 7) {
+          		mask = (number[curbyte+1] & 0x01) ? 0x80 : 0x00;
+          		number[curbyte] = (number[curbyte] >> 1) | mask;
+        	} else {
+          		number[curbyte] >>= 1;
+        	}
+    	}
+	return;
+}
+
+/*
+  Shifts the divisor to the left as necessary to align the most signifcant
+  bit with the msb of the dividend.
+ */
+void rl_align(unsigned char * dividend, unsigned char * divisor)
+{
+  	int maxbyte;
+  	int maxbit;
+
+  	for (maxbyte = 7; maxbyte >= 0; maxbyte--) {
+      		if (dividend[maxbyte] > 0)
+        		break;
+    	}
+  	for (maxbit = 8; maxbit >= 0; maxbit--) {
+      		if (dividend[maxbyte] & (1 << maxbit)) 
+          		break;
+    	}
+  	while (!(divisor[maxbyte] & (1 << maxbit)))
+    		rl_left(divisor);
+	return;
+}
+
+/*
+  Returns true if the dividend is greater than or equal to the divisor.
+ */
+int rl_lt(unsigned char * dividend, unsigned char * divisor)
+{
+  	int maxbyte;
+  	int curbyte;
+
+  	for (maxbyte = 7; maxbyte > 0; maxbyte--) {
+      		if ((dividend[maxbyte] != 0) || (divisor[maxbyte] != 0))
+          		break;
+    	}
+  	for (curbyte = maxbyte; curbyte > 0; curbyte--) {
+      		if (dividend[curbyte] == divisor[curbyte])
+          		continue;
+		else
+          		return dividend[curbyte] >= divisor[curbyte];
+        }
+  	return 0;
+}
+
+/*
+  Divides two 64 bit numbers.  The numbers need to be passed as 8 element
+  arrays of unsigned char.  The quotient is returned in quotient, and the
+  remainder is returned in dividend.  The divisor is shifted during the
+  division, so don't count on it having the same value after invocation.
+ */
+void rl_div(unsigned char * dividend, unsigned char * divisor,
+       unsigned char * quotient)
+{
+  	unsigned char tempdiv[8];
+  	int curbyte;
+
+  	memset(quotient, 0, 8);
+
+  	for (curbyte=0; curbyte < 8; curbyte++)
+      		tempdiv[curbyte] = divisor[curbyte];
+  	rl_align(dividend, divisor);
+
+  	do {
+    		if (rl_lt(dividend, divisor)) {
+        		rl_sub(dividend, divisor);
+        		rl_left(quotient);
+        		quotient[0] = quotient[0] | 0x01;
+      		} else {
+        		rl_left(quotient);
+      		}
+    		rl_right(divisor);
+  	} while (rl_lt(dividend, tempdiv));
+	return;
+}
+
+/* Generates a FQPCID in the and returns it in the correct order. */
+int sna_ss_generate_pcid(char *net, char *name)
+{
+        unsigned char prime1[8] = {0xC7,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00};
+        unsigned char prime2[8] = {0x1F,0x88,0x53,0x7E,0x00,0x00,0x00,0x00};
+        unsigned char pname[8], pnet[8], fname[8], fnet[8];
+        unsigned char quotient[8], dividend[8], dividend2[8];
+        unsigned long scratch1;
+        struct timeval time;
+        int i;
+
+        /* Dividend */
+        atoe_strncpy(pname, name, strlen(name));
+        for (i = strlen(name); i < 8; i++)
+                pname[i] = 0x40;
+        for (i = 0; i < 8; i++)          /* reverse order */
+                fname[i] = pname[7-i];
+        atoe_strncpy(pnet, net, strlen(net));
+        for (i = strlen(net); i < 8; i++)
+                pnet[i] = 0x40;
+        etor_strncpy(pnet, pnet, 8);
+        for (i = 0; i < 8; i++)          /* reverse order */
+                fnet[i] = pnet[7-i];
+        for (i = 0; i < 8; i++)
+                dividend[i] = fname[i] ^ fnet[i];
+        memcpy(dividend2, dividend, 8);
+
+        /* Hash 1 */
+        rl_div(dividend2, prime1, quotient);
+        memcpy(&hash1, dividend2, sizeof(unsigned long));
+        scratch1 = (hash1 ^ (unsigned short)hash1) << 2;
+        set_bit(16, &scratch1);
+        set_bit(17, &scratch1);
+        set_bit(30, &scratch1);
+        set_bit(31, &scratch1);
+        hash1 = (scratch1 | (unsigned short)hash1);
+        hash1 += htonl(sna_pc_system_id++);
+
+        sna_debug(5, "HASH1 - %04lX\n", hash1);
+
+        /* Hash 2 */
+        memcpy(dividend2, dividend, 8);
+        rl_div(dividend2, prime2, quotient);
+        memcpy(&hash2, dividend2, sizeof(unsigned long));
+
+        do_gettimeofday(&time);
+        hash2 += time.tv_sec;
+
+        sna_debug(5, "HASH2 - %04lX\n", hash2);
+
+        return 0;
+}
+
+int sna_ss_update_pcid(unsigned char *r)
+{
+        unsigned char result[8], scratch2[8];
+        unsigned long nhash1, nhash2;
+
+        hash2++;
+
+        /* Generate final pcid */
+        memcpy(scratch2, &hash1, 4);
+        memcpy(scratch2 + 4, &hash2, 4);
+        nhash1 = ntohl(hash1);
+        nhash2 = ntohl(hash2);
+        memcpy(result, &nhash1, 4);
+        memcpy(result + 4, &nhash2, 4);
+        strncpy(r, result, 8);
+        return 0;
+}
+
+int sna_ss_assign_pcid(struct sna_assign_pcid *pcid)
+{
+//	struct sna_lulu_cb *lulu;
+
+	sna_debug(5, "sna_ss_assign_pcid\n");
+/*
+	lulu = sna_sm_find_lulu(pcid->sm_proc_id);
+	if(!lulu)
+		return (-ENOENT);
+
+	sna_ss_generate_pcid(lulu->netid.net, lulu->netid.name);
+	sna_ss_update_pcid(pcid->fqpcid);
+*/
+	pcid->duplicate_pcid = 0;	/* reset */
+        return 0;
+}
+
+int sna_ss_process_init_signal(struct sna_init_signal *init)
+{
+	struct sna_cos_tpf_vector *cos;
+	struct sna_rq_single_hop_route *rt;
+	struct sna_activate_route *as;
+	struct sna_cinit_signal *cinit;
+	struct sna_netid *netid;	
+	int err = 0;
+
+	sna_debug(5, "init: %s %s\n",
+		sna_pr_netid(&init->plu_name), sna_pr_netid(&init->slu_name));
+
+	new(cos, GFP_ATOMIC);
+	if (!cos)
+		return -ENOMEM;
+	memcpy(&cos->mode_name, &init->mode_name, SNA_RESOURCE_NAME_LEN);
+	err = sna_cosm_cos_tpf_vector(cos);
+	if (err < 0)
+		return err;
+
+	new(rt, GFP_ATOMIC);
+	if (!rt)
+		return -ENOMEM;
+	memcpy(&rt->dst_cp_name, &init->plu_name, sizeof(struct sna_netid));
+	err = sna_rss_request_single_hop_route(rt);
+	if (err < 0)
+		return err;
+
+	new(as, GFP_ATOMIC);
+	if (!as)
+		return -ENOMEM;
+	as->tg_id = rt->rs.tg_desc.id.tg_number;
+	memcpy(&as->pc_id, &init->fqpcid, 8);
+	netid = sna_char_to_netid(rt->rs.tg_desc.id.pcp_name);
+//	memcpy(&as->cp_name, netid, sizeof(struct sna_netid));
+	memcpy(&as->cp_name, &init->slu_name, sizeof(struct sna_netid));
+	err = sna_cs_activate_route(as);		/* XID */
+	if (err < 0)
+		return err;
+
+	new(cinit, GFP_ATOMIC);
+	if (!cinit)
+		return -ENOMEM;
+	err = sna_sm_process_cinit_signal(cinit);	/* BIND */
+	if (err < 0)
+		return err;
+
+	kfree(cos);
+        kfree(rt);
+        kfree(as);
+	kfree(cinit);
+
+        return err;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_tc.c linux/net/sna/sna_tc.c
--- linux-2.4.18-clean/net/sna/sna_tc.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_tc.c	Fri Jun  7 09:32:12 2002
@@ -0,0 +1,798 @@
+/* sna_tc.c: Linux Systems Network Architecture implementation
+ * - SNA Transmission Control (TC)
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc_if.h>
+#include <net/llc_sap.h>
+#include <net/llc_pdu.h>
+#include <net/llc_conn.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+#include <linux/sna.h>
+
+int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	sna_debug(5, "sna_tc_rcv\n");
+	sna_dfc_rcv(skb);
+	return 0;
+}
+
+int sna_tc_send_mu(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_tc_send_mu\n");
+	kfree_skb(skb);
+
+#ifdef NOT
+	int i;
+
+	if (sna_debug_level > 5) {
+		sna_debug(5, "sna_tc_send_mu\n");
+		hexdump(skb->data, skb->len);
+		sna_debug(5, "Sizeof TH %d, RH %d, FMH %d\n", 
+			sizeof(struct sna_fid2), sizeof(struct snarhdr), 
+			sizeof(struct sna_fmh5)); 
+	}
+
+	skb = skb_unshare(skb, GFP_ATOMIC);
+	if (!skb)
+		return -1;
+
+	for(i = 0; i < 1000; i++)
+		schedule();
+	sna_tc_rcv(skb);
+#endif
+	return 0;
+}
+
+int sna_tc_init(void)
+{
+	return 0;
+}
+
+#if defined(CONFIG_SNA_HS) || defined(CONFIG_SNA_HS_MODULE)
+
+extern __u16 sys_snf_ids;
+
+/* Initialize the Transmission Control layer. */
+int sna_tc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+
+	if (init_hs->type == SNA_HS_PRI)
+		tcb->max_rcv_ru_size 
+			= init_hs->bind.sec_hs_max_ru_size_sent;
+	else
+		tcb->max_rcv_ru_size
+			= init_hs->bind.pri_hs_max_ru_size_sent;
+	tcb->sqn_rcv_cnt = 0;
+
+	tcb->ccb.caller			= SNA_HS;
+	tcb->ccb.lfsid			= init_hs->lfsid;
+	tcb->ccb.pc_id			= init_hs->pc_id;
+	tcb->ccb.perm_buf_pool_id	= init_hs->perm_buf_pool_id;
+	tcb->ccb.dynamic_buf_pool_id	= init_hs->dynamic_buf_pool_id;
+	tcb->ccb.limit_buf_pool_id	= init_hs->limit_buf_pool_id;
+	tcb->ccb.tx_priority 		= init_hs->tx_priority;
+	tcb->ccb.num_bufs_per_ru	= 1;
+	tcb->ccb.send_pacing.rlwi	= SNA_CCB_NO_RLW;
+	tcb->ccb.send_pacing.rpc	= 0;
+	tcb->ccb.receive_pacing.rpc	= 0;
+
+	if (init_hs->type == SNA_HS_PRI) {
+		tcb->ccb.send_pacing.nws	= init_hs->bind.pri_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.pri_rws;
+	} else {
+		tcb->ccb.send_pacing.nws 	= init_hs->bind.sec_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.sec_rws;
+	}
+
+	if (init_hs->bind.adapt_pace == SNA_RU_BIND_ADAPT_NO_SUPP)
+		tcb->ccb.send_pacing.type = SNA_PACING_TYPE_ADAPTIVE;
+	else {
+		tcb->ccb.receive_pacing.type = SNA_PACING_TYPE_FIXED;
+		if (tcb->ccb.send_pacing.nws > 0)
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_FIXED;
+		else
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_NONE;
+	}
+
+	tcb->ccb.send_pacing.first_ws = tcb->ccb.send_pacing.nws;
+	tcb->ccb.receive_pacing.unsolicited_ipm_outstanding	= 0;
+	tcb->ccb.receive_pacing.adjust_ipm_ack_outstanding	= 0;
+	tcb->ccb.receive_pacing.unsolicited_nws 		= 0;
+	tcb->ccb.reserve_flag 					= 0;
+
+	if (init_hs->bind.whole_biu)
+		tcb->segmenting_supported = 0;
+	else
+		tcb->segmenting_supported = 1;
+
+	tcb->crypto = 0;
+	if (init_hs->bind.crypto.sess_level_crypto == SNA_RU_CRYPTO_MANDATORY) {
+		tcb->crypto = 1;
+		sna_tc_exchange_crv(init_hs);
+	}
+
+	return 0;
+}
+
+/* Handle the exchange of the Cryptograhpy Verification (CRV) request. */
+static int sna_tc_exchange_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->pc_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+	struct sna_mu *mu = NULL;
+	int err;
+
+	if (init_hs->type == SNA_HS_PRI) {
+		mu = sna_tc_build_crv(init_hs);
+		local->tcb.ccb.caller = SNA_HS;
+		sna_send_mu(mu, &tcb->ccb);
+
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+
+		err = sna_tc_crv_format_chk(mu);
+		if (err == 0)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		sna_free_buffer(mu);
+	} else {
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+		err = sna_tc_crv_format_chk(mu);
+		if (err == 0) {
+			/* Check the crypto test values. */
+			if (err) {
+				local->sense = 0x08350001;
+				sna_free_buffer(mu);
+			} else {
+				local->sense = 0;
+				mu->biu->rh.rh.rsp_h.rri = SNA_RH_RRI_RSP;
+				mu->biu->rh.rh.rsp_h.rti = SNA_RH_RTI_POS;
+				local->tcb.ccb.caller = SNA_HS;
+				sna_send_mu(mu, &tcb->ccb);
+			}
+		}
+	}
+	return 0;
+}
+
+/* Build and MU (containing the CRV request) by appropriately initializing
+ * the TH, RH, and RU fields.
+ */
+static struct sna_mu *sna_tc_build_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_mu *mu = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu = sna_get_buffer(SNA_BM_TYPE_DEMAND, init_hs->dynamic_buf_pool_id, 
+		0, SNA_BM_NO_WAIT);
+
+	mu->biu->th.fid.fid0.efi 		= SNA_TH_EFI_EXP;
+	mu->biu->th.fid.fid0.snf.number 	= *(__u16 *)jiffies;
+	mu->biu->th.fid.fid0.mpf		= SNA_TH_MPF_WHOLE_BIU;
+
+	req_h->rri	= SNA_RH_RRI_REQ;
+	req_h->ru	= SNA_RH_RU_SC;
+	req_h->fi	= SNA_RH_FI_FMH;
+	req_h->sdi	= SNA_RH_SDI_NO_SD;
+	req_h->bci	= SNA_RH_BCI_BC;
+	req_h->eci	= SNA_RH_ECI_EC;
+	SNA_DFC_SET_RQD1(req_h);
+	req_h->rlwi	= SNA_RH_RLWI_NO_RLW;
+	req_h->qri	= SNA_RH_QRI_NO_QR;
+	req_h->pi	= SNA_RH_PI_NO_PAC;
+	req_h->bbi	= SNA_RH_BBI_NO_BB;
+	req_h->cdi	= SNA_RH_CDI_NO_CD;
+	req_h->csi	= SNA_RH_CSI_CODE0;
+	req_h->edi	= SNA_RH_EDI_NO_ED;
+	req_h->pdi	= SNA_RH_PDI_NO_PD;
+	req_h->cebi	= SNA_RH_CEBI_NO_CEB;
+
+	/* More crypto stuff.. */
+
+	return mu;
+}
+
+/* Check the RH bits of the CRV request or RSP(CRV) received from path_control
+ * (from the partner half_session).
+ */
+static int sna_tc_crv_format_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int length;
+
+	/* Calculate the length of the RU data. */
+	length = 0;
+
+	if (req_h->rri == SNA_RH_RRI_REQ) {
+		if (local->half_session == SNA_HS_PRI)
+			local->sense = 0x20090000;
+		if (req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if ((req_h->sdi == SNA_RH_SDI_NO_SD && length < 1)
+			|| (req_h->sdi == SNA_RH_SDI_SD && length < 5))
+			local->sense = 0x10020000;
+		if ((req_h->sdi == SNA_RH_SDI_NO_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if (req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+
+		if (req_h->sdi == SNA_RH_SDI_SD)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		if (req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if (req_h->eci == SNA_RH_ECI_NO_EC)
+	 		local->sense = 0x400B0000;
+		if (SNA_DFC_RQD1(req_h))
+			local->sense = 0x40140000;
+		if (th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if (req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if (req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+		if (req_h->bbi == SNA_RH_BBI_BB)
+			local->sense = 0x400C0000;
+		if (req_h->ebi == SNA_RH_EBI_EB)
+			local->sense = 0x400C0000;
+		if (req_h->cdi == SNA_RH_CDI_CD)
+			local->sense = 0x400D0000;
+		if (req_h->csi == SNA_RH_CSI_CODE1)
+			local->sense = 0x40100000;
+		if (req_h->edi == SNA_RH_EDI_ED)
+			local->sense = 0x40160000;
+		if (req_h->pdi == SNA_RH_PDI_PD)
+			local->sense = 0x40170000;
+		if (req_h->cebi == SNA_RH_CEBI_CEB)
+			local->sense = 0x400C0000;
+	} else {	/* CRV Response */
+		if (local->half_session == SNA_HS_SEC)
+			local->sense = 0x20090000;
+		if (req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if ((rsp_h->rti && length < 1) 
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && length < 5))
+			local->sense = 0x10020000;
+		if ((req_h->sdi != SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if (req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+		if (req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if (req_h->eci == SNA_RH_ECI_NO_EC)
+			local->sense = 0x400B0000;
+		if (th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if (req_h->dr1i != SNA_RH_DR1I_DR1 
+			|| req_h->dr2i == SNA_RH_DR2I_DR2)
+			local->sense = 0x40140000;
+		if ((rsp_h->rti == SNA_RH_RTI_POS && req_h->sdi == SNA_RH_SDI_SD)
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && req_h->sdi== SNA_RH_SDI_NO_SD))
+			local->sense = 0x40130000;
+		if (req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if (req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+	}
+	return 0;
+}
+
+/* Send the input MU to path control. */
+int sna_send_mu(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *rh = &mu->biu->rh.rh.req_h;
+	int err = 0;
+
+	if (th->efi == SNA_TH_EFI_EXP)
+		sna_send_to_pc(mu, cb);
+	if (th->mpf == SNA_TH_MPF_EBIU || rh->rri == SNA_RH_RRI_REQ) {
+		if (local->tcb.ccb.caller == SNA_HS) {
+			if (rh->ru == SNA_RH_RU_FMD) {
+				/* sna_pad_mu(mu); */
+				rh->pdi = SNA_RH_PDI_PD;
+			} else
+				rh->pdi = SNA_RH_PDI_NO_PD;
+
+			err = sna_des_encipher(mu);
+			if (err)
+				local->sense = 0x8480000;
+			else
+				local->sense = 0x0000000;
+		}
+
+		if (err)
+			sna_free_buffer(mu);
+		else {
+			rh->edi = SNA_RH_EDI_ED;
+			if (cb->send_pacing.type != SNA_PACING_TYPE_NONE) {
+				if (sna_hs_pacing_queue_empty 
+					|| (th->mpf == SNA_TH_MPF_BBIU
+					&& cb->send_pacing.rpc 
+					+ cb->send_pacing.nws == 0)) {
+					sna_hs_pacing_queue_tail(mu);
+				}
+			} else
+				sna_send_to_pc(mu, cb);
+		}
+	}
+
+	if (rh->rri == SNA_RH_RRI_RSP) {
+		if (cb->send_pacing.type == SNA_PACING_TYPE_NONE
+			|| sna_hs_pacing_queue_empty(mu) 
+			|| rh->qri == SNA_RH_QRI_NO_QR) {
+			sna_send_to_pc(mu, cb);
+		} else
+			sna_hs_pacing_queue_tail(mu);
+	}
+	return 0;
+}
+
+/* Update the send pacing counts in the common control block and set the
+ * pacing bits (rh->pi and rh->rlwi of the MU being sent) to the
+ * appropriate values.
+ */
+static int sna_send_pacing(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+
+	if (cb->send_pacing.rpc > 0)
+		cb->send_pacing.rpc--;
+	else {
+		cb->send_pacing.rpc		= cb->send_pacing.nws - 1;
+		cb->send_pacing.nws 		= 0;
+		mu->biu->rh.rh.req_h.pi		= SNA_RH_PI_PAC;
+		mu->biu->rh.rh.req_h.rlwi 	= cb->send_pacing.rlwi;
+		cb->send_pacing.rlwi		= SNA_CCB_NO_RLW;
+	}
+	return 0;
+}
+
+/* Send an MU to path control. */
+static int sna_send_to_pc(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_ipm_extension *ipm_ext = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_msg_queue *msg = NULL;
+	int err;
+
+	mu->header_type = SNA_MU_HS_TO_PC;
+	mu->layer.hs_to_pc.lfsid = cb->lfsid;
+	mu->layer.hs_to_pc.tx_priority = cb->tx_priority;
+
+	if (th->mpf == SNA_TH_MPF_BBIU) {
+		if ((req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC) 
+			|| req_h->dr1i == SNA_RH_DR1I_NO_DR1
+			|| (req_h->dr2i == SNA_RH_DR2I_NO_DR2 
+			&& cb->send_pacing.type == SNA_PACING_TYPE_ADAPTIVE)) {
+			if (ipm_ext->type != SNA_IPM_TYPE_RESET_ACK)
+				mu->layer.hs_to_pc.tx_priority 
+					= SNA_TP_NETWORK;
+		} else {
+			if (th->efi != SNA_TH_EFI_EXP && cb->send_pacing.type 
+				!= SNA_PACING_TYPE_NONE)
+				sna_send_pacing(mu);
+		}
+
+		msg->mu = mu;
+		err = sna_pc(msg);
+		if (err)
+			sna_free_buffer(mu);
+	}
+	return 0;
+}
+
+/* Receive an MU sent from path control. */
+int sna_tc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_mu *wmu;
+
+	sna_tc_segment_rcv_chk(mu);
+	if (local->sense != 0)
+		return -1;
+
+	if (th->efi == SNA_TH_EFI_NORM && th->mpf == SNA_TH_MPF_BBIU)
+		sna_rcv_pacing(mu, &local->tcb.ccb);
+	if (th->efi == SNA_TH_EFI_NORM) {
+		wmu = sna_segment_reassembly(mu);
+		if (local->sense == 0x00000000) {
+			if (wmu) {
+				sna_tc_biu_rcv_chk(mu);
+				if (local->sense == 0x00000000) {
+					if (th->efi == SNA_TH_EFI_NORM) {
+						if (req_h->edi == SNA_RH_EDI_ED
+							&& mu->biu->ru.ru.raw != NULL
+							&& req_h->ru == SNA_RH_RU_FMD) {
+							sna_tc_decipher_ru(mu);
+
+							if (local->sense == 0x00000000) {
+								/* Must wrap to 0 after 65535 */
+								local->sqn_rcv_cnt++;
+							}
+
+							sna_dfc_rcv(mu);
+						} else {
+							if (req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC) {
+								sna_rcv_pacing_rsp(mu, &local->tcb.ccb);
+								if (mu != NULL)
+									sna_dfc_rcv(mu);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* Perform receive checks on all segments received from PC. */
+static int sna_tc_segment_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if (local->segmenting_supported && th->mpf == SNA_TH_MPF_NO_BIU) {
+		local->sense = 0x80070001;
+	}
+	if (th->mpf == SNA_TH_MPF_BBIU) {
+		local->sense = 0x80070000;
+	}
+	if (SNA_DFC_RQD(req_h) 
+		|| (th->mpf == SNA_TH_MPF_BBIU && local->segmenting_supported)) {
+		local->sense = 0x80070000;
+	}
+	if (th->mpf == SNA_TH_MPF_EBIU && !local->segmenting_supported) {
+		local->sense = 0x80070000;
+	}
+	if ((th->mpf == SNA_TH_MPF_EBIU && th->mpf == SNA_TH_MPF_BBIU) 
+		!= th->mpf == SNA_TH_MPF_EBIU) {
+		local->sense = 0x80070000;
+	}
+	if (mu->dcf < 10) {
+		local->sense = 0x80070000;
+	}
+	if (th->mpf == SNA_TH_MPF_BBIU && local->sense == 0x00000000)
+		sna_mu_pacing_chk(mu);
+	return 0;
+}
+
+/* This procedure performs receive checks on BIUs. */
+static int sna_tc_biu_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u8 ru_len;
+
+	if (req_h->ru != SNA_RH_RU_FMD || req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x10070000;
+	else {
+		ru_len = 0;
+		if (req_h->sdi == SNA_RH_SDI_SD)
+			ru_len += 4;
+		if (req_h->ru == SNA_RH_RU_DFC)
+			ru_len += 1;
+		if (mu->dcf < ru_len + 3)
+			local->sense = 0x1002000;
+		else {
+			if (req_h->sdi == SNA_RH_SDI_SD) {
+					local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+			} else {
+				if (th->efi == SNA_TH_EFI_NORM) {
+					if (th->snf.number != local->sqn_rcv_cnt + 1)
+						local->sense = 0x2001000;
+					if (local->crypto) {
+						if (req_h->ru == SNA_RH_RU_FMD) {
+							if (mu->biu->ru.ru.raw != NULL
+								&& local->sense == 0x00000000) {
+								if (req_h->edi != SNA_RH_EDI_ED)
+									local->sense = 0x08090000;
+								else {
+									if (!(mu->dcf % 8))
+										local->sense = 0x10010000;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static int sna_mu_pacing_chk(struct sna_mu *mu)
+{
+	struct sna_ipm_extension *ipm_extension = NULL;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if (th->efi == SNA_TH_EFI_NORM) {
+		if (local->tcb.ccb.receive_pacing.rpc == 0) {
+			if (local->tcb.ccb.receive_pacing.nws == 0)
+				local->sense = 0x20110000;
+			else {
+				if (mu->biu->rh.rh.rsp_h.pi != SNA_RH_PI_PAC)
+					local->sense = 0x20110000;
+			}
+		} else {
+			if (mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC)
+				local->sense = 0x20110002;
+		}
+		return 0;
+	}
+
+	if (local->tcb.ccb.send_pacing.type == SNA_PACING_TYPE_ADAPTIVE 
+		&& mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC) {
+		if (SNA_IPM_FORMAT_0) {
+			if (mu->dcf < sizeof(struct sna_rh)
+				+ sizeof(struct sna_ipm_extension)) {
+				local->sense = 0x10020000;
+			} else {
+				if (ipm_extension->format_indicator
+					!= SNA_IPM_FORMAT_0) {
+					local->sense = 0x10010003;
+				}
+			}
+		} else {
+			switch (ipm_extension->type) {
+				case SNA_IPM_TYPE_SOLICITED:
+					if (ipm_extension->nws == 0
+						|| mu->biu->ru.ru.ipm.rwi == SNA_IPM_RWI_RESET_WINDOW) {
+						local->sense = 0x10010003;
+					} else {
+						if (local->tcb.ccb.send_pacing.nws > 0) {
+							local->sense = 0x20110001;
+						}
+					}
+					break;
+
+				case SNA_IPM_TYPE_UNSOLICITED:
+					if (ipm_extension->rwi != SNA_IPM_RWI_RESET_WINDOW)
+						local->sense = 0x10010003;
+					break;
+
+				case SNA_IPM_TYPE_RESET_ACK:
+					if (local->tcb.ccb.receive_pacing.unsolicited_ipm_outstanding)
+						local->sense = 0x20110001;
+					break;
+
+				default:
+					local->sense = 0x10010003;
+					break;
+			}
+		}
+	}
+
+	local->sense = 0x20110003;
+	return 0;
+}
+
+/* This procedure updates the receive pacing counts in the local->common_cb
+ * and determines the type of buffer reserve action to request of the BM.
+ * This procedure is never called when the reidual pacing count and the
+ * next-window size are both 0.
+ */
+static int sna_rcv_pacing(struct sna_mu *mu, 
+	struct sna_common_cb *common_cb)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if (req_h->pi != SNA_RH_PI_PAC) {
+		common_cb->receive_pacing.rpc++;
+		common_cb->reserve_flag = SNA_CCB_NO;
+	} else {
+		common_cb->receive_pacing.rpc = common_cb->receive_pacing.nws-1;
+		common_cb->receive_pacing.nws = 0;
+		if (req_h->rlwi == SNA_RH_RLWI_RLW)
+			common_cb->reserve_flag = SNA_CCB_MORE;
+		else
+			common_cb->reserve_flag = SNA_CCB_ALL;
+	}
+	return 0;
+}
+
+/* This procedure copies normal-flow request MUs from link buffer to a
+ * dynamic buffer. This procedure is called to reassemble segments into a
+ * whole BIU.
+ */
+static struct sna_mu *sna_segment_reassembly(struct sna_mu *mu)
+{
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_mu *wmu = NULL;
+
+	if (th->mpf == SNA_TH_MPF_BBIU) {
+		if (sizeof(mu->biu->ru) > 0)
+			local->sense = 0x10020000;
+		else {
+			wmu = sna_get_buffer(SNA_BM_TYPE_DEMAND, 
+				local->tcb.ccb.limit_buf_pool_id, 0,
+				SNA_BM_NO_WAIT);
+		}
+		sna_free_buffer(mu);
+	} else {
+		/* Theres more. */
+		sna_free_buffer(mu);
+	}
+
+	if (th->mpf == SNA_TH_MPF_EBIU) {
+		th->mpf = SNA_TH_MPF_EBIU;
+	}
+
+	if (local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding) {
+		sna_adjust_buf_pool(local->perm_buf_pool_id, SNA_BM_TYPE_PERM,
+			0);
+		local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding = 0;
+	}
+	return wmu;
+}
+
+/* This procedure updates pacing counts in the local->common_cb, sends
+ * reset acknowledgments to unsolicited IPMs and sends MUs to path_control
+ * if possible.
+ */
+static int sna_rcv_pacing_rsp(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ipm_extension *ipm_ex = NULL;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	switch (rsp_h->pi) {
+		case SNA_PACING_TYPE_ADAPTIVE:
+			if (ipm_ex->type == SNA_IPM_TYPE_RESET_ACK) {
+				cb->receive_pacing.rpc = 0;
+				cb->receive_pacing.nws 
+					= cb->receive_pacing.unsolicited_nws;
+				cb->receive_pacing.unsolicited_ipm_outstanding = 0;
+				sna_free_buffer(mu);
+
+				if (1)
+					sna_adjust_buf_pool(local->tcb.ccb.dynamic_buf_pool_id, SNA_BM_TYPE_DEMAND, 0);
+				else
+					cb->receive_pacing.adjust_ipm_ack_outstanding = 1;
+			}
+
+			if (ipm_ex->type == SNA_IPM_TYPE_SOLICITED) {
+				if (sna_hs_pacing_queue_empty(mu)) {
+					if (cb->send_pacing.rpc == 0)
+						cb->send_pacing.rlwi
+							= SNA_CCB_RLW;
+					sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id, SNA_BM_TYPE_LIMIT, 0);
+					cb->send_pacing.nws = ipm_ex->nws;
+					sna_free_buffer(mu);
+				}
+			}
+
+			if (ipm_ex->type == SNA_IPM_TYPE_UNSOLICITED) {
+				mu = sna_get_buffer(SNA_BM_TYPE_DEMAND,
+					local->tcb.ccb.limit_buf_pool_id,
+					0, SNA_BM_NO_WAIT);
+				cb->send_pacing.nws = mu->biu->ru.ru.ipm.nws;
+				cb->send_pacing.rpc = 0;
+				ipm_ex->type 	= SNA_IPM_TYPE_RESET_ACK;
+				ipm_ex->rwi 	= SNA_IPM_RWI_NO_RESET_WINDOW;
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case SNA_PACING_TYPE_NONE:
+			while (sna_hs_pacing_queue_empty(mu)) {
+				sna_hs_pacing_dequeue(mu);
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case SNA_PACING_TYPE_FIXED:
+			cb->send_pacing.nws = cb->send_pacing.first_ws;
+			if (rsp_h->dr1i == SNA_RH_DR1I_NO_DR1 
+				|| rsp_h->dr2i == SNA_RH_DR2I_NO_DR2) {
+				sna_free_buffer(mu);
+			}
+			sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id,
+				SNA_BM_TYPE_LIMIT, 0);
+			break;
+	}
+	return 0;
+}
+
+/* This procedure receives buffers_reserved signals from the
+ * BM, updates the appropriate pacing counts in the local->common_cb
+ * and builds and sends the appropriate pacing response.
+ */
+int sna_buffers_reserved(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_ipm_extension *ipm_ex = NULL;
+
+	if (1) {	/* reserved_buf_reduce. */
+		cb->receive_pacing.unsolicited_ipm_outstanding = 1;
+		cb->receive_pacing.unsolicited_nws = 0;
+		mu->dcf = sizeof(struct sna_req_h) + sizeof(struct sna_ru_ipm);
+		ipm_ex->type = SNA_IPM_TYPE_UNSOLICITED;
+		ipm_ex->rwi = SNA_IPM_RWI_RESET_WINDOW;
+		ipm_ex->format_indicator = SNA_IPM_FORMAT_0;
+		ipm_ex->nws = cb->receive_pacing.nws;
+	} else
+		mu->dcf = th->dcf;
+
+	th->mpf		= SNA_TH_MPF_WHOLE_BIU;
+	th->efi 	= SNA_TH_EFI_EXP;
+	th->snf.number 	= 0;
+
+	sna_send_to_pc(mu, cb);
+	return 0;
+}
+
+/* Decipher an enciphered message. */
+static int sna_tc_decipher_ru(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	int err;
+	__u8 len, pad_cnt = 0;
+
+	err = sna_des_decipher(mu);
+	if (err)
+		local->sense = 0x08480000;
+	else {
+		if (req_h->pdi == SNA_RH_PDI_PD) {
+			len = mu->dcf - sizeof(mu->biu->ru);
+			pad_cnt = mu->biu->ru.ru.raw[len];
+			if (pad_cnt < 1 || pad_cnt > 7)
+				local->sense = 0x10010000;
+			else {
+				mu->dcf -= pad_cnt;
+				req_h->pdi = SNA_RH_PDI_NO_PD;
+			}
+		}
+	}
+	return 0;
+}
+
+#endif /* CONFIG_SNA_LU62_HS || CONFIG_SNA_LU62_HS_MODULE */
diff -ruN linux-2.4.18-clean/net/sna/sna_tdm.c linux/net/sna/sna_tdm.c
--- linux-2.4.18-clean/net/sna/sna_tdm.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_tdm.c	Sat Jun  8 15:55:29 2002
@@ -0,0 +1,437 @@
+/* sna_tdm.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+/*
+ * Bugs:
+ * - process TDUs
+ * - Garbage collection
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/ctype.h>
+#include <linux/list.h>
+
+#include <linux/sna.h>
+
+static LIST_HEAD(node_list);
+static LIST_HEAD(ancb_list);
+
+unsigned char sna_system_tg_num_id	 = 1;
+
+int sysctrl_co_max_retries		 = CO_MAX_RETRIES;
+
+struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid)
+{
+	struct sna_tdm_node_cb *n;
+	struct list_head *le;
+	
+	sna_debug(5, "init: %s\n", sna_pr_netid(netid));
+	list_for_each(le, &node_list) {
+		n = list_entry(le, struct sna_tdm_node_cb, list);
+		sna_debug(5, "-%s- -%s- -%s- -%s-\n",
+			n->netid.net, netid->net, n->netid.name, netid->name);
+		if (!strncmp(n->netid.net, netid->net, SNA_RESOURCE_NAME_LEN)
+			&& !strncmp(n->netid.name, netid->name, SNA_RESOURCE_NAME_LEN))
+			return n;
+	}
+	return NULL;
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac)
+{
+	struct sna_tdm_node_cb *n;
+	struct list_head *le, *se;
+	struct sna_tg_cb *t;
+	
+        sna_debug(5, "init: (%s)\n", sna_pr_ether(mac));
+	list_for_each(le, &node_list) {
+		n = list_entry(le, struct sna_tdm_node_cb, list);
+		list_for_each(se, &n->tg_list) {
+			t = list_entry(se, struct sna_tg_cb, list);
+                        if (!memcmp(t->tg_vector.desc.dlc.mac, mac, IFHWADDRLEN))
+                                return t;
+		}
+        }
+        return NULL;
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num)
+{
+	struct sna_tdm_node_cb *n;
+	struct list_head *le, *se;
+	struct sna_tg_cb *t;
+	
+	sna_debug(5, "init\n");
+	list_for_each(le, &node_list) {
+		n = list_entry(le, struct sna_tdm_node_cb, list);
+		list_for_each(se, &n->tg_list) {
+			t = list_entry(se, struct sna_tg_cb, list);
+			sna_debug(5, "%d %d\n", t->tg_vector.desc.id.tg_number, tg_num);
+                	if (t->tg_vector.desc.id.tg_number == tg_num)
+                        	return t;
+		}
+	}
+	return NULL;
+}
+
+struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n, 
+	unsigned char tg_num)
+{
+	struct list_head *le;
+	struct sna_tg_cb *t;
+
+	sna_debug(5, "init: %d\n", tg_num);
+	list_for_each(le, &n->tg_list) {
+		t = list_entry(le, struct sna_tg_cb, list);
+	        if (t->tg_vector.desc.id.tg_number == tg_num)
+	                return t;
+	}
+	return NULL;
+}
+
+int sna_tdm_cp_status(void)
+{
+	return 0;
+}
+
+int sna_tdm_init_tg_update(struct sna_tg_update *tg)
+{
+	sna_debug(5, "init\n");
+	tg->node_type			= 0;
+	tg->routing			= 0;
+	tg->tg_desc.type		= 0;
+	tg->tg_desc.id.type		= 0;
+	tg->tg_desc.id.tg_number	= 0;
+	tg->tg_desc.id.pcp_len		= 0;
+	tg->tg_desc.id.pcp_name		= NULL;
+	tg->tg_desc.id.pcp_name_id_cn	= 0;
+	tg->tg_desc.id.more_cfg_info	= 0;
+	tg->tg_desc.id.hpr_support	= 0;
+	tg->tg_desc.id.tg_type		= 0;
+	tg->tg_desc.id.intersubnet_tg	= 0;
+	tg->tg_desc.id.rtp_support	= 0;
+	tg->tg_desc.id.subarea_number	= 0;
+	tg->tg_desc.dlc.type		= 0;
+	tg->tg_desc.dlc.lsap		= 0;
+	memset(tg->tg_desc.dlc.mac, 0, MAX_ADDR_LEN);
+	tg->tg_chars.type		= 0;
+	tg->tg_chars.rsn		= 0;
+	tg->tg_chars.status		= 0;
+	tg->tg_chars.garbage		= 0;
+	tg->tg_chars.quiescing		= 0;
+	tg->tg_chars.cpcp_session	= 0;
+	tg->tg_chars.effective_capacity	= 0;
+	tg->tg_chars.cost_per_connect	= 0;
+	tg->tg_chars.cost_per_byte	= 0;
+	tg->tg_chars.security		= 0;
+	tg->tg_chars.propagation_delay	= 0;
+	tg->tg_chars.user1		= 0;
+	tg->tg_chars.user2		= 0;
+	tg->tg_chars.user3		= 0;
+	return 0;
+}
+
+int sna_tdm_tg_update(struct sna_tg_update *utg)
+{
+	struct sna_tdm_node_cb *cb;
+	struct sna_tg_cb *tg;
+	struct sna_netid *pcp_name;
+
+	sna_debug(5, "init: %s\n", utg->tg_desc.id.pcp_name);
+	pcp_name = sna_char_to_netid(utg->tg_desc.id.pcp_name);
+	sna_debug(5, "(%s) (%s)\n", pcp_name->net, pcp_name->name);
+
+	cb = sna_tdm_find_node_entry(pcp_name);
+	if (!cb)
+		return -ENOENT;
+	tg = sna_tdm_find_tg(cb, utg->tg_desc.id.tg_number);
+	if (!tg) {
+		new(tg, GFP_ATOMIC);
+		if (!tg)
+			return -ENOMEM;
+		init_timer(&tg->co_retry);
+		init_waitqueue_head(&tg->sleep);
+        	tg->co_retry.function   = sna_cs_connect_out;
+        	tg->co_retry.data       = (unsigned long)tg;
+        	tg->co_interval         = CO_TIMEOUT;
+        	tg->co_retries          = 0;
+        	tg->co_max_retries      = sysctrl_co_max_retries;
+		INIT_LIST_HEAD(&tg->cos_list);
+		list_add_tail(&tg->list, &cb->tg_list);
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+		tg->tg_vector.desc.id.tg_number = sna_system_tg_num_id++;
+
+		/* init xid information for this transmission group */
+		new(tg->xid_info, GFP_ATOMIC);
+		if (!tg->xid_info)
+			return -ENOMEM;
+		init_timer(&tg->xid_info->xid_timer);
+		tg->xid_info->xid_timer.function 	= sna_cs_connect_out;
+		tg->xid_info->xid_timer.data 		= (unsigned long)tg;
+		tg->xid_info->xid_retry_interval 	= 3 * HZ;
+		tg->xid_info->xid_retry_limit 		= 10;
+		tg->xid_info->xid_retries 		= 0;
+		tg->xid_info->last_tx_xid 		= NULL;
+		tg->xid_info->last_rx_xid 		= NULL;
+		tg->xid_info->xid_status        	= XID_RESET;
+	} else {
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+	}
+
+	do_gettimeofday(&tg->updated);
+	tg->dev				= utg->dev;
+	tg->lsap			= utg->lsap;
+	tg->partner_node_type    	= utg->node_type;
+        tg->intermediate_routing 	= utg->routing;
+	tg->tg_vector.desc.id.pcp_name 	= utg->tg_desc.id.pcp_name;
+        utg->tg_desc.id.pcp_name 	= NULL;
+	memcpy(&tg->tg_vector.chars,&utg->tg_chars,sizeof(struct sna_tg_chars));
+
+	sna_debug(5, "It is %s %d %d\n", tg->tg_vector.desc.id.pcp_name,
+		strlen(tg->tg_vector.desc.id.pcp_name), 
+		tg->tg_vector.desc.id.pcp_len);
+
+//	sna_rss_resource_updates();
+	kfree(utg);
+
+	return tg->tg_vector.desc.id.tg_number;	/* TG Number */
+}
+
+int sna_tdm_define_node_chars(struct sna_define_node_chars *n)
+{
+	struct sna_tdm_node_cb *cb;
+
+	sna_debug(5, "init\n");
+	cb = sna_tdm_find_node_entry(&n->cp_name);
+	if (!cb) {
+		new(cb, GFP_ATOMIC);
+		if (!cb)
+			return -ENOMEM;
+		memcpy(&cb->netid, &n->cp_name, sizeof(struct sna_netid));
+		memset(&cb->node_vector, 0, sizeof(struct sna_node_vector));
+		INIT_LIST_HEAD(&cb->tg_list);
+		INIT_LIST_HEAD(&cb->cos_list);
+		list_add_tail(&cb->list, &node_list);
+	}
+	do_gettimeofday(&cb->updated);
+	memcpy(&cb->node_vector.desc.cp_name, &n->cp_name,
+		sizeof(struct sna_netid));
+	cb->node_vector.chars.info.route_resistance 	= n->route_resistance;
+	cb->node_vector.chars.info.quiescing		= n->quiescing;
+//	sna_rss_resource_updates();
+	return 0;
+}
+
+int sna_tdm_node_congenstion(void)
+{
+	return 0;
+}
+
+int sna_tdm_query_cpname(void)
+{
+	return 0;
+}
+
+/* Returned last FRSN recieved for cp_name specified */
+unsigned long sna_tdm_request_last_frsn(struct sna_netid *cp_name)
+{
+	struct sna_tdm_node_cb *cb;
+
+	cb = sna_tdm_find_node_entry(cp_name);
+	if (!cb)
+		return -ENOENT;
+	return cb->frsn;
+}
+
+/* This only returns the first TG found and does not check for any
+ * options.
+ */
+int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v)
+{
+	struct sna_tg_cb *tg = NULL;
+	struct sna_tdm_node_cb *cb;
+	struct list_head *le;
+	
+	sna_debug(5, "init: %s.%s\n",
+		v->org_cp_name.net, v->org_cp_name.name);
+	cb = sna_tdm_find_node_entry(&v->org_cp_name);
+	if (!cb)
+		return -ENOENT;
+	list_for_each(le, &cb->tg_list) {
+		tg = list_entry(le, struct sna_tg_cb, list);
+		break;
+	}
+	if (!tg)
+		return -ENOENT;
+	new(v->tg_vectors, GFP_ATOMIC);
+	if (!v->tg_vectors)
+		return -ENOMEM;
+	memcpy(v->tg_vectors, &tg->tg_vector, sizeof(struct sna_tg_vector));
+//	memcpy(v->tg_vectors, &cb->tg_list->tg_vector, 
+//		sizeof(struct sna_tg_vector));
+	new_s(v->tg_vectors->desc.id.pcp_name, 
+		v->tg_vectors->desc.id.pcp_len + 1, GFP_ATOMIC);
+	if (!v->tg_vectors->desc.id.pcp_name)
+		return -ENOMEM;
+	strcpy(v->tg_vectors->desc.id.pcp_name, tg->tg_vector.desc.id.pcp_name);
+//	strcpy(v->tg_vectors->desc.id.pcp_name, 
+//		cb->tg_list->tg_vector.desc.id.pcp_name);
+	return 0;
+}
+
+int sna_tdm_garbage_collection(void)
+{
+	return 0;
+}
+
+int sna_tdm_tdu_chk_errors(void)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+	struct list_head *le;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s\n", "NetID.Node");
+	list_for_each(le, &node_list) {
+		c = list_entry(le, struct sna_tdm_node_cb, list);
+                len += sprintf(buffer + len, "%-18s\n",sna_pr_netid(&c->netid));
+
+                /* Are we still dumping unwanted data then discard the record */
+		pos = begin + len;
+                if (pos < offset) {
+                        len = 0;        /* Keep dumping into the buffer start */
+			begin = pos;
+                }
+                if (pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+	if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+
+int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+	struct list_head *le, *se;
+	struct sna_tg_cb *t;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%5s%4s%7s%8s%10s%5s%5s%4s%4s%9s%18s%6s%6s%6s\n",
+                "NetID.Node", "type", "tgn", "status", "garbage",
+		"quiescing", "cpcp", "ecap", "cpc",
+		"cpb", "security", "propagation_delay",
+		"user1", "user2", "user3");
+	list_for_each(le, &node_list) {
+		c = list_entry(le, struct sna_tdm_node_cb, list);
+		list_for_each(se, &c->tg_list) {
+			t = list_entry(se, struct sna_tg_cb, list);
+                	len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&c->netid));
+			len += sprintf(buffer + len, "%5d%4d%7d%8d%10d%5d"
+				"%5d%4d%4d%9d%18d%6d%6d%6d\n",
+				t->tg_vector.desc.id.type,
+				t->tg_vector.desc.id.tg_number,
+				t->tg_vector.chars.status,
+				t->tg_vector.chars.garbage,
+				t->tg_vector.chars.quiescing,
+				t->tg_vector.chars.cpcp_session,
+				t->tg_vector.chars.effective_capacity,
+				t->tg_vector.chars.cost_per_connect,
+				t->tg_vector.chars.cost_per_byte,
+				t->tg_vector.chars.security,
+				t->tg_vector.chars.propagation_delay,
+				t->tg_vector.chars.user1,
+				t->tg_vector.chars.user2,
+				t->tg_vector.chars.user3);
+
+			pos = begin + len;
+                	if (pos < offset) {
+                        	len = 0; 
+				begin = pos;
+                	}
+                	if (pos > offset + length) 
+                        	break;
+		}
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if (len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if (len < 0)
+                len = 0;
+        return len;
+}
+#endif
+
+int sna_tdm_create(struct sna_start_node *start)
+{
+	return 0;
+}
+
+int sna_tdm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_tdm_node_cb *cb;
+	struct list_head *le, *se, *ae, *be;
+	struct sna_tg_cb *t;
+
+	list_for_each_safe(le, se, &node_list) {
+		cb = list_entry(le, struct sna_tdm_node_cb, list);
+		list_for_each_safe(ae, be, &cb->tg_list) {
+			t = list_entry(ae, struct sna_tg_cb, list);
+			list_del(&t->list);
+			kfree(t);
+		}
+		list_del(&cb->list);
+		kfree(cb);
+	}
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sna_trs.c linux/net/sna/sna_trs.c
--- linux-2.4.18-clean/net/sna/sna_trs.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sna_trs.c	Fri Jun  7 15:15:35 2002
@@ -0,0 +1,52 @@
+/* sna_trs.c: Linux Systems Network Architecture implementation
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_trs_create(struct sna_start_node *start)
+{
+	sna_debug(5, "init\n");
+	sna_cosm_create(start);
+	sna_rss_create(start);
+	sna_tdm_create(start);
+	return 0;
+}
+
+int sna_trs_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "init\n");
+	sna_tdm_destroy(delete);
+	sna_rss_destroy(delete);
+	sna_cosm_destroy(delete);
+	return 0;
+}
diff -ruN linux-2.4.18-clean/net/sna/sysctl_net_sna.c linux/net/sna/sysctl_net_sna.c
--- linux-2.4.18-clean/net/sna/sysctl_net_sna.c	Wed Dec 31 19:00:00 1969
+++ linux/net/sna/sysctl_net_sna.c	Fri Jun  7 04:57:42 2002
@@ -0,0 +1,103 @@
+/* sysctl_net_sna.c: Linux Systems Network Architecture implementation
+ * - SysCtrl user interface to Linux-SNA
+ *
+ * Copyright (c) 1999-2002 by Jay Schulist <jschlst@linux-sna.org>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+extern __u32   	sysctl_max_link_stations_cnt;
+extern __u32   	sysctl_max_lu_cnt;
+extern __u32   	sysctl_max_mode_cnt;
+extern __u32   	sysctl_max_inbound_activations;
+extern __u32   	sysctl_max_outbound_activations;
+extern __u32   	sysctl_max_retry_limit;
+extern __u32   	sysctl_max_btu_size;
+extern __u32   	sysctl_max_tx_ru_size;
+extern __u32   	sysctl_max_rx_ru_size;
+extern __u32   	sysctl_max_auto_activation_limit;
+extern __u32   	sysctl_bind_pacing_cnt;
+extern __u8    	sna_debug_level;
+
+/* XID sysctls */
+extern __u32	sysctl_xid_idle_limit;
+extern __u32	sysctl_xid_retry_interval;
+extern __u32	sysctl_xid_retry_limit;
+
+extern int	sysctrl_co_max_retries;
+
+#ifdef CONFIG_SYSCTL
+ctl_table sna_table[] = {
+	{NET_SNA_MAX_LINK_STATIONS, "max_link_station_count",
+        &sysctl_max_link_stations_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_LU, "max_lu_count",
+        &sysctl_max_lu_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_MODE, "max_mode_count", &sysctl_max_mode_cnt,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_XID_RETRY, "xid_retry_limit", &sysctl_xid_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_IDLE_LIMIT, "xid_idle_limit", &sysctl_xid_idle_limit,
+	sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_RETRY_INTERVAL, "xid_retry_interval", 
+	&sysctl_xid_retry_interval, sizeof(__u32), 0644, NULL, 
+	&proc_dointvec_jiffies},
+        {NET_SNA_MIA, "max_inbound_activations",
+        &sysctl_max_inbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MOA, "max_outbound_activations",
+        &sysctl_max_outbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RETRY, "max_retry_limit", &sysctl_max_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_BTU, "max_btu_size", &sysctl_max_btu_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_TX_RU, "max_tx_ru_size", &sysctl_max_tx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RX_RU, "max_rx_ru_size", &sysctl_max_rx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_MAX_AUTO_ACT, "max_auto_activation_limit",
+        &sysctl_max_auto_activation_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_DEBUG, "debug_level", &sna_debug_level,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_CO_MAX_RETRIES, "max_connect_out_retries",
+	&sysctrl_co_max_retries, 
+	sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+	{0}
+};
+
+static ctl_table sna_dir_table[] = {
+        {NET_SNA, "sna", NULL, 0, 0555, sna_table},
+        {0}
+};
+
+static ctl_table sna_root_table[] = {
+        {CTL_NET, "net", NULL, 0, 0555, sna_dir_table},
+        {0}
+};
+
+static struct ctl_table_header *sna_table_header;
+
+void sna_register_sysctl(void)
+{
+	sna_table_header = register_sysctl_table(sna_root_table, 1);
+	return;
+}
+
+void sna_unregister_sysctl(void)
+{
+	unregister_sysctl_table(sna_table_header);
+	return;
+}
+#endif
