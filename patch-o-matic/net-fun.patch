diff -ruN linux-2.4.13/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.13/Documentation/Configure.help	Sat Oct 20 19:17:19 2001
+++ linux/Documentation/Configure.help	Sat Nov  3 13:18:54 2001
@@ -4417,6 +4417,23 @@
   The module will be called af_spx.o. If you want to compile it as a
   module, say M here and read Documentation/modules.txt.
 
+SNA Networking
+CONFIG_SNA
+  Systems Network Architecture (SNA) is a data communication protocol
+  established by IBM to specify common conventions for communication among
+  the wide array of IBM hardware and software data communications products.
+
+  Linux-SNA is the Linux supported version of the IBM SNA protocol
+  specifications. To learn more about Linux-SNA point your web browser
+  to http://www.linux-sna.org
+
+  Many of the Linux-SNA protocol options can be compiled as (M)odules
+  or staticly in the kernel. Please follow the proper Linux-SNA FAQs
+  and HOWTOs in order to select the appropriate options for your SNA
+  enviroment.
+
+  If you don't know what you are doing, say  N.
+
 DECnet networking (EXPERIMENTAL)
 CONFIG_DECNET
   The DECnet networking protocol was used in many products made by
diff -ruN linux-2.4.13/Documentation/networking/sna/node-start.txt linux/Documentation/networking/sna/node-start.txt
--- linux-2.4.13/Documentation/networking/sna/node-start.txt	Wed Dec 31 16:00:00 1969
+++ linux/Documentation/networking/sna/node-start.txt	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,24 @@
+Linux-SNA DLC handling is as follows:
+
+Each system (node) has a pool of non-active DLCs (eth0, tr0, etc).
+
+Once a DLC has been defined 
+
+
+Available DLCs: tr0, sdlc0
+Active DLCs: eth0
+
+Upon start_node command:
+1. IFF_UP interfaces are defined and placed into the DLC_UP state.
+
+Upon port start:
+2. Listener is added for new interface when registered to be defined.
+
+DLC is only active and associated with a node when the start_dlc command
+is issued by the use.
+
+define_dlc + delete_dlc are system commands.
+
+/proc/net/sna/sna-cs-dlc
+
+
diff -ruN linux-2.4.13/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux-2.4.13/arch/i386/kernel/entry.S	Wed Oct 17 10:02:39 2001
+++ linux/arch/i386/kernel/entry.S	Sat Nov  3 13:18:54 2001
@@ -622,6 +622,15 @@
 	.long SYMBOL_NAME(sys_ni_syscall)	/* Reserved for Security */
 	.long SYMBOL_NAME(sys_gettid)
 	.long SYMBOL_NAME(sys_readahead)	/* 225 */
+	.long SYMBOL_NAME(sys_cpicall)
+	.long SYMBOL_NAME(sys_appcall)
+	.long SYMBOL_NAME(sys_tp_register)
+	.long SYMBOL_NAME(sys_tp_correlate)
+	.long SYMBOL_NAME(sys_tp_unregister)	/* 230 */
+	.long SYMBOL_NAME(sys_attach_open)
+	.long SYMBOL_NAME(sys_attach_listen)
+	.long SYMBOL_NAME(sys_attach_close)
+
 
 	.rept NR_syscalls-(.-sys_call_table)/4
 		.long SYMBOL_NAME(sys_ni_syscall)
diff -ruN linux-2.4.13/drivers/net/channel/Config.in linux/drivers/net/channel/Config.in
--- linux-2.4.13/drivers/net/channel/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/channel/Config.in	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,13 @@
+#
+# ESCON / BUS/TAG channel adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'Channel driver support'
+
+bool 'Channel driver support' CONFIG_CHANNEL
+if [ "$CONFIG_CHANNEL" = "y" ]; then
+   tristate 'Bus-Tech adapter support' CONFIG_BUSTECH
+fi
+
+endmenu
diff -ruN linux-2.4.13/drivers/net/channel/Makefile linux/drivers/net/channel/Makefile
--- linux-2.4.13/drivers/net/channel/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/channel/Makefile	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/channel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.13/drivers/net/twinax/Config.in linux/drivers/net/twinax/Config.in
--- linux-2.4.13/drivers/net/twinax/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/twinax/Config.in	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,14 @@
+#
+# Twinax adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'TwinAx driver support'
+
+bool 'TwinAx driver support' CONFIG_TWINAX
+if [ "$CONFIG_TWINAX" = "y" ]; then
+   tristate 'Affinity adapter support' CONFIG_AFFINITY
+   tristate 'Praim adapter support' CONFIG_PRAIM
+fi
+
+endmenu
diff -ruN linux-2.4.13/drivers/net/twinax/Makefile linux/drivers/net/twinax/Makefile
--- linux-2.4.13/drivers/net/twinax/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/twinax/Makefile	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/twinax
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.13/include/asm-i386/unistd.h linux/include/asm-i386/unistd.h
--- linux-2.4.13/include/asm-i386/unistd.h	Wed Oct 17 10:03:03 2001
+++ linux/include/asm-i386/unistd.h	Sat Nov  3 13:18:54 2001
@@ -230,6 +230,14 @@
 #define __NR_security		223	/* syscall for security modules */
 #define __NR_gettid		224
 #define __NR_readahead		225
+#define __NR_cpicall            226
+#define __NR_appcall            227
+#define __NR_tp_register        228
+#define __NR_tp_correlate       229
+#define __NR_tp_unregister      230
+#define __NR_attach_open        231
+#define __NR_attach_listen      232
+#define __NR_attach_close      	233
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
 
diff -ruN linux-2.4.13/include/linux/appc.h linux/include/linux/appc.h
--- linux-2.4.13/include/linux/appc.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/appc.h	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,571 @@
+/* appc.h: Advanced Program-to-Program Communications structures and defs.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _APPC_H
+#define _APPC_H
+
+/* Linux-SNA APPC Call OPCODES */
+#define AC_ALLOCATE				0x0001
+#define AC_MC_ALLOCATE				0x0010
+#define AC_DEALLOCATE				0x0020
+#define AC_MC_DEALLOCATE			0x0030
+#define AC_GET_ATTRIBUTES			0x0040
+#define AC_GET_TP_PROPERTIES			0x0050
+#define AC_RECEIVE_AND_WAIT			0x0060
+#define AC_MC_RECEIVE_AND_WAIT			0x0070
+#define AC_REQUEST_TO_SEND			0x0080
+#define AC_MC_REQUEST_TO_SEND			0x0090
+#define AC_SEND_DATA				0x00A0
+#define AC_MC_SEND_DATA				0x00B0
+#define AC_CONFIRM				0x00C0
+#define AC_MC_CONFIRM				0x00D0
+#define AC_CONFIRMED				0x00E0
+#define AC_MC_CONFIRMED				0x00F0
+#define AC_SEND_ERROR				0x0100
+#define AC_MC_SEND_ERROR			0x0110
+#define AC_CHANGE_SESSION_LIMIT			0x0120
+#define AC_INIT_SESSION_LIMIT			0x0130
+#define AC_PROCESS_SESSION_LIMIT		0x0140
+#define AC_RESET_SESSION_LIMIT			0x0150
+#define AC_MC_GET_ATTRIBUTES			0x0160
+#define AC_GET_TYPE				0x0170
+#define AC_SET_SYNCPT_OPTIONS			0x0180
+#define AC_FLUSH				0x0190
+#define AC_MC_FLUSH				0x01A0
+#define AC_POST_ON_RECEIPT			0x01B0
+#define AC_MC_POST_ON_RECEIPT			0x01C0
+#define AC_PREPARE_TO_RECEIVE			0x01D0
+#define AC_MC_PREPARE_TO_RECEIVE		0x01E0
+#define AC_RECEIVE_EXPEDITED_DATA		0x01F0
+#define AC_RECEIVE_IMMEDIATE			0x0200
+#define AC_MC_RECEIVE_IMMEDIATE			0x0210
+#define AC_SEND_EXPEDITED_DATA			0x0220
+#define AC_MC_SEND_EXPEDITED_DATA		0x0230
+#define AC_TEST					0x0240
+#define AC_MC_TEST				0x0250
+#define AC_WAIT					0x0260
+#define AC_WAIT_FOR_COMPLETION			0x0270
+#define AC_BACKOUT				0x0280
+#define AC_PREPARE_FOR_SYNCPT			0x0290
+#define AC_MC_PREPARE_FOR_SYNCPT		0x02A0
+#define AC_ACTIVATE_SESSION			0x02B0
+#define AC_DEACTIVATE_CONVERSATION_GROUP	0x02C0
+#define AC_DEACTIVATE_SESSION			0x02D0
+#define AC_DEFINE_LOCAL_LU			0x02E0
+#define AC_DEFINE_MODE				0x02F0
+#define AC_DEFINE_REMOTE_LU			0x0300
+#define AC_DEFINE_TP				0x0310
+#define AC_DELETE				0x0320
+#define AC_DISPLAY_LOCAL_LU			0x0330
+#define AC_DISPLAY_MODE				0x0340
+#define AC_DISPLAY_REMOTE_LU			0x0350
+#define AC_DISPLAY_TP				0x0360
+#define AC_PROCESS_SIGNOFF			0x0370
+#define AC_SIGNOFF				0x0380
+
+/* Linux-SNA APPC return codes */
+#define AC_OK					0x0000
+#define AC_PARAMETER_CHECK			0x0001
+#define AC_BAD_TP_ID				0x0010
+#define AC_BAD_CONV_ID				0x0020
+#define AC_BAD_LU_ALIAS				0x0030
+#define AC_INVALID_DATA_SEGMENT			0x0040
+#define AC_BAD_CONV_TYPE			0x0050
+#define AC_BAD_SYNC_LEVEL			0x0060
+#define AC_BAD_SECURITY				0x0070
+#define AC_BAD_RETURN_CONTROL			0x0080
+#define AC_PIP_LEN_INCORRECT			0x0090
+#define AC_NO_USE_OF_SNASVCMG			0x00A0
+#define AC_UNKNOWN_PARTNER_MODE			0x00B0
+#define AC_CONFIRM_ON_SYNC_LEVEL_NONE		0x00C0
+#define AC_DEALLOC_BAD_TYPE			0x00D0
+#define AC_DEALLOC_LOG_LL_WRONG			0x00E0
+#define AC_P_TO_R_INVALID_TYPE			0x00F0
+#define AC_RCV_AND_WAIT_BAD_FILL		0x0100
+#define AC_RCV_IMMD_BAD_FILL			0x0110
+#define AC_RCV_AND_POST_BAD_FILL		0x0120
+#define AC_INVALID_SEMAPHONE_HANDLE		0x0130
+#define AC_BAD_RETURN_STATUS_WITH_DATA		0x0140
+#define AC_BAD_LL				0x0150
+#define AC_SEND_INVALID_TYPE			0x0160
+#define AC_INVALID_SESSION_ID			0x0170
+#define AC_INVALID_POLARITY			0x0180
+#define AC_INVALID_TYPE				0x0190
+#define AC_INVALID_LU_ALIAS			0x01A0
+#define AC_INVALID_PLU_ALIAS			0x01B0
+#define AC_INVALID_MODE_NAME			0x01C0
+#define AC_INVALID_TRANSACT_ID			0x01D0
+#define AC_SEND_DATA_CONFIRM_SYNC_LEVEL_NONE	0x01E0
+#define AC_BAD_PARTNER_LU_ALIAS			0x01F0
+#define AC_SEND_ERROR_LOG_LL_WRONG		0x0200
+#define AC_SEND_ERROR_BAD_TYPE			0x0210
+#define AC_BAD_ERROR_DIRECTION			0x0220
+#define AC_TOO_MANY_TPS				0x0230
+#define AC_BAD_TYPE				0x0240
+#define AC_UNDEFINED_TP_NAME			0x0250
+#define AC_INVALID_SET_PROT			0x0260
+#define AC_INVALID_NEW_PROT			0x0270
+#define AC_INVALID_SET_UNPROT			0x0280
+#define AC_INVALID_NEW_UNPROT			0x0290
+#define AC_INVALID_SET_USER			0x02A0
+#define AC_INVALID_DATA_TYPE			0x02B0
+#define AC_BAD_LOCAL_LU_ALIAS			0x02C0
+#define AC_BAD_REMOTE_LU_ALIAS			0x02D0
+#define AC_POST_ON_RECEIPT_BAD_FILL		0x02E0
+#define AC_STATE_CHECK				0x02F0
+#define AC_CONFIRM_BAD_STATE			0x0300
+#define AC_CONFIRM_NO_LL_BDY			0x0310
+#define AC_CONFIRMED_BAD_STATE			0x0320
+#define AC_DEALLOC_FLUSH_BAD_STATE		0x0330
+#define AC_DEALLOC_CONFIRM_BAD_STATE		0x0340
+#define AC_DEALLOC_NOT_LL_BDY			0x0350
+#define AC_FLUSH_NOT_SEND_STATE			0x0360
+#define AC_P_TO_R_NOT_LL_BDY			0x0370
+#define AC_P_TO_R_NOT_SEND_STATE		0x0380
+#define AC_RCV_AND_WAIT_BAD_STATE		0x0390
+#define AC_RCV_AND_WAIT_NOT_LL_BDY		0x03A0
+#define AC_RCV_IMMD_BAD_STATE			0x03B0
+#define AC_RCV_AND_POST_BAD_STATE		0x03C0
+#define AC_RCV_AND_POST_NOT_LL_BDY		0x03D0
+#define AC_R_T_S_BAD_STATE			0x03E0
+#define AC_SEND_DATA_NOT_SEND_STATE		0x03F0
+#define AC_SEND_DATA_NOT_LL_BDY			0x0400
+#define AC_ATTACH_MANAGER_INACTIVE		0x0410
+#define AC_ALLOCATE_NOT_PENDING			0x0420
+#define AC_INVALID_PROCESS			0x0430
+#define AC_ALLOCATION_ERROR			0x0440
+#define AC_ALLOCATION_FAILURE_NO_RETRY		0x0450
+#define AC_ALLOCATION_FAILURE_RETRY		0x0460
+#define AC_SECURITY_NOT_VALID			0x0470
+#define AC_TRANS_PGM_NOT_AVAIL_RETRY		0x0480
+#define AC_TRANS_PGM_NOT_AVAIL_NO_RETRY		0x0490
+#define AC_TP_NAME_NOT_RECOGNIZED		0x04A0
+#define AC_PIP_NOT_ALLOWED			0x04B0
+#define AC_PIP_NOT_SPECIFIED_CORRECTLY		0x04C0
+#define AC_CONVERSATION_TYPE_MISMATCH		0x04D0
+#define AC_SYNC_LEVEL_NOT_SUPPORTED		0x04E0
+#define AC_DEALLOC_ABEND			0x04F0
+#define AC_DEALLOC_ABEND_PROG			0x0500
+#define AC_DEALLOC_ABEND_SCV			0x0510
+#define AC_DEALLOC_ABEND_TIMER			0x0520
+#define AC_DEALLOC_NORMAL			0x0530
+#define AC_PROG_ERROR_NO_TRUNC			0x0540
+#define AC_PROG_ERROR_PURGING			0x0550
+#define AC_CONV_FAILURE_RETRY			0x0560
+#define AC_CONV_FAILURE_NO_RETRY		0x0570
+#define AC_SCV_ERROR_TRUNC			0x0580
+#define AC_SCV_ERROR_PURGING			0x0590
+#define AC_UNSUCCESSFUL				0x05A0
+#define AC_CONVERSATION_TYPE_MIXED		0x05B0
+#define AC_CANCELLED				0x05C0
+#define AC_SECURITY_REQUESTED_NOT_SUPPORTED	0x05D0
+#define AC_TP_BUSY				0x05E0
+#define AC_BACKED_OUT				0x05F0
+#define AC_BO_NO_RESYNC				0x0600
+#define AC_BO_RESYNC				0x0610
+#define AC_ACTIVATION_FAIL_RETRY		0x0620
+#define AC_ACTIVATION_FAIL_NO_RETRY		0x0630
+#define AC_SESSION_LIMITS_CLOSED		0x0640
+#define AC_SESSION_LIMITS_EXCEEDED		0x0650
+#define AC_VERB_IN_PROGRESS			0x0660
+#define AC_SESSION_DEACTIVATED			0x0670
+#define AC_COMM_SUBSYSTEM_ABENDED		0x0680
+#define AC_COMM_SUBSYSTEM_NOT_LOADED		0x0690
+#define AC_CONV_BUSY				0x06A0
+#define AC_INVALID_VERB				0x06B0
+
+
+/* Linux-SNA APPC call data structures. */
+struct sna_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	conv_type;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char 	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_mc_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+};
+
+struct sna_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_tp_properties {
+
+};
+
+struct sna_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_request_to_send {
+
+};
+
+struct sna_mc_request_to_send {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_mc_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_mc_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_error {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	err_type;
+	unsigned char	err_dir;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_send_error {
+        unsigned char   tp_id[8];
+        unsigned long   conv_id;
+        unsigned char   rts_rcvd;
+        unsigned char   err_type;
+        unsigned char   err_dir;
+        unsigned short  log_dlen;
+        unsigned char   *log_dptr;
+};
+
+struct sna_change_session_limit {
+
+};
+
+struct sna_init_session_limit {
+
+};
+
+struct sna_process_session_limit {
+
+};
+
+struct sna_reset_session_limit {
+
+};
+
+struct sna_mc_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_type {
+
+};
+
+struct sna_set_syncpt_options {
+
+};
+
+struct sna_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_post_on_receipt {
+
+};
+
+struct sna_mc_post_on_receipt {
+
+};
+
+struct sna_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_mc_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_receive_expedited_data {
+
+};
+
+struct sna_mc_receive_expedited_data {
+
+};
+
+struct sna_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_send_expedited_data {
+
+};
+
+struct sna_mc_send_expedited_data {
+
+};
+
+struct sna_test {
+
+};
+
+struct sna_mc_test {
+
+};
+
+struct sna_wait {
+
+};
+
+struct sna_wait_for_completion {
+
+};
+
+struct sna_backout {
+
+};
+
+struct sna_prepare_for_syncpt {
+
+};
+
+struct sna_mc_prepare_for_syncpt {
+
+};
+
+struct sna_syncpt {
+
+};
+
+struct sna_activate_session {
+
+};
+
+struct sna_deactivate_conversation_group {
+
+};
+
+struct sna_deactivate_session {
+
+};
+
+struct sna_define_local_lu {
+
+};
+
+struct sna_define_mode {
+
+};
+
+struct sna_define_remote_lu {
+
+};
+
+struct sna_define_tp {
+
+};
+
+struct sna_delete {
+
+};
+
+struct sna_display_local_lu {
+
+};
+
+struct sna_display_mode {
+
+};
+
+struct sna_display_remote_lu {
+
+};
+
+struct sna_display_tp {
+
+};
+
+struct sna_process_signoff {
+
+};
+
+struct sna_signoff {
+
+};
+
+extern void appc(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr);
+
+#ifdef __KERNEL__
+
+struct appc_ops {
+	int family;
+};
+
+#endif /* __KERNEL__ */
+#endif /* _APPC_H */
diff -ruN linux-2.4.13/include/linux/attach.h linux/include/linux/attach.h
--- linux-2.4.13/include/linux/attach.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/attach.h	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,66 @@
+#ifndef _LINUX_ATTACH_H
+#define _LINUX_ATTACH_H
+
+struct tp_info {
+        char            tp_name[64];
+        unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+        unsigned long   flags;
+};
+
+struct tp_attach {
+	char		tp_name[64];
+	int		tp_len;
+	unsigned long	tcb_id;
+	char		netid[17];
+	char		luow_id[6];
+	char		raw_attach_hdr[100];
+};
+
+#ifdef __KERNEL__
+
+typedef enum {
+        AT_RESET = 1,
+        AT_INIT,
+        AT_WAITING,
+        AT_ATTACHED
+} attach_state;
+
+struct attach_tps {
+	struct attach_tps *next;
+	struct attach_tps *prev;
+
+	attach_state	state;
+	unsigned short	flags;
+	pid_t		pid;
+	unsigned long	id;
+
+	char		tp_name[64];
+	unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+};
+
+struct attach {
+        unsigned short          flags;
+
+        struct attach_ops       *ops;		/* Calls backs for this ID */
+	struct attach_tps	*tps;		/* All TPs using the attach */
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+
+        wait_queue_head_t       wait;
+};
+
+struct attach_ops {
+        int family;
+        int (*tp_correlate)  (pid_t pid, unsigned long tcb_id, char *tp_name);
+        int (*attach_listen) (struct attach *at, void *buf, int len);
+};
+
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+#endif /* __KERNEL__ */
+#endif /* __LINUX_ATTACH_H */
diff -ruN linux-2.4.13/include/linux/cpic.h linux/include/linux/cpic.h
--- linux-2.4.13/include/linux/cpic.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/cpic.h	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,855 @@
+/* cpic.h: CPI Communications Header.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _CPIC_H
+#define _CPIC_H
+
+#define CM_INT32 signed long int
+#define CM_ENTRY extern void
+#define CM_PTR *
+
+typedef unsigned char CONVERSATION_ID [8];
+typedef unsigned char CONTEXT_ID [32];
+typedef unsigned char SECURITY_PASSWORD [10];
+typedef unsigned char SECURITY_USER_ID [10];
+
+typedef CM_INT32 CM_AE_QUAL_OR_AP_TITLE_FORMAT;
+typedef CM_INT32 CM_ALLOCATE_CONFIRM_TYPE;
+typedef CM_INT32 CM_BEGIN_TRANSACTION;
+typedef CM_INT32 CM_BUFFER_LENGTH;
+typedef CM_INT32 CM_CALL_ID;
+typedef CM_INT32 CM_COMPLETED_OP_COUNT;
+typedef CM_INT32 CM_CONFIRMATION_URGENCY;
+typedef CM_INT32 CM_CONTEXT_ID_LENGTH;
+typedef CM_INT32 CM_CONTROL_INFORMATION_RECEIVED;
+typedef CM_INT32 CM_CONVERSATION_QUEUE;
+typedef CM_INT32 CM_CONVERSATION_RETURN_CODE;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 CM_SECURITY_PASSWORD_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_LENGTH;
+typedef CM_INT32 CM_SECURITY_USER_ID_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_STATE;
+typedef CM_INT32 CM_CONVERSATION_TYPE;
+typedef CM_INT32 CM_DATA_RECEIVED_TYPE;
+typedef CM_INT32 CM_DEALLOCATE_TYPE;
+typedef CM_INT32 CM_DIRECTORY_ENCODING;
+typedef CM_INT32 CM_DIRECTORY_SYNTAX;
+typedef CM_INT32 CM_ERROR_DIRECTION;
+typedef CM_INT32 CM_FILL;
+typedef CM_INT32 CM_MAXIMUM_BUFFER_SIZE;
+typedef CM_INT32 CM_OOID;
+typedef CM_INT32 CM_PARTNER_ID_SCOPE;
+typedef CM_INT32 CM_PARTNER_ID_TYPE;
+typedef CM_INT32 CM_PREPARE_DATA_PERMITTED_TYPE;
+typedef CM_INT32 CM_PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 CM_PROCESSING_MODE;
+typedef CM_INT32 CM_RECEIVE_TYPE;
+typedef CM_CONTROL_INFORMATION_RECEIVED CM_REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETURN_CODE;
+typedef CM_INT32 CM_RETURN_CONTROL;
+typedef CM_INT32 CM_SEND_RECEIVE_MODE;
+typedef CM_INT32 CM_SEND_TYPE;
+typedef CM_INT32 CM_STATUS_RECEIVED;
+typedef CM_INT32 CM_SYNC_LEVEL;
+typedef CM_INT32 CM_TIMEOUT;
+typedef CM_INT32 CM_TRANSACTION_CONTROL;
+typedef CM_INT32 CONVERSATION_TYPE;
+typedef CM_INT32 CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 DATA_RECEIVED;
+typedef CM_INT32 DEALLOCATE_TYPE;
+typedef CM_INT32 ERROR_DIRECTION;
+typedef CM_INT32 PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 PROCESSING_MODE;
+typedef CM_INT32 RECEIVE_TYPE;
+typedef CM_INT32 REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETCODE;
+typedef CM_INT32 RETURN_CONTROL;
+typedef CM_INT32 SEND_TYPE;
+typedef CM_INT32 STATUS_RECEIVED;
+typedef CM_INT32 SYNC_LEVEL;
+
+#define CM_DN	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 0
+#define CM_OID	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 1
+
+/* Allocate_confirm values. */
+#define CM_ALLOCATE_NO_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 0
+#define CM_ALLOCATE_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 1
+
+/* begin_transaction values. */
+#define CM_BEGIN_IMPLICIT	(CM_BEGIN_TRANSACTION) 0
+#define CM_BEGIN_EXPLICIT	(CM_BEGIN_TRANSACTION) 1
+
+/* call_ID values. */
+#define CM_CMACCI		(CM_CALL_ID) 1
+#define CM_CMACCP		(CM_CALL_ID) 2
+#define CM_CMALLC		(CM_CALL_ID) 3
+#define CM_CMCANC		(CM_CALL_ID) 4
+#define CM_CMCFM		(CM_CALL_ID) 5
+#define CM_CMCFMD		(CM_CALL_ID) 6
+#define CM_CMCNVI		(CM_CALL_ID) 7
+#define CM_CMCNVO		(CM_CALL_ID) 8
+#define CM_CMDEAL		(CM_CALL_ID) 9
+#define CM_CMDFDE		(CM_CALL_ID) 10
+#define CM_CMEACN		(CM_CALL_ID) 11
+#define CM_CMEAEQ		(CM_CALL_ID) 12
+#define CM_CMEAPT		(CM_CALL_ID) 13
+#define CM_CMECS		(CM_CALL_ID) 14
+#define CM_CMECT		(CM_CALL_ID) 15
+#define CM_CMECTX		(CM_CALL_ID) 16
+#define CM_CMEID		(CM_CALL_ID) 17
+#define CM_CMEMBS		(CM_CALL_ID) 18
+#define CM_CMEMN		(CM_CALL_ID) 19
+#define CM_CMEPID		(CM_CALL_ID) 20
+#define CM_CMEPLN		(CM_CALL_ID) 21
+#define CM_CMESI		(CM_CALL_ID) 22
+#define CM_CMESL		(CM_CALL_ID) 23
+#define CM_CMESRM		(CM_CALL_ID) 24
+#define CM_CMESUI		(CM_CALL_ID) 25
+#define CM_CMETC		(CM_CALL_ID) 26
+#define CM_CMETPN		(CM_CALL_ID) 27
+#define CM_CMFLUS		(CM_CALL_ID) 28
+#define CM_CMINCL		(CM_CALL_ID) 29
+#define CM_CMINIC		(CM_CALL_ID) 30
+#define CM_CMINIT		(CM_CALL_ID) 31
+#define CM_CMPREP		(CM_CALL_ID) 32
+#define CM_CMPTR		(CM_CALL_ID) 33
+#define CM_CMRCV		(CM_CALL_ID) 34
+#define CM_CMRCVX		(CM_CALL_ID) 35
+#define CM_CMRLTP		(CM_CALL_ID) 36
+#define CM_CMRTS		(CM_CALL_ID) 37
+#define CM_CMSAC		(CM_CALL_ID) 38
+#define CM_CMSACN		(CM_CALL_ID) 39
+#define CM_CMSAEQ		(CM_CALL_ID) 40
+#define CM_CMSAPT		(CM_CALL_ID) 41
+#define CM_CMSBT		(CM_CALL_ID) 42
+#define CM_CMSCSP		(CM_CALL_ID) 43
+#define CM_CMSCST		(CM_CALL_ID) 44
+#define CM_CMSCSU		(CM_CALL_ID) 45
+#define CM_CMSCT		(CM_CALL_ID) 46
+#define CM_CMSCU		(CM_CALL_ID) 47
+#define CM_CMSDT		(CM_CALL_ID) 48
+#define CM_CMSED		(CM_CALL_ID) 49
+#define CM_CMSEND		(CM_CALL_ID) 50
+#define CM_CMSERR		(CM_CALL_ID) 51
+#define CM_CMSF			(CM_CALL_ID) 52
+#define CM_CMSID		(CM_CALL_ID) 53
+#define CM_CMSLD		(CM_CALL_ID) 54
+#define CM_CMSLTP		(CM_CALL_ID) 55
+#define CM_CMSMN		(CM_CALL_ID) 56
+#define CM_CMSNDX		(CM_CALL_ID) 57
+#define CM_CMSPDP		(CM_CALL_ID) 58
+#define CM_CMSPID		(CM_CALL_ID) 59
+#define CM_CMSPLN		(CM_CALL_ID) 60
+#define CM_CMSPM		(CM_CALL_ID) 61
+#define CM_CMSPTR		(CM_CALL_ID) 62
+#define CM_CMSQCF		(CM_CALL_ID) 63
+#define CM_CMSQPM		(CM_CALL_ID) 64
+#define CM_CMSRC		(CM_CALL_ID) 65
+#define CM_CMSRT		(CM_CALL_ID) 66
+#define CM_CMSSL		(CM_CALL_ID) 67
+#define CM_CMSSRM		(CM_CALL_ID) 68
+#define CM_CMSST		(CM_CALL_ID) 69
+#define CM_CMSTC		(CM_CALL_ID) 70
+#define CM_CMSTPN		(CM_CALL_ID) 71
+#define CM_CMTRTS		(CM_CALL_ID) 72
+#define CM_CMWAIT		(CM_CALL_ID) 73
+#define CM_CMWCMP		(CM_CALL_ID) 74
+
+/* confirmation_urgency values. */
+#define CM_CONFIRMATION_NOT_URGENT	(CM_CONFIRMATION_URGENCY) 0
+#define CM_CONFIRMATION_URGENT		(CM_CONFIRMATION_URGENCY) 1
+
+/* control_information_received, request_to_send_received_values. */
+#define CM_NO_CONTROL_INFO_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_NOT_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_RECEIVED		(CM_CONTROL_INFORMATION_RECEIVED) 1
+#define CM_ALLOCATE_CONFIRMED		(CM_CONTROL_INFORMATION_RECEIVED) 2
+#define CM_ALLOCATE_CONFIRMED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 3
+#define CM_ALLOCATE_REJECTED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 4
+#define CM_EXPEDITED_DATA_AVAILABLE	(CM_CONTROL_INFORMATION_RECEIVED) 5
+#define CM_RTS_RCVD_AND_EXP_DATA_AVAIL	(CM_CONTROL_INFORMATION_RECEIVED) 6
+
+/* conversation_queue values. */
+#define CM_INITIALIZATION_QUEUE		(CM_CONVERSATION_QUEUE) 0
+#define CM_SEND_QUEUE			(CM_CONVERSATION_QUEUE) 1
+#define CM_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 2
+#define CM_SEND_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 3
+#define CM_EXPEDITED_SEND_QUEUE		(CM_CONVERSATION_QUEUE) 4
+#define CM_EXPEDITED_RECEIVE_QUEUE	(CM_CONVERSATION_QUEUE) 5
+
+/* conversation_state values. */
+#define CM_INITIALIZE_STATE		(CM_CONVERSATION_STATE) 2
+#define CM_SEND_STATE			(CM_CONVERSATION_STATE) 3
+#define CM_RECEIVE_STATE		(CM_CONVERSATION_STATE) 4
+#define CM_SEND_PENDING_STATE		(CM_CONVERSATION_STATE) 5
+#define CM_CONFIRM_STATE		(CM_CONVERSATION_STATE) 6
+#define CM_CONFIRM_SEND_STATE		(CM_CONVERSATION_STATE) 7
+#define CM_CONFIRM_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 8
+#define CM_DEFER_RECEIVE_STATE		(CM_CONVERSATION_STATE) 9
+#define CM_DEFER_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 10
+#define CM_SYNC_POINT_STATE		(CM_CONVERSATION_STATE) 11
+#define CM_SYNC_POINT_SEND_STATE	(CM_CONVERSATION_STATE) 12
+#define CM_SYNC_POINT_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 13
+#define CM_INITIALIZE_INCOMING_STATE	(CM_CONVERSATION_STATE) 14
+#define CM_SEND_ONLY_STATE		(CM_CONVERSATION_STATE) 15
+#define CM_RECEIVE_ONLY_STATE		(CM_CONVERSATION_STATE) 16
+#define CM_SEND_RECEIVE_STATE		(CM_CONVERSATION_STATE) 17
+#define CM_PREPARED_STATE		(CM_CONVERSATION_STATE) 18
+
+/* conversation_type value. */
+#define CM_BASIC_CONVERSATION		(CM_CONVERSATION_TYPE) 0
+#define CM_MAPPED_CONVERSATION		(CM_CONVERSATION_TYPE) 1
+
+/* data_received values. */
+#define CM_NO_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 0
+#define CM_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 1
+#define CM_COMPLETE_DATA_RECEIVED	(CM_DATA_RECEIVED_TYPE) 2
+#define CM_INCOMPLETE_DATA_RECEVIED	(CM_DATA_RECEIVED_TYPE) 3
+
+/* deallocate_type values. */
+#define CM_DEALLOCATE_SYNC_LEVEL	(CM_DEALLOCATE_TYPE) 0
+#define CM_DEALLOCATE_FLUSH		(CM_DEALLOCATE_TYPE) 1
+#define CM_DEALLOCATE_CONFIRM		(CM_DEALLOCATE_TYPE) 2
+#define CM_DEALLOCATE_ABEND		(CM_DEALLOCATE_TYPE) 3
+
+/* directory_encoding values. */
+#define CM_DEFAULT_ENCODING		(CM_DIRECTORY_ENCODING) 0
+#define CM_UNICODE_ENCODING		(CM_DIRECTORY_ENCODING) 1
+
+/* directory_syntax values. */
+#define CM_DEFAULT_SYNTAX		(CM_DIRECTORY_SYNTAX) 0
+#define CM_DCE_SYNTAX			(CM_DIRECTORY_SYNTAX) 1
+#define CM_XDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 2
+#define CM_NDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 3
+
+/* error_direction values. */
+#define CM_RECEIVE_ERROR		(CM_ERROR_DIRECTION) 0
+#define CM_SEND_ERROR			(CM_ERROR_DIRECTION) 1
+
+/* fill values. */
+#define CM_FILL_LL			(CM_FILL) 0
+#define CM_FILL_BUFFER			(CM_FILL) 1
+
+/* partner_ID_scope values. */
+#define CM_EXPLICIT			(CM_PARTNER_ID_SCOPE) 0
+#define CM_REFERENCE			(CM_PARTNER_ID_SCOPE) 1
+
+/* partner_ID_type values. */
+#define CM_DISTINGUISHED_NAME		(CM_PARTNER_ID_TYPE) 0
+#define CM_LOCAL_DISTINGUISHED_NAME	(CM_PARTNER_ID_TYPE) 1
+#define CM_PROGRAM_FUNCTION_ID		(CM_PARTNER_ID_TYPE) 2
+#define CM_OSI_TPSU_TITLE_OID		(CM_PARTNER_ID_TYPE) 3
+#define CM_PROGRAM_BINDING		(CM_PARTNER_ID_TYPE) 4
+
+/* prepare_data_permitted values. */
+#define CM_PREPARE_DATA_NOT_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 0
+#define CM_PREPARE_DATA_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 1
+
+/* prepare_to_receive_type values. */
+#define CM_PREP_TO_RECEIVE_SYNC_LEVEL	(CM_PREPARE_TO_RECEIVE_TYPE) 0
+#define CM_PREP_TO_RECEIVE_FLUSH	(CM_PREPARE_TO_RECEIVE_TYPE) 1
+#define CM_PREP_TO_RECEIVE_CONFIRM	(CM_PREPARE_TO_RECEIVE_TYPE) 2
+
+/* processing_mode values. */
+#define CM_BLOCKING			(CM_PROCESSING_MODE) 0
+#define CM_NON_BLOCKING			(CM_PROCESSING_MODE) 1
+
+/* receive_type values. */
+#define CM_RECEIVE_AND_WAIT		(CM_RECEIVE_TYPE) 0
+#define CM_RECEIVE_IMMEDIATE		(CM_RECEIVE_TYPE) 1
+
+/* return_code values. */
+#define CM_OK				(CM_RETURN_CODE) 0
+#define CM_ALLOCATE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 1
+#define CM_ALLOCATE_FAILURE_RETRY	(CM_RETURN_CODE) 2
+#define CM_CONVERSATION_TYPE_MISMATCH	(CM_RETURN_CODE) 3
+#define CM_PIP_NOT_SPECIFIED_CORRECTLY	(CM_RETURN_CODE) 5
+#define CM_SECURITY_NOT_VALID		(CM_RETURN_CODE) 6
+#define CM_SYNC_LVL_NOT_SUPPORTED_LU	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_SYS	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_PGM	(CM_RETURN_CODE) 8
+#define CM_TPN_NOT_RECOGNIZED		(CM_RETURN_CODE) 9
+#define CM_TP_NOT_AVAILABLE_NO_RETRY	(CM_RETURN_CODE) 10
+#define CM_TP_NOT_AVAILABLE_RETRY	(CM_RETURN_CODE) 11
+#define CM_DEALLOCATED_ABEND		(CM_RETURN_CODE) 17
+#define CM_DEALLOCATED_NORMAL		(CM_RETURN_CODE) 18
+#define CM_PARAMETER_ERROR		(CM_RETURN_CODE) 19
+#define CM_PRODUCT_SPECIFIC_ERROR	(CM_RETURN_CODE) 20
+#define CM_PROGRAM_ERROR_NO_TRUNC	(CM_RETURN_CODE) 21
+#define CM_PROGRAM_ERROR_PURGING	(CM_RETURN_CODE) 22
+#define CM_PROGRAM_ERROR_TRUNC		(CM_RETURN_CODE) 23
+#define CM_PROGRAM_PARAMETER_CHECK	(CM_RETURN_CODE) 24
+#define CM_PROGRAM_STATE_CHECK		(CM_RETURN_CODE) 25
+#define CM_RESOURCE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 26
+#define CM_RESOURCE_FAILURE_RETRY	(CM_RETURN_CODE) 27
+#define CM_UNSUCCESSFUL			(CM_RETURN_CODE) 28
+#define CM_DEALLOCATED_ABEND_SVC	(CM_RETURN_CODE) 30
+#define CM_DEALLOCATED_ABEND_TIMER	(CM_RETURN_CODE) 31
+#define CM_SVC_ERROR_NO_TRUNC		(CM_RETURN_CODE) 32
+#define CM_SVC_ERROR_PURGING		(CM_RETURN_CODE) 33
+#define CM_SVC_ERROR_TRUNC		(CM_RETURN_CODE) 34
+#define CM_OPERATION_INCOMPLETE		(CM_RETURN_CODE) 35
+#define CM_SYSTEM_EVENT			(CM_RETURN_CODE) 36
+#define CM_OPERATION_NOT_ACCEPTED	(CM_RETURN_CODE) 37
+#define CM_CONVERSATION_ENDING		(CM_RETURN_CODE) 38
+#define CM_SEND_RCV_MODE_NOT_SUPPORTED	(CM_RETURN_CODE) 39
+#define CM_BUFFER_TOO_SMALL		(CM_RETURN_CODE) 40
+#define CM_EXP_DATA_NOT_SUPPORTED	(CM_RETURN_CODE) 41
+#define CM_DEALLOC_CONFIRM_REJECT	(CM_RETURN_CODE) 42
+#define CM_ALLOCATION_ERROR		(CM_RETURN_CODE) 43
+#define CM_RETRY_LIMIT_EXCEEDED		(CM_RETURN_CODE) 44
+#define CM_NO_SECONDARY_INFORMATION	(CM_RETURN_CODE) 45
+#define CM_SECURITY_NOT_SUPPORTED	(CM_RETURN_CODE) 46
+#define CM_SECURITY_MUTUAL_FAILED	(CM_RETURN_CODE) 47
+#define CM_CALL_NOT_SUPPORTED		(CM_RETURN_CODE) 48
+#define CM_PARM_VALUE_NOT_SUPPORTED	(CM_RETURN_CODE) 49
+#define CM_TAKE_BACKOUT			(CM_RETURN_CODE) 100
+#define CM_DEALLOCATED_ABEND_BO		(CM_RETURN_CODE) 130
+#define CM_DEALLOCATED_ABEND_SVC_BO	(CM_RETURN_CODE) 131
+#define CM_DEALLOCATED_ABEND_TIMER_BO	(CM_RETURN_CODE) 132
+#define CM_RESOURCE_FAIL_NO_RETRY_BO	(CM_RETURN_CODE) 133
+#define CM_RESOURCE_FAILURE_RETRY_BO	(CM_RETURN_CODE) 134
+#define CM_DEALLOCATED_NORMAL_BO	(CM_RETURN_CODE) 135
+#define CM_CONV_DEALLOC_AFTER_SYNCPT	(CM_RETURN_CODE) 136
+#define CM_INCLUDE_PARTNER_REJECT_BO	(CM_RETURN_CODE) 137
+
+/* return_control values. */
+#define CM_WHEN_SESSION_ALLOCATED	(CM_RETURN_CONTROL) 0
+#define CM_IMMEDIATE			(CM_RETURN_CONTROL) 1
+
+/* send_receive_mode values. */
+#define CM_HALF_DUPLEX			(CM_SEND_RECEIVE_MODE) 0
+#define CM_FULL_DUPLEX			(CM_SEND_RECEIVE_MODE) 1
+
+/* send_type values. */
+#define CM_BUFFER_DATA			(CM_SEND_TYPE) 0
+#define CM_SEND_AND_FLUSH		(CM_SEND_TYPE) 1
+#define CM_SEND_AND_CONFIRM		(CM_SEND_TYPE) 2
+#define CM_SEND_AND_PREP_TO_RECEIVE	(CM_SEND_TYPE) 3
+#define CM_SEND_AND_DEALLOCATE		(CM_SEND_TYPE) 4
+
+/* status_received values. */
+#define CM_NO_STATUS_RECEIVED		(CM_STATUS_RECEIVED) 0
+#define CM_SEND_RECEIVED		(CM_STATUS_RECEIVED) 1
+#define CM_CONFIRM_RECEIVED		(CM_STATUS_RECEIVED) 2
+#define CM_CONFIRM_SEND_RECEIVED	(CM_STATUS_RECEIVED) 3
+#define CM_CONFIRM_DEALLOC_RECEIVED	(CM_STATUS_RECEIVED) 4
+#define CM_TAKE_COMMIT			(CM_STATUS_RECEIVED) 5
+#define CM_TAKE_COMMIT_SEND		(CM_STATUS_RECEIVED) 6
+#define CM_TAKE_COMMIT_DEALLOCATE	(CM_STATUS_RECEIVED) 7
+#define CM_TAKE_COMMIT_DATA_OK		(CM_STATUS_RECEIVED) 8
+#define CM_TAKE_COMMIT_SEND_DATA_OK	(CM_STATUS_RECEIVED) 9
+#define CM_TAKE_COMMIT_DEALLOC_DATA_OK	(CM_STATUS_RECEIVED) 10
+#define CM_PREPARE_OK			(CM_STATUS_RECEIVED) 11
+#define CM_JOIN_TRANSACTION		(CM_STATUS_RECEIVED) 12
+
+/* sync_level values. */
+#define CM_NONE				(CM_SYNC_LEVEL) 0
+#define CM_CONFIRM			(CM_SYNC_LEVEL) 1
+#define CM_SYNC_POINT			(CM_SYNC_LEVEL) 2
+#define CM_SYNC_POINT_NO_CONFIRM	(CM_SYNC_LEVEL) 3
+
+/* conversation_security_type values. */
+#define CM_SECURITY_NONE		(CM_CONVERSATION_SECURITY_TYPE) 0
+#define CM_SECURITY_SAME		(CM_CONVERSATION_SECURITY_TYPE) 1
+#define CM_SECURITY_PROGRAM		(CM_CONVERSATION_SECURITY_TYPE) 2
+#define CM_SECURITY_DISTRIBUTED		(CM_CONVERSATION_SECURITY_TYPE) 3
+#define CM_SECURITY_MUTUAL		(CM_CONVERSATION_SECURITY_TYPE) 4
+#define CM_SECURITY_PROGRAM_STRONG	(CM_CONVERSATION_SECURITY_TYPE) 5
+
+/* transaction_control values. */
+#define CM_CHAINED_TRANSACTIONS		(CM_TRANSACTION_CONTROL) 0
+#define CM_UNCHAINED_TRANSACTIONS	(CM_TRANSACTION_CONTROL) 1
+
+/* maximum sizes of strings and buffers. */
+#define CM_CID_SIZE	(8)	/* converstation ID. */
+#define CM_CTX_SIZE	(32)	/* context ID. */
+#define CM_LD_SIZE	(512)	/* log data. */
+#define CM_MN_SIZE	(8)	/* mode name. */
+#define CM_PLN_SIZE	(17)	/* partner LU name. */
+#define CM_PW_SIZE	(10)	/* password. */
+#define CM_SDN_SIZE	(8)	/* synbolic destination name. */
+#define CM_TPN_SIZE	(64)	/* TP name. */
+#define CM_UID_SIZE	(10)	/* userid ID. */
+
+CM_ENTRY cmacci(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmaccp(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmallc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcanc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfm(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfmd(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvo(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdeal(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdfde(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmecs(unsigned char CM_PTR,
+        CM_CONVERSATION_STATE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmect(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmectx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmembs(CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmemn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesui(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmflus(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmincl(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminic(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminit(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmprep(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmptr(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcv(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_STATUS_RECEIVED CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcvx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrts(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsac(unsigned char CM_PTR,
+        CM_ALLOCATE_CONFIRM_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsbt(unsigned char CM_PTR,
+        CM_BEGIN_TRANSACTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsp(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscst(unsigned char CM_PTR,
+        CM_CONVERSATION_SECURITY_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsu(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsct(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscu(unsigned char CM_PTR,
+        CM_CONFIRMATION_URGENCY CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsdt(unsigned char CM_PTR,
+        CM_DEALLOCATE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsed(unsigned char CM_PTR,
+        CM_ERROR_DIRECTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsend(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmserr(unsigned char CM_PTR,
+	CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsf(unsigned char CM_PTR,
+        CM_FILL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsld(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsmn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsndx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspdp(unsigned char CM_PTR,
+        CM_PREPARE_DATA_PERMITTED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspm(unsigned char CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsptr(unsigned char CM_PTR,
+        CM_PREPARE_TO_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqcf(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqpm(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrc(unsigned char CM_PTR,
+        CM_RETURN_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrt(unsigned char CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsst(unsigned char CM_PTR,
+        CM_SEND_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmtrts(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwait(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwcmp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+
+/* Macros to use long descriptive names instead of crusty CPI-C names. */
+#define Accept_Conversation(v1,v2)			cmaccp(v1,v2)
+#define Accept_Incoming(v1,v2)				cmacci(v1,v2)
+#define Allocate(v1,v2)					cmallc(v1,v2)
+#define Cancel_Conversation(v1,v2)			cmcanc(v1,v2)
+#define Confirm(v1,v2,v3)				cmcfm(v1,v2,v3)
+#define Confirmed(v1,v2)				cmcfmd(v1,v2)
+#define Convert_Incoming(v1,v2,v3)			cmcnvi(v1,v2,v3)
+#define Convert_Outgoing(v1,v2,v3)			cmcnvo(v1,v2,v3)
+#define Deallocate(v1,v2)				cmdeal(v1,v2)
+#define Deferred_Deallocate(v1,v2)			cmdfde(v1,v2)
+#define Extract_AE_Qualifier(v1,v2,v3,v4,v5)		cmeaeq(v1,v2,v3,v4,v5)
+#define Extract_AP_Title(v1,v2,v3,v4,v5)		cmeapt(v1,v2,v3,v4,v5)
+#define Extract_Application_Context_Name(v1,v2,v3,v4)	cmeacn(v1,v2,v3,v4)
+#define Extract_Conversation_Context(v1,v2,v3,v4)	cmectx(v1,v2,v3,v4)
+#define Extract_Conversation_State(v1,v2,v3)		cmecs(v1,v2,v3)
+#define Extract_Conversation_Type(v1,v2,v3)		cmect(v1,v2,v3)
+#define Extract_Initialization_Data(v1,v2,v3,v4,v5)	cmeid(v1,v2,v3,v4,v5)
+#define Extract_Maximum_Buffer_Size(v1,v2)		cmembs(v1,v2)
+#define Extract_Mode_Name(v1,v2,v3,v4,v5)		cmemn(v1,v2,v3,v4,v5)
+#define Extract_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8,v9) \
+	cmepid(v1,v2,v3,v4,v5,v6,v7,v8,v9)
+#define Extract_Partner_LU_Name(v1,v2,v3,v4)		cmpln(v1,v2,v3,v4)
+#define Extract_Secondary_Information(v1,v2,v3,v4,v5,v6,v7) \
+	cmesi(v1,v2,v3,v4,v5,v6,v7)
+#define Extract_Security_User_ID(v1,v2,v3,v4)		cmesui(v1,v2,v3,v4)
+#define Extract_Send_Receive_Mode(v1,v2,v3)		cmesrm(v1,v2,v3)
+#define Extract_Sync_Level(v1,v2,v3)			cmesl(v1,v2,v3)
+#define Extract_Transaction_Control(v1,v2,v3)		cmetc(v1,v2,v3)
+#define Extract_TP_Name(v1,v2,v3,v4)			cmetpn(v1,v2,v3,v4)
+#define Flush(v1,v2)					cmflus(v1,v2)
+#define Include_Partner_In_Transaction(v1,v2)		cmincl(v1,v2)
+#define Initialize_Conversation(v1,v2,v3)		cminit(v1,v2,v3)
+#define Initialize_For_Incomint(v1,v2)			cminic(v1,v2)
+#define Prepare(v1,v2)					cmprep(v1,v2)
+#define Prepare_To_Receive(v1,v2)			cmptr(v1,v2)
+#define Receive(v1,v2,v3,v4,v5,v6,v7,v8)		\
+	cmrcv(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Receive_Expedited_Data(v1,v2,v3,v4,v5,v6,v7)	\
+	cmrcvx(v1,v2,v3,v4,v5,v6,v7)
+#define Release_Local_TP_Name(v1,v2,v3)			cmrltp(v1,v2,v3)
+#define Request_To_Send(v1,v2)				cmrts(v1,v2)
+#define Send_Data(v1,v2,v3,v4,v5)			cmsend(v1,v2,v3,v4,v5)
+#define Send_Error(v1,v2,v3)				cmserr(v1,v2,v3)
+#define Send_Expedited_Data(v1,v2,v3,v4,v5)		cmsndx(v1,v2,v3,v4,v5)
+#define Set_AE_Qualifier(v1,v2,v3,v4,v5)		cmsaeq(v1,v2,v3,v4,v5)
+#define Set_Allocate_Confirm(v1,v2,v3)			cmsac(v1,v2,v3)
+#define Set_AP_Title(v1,v2,v3,v4,v5)			cmsapt(v1,v2,v3,v4,v5)
+#define Set_Application_Context_Name(v1,v2,v3,v4)	cmsacn(v1,v2,v3,v4)
+#define Set_Begin_Transaction(v1,v2,v3)			cmsbt(v1,v2,v3)
+#define Set_Confirmation_Urgency(v1,v2,v3)		cmscu(v1,v2,v3)
+#define Set_Conversation_Security_Password(v1,v2,v3,v4)	cmscsp(v1,v2,v3,v4)
+#define Set_Conversation_Security_Type(v1,v2,v3)	cmscst(v1,v2,v3)
+#define Set_Conversation_Security_User_ID(v1,v2,v3,v4)	cmscsu(v1,v2,v3,v4)
+#define Set_Conversation_Type(v1,v2,v3)			cmsct(v1,v2,v3)
+#define Set_Deallocate_Type(v1,v2,v3)			cmsdt(v1,v2,v3)
+#define Set_Error_Direction(v1,v2,v3)			cmsed(v1,v2,v3)
+#define Set_Fill(v1,v2,v3)				cmsf(v1,v2,v3)
+#define Set_Initialization_Data(v1,v2,v3,v4)		cmsid(v1,v2,v3,v4)
+#define Set_Log_Data(v1,v2,v3,v4)			cmsld(v1,v2,v3,v4)
+#define Set_Mode_Name(v1,v2,v3,v4)			cmsmn(v1,v2,v3,v4)
+#define Set_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8)	\
+	cmspid(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Set_Partner_LU_Name(v1,v2,v3,v4)		cmspln(v1,v2,v3,v4)
+#define Set_Prepare_Data_Permitted(v1,v2,v3)		cmspdp(v1,v2,v3)
+#define Set_Prepare_To_Receive_Type(v1,v2,v3)		cmsptr(v1,v2,v3)
+#define Set_Processing_Mode(v1,v2,v3)			cmspm(v1,v2,v3)
+#define Set_Queue_Callback_Function(v1,v2,v3,v4,v5,v6)	\
+	cmsqcf(v1,v2,v3,v4,v5,v6)
+#define Set_Queue_Processing_Mode(v1,v2,v3,v4,v5,v6)	\
+	cmsqpm(v1,v2,v3,v4,v5,v6)
+#define Set_Receive_Type(v1,v2,v3)			cmsrt(v1,v2,v3)
+#define Set_Return_Control(v1,v2,v3)			cmsrc(v1,v2,v3)
+#define Set_Send_Type(v1,v2,v3)				cmsst(v1,v2,v3)
+#define Set_Sync_Level(v1,v2,v3)			cmssl(v1,v2,v3)
+#define Set_TP_Name(v1,v2,v3,v4)			cmstpn(v1,v2,v3,v4)
+#define Set_Transaction_Control(v1,v2,v3)		cmstc(v1,v2,v3)
+#define Specify_Local_TP_Name(v1,v2,v3)			cmsltp(v1,v2,v3)
+#define Test_Request_To_Send_Received(v1,v2,v3)		cmtrts(v1,v2,v3)
+#define Wait_For_Completion(v1,v2,v3,v4,v5,v6,v7)	\
+	cmwcmp(v1,v2,v3,v4,v5,v6,v7)
+#define Wait_For_Conversation(v1,v2,v3)			cmwait(v1,v2,v3)
+
+#define CPIC_DEFINE_SIDE                0x101D
+#define CPIC_DELETE_SIDE                0x1035
+
+struct cpic_define_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+
+        unsigned char           sym_dest_name[9];
+        unsigned char           mode_name[9];
+        unsigned char           tp_name[64];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[10];
+        unsigned char           password[10];
+};
+
+struct cpic_delete_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+        unsigned char           sym_dest_name[9];
+};
+
+struct cpicsreq {
+	struct cpicsreq		*next;
+	struct cpicsreq		*prev;
+
+	char			netid[18];
+	char			netid_plu[18];
+        char            	sym_dest_name[9];
+        char            	mode_name[9];
+        char            	tp_name[65];
+        unsigned char   	service_tp;
+        unsigned char   	security_level;
+        char            	username[11];
+        char            	password[11];
+        unsigned short  	flags;
+        unsigned long   	proc_id;
+};
+
+struct cpicsconf {
+        int     cpics_len;
+        char    cpics_net[9];
+        char    cpics_name[9];
+        char    cpics_plunet[9];
+        char    cpics_pluname[9];
+        char    cpics_sym_dest_name[9];
+
+        union {
+                char            *cpicsc_buf;
+                struct cpicsreq   *cpicsc_req;
+        } cpicsc_cpicscu;
+};
+
+struct sna_qcpics {
+        struct sna_qcpics *next;
+        struct cpicsreq   data;
+};
+
+#define cpicsc_buf cpicsc_cpicscu.cpicsc_buf         /* buffer address       */
+#define cpicsc_req cpicsc_cpicscu.cpicsc_req         /* array of structures  */
+
+/* Input/Output CPI-C call structure. */
+typedef struct {
+        unsigned long   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
+} cpic_args;
+
+#define cargo1(a, v1)                   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1;
+
+#define cargo2(a, v1, v2)               \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2;
+
+#define cargo3(a, v1, v2, v3)           \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3;
+
+#define cargo4(a, v1, v2, v3, v4)       \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4;
+
+#define cargo5(a, v1, v2, v3, v4, v5)   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5;
+
+#define cargo6(a, v1, v2, v3, v4, v5, v6) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6;
+
+#define cargo7(a, v1, v2, v3, v4, v5, v6, v7) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6; \
+        a->a7 = (unsigned long *)v7;
+
+#endif	/* _CPIC_H */
diff -ruN linux-2.4.13/include/linux/fs.h linux/include/linux/fs.h
--- linux-2.4.13/include/linux/fs.h	Tue Oct 23 21:59:06 2001
+++ linux/include/linux/fs.h	Wed Nov  7 11:06:38 2001
@@ -27,6 +27,9 @@
 
 struct poll_table_struct;
 
+#include <linux/cpic.h>
+#include <net/cpic.h>
+#include <linux/attach.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -463,6 +466,8 @@
 
 	unsigned int		i_flags;
 	unsigned char		i_sock;
+	unsigned char		i_cpic;
+	unsigned char		i_attach;
 
 	atomic_t		i_writecount;
 	unsigned int		i_attr_flags;
@@ -495,6 +500,8 @@
 		struct socket			socket_i;
 		struct usbdev_inode_info        usbdev_i;
 		struct jffs2_inode_info		jffs2_i;
+		struct cpic			cpic_i;
+		struct attach			attach_i;
 		void				*generic_ip;
 	} u;
 };
diff -ruN linux-2.4.13/include/linux/if_arp.h linux/include/linux/if_arp.h
--- linux-2.4.13/include/linux/if_arp.h	Tue Oct 23 21:59:29 2001
+++ linux/include/linux/if_arp.h	Wed Nov  7 11:07:57 2001
@@ -50,9 +50,11 @@
 #define ARPHRD_ROSE	270
 #define ARPHRD_X25	271		/* CCITT X.25			*/
 #define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CHANNEL	273		/* ESCON / Bus-Tag channel	*/
 #define ARPHRD_PPP	512
 #define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
 #define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_SDLC	514		/* SDLC				*/
 #define ARPHRD_LAPB	516		/* LAPB				*/
 #define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
 #define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
diff -ruN linux-2.4.13/include/linux/if_ether.h linux/include/linux/if_ether.h
--- linux-2.4.13/include/linux/if_ether.h	Thu Apr 19 08:38:50 2001
+++ linux/include/linux/if_ether.h	Sat Nov  3 13:18:54 2001
@@ -55,6 +55,7 @@
 #define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
 #define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
 #define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_SNA	0x80D5		/* SNA				*/
 #define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
 #define ETH_P_IPX	0x8137		/* IPX over DIX			*/
 #define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
diff -ruN linux-2.4.13/include/linux/skbuff.h linux/include/linux/skbuff.h
--- linux-2.4.13/include/linux/skbuff.h	Tue Oct 23 21:59:23 2001
+++ linux/include/linux/skbuff.h	Wed Nov  7 11:06:56 2001
@@ -134,9 +134,24 @@
 	struct timeval	stamp;			/* Time we arrived				*/
 	struct net_device	*dev;		/* Device we arrived on/are leaving by		*/
 
+	/* Function management header */
+	union
+	{
+		struct fmhdr    *fm;
+		unsigned char   *raw;
+	} f;
+
+	/* Session layer header */
+	union
+	{
+		struct snaruhdr *ru;
+		unsigned char   *raw;
+	} s;
+
 	/* Transport layer header */
 	union
 	{
+		struct snarhdr  *rh;
 		struct tcphdr	*th;
 		struct udphdr	*uh;
 		struct icmphdr	*icmph;
@@ -149,8 +164,10 @@
 	/* Network layer header */
 	union
 	{
+		struct snathdr  *fidh;
 		struct iphdr	*iph;
 		struct ipv6hdr	*ipv6h;
+		struct larhdr   *larh;
 		struct arphdr	*arph;
 		struct ipxhdr	*ipxh;
 		unsigned char	*raw;
diff -ruN linux-2.4.13/include/linux/sna.h linux/include/linux/sna.h
--- linux-2.4.13/include/linux/sna.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/sna.h	Wed Nov  7 11:11:31 2001
@@ -0,0 +1,1147 @@
+/* sna.h: Linux-SNA Network Operator Facility Headers.
+ *
+ * Author:
+ * Jay Schulist		<jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#define SNA_NETWORK_NAME_LEN    9
+#define SNA_RESOURCE_NAME_LEN   9
+#define SNA_FQCP_NAME_LEN	18
+#define SNA_PORT_ADDR_LEN       12
+
+struct sna_netid {
+        unsigned char net[SNA_NETWORK_NAME_LEN];
+        unsigned char name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_nodeid {
+	unsigned long	block_id:12,
+			pu_id:20;
+};
+
+#define SNA_DOWN        0x1
+#define SNA_UP          0x2             /* Registed w/ the system */
+#define SNA_RUNNING     0x4             /* In a Running state */
+#define SNA_STOPPED     0x8             /* In a Stopped state */
+
+#define SNA_PORT_ROLE_PRI       0x1
+#define SNA_PORT_ROLE_SEC       0x2
+#define SNA_PORT_ROLE_NEG       0x4
+
+#ifdef __KERNEL__
+
+extern char sna_version[];
+extern char sna_maintainer[];
+extern __u32 sna_debug_level;
+
+extern void sna_mod_inc_use_count(void);
+extern void sna_mod_dec_use_count(void);
+
+extern int hexdump(unsigned char *pkt_data, int pkt_len);
+extern int sna_utok(void *uaddr, int ulen, void *kaddr);
+extern int sna_ktou(void *kaddr, int klen, void *uaddr);
+
+#define sna_debug(level, format, arg...) \
+        if(sna_debug_level > level)  \
+                printk(__FILE__ ": " format, ## arg)
+
+/* Linux-SNA Layer Identifiers */
+#define SNA_SM          0x01    /* Session Manager */
+#define SNA_HS          0x02    /* Half Session Router */
+#define SNA_INIT        0x03    /* SNA Initiator */
+#define SNA_PS          0x04    /* Presentation Services */
+#define SNA_RM          0x05    /* Resource Manager */
+#define SNA_ASM         0x06    /* Address Space Manager */
+#define SNA_SS          0x07    /* Session Services */
+
+/* Linux-SNA MU header types */
+#define SNA_MU_BIND_RQ_SEND             0x01
+#define SNA_MU_BIND_RSP_SEND            0x02
+#define SNA_MU_UNBIND_RQ_SEND           0x03
+#define SNA_MU_UNBIND_RQ_RCV            0x04
+#define SNA_MU_UNBIND_RSP_SEND          0x05
+#define SNA_MU_BIND_RQ_RCV              0x06
+#define SNA_MU_BIND_RSP_RCV             0x07
+#define SNA_MU_HS_TO_RM                 0x08
+#define SNA_MU_RM_TO_PS                 0x09
+#define SNA_MU_HS_TO_PS                 0x0A
+#define SNA_MU_PS_TO_HS                 0x0B
+#define SNA_MU_HS_TO_PC                 0x0C
+
+/* Linux-SNA Deactivate session identifiers */
+#define SNA_DEACT_PENDING               0x01
+#define SNA_DEACT_ACTIVE                0x02
+
+/* Linux-SNA Session Identifiers */
+#define SNA_SESSION_NONE                0x00    /* No Session Speaker */
+#define SNA_SESSION_FIRST_SPEAKER       0x01    /* First Speaker Session */
+#define SNA_SESSION_BIDDER              0x02    /* Bidder Session */
+#define SNA_SESSION_EITHER              0x03    /* First or Bidder Session */
+
+/* Linux-SNA Sync level indicators */
+#define SNA_SYNC_NONE                   0x01
+#define SNA_SYNC_CONFIRM                0x02
+#define SNA_SYNC_SYNCPT                 0x03
+#define SNA_SYNC_BACKOUT                0x04
+
+/* Linux-SNA HS type indicators */
+#define SNA_HS_PRI                      0x01
+#define SNA_HS_SEC                      0x02
+
+/* Linux-SNA Security indicators */
+#define SNA_SECURITY_NONE               0x01
+#define SNA_SECURITY_SAME               0x02
+#define SNA_SECURITY_PGM                0x03
+
+/* Linux-SNA sna_send_deactivate_pending() indicators */
+#define SNA_PENDING                     0x01
+#define SNA_ACTIVE                      0x02
+#define SNA_ABNORMAL                    0x03
+#define SNA_ABNORMAL_RETRY              0x04
+#define SNA_ABNORMAL_NO_RETRY           0x05
+#define SNA_CLEANUP                     0x06
+#define SNA_NORMAL                      0x07
+
+/* Linux-SNA Structure Identifiers */
+#define SNA_REC_BID                     0x001
+#define SNA_REC_BID_RSP                 0x002
+#define SNA_REC_MU                      0x003
+#define SNA_REC_MU_FMH5                 0x004
+#define SNA_REC_MU_FMH12                0x005
+#define SNA_REC_FREE_SESSION            0x006
+#define SNA_REC_RTR_RQ                  0x007
+#define SNA_REC_RTR_RSP                 0x008
+#define SNA_REC_BIS_REPLY               0x009
+#define SNA_REC_ALLOCATE_RCB            0x00A
+#define SNA_REC_GET_SESSION             0x00B
+#define SNA_REC_DEALLOCATE_RCB          0x00C
+#define SNA_REC_TERMINATE_PS            0x00D
+#define SNA_REC_CHANGE_SESSIONS         0x00E
+#define SNA_REC_RM_ACTIVATE_SESSION     0x00F
+#define SNA_REC_RM_DEACTIVATE_SESSION   0x010
+#define SNA_REC_DEACTIVATE_CONV_GROUP   0x011
+#define SNA_REC_UNBIND_PROTOCOL_ERROR   0x012
+#define SNA_REC_ABEND_NOTIFICATION      0x013
+#define SNA_REC_ACTIVATE_SESSION_RSP    0x014
+#define SNA_REC_SESSION_ACTIVATED       0x015
+#define SNA_REC_SESSION_DEACTIVATED     0x016
+#define SNA_REC_BIS_RQ                  0x017
+#define SNA_REC_ACTIVATE_SESSION        0x018
+#define SNA_REC_DEACTIVATE_SESSION      0x019
+#define SNA_REC_INIT_HS_RSP             0x01B
+#define SNA_REC_ABORT_HS                0x01C
+#define SNA_REC_INIT_SIGNAL_NEG_RSP     0x01D
+#define SNA_REC_CINIT_SIGNAL            0x01E
+#define SNA_REC_SESSION_ROUTE_INOP      0x01F
+#define SNA_REC_LFSID_IN_USE            0x020
+#define SNA_REC_BRACKET_FREED           0x021
+#define SNA_REC_BID_WITHOUT_ATTACH      0x022
+#define SNA_REC_HS_PS_CONNECTED         0x023
+#define SNA_REC_RM_HS_CONNECTED         0x024
+#define SNA_REC_SECURITY_REPLY_2        0x025
+#define SNA_REC_YIELD_SESSION           0x026
+#define SNA_REC_INIT_HS                 0x027
+#define SNA_REC_RCB_ALLOCATED           0x028
+#define SNA_REC_SESSION_ALLOCATED       0x029
+#define SNA_REC_RM_SESSION_ALLOCATED    0x02A
+#define SNA_REC_CONV_FAIL               0x02B
+#define SNA_REC_RM_SESSION_ACTIVATED    0x02C
+#define SNA_REC_START_TP                0x02D
+#define SNA_REC_FREE_LFSID              0x02E
+#define SNA_REC_PC_HS_DISCONNECT        0x02F
+#define SNA_REC_ASSIGN_LFSID            0x030
+#define SNA_REC_LFSID_IN_USE_RSP        0x031
+#define SNA_REC_INIT_SIGNAL             0x032
+#define SNA_REC_SESSEND_SIGNAL          0x033
+#define SNA_REC_SESSST_SIGNAL           0x034
+#define SNA_REC_ASSIGN_PCID             0x035
+#define SNA_REC_RCB_DEALLOCATED         0x036
+#define SNA_REC_SEND_RTR                0x037
+#define SNA_REC_RM_TIMER_POP            0x038
+
+#endif /* __KERNEL__ */
+
+#define SIOCGNODE	0x1000
+#define SIOCGDLC	0x1001
+#define SIOCGPORT	0x1002
+#define SIOCGLS		0x1003
+#define SIOCGMODE	0x1004
+#define SIOCGLU		0x1005
+#define SIOCGPLU	0x1006
+#define SIOCGCPICS	0x1007
+#define SIOCGPS		0x1008
+#define SIOCGCOS	0x1009
+
+struct cosreq {
+	struct cosreq		*next;
+	struct cosreq		*prev;
+
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+};
+
+struct cosconf {
+        int     cos_len;
+        char    cos_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *cosc_buf;
+                struct cosreq   *cosc_req;
+        } cosc_coscu;
+};
+
+struct sna_qcos {
+        struct sna_qcos *next;
+        struct cosreq   data;
+};
+
+#define cosc_buf cosc_coscu.cosc_buf              /* buffer address       */
+#define cosc_req cosc_coscu.cosc_req              /* array of structures  */
+
+struct plureq {
+	struct plureq		*next;
+	struct plureq		*prev;
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	struct sna_netid	fqcp_name;
+	unsigned char		parallel_ss;
+        unsigned char   	cnv_security;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct pluconf {
+	int	plu_len;
+	char	plu_net[SNA_NETWORK_NAME_LEN];
+	char	plu_name[SNA_RESOURCE_NAME_LEN];
+	char	plu_plunet[SNA_NETWORK_NAME_LEN];
+	char	plu_pluname[SNA_RESOURCE_NAME_LEN];
+	char	plu_fqcpnet[SNA_NETWORK_NAME_LEN];
+	char	plu_fqcpname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *pluc_buf;
+                struct plureq	*pluc_req;
+        } pluc_plucu;
+};
+
+struct sna_qplu {
+        struct sna_qplu *next;
+        struct plureq   data;
+};
+
+#define pluc_buf pluc_plucu.pluc_buf              /* buffer address       */
+#define pluc_req pluc_plucu.pluc_req              /* array of structures  */
+
+struct lureq {
+	struct lureq		*next;
+	struct lureq		*prev;
+
+	struct sna_netid	netid;
+	char			name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		sync_point;
+	unsigned long		lu_sess_limit;
+	unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct luconf {
+	int             lu_len;
+        char            lu_net[SNA_NETWORK_NAME_LEN];
+        char            lu_name[SNA_RESOURCE_NAME_LEN];
+	char		lu_luname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *luc_buf;
+                struct lureq      *luc_req;
+        } luc_lucu;
+};
+
+struct sna_qlu {
+        struct sna_qlu *next;
+        struct lureq   data;
+};
+
+#define luc_buf luc_lucu.luc_buf              /* buffer address       */
+#define luc_req luc_lucu.luc_req              /* array of structures  */
+
+/* mode information request record. */
+struct modereq {
+	struct modereq		*next;
+	struct modereq		*prev;
+
+	char			mode_name[SNA_RESOURCE_NAME_LEN];
+	char			cos_name[SNA_RESOURCE_NAME_LEN];
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	unsigned long		tx_pacing;
+        unsigned long   	rx_pacing;
+        unsigned long   	max_tx_ru;
+        unsigned long   	max_rx_ru;
+        unsigned long   	crypto;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+
+	unsigned short  	auto_activation;
+        unsigned long   	max_sessions;
+        unsigned long   	min_conlosers;
+        unsigned long   	min_conwinners;
+
+        unsigned long   	act_sessions;
+        unsigned long   	act_conwinners;
+        unsigned long   	act_conlosers;
+
+        unsigned long   	pend_sessions;
+        unsigned long   	pend_conwinners;
+        unsigned long   	pend_conlosers;
+};
+
+struct modeconf {
+	int             mode_len;
+        char            mode_net[SNA_NETWORK_NAME_LEN];
+        char            mode_name[SNA_RESOURCE_NAME_LEN];
+	char		mode_modename[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *modec_buf;
+                struct modereq      *modec_req;
+        } modec_modecu;
+};
+
+struct sna_qmode {
+        struct sna_qmode *next;
+        struct modereq   data;
+};
+
+#define modec_buf modec_modecu.modec_buf              /* buffer address       */
+#define modec_req modec_modecu.modec_req              /* array of structures  */
+
+struct lsreq {
+	struct lsreq		*next;
+	struct lsreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+        char            	lsname[SNA_RESOURCE_NAME_LEN];
+	char			dname[SNA_FQCP_NAME_LEN];
+	char			daddr[12];
+	unsigned char		sport;
+	unsigned long		proc_id;
+	unsigned short		flags;
+	unsigned long		auto_act;
+	unsigned long		auto_deact;
+	unsigned long		byteswap;
+};
+
+struct lsconf {
+        int             ls_len;
+        char            ls_net[SNA_NETWORK_NAME_LEN];
+        char            ls_name[SNA_RESOURCE_NAME_LEN];
+        char            ls_devname[SNA_RESOURCE_NAME_LEN];
+        char            ls_portname[SNA_RESOURCE_NAME_LEN];
+	char		ls_lsname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *lsc_buf;
+                struct lsreq      *lsc_req;
+        } lsc_lscu;
+};
+
+struct sna_qls {
+        struct sna_qls *next;
+        struct lsreq   data;
+};
+
+#define lsc_buf lsc_lscu.lsc_buf              /* buffer address       */
+#define lsc_req lsc_lscu.lsc_req              /* array of structures  */
+
+struct portreq {
+	struct portreq		*next;
+	struct portreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+
+	char			saddr[12];
+	unsigned long		ls_qlen;
+	unsigned long		proc_id;
+	unsigned long		role;
+	unsigned long		btu;
+	unsigned long		mia;
+	unsigned long		moa;
+
+	unsigned short		flags;
+
+	struct lsreq		*ls;
+};
+
+struct portconf {
+        int             port_len;
+        char            port_net[SNA_NETWORK_NAME_LEN];
+        char            port_name[SNA_RESOURCE_NAME_LEN];
+        char            port_devname[SNA_RESOURCE_NAME_LEN];
+	char		port_portname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *portc_buf;
+                struct portreq    *portc_req;
+        } portc_portcu;
+};
+
+struct sna_qport {
+        struct sna_qport *next;
+        struct portreq   data;
+};
+
+#define portc_buf portc_portcu.portc_buf              /* buffer address       */
+#define portc_req portc_portcu.portc_req              /* array of structures  */
+
+struct dlcreq {
+	struct dlcreq		*next;
+	struct dlcreq		*prev;
+
+	struct sna_netid	netid;
+	char			devname[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		port_qlen;
+	unsigned long		proc_id;
+	unsigned short		flags;	
+
+	struct portreq		*port;
+};
+
+struct dlconf {
+        int             dlc_len;
+        char            dlc_net[SNA_NETWORK_NAME_LEN];
+        char            dlc_name[SNA_RESOURCE_NAME_LEN];
+	char		dlc_devname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *dlc_buf;
+                struct dlcreq    *dlc_req;
+        } dlc_dlcu;
+};
+
+struct sna_qdlc {
+        struct sna_qdlc *next;
+        struct dlcreq   data;
+};
+
+#define dlc_buf dlc_dlcu.dlc_buf              /* buffer address       */
+#define dlc_req dlc_dlcu.dlc_req              /* array of structures  */
+
+struct snareq {
+	char		net[SNA_NETWORK_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short   bind_seg;      /* Is Bind segmenting supported. */
+        unsigned long    max_lus;	/* Max LU sessions */
+	unsigned short	node_status;
+};
+
+struct snaconf {
+        int             snac_len;
+	char		snac_net[SNA_NETWORK_NAME_LEN];
+	char		snac_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *snac_buf;
+                struct snareq    *snac_req;
+        } snac_snacu;
+};
+
+struct sna_qsna {
+        struct sna_qsna *next;
+        struct snareq   data;
+};
+
+#define snac_buf snac_snacu.snac_buf              /* buffer address       */
+#define snac_req snac_snacu.snac_req              /* array of structures  */
+
+struct sna_all_info {
+	struct sna_all_info *next;		/* Next node */
+
+	/* Std. Node info. */
+	char		net[SNA_RESOURCE_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;      	/* Is Bind segmenting supported. */
+        unsigned long   max_lus;       	/* Max LU sessions */
+	unsigned short	node_status;	
+
+	struct modereq		*mode;
+	struct plureq		*plu;
+	struct lureq		*lu;
+	struct dlcreq		*dl;
+	struct cpicsreq		*cpics;
+	struct cosreq		*cos;
+};
+
+#define SNA_NODE_NAME_LEN	8
+
+struct sna_nof_pinfo {
+	struct sna_nof_pinfo *next;
+	struct sna_nof_pinfo *prev;
+
+	struct sna_netid 	netid;
+	struct sna_nodeid	nodeid;
+	unsigned short	status;
+	unsigned char	type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;       /* Is Bind segmenting supported. */
+        unsigned long   max_lus;        /* Max number of LU sessions,
+                                         * 0 = Unlimited.
+                                         */
+
+	/* Data below not currently used. */
+        unsigned long   netid_registered;
+        unsigned long   ls_supp_type;
+        unsigned long   resource_registration;
+        unsigned long   segment_generation_lvl;
+        unsigned long   mode_to_cos_mapping;
+        unsigned long   ms_node_type;
+        unsigned long   mj_vector_file;
+        unsigned long   ms_log_file;
+        unsigned long   peer_resource_registration;
+        unsigned long   network_node_type;
+        unsigned long   directory_type_supp;
+        unsigned long   rs_tree_update_type;
+        unsigned long   tdm_node_name;
+        unsigned long   cosdm_node_name;
+        unsigned long   max_rs_cache_trees;
+        unsigned long   max_oos_tdm_updates;
+        unsigned long   resource_service_search;
+        unsigned long   general_odai_usage_supp;
+};
+
+#define SNA_NOF_NODE_SHUTDOWN_RQ		0xFFFF
+
+#define SNA_CP_CREATE_PARMS_RQ			0x0100
+struct sna_cp_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_cp;
+	unsigned long	*netid;
+	unsigned long	bind_reassembly;
+	unsigned long	adaptive_bind_pacing;
+	unsigned long	sense;
+};
+
+#define SNA_TRS_CREATE_PARMS_RQ			0x0102
+struct sna_trs_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	node_type;
+	unsigned long	*cp_name;
+	unsigned long	netid;
+	unsigned long	rs_tree_caching;
+	unsigned long	incr_rs_tree_updates;
+	unsigned long	max_rs_trees;
+	unsigned long	max_tdm_nodes;
+	unsigned long	max_oos_tdus;
+	unsigned long	cosdm_file_name;
+	unsigned long	tdm_file_name;
+	unsigned long	gateway;
+	unsigned long	central_directory_server;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NAME		0x9998
+struct sna_query_connection_name {
+	char 		connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned 	long sense;
+};
+
+#define SNA_ACTIVATE_CONTROL_SESSIONS	0x1000
+struct sna_activate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*remote_cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_CHANGE_SESSION_LIMIT		0x1002
+struct sna_change_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	new_limit_conwinner;
+	unsigned long	new_limit_conloser;
+	unsigned long	deactivating_lu;
+	unsigned long   sense;
+};
+
+#define SNA_DEACTIVATE_CONTROL_SESSIONS	0x1004
+struct sna_deactivate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_ADJACENT_NODE		0x1006
+struct sna_define_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long	cp_capabilities;
+	unsigned long	node_type;
+	unsigned long	auth_lvl_adj_node;
+	unsigned long	*netid_lu_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_CLASS_OF_SERVICE		0x1008
+struct sna_define_cos {
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+
+	/* Tg Characteristics */
+	unsigned short	tg_rsn;
+	unsigned short  min_cost_per_connect;
+        unsigned short  max_cost_per_connect;
+        unsigned short  min_cost_per_byte;
+        unsigned short  max_cost_per_byte;
+        unsigned short  min_security;
+        unsigned short  max_security;
+        unsigned short  min_propagation_delay;
+        unsigned short  max_propagation_delay;
+        unsigned short  min_effective_capacity;
+        unsigned short  max_effective_capacity;
+        unsigned short  min_user1;
+        unsigned short  max_user1;
+        unsigned short  min_user2;
+        unsigned short  max_user2;
+        unsigned short  min_user3;
+        unsigned short  max_user3;
+
+	/* Node Characteristics */
+	unsigned short  node_rsn;
+        unsigned short  min_route_resistance;
+	unsigned short	max_route_resistance;
+        unsigned short  min_node_congested;
+	unsigned short	max_node_congested;
+};
+
+#define SNA_DEFINE_CONNECTION_NETWORK	0x100A
+struct sna_define_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid;
+	unsigned long	tg_characteristics;
+	unsigned long	port_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_DIRECTORY_ENTRY		0x100C
+struct sna_define_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource;
+	unsigned long	entry_class;
+	unsigned long	directory_entry_scope;
+	unsigned long	registration_requirements;
+	unsigned long   sense;
+};
+
+#define SNA_LS_MODE_ABM				0x1
+#define SNA_LS_MODE_NRM				0x2
+
+#define SNA_DEFINE_ISR_TUNING		0x1010
+struct sna_define_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*secondary_lu_name;
+	unsigned long	*mode_name;
+	unsigned long	slu_mode_entry;
+	unsigned long	pri_rws;
+	unsigned long	sec_rws;
+	unsigned long	max_pri_rws;
+	unsigned long	max_sec_rws;
+	unsigned long	nonreserved_perm_buf_pool_size;
+	unsigned long	max_pri_ru_size;
+	unsigned long	max_sec_ru_size;
+	unsigned long	adaptive_session_lvl_pacing;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_LINK_STATION		0x1012
+struct sna_define_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+        char    saddr[SNA_PORT_ADDR_LEN];       /* 0x04 */
+
+	struct sna_netid plu_name;
+	char	dname[7];			/* Dest. MAC addr */
+	char	daddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+
+	int byteswap;
+	int retry_on_fail;
+        int retry_times;
+        int autoact;
+        int autodeact;
+        int tg_number;
+        int cost_per_byte;
+        int cost_per_connect_time;
+        int effective_capacity;
+        int propagation_delay;
+        int security;
+        int user1;
+        int user2;
+        int user3;
+};
+
+#define SNA_DEFINE_LOCAL_LU			0x1014
+struct sna_define_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char	sync_point;
+	unsigned long	lu_sess_limit;
+
+	/* Data below not used */
+	unsigned long	reg_requirments;
+	unsigned long	bind_range_process;
+	unsigned long	queueing_capability;
+	unsigned long	map_lu_names_list;
+};
+
+#define SNA_DEFINE_MODE			0x1016
+struct sna_define_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		tx_pacing;
+	unsigned long		rx_pacing;
+	unsigned long		max_tx_ru;
+	unsigned long		max_rx_ru;
+	unsigned char		crypto;
+	unsigned long		min_conwinners;
+	unsigned long		min_conlosers;
+	unsigned long		max_sessions;
+	unsigned char		auto_activation;
+};
+
+#define SNA_DEFINE_NODE_CHARS		0x1018
+struct sna_define_node_chars {
+	struct sna_netid	cp_name;
+	unsigned char		route_resistance;
+	unsigned char		quiescing;
+};
+
+#define SNA_DEFINE_PARTNER_LU		0x101A
+struct sna_define_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+	struct sna_netid netid_fqcp;
+	unsigned char 	parallel_ss;
+	unsigned char 	cnv_security;
+
+	/* Data below not used. */
+	unsigned long	init_lu_type;
+	unsigned long	multi_sessions;
+	unsigned long	cnos_lvl_exchg;
+	unsigned long	password;
+	unsigned long	lu_access_security;
+};
+
+#define SNA_DEFINE_PORT			0x101C
+struct sna_define_port {
+	struct sna_netid netid;
+	char	name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x4 */
+	unsigned long	role;		/* PRI */
+	unsigned long	btu;		/* Max Rx/Tx BTU size. */
+	unsigned long	mia;		/* Max inbound activations */
+	unsigned long	moa;		/* Max outbound activations */
+	
+	unsigned long	link_station_txrx;
+	unsigned long	max_nonack_xid;
+};
+
+#define SNA_DEFINE_TP			0x101E
+struct sna_define_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	init_tp_status;
+	unsigned long	conv_types_allowed;
+	unsigned long	sync_lvl_supp;
+	unsigned long	pip_lvl;
+	unsigned long	num_pip_parms;
+	unsigned long	data_map_supp;
+	unsigned long	fm_hdr_supp;
+	unsigned long	max_concurrent_tp_instances;
+	unsigned long	*issue_verb_list;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ADJACENT_NODE		0x1020
+struct sna_delete_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_CLASS_OF_SERVICE		0x1022
+struct sna_delete_cos {
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_CONNECTION_NETWORK	0x1024
+struct sna_delete_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_net;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_DIRECTORY_ENTRY		0x1026
+struct sna_delete_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource_name;
+	unsigned long	parent_resource_type;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ISR_TUNING		0x102A
+struct sna_delete_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	mode_name;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_LINK_STATION		0x102C
+struct sna_delete_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN]; 
+	char	dname[17];
+	char	daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_DELETE_LOCAL_LU			0x102E
+struct sna_delete_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_MODE			0x1030
+struct sna_delete_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_PARTNER_LU		0x1032
+struct sna_delete_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+};
+
+#define SNA_DELETE_PORT			0x1034
+struct sna_delete_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_DELETE_TP			0x1036
+struct sna_delete_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long   sense;
+};
+
+#define SNA_INITIALIZE_SESSION_LIMIT		0x1038
+struct sna_initialize_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	max_session_limit;
+	unsigned long	max_session_limit_conwinner;
+	unsigned long	max_session_limit_conloser;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CLASS_OF_SERVICE		0x103A
+struct sna_query_class_of_service {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cos_name;
+
+	unsigned long	tx_priority;
+	unsigned long	*mode_name_list;
+	unsigned long	*node_weights;
+	unsigned long	*tg_weights;
+	unsigned long	default_cos;
+	unsigned long	default_blank_cos;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NETWORK		0x103C
+struct sna_query_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_network;
+
+	unsigned long	*network_control_block;
+	unsigned long	*tg_status_list;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_DLC			0x103E
+struct sna_query_dlc {
+	struct sna_netid netid;
+
+	char 		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+	unsigned long	fsm_dlc_state;
+
+	char		port_list[90];	/* Room for 10 ports to be listed. */
+};
+
+#define SNA_QUERY_ISR_TUNING			0x1040
+struct sna_query_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	*mode_name;
+
+	unsigned long	*slu_mode_entry;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_LINK_STATION		0x1042
+struct sna_query_link_station {
+	struct sna_netid *netid;
+
+	char		ls_name[SNA_RESOURCE_NAME_LEN];
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long	adj_node_type;
+	unsigned long	fsm_ls_state;
+
+	unsigned long	ls_entered_act_state;
+	unsigned long	node_act;
+	unsigned long	ls_activation;
+
+	char		dest_addr[6];
+
+	unsigned long	tx_win_size;
+	unsigned long	rx_win_size;
+
+	unsigned long	fsm_xid_state;
+	unsigned long	fsm_nonact_xid_state;
+	unsigned long	fsm_ls_role_state;
+};
+
+#define SNA_QUERY_PORT			0x1044
+struct sna_query_port {
+	struct sna_netid *netid;
+
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_system_id;
+	char		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_type;
+	unsigned long   max_rx_btu_size;
+        unsigned long   max_tx_btu_size;
+
+        unsigned long   max_adjacent_link_stations;
+        unsigned long   real_adjacent_link_stations;
+
+        unsigned long   max_inbound_activation;
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   max_outbound_activation;
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+	unsigned long   port_role;
+	unsigned long   link_station_txrx;
+	unsigned long   max_nonack_xid;
+	unsigned long	port_address;
+	unsigned long	fsm_port_state;
+};
+
+#define SNA_QUERY_STATISTICS			0x1046
+struct sna_query_stats {
+	struct sna_netid *netid;
+
+	unsigned long	*adj_link_station_name;
+	unsigned long	*sysid_dlc;
+	unsigned long	*sysid_port;
+	unsigned long	*sysid_adj_ls;
+	unsigned long	*stats;
+};
+
+#define SNA_RESET_SESSION_LIMIT		0x1048
+struct sna_reset_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	rsp_lu;
+	unsigned long	lu_session_availability;
+	unsigned long	plu_session_availability;
+	unsigned long	cnos_error_handling;
+	unsigned long   sense;
+};
+
+#define SNA_START_NODE			0x104A
+struct sna_start_node {
+	struct sna_netid 	netid;	/* Local NetID.Node. */
+	struct sna_nodeid	nodeid;	/* Local Block and PU ID. */
+	unsigned char	type;		/* Node type. */
+	unsigned short	lu_seg;		/* Is LU segmenting supported. */
+	unsigned short	bind_seg;	/* Is Bind segmenting supported. */
+	unsigned long	max_lus;	/* Max number of LU sessions,
+					 * 0 = Unlimited.
+					 */
+
+	/* Data below not used at the moment */
+	unsigned long	netid_registered;
+	unsigned long	ls_supp_type;
+	unsigned long	resource_registration;
+	unsigned long	segment_generation_lvl;
+	unsigned long	mode_to_cos_mapping;
+	unsigned long	ms_node_type;
+	unsigned long	*mj_vector_file;
+	unsigned long	*ms_log_file;
+	unsigned long	peer_resource_registration;
+	unsigned long	network_node_type;
+	unsigned long	directory_type_supp;
+	unsigned long	rs_tree_update_type;
+	unsigned long	*tdm_node_name;
+	unsigned long	*cosdm_node_name;
+	unsigned long	max_rs_cache_trees;
+	unsigned long	max_oos_tdm_updates;
+	unsigned long	*resource_service_search;
+	unsigned long	general_odai_usage_supp;
+};
+
+#define SNA_DELETE_NODE			0x104B
+struct sna_delete_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_START_DLC			0x104C
+struct sna_start_dlc {
+	char node_name[SNA_NODE_NAME_LEN];
+	unsigned long	*dlc_name;
+        unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+        unsigned long   data;
+	unsigned long   sense;
+};
+
+#define SNA_START_LINK_STATION		0x104E
+struct sna_start_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_START_PORT			0x1050
+struct sna_start_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_START_TP				0x1052
+struct sna_start_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	*pip;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_DLC				0x1054
+struct sna_stop_dlc {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*dlc_name;
+	unsigned long	deact_type;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_NODE				0x1055
+struct sna_stop_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_STOP_LINK_STATION		0x1056
+struct sna_stop_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+
+	unsigned long	deact_type;
+};
+
+#define SNA_STOP_PORT			0x1058
+struct sna_stop_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+	unsigned long	deact_type;
+};
+
+/* SNA node types. */
+#define SNA_LEN_END_NODE	0x1
+#define SNA_APPN_END_NODE	0x2
+#define SNA_APPN_NET_NODE	0x4
+
+/* SNA Network qualified name is registered or not. */
+#define SNA_NOF_NO_NETID_REG		0x0
+#define SNA_NOF_NETID_REG		0x1
+
+/* SNA resource registration indicatiors. */
+#define SNA_NOF_RESOURCE_REG_NONE	0x0
+#define SNA_NOF_RESOURCE_REG_RESOURCES	0x1
+
+/* MS node type. */
+#define SNA_NOF_MS_ENTRY_POINT		0x0
+#define SNA_NOF_MS_FOCAL_POINT		0x1
+
+#ifdef __KERNEL__
+
+#include <net/sna_formats.h>
+#include <net/sna_cbs.h>
+#include <net/sna_externs.h>
+#include <net/sna_errors.h>
+
+#endif  /* __KERNEL__ */
diff -ruN linux-2.4.13/include/linux/socket.h linux/include/linux/socket.h
--- linux-2.4.13/include/linux/socket.h	Tue Oct 23 21:59:05 2001
+++ linux/include/linux/socket.h	Wed Nov  7 11:06:38 2001
@@ -238,6 +238,10 @@
 #define SOL_AAL		265	/* ATM Adaption Layer (packet level) */
 #define SOL_IRDA        266
 
+#define SOL_SNA_NOF     278     /* SNA Network Operator Facility */
+#define SOL_SNA_CPIC    279     /* CPI-C v2.1 */
+#define SOL_SNA_PS     	281     /* Presentation Services */
+
 /* IPX options */
 #define IPX_TYPE	1
 
diff -ruN linux-2.4.13/include/linux/sysctl.h linux/include/linux/sysctl.h
--- linux-2.4.13/include/linux/sysctl.h	Tue Oct 23 21:59:06 2001
+++ linux/include/linux/sysctl.h	Wed Nov  7 11:06:41 2001
@@ -161,7 +161,8 @@
 	NET_TR=14,
 	NET_DECNET=15,
 	NET_ECONET=16,
-	NET_KHTTPD=17
+	NET_KHTTPD=17,
+	NET_SNA=18
 };
 
 /* /proc/sys/kernel/random */
@@ -207,6 +208,26 @@
 /* /proc/sys/net/ethernet */
 
 /* /proc/sys/net/802 */
+
+/* /proc/sys/net/sna */
+enum {
+        NET_SNA_MAX_LINK_STATIONS=1,
+        NET_SNA_MAX_LU=2,
+        NET_SNA_MAX_MODE=3,
+        NET_SNA_XID_RETRY=4,
+        NET_SNA_MIA=5,
+        NET_SNA_MOA=6,
+        NET_SNA_MAX_RETRY=7,
+        NET_SNA_MAX_BTU=8,
+        NET_SNA_MAX_TX_RU=9,
+        NET_SNA_MAX_RX_RU=10,
+        NET_SNA_MAX_AUTO_ACT=11,
+        NET_SNA_DEBUG=12,
+        NET_SNA_XID_IDLE_LIMIT=13,
+        NET_SNA_XID_RETRY_INTERVAL=14,
+        NET_SNA_CO_MAX_RETRIES=15,
+       	NET_SNA_MAX_LS_CNT=16
+};
 
 /* /proc/sys/net/unix */
 
diff -ruN linux-2.4.13/include/net/cpic.h linux/include/net/cpic.h
--- linux-2.4.13/include/net/cpic.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/cpic.h	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,183 @@
+#ifndef _NET_CPIC_H
+#define _NET_CPIC_H
+
+#ifdef __KERNEL__
+
+typedef enum {
+	CM_RESET = 1,
+	CM_INIT,
+	CM_SEND,
+	CM_RCV,
+	CM_SEND_PEND,
+//	CM_CONFIRM,
+	CM_CONFIRM_SEND,
+	CM_CONFIRM_DEALLOC,
+	CM_INIT_INCOMING,
+	CM_SEND_RCV,
+	CM_SEND_ONLY,
+	CM_RCV_ONLY,
+	CM_DEFER_RCV,
+	CM_DEFER_DEALLOC,
+	CM_PREPARED,
+//	CM_SYNC_POINT,
+	CM_SYNC_POINT_SEND,
+	CM_SYNC_POINT_DEALLOC
+} cpic_state;
+
+#define NETWORK_NAME_LEN    9
+#define RESOURCE_NAME_LEN   9
+struct netid {
+        unsigned char net[NETWORK_NAME_LEN];
+        unsigned char name[RESOURCE_NAME_LEN];
+};
+
+struct cpic_side_info {
+        struct cpic_side_info   *next;
+        struct cpic_side_info   *prev;
+
+        unsigned long           proc_id;
+
+	struct netid		netid;
+	struct netid		netid_plu;
+
+        unsigned char           sym_dest_name[RESOURCE_NAME_LEN];
+        unsigned char           mode_name[RESOURCE_NAME_LEN];
+        unsigned char           tp_name[65];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[11];
+        unsigned char           password[11];
+};
+
+struct cpic {
+        cpic_state              state;
+        unsigned short          flags;
+
+        struct cpic_ops         *ops;
+        struct cpic_side_info   *side;
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+        pid_t                   pid;
+
+	union {
+        	struct sna_tcb         *sna;
+	} vi;
+
+        wait_queue_head_t       wait;
+};
+
+/* Should be:
+ *
+ *	struct cpic_ops {
+ *		int family;
+ *		*release
+ *		*create
+ *		*extract
+ *		*set
+ *		*rcv
+ *		*rcvx
+ *		*send
+ *		*sendx
+ *	};
+ */
+
+struct cpic_ops {
+        int     family;
+
+	struct sna_tcb *(*find_tcb_by_pid) (pid_t pid);
+        int     (*release)      (struct cpic *cpic);
+        int     (*create)       (struct cpic *cpic, int s);
+
+        __u32 (*cmsaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+/* 5 */ __u32 (*cmsac)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmsbt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsp)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*10*/  __u32 (*cmscst)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsu)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsct)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscu)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsdt)          (struct cpic *cpic, __u32 *a1);
+/*15*/  __u32 (*cmsed)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsend)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmserr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsf)           (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsid)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*20*/  __u32 (*cmsld)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsmn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsndx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmspdp)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmspid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+/*25*/  __u32 (*cmspln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmspm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsptr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsqcf)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+        __u32 (*cmsqpm)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+/*30*/  __u32 (*cmsrc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsrt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssrm)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsst)          (struct cpic *cpic, __u32 *a1);
+/*35*/  __u32 (*cmstc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmstpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmeapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmeacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*40*/  __u32 (*cmecs)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmect)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmectx)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeid)  (struct cpic *cpic, __u32 *a1, __u32 *a2, __u32 *a3);
+        __u32 (*cmemn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*45*/  __u32 (*cmepid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6, __u32 *a7);
+        __u32 (*cmepln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmesi)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+        __u32 (*cmesl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmesrm)         (struct cpic *cpic, __u32 *a1);
+/*50*/  __u32 (*cmesui)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmetc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmetpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmallc)         (struct cpic *cpic);
+        __u32 (*cmcanc)         (struct cpic *cpic);
+/*55*/  __u32 (*cmcfmd)         (struct cpic *cpic);
+        __u32 (*cmcfm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmdeal)         (struct cpic *cpic);
+        __u32 (*cmrcv)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+        __u32 (*cmdfde)         (struct cpic *cpic);
+/*60*/  __u32 (*cmacci)         (struct cpic *cpic);
+        __u32 (*cmwait)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsltp)         (__u32 *a1, __u32 *a2);
+        __u32 (*cmflus)         (struct cpic *cpic);
+        __u32 (*cmincl)         (struct cpic *cpic);
+/*65*/  __u32 (*cmprep)         (struct cpic *cpic);
+        __u32 (*cmptr)          (struct cpic *cpic);
+        __u32 (*cmrcvx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5);
+        __u32 (*cmrts)          (struct cpic *cpic);
+        __u32 (*cmtrts)         (struct cpic *cpic, __u32 *a1);
+/*70*/  __u32 (*cminic)         (struct cpic *cpic);
+};
+
+extern int cpic_query_side_info(char *arg);
+extern int cpic_register_side_info(struct cpic_define_side_info *side);
+extern int cpic_unregister_side_info(struct cpic_delete_side_info *side);
+extern int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int cpic_register(struct cpic_ops *ops);
+extern int cpic_unregister(int family);
+
+#endif  /* __KERNEL__ */
+#endif /* _NET_CPIC_H */
diff -ruN linux-2.4.13/include/net/sna_cbs.h linux/include/net/sna_cbs.h
--- linux-2.4.13/include/net/sna_cbs.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_cbs.h	Wed Nov  7 11:11:31 2001
@@ -0,0 +1,1896 @@
+/* sna_cbs.h: Linux-SNA Control blocks and layer specific declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_CBS_H
+#define __NET_SNA_CBS_H
+
+#ifdef __KERNEL__
+
+#include <linux/netdevice.h>
+
+/* CREATE.
+ */
+
+struct sna_hs_create_parms {
+        __u8 lu_id;
+        __u8 hs_id;
+};
+
+struct sna_ps_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+
+        struct sna_tcb *tcb_list_ptr;
+        __u8 tcb_id;
+
+        struct sna_rcb *rcb_list_ptr;
+};
+
+struct sna_rm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_sm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_rm_created {
+        __u8 lu_id;
+};
+
+/* ASM.
+ */
+
+struct sna_session_id {
+        __u16   sidh:8,
+                sidl:8;
+};
+
+/* Structure size is 17bits */
+struct sna_lfsid {
+        __u8    odai:1;		/* Pri = 0x0, Sec = 0x1 */
+        union {
+                __u16 raw;
+                struct sna_session_id hl;
+        } sid;
+};
+
+struct sna_assign_lfsid {
+	unsigned char 	 pc_id[8];
+	unsigned short	 sm_id;
+        struct sna_lfsid lfsid;
+};
+
+struct sna_free_lfsid {
+	unsigned char	 pc_id[8];
+	unsigned short	 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_linfo{
+	__u8		 active:1;	/* 1 = active, 0 = inactive */ 
+	__u16		 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_lfsid_block {
+	struct sna_lfsid_block *next;
+	struct sna_lfsid_block *prev;
+
+	struct sna_linfo l[256];
+};
+
+/* one for each PC */
+struct sna_asm_pinfo {
+        struct sna_asm_pinfo *next;
+        struct sna_asm_pinfo *prev;
+
+	unsigned char	pc_id[8];
+	unsigned char   intranode;      /* 0 = internode, 1 = intranode */
+        unsigned char   odai;           /* 0 = Pri, 1 = Sec */
+        unsigned short  max_btu;
+        unsigned char   tx_rx_bind_pacing;
+        unsigned char   dependent_lulu;
+        unsigned char   adp_bind_pacing_dep_lulu;
+        unsigned char   generalized_oadi;
+
+	/* list of 256 unique addresses */
+	unsigned short		blk_count;
+	struct sna_lfsid_block	*l_blks;
+};
+
+struct sna_activate_as {
+	unsigned char	pc_id[8];
+	unsigned char	intranode;	/* 0 = internode, 1 = intranode */
+	unsigned char	odai;		/* 0 = Pri, 1 = Sec */
+	unsigned short	max_btu;
+	unsigned char	tx_rx_bind_pacing;
+	unsigned char	dependent_lulu;
+	unsigned char	adp_bind_pacing_dep_lulu;
+	unsigned char	generalized_oadi;
+};
+
+/* CS.
+ */
+
+typedef enum {
+	SNA_XID_REMOTE_INIT = 1,
+	SNA_XID_LOCAL_INIT,
+	SNA_XID_INPUT,
+	SNA_XID_ACTIVE,
+	SNA_XID_RESET
+} xid_inputs;
+
+typedef enum {
+	SNA_XID_NULL = 1,
+	SNA_XID_PN,
+	SNA_XID_NEG
+} xid_packets;
+
+typedef enum {
+	XID_RESET = 1,
+	XID_S_NULL,
+	XID_S_PN,
+	XID_S_NEG,
+	XID_S_PRI,
+	XID_S_SEC,
+	XID_R_NULL,
+	XID_R_PN,
+	XID_R_NEG,
+	XID_R_PRI,
+	XID_R_SEC,
+	XID_ACTIVE,
+	XID_FAIL
+} xid_state;
+
+typedef enum {
+	XID_BEGIN = 1,
+	XID_NULL,
+	XID_PN,
+	XID_NEG,
+	XID_PRI,
+	XID_SEC
+} xid_input;
+
+#define	XID_OUTBOUND	0x00		/* XID CMD */
+#define XID_INBOUND	0x01		/* XID RSP */
+
+struct sna_xid_info {
+        struct sk_buff  *last_tx_xid;
+        struct sk_buff  *last_rx_xid;
+
+        xid_state               xid_status;
+        struct timer_list       xid_timer;
+        __u32                   xid_idle_limit;
+        __u32                   xid_retry_interval;
+        __u32                   xid_retry_limit;
+	__u32			xid_retries;
+
+        __u8    xid_initiator;		/* 0x00 = Local / 0x01 = Remote */
+	__u8	xid_direction;		/* 0x00 = cmd / 0x01 = rsp */
+        __u32   xid_count;              /* number of xids exchanged */
+
+        __u16   i_tx_window;
+        __u16   i_rx_window;
+        __u16   i_mtu;                  /* max btu size */
+
+        __u8    tg_type;
+        __u8    tg_id;
+
+	/* detailed xid information */
+	__u8	init_self;
+	__u8	tx_bind_wo_init_self;
+	__u8	tx_bind_piu;
+	__u8	rx_bind_piu;
+
+	__u8	adaptive_tx_bind;
+	__u8	adaptive_rx_bind;
+
+	/* Junk below but keeping around for a while */
+	__u32   adj_node_id;
+        char    real_adj_cp_name[8];
+        __u32   local_odai_value;
+        __u32   sscp_med_sessions;
+        __u32   adj_node_bind_reassembly;
+        __u32   local_cpcp_sessions_supp_status;
+        __u32   adj_node_cpcp_sessions_supp_status;
+        __u32   curr_cpcp_sessions_supp_status;
+        __u32   ss_cpcp_sessions_supp_override;
+        __u32   partner_node_type;
+        __u32   tg_sec_init_nonact_xchg;
+        __u32   restart_nonact_xid3_xchg;
+};
+
+typedef enum {
+	BIND_RESET = 1,
+	BIND_S_BIND,
+	BIND_S_BIND_W_AF,
+	BIND_S_PR_FMD,
+	BIND_S_PR_FMD_W_AF,
+	BIND_S_PR_BIND,
+	BIND_S_PR_BIND_W_AF,
+	BIND_ACTIVE
+} bind_state;
+
+struct sna_session_initiation_info {
+        char    adj_cp_name[8];
+        __u32   real_node_tgs;
+        __u32   virtual_node_tgs;
+        char    virtual_node_cp_name[8];
+};
+
+struct sna_xid_error_info {
+        __u32   sense;
+        __u32   *procedure_name;
+        __u32   byte_offset;
+        __u32   bit_offset;
+        __u32   send_xid;
+};
+
+struct sna_adj_node_cb {
+        struct sna_adj_node_cb *next;
+        struct sna_adj_node_cb *prev;
+
+        char    real_adj_cp_name[8];
+        __u32   last_adj_cp_contacted;
+        __u32   parallel_tgs;
+        __u32   tg_numbers;
+
+        struct sna_cs_process_data *cs_instance;
+};
+
+/*
+ * Link Station data structures.
+ */
+
+struct sna_activate_route {
+	unsigned char	pc_id[8];	/* associated path control */
+	unsigned long	tg_id;		/* tg to use, 0 if intranode */
+	struct sna_netid cp_name;	/* name of adjacent node */
+};
+
+#define SNA_LS_TYPE_DEFINED             0x01
+#define SNA_LS_TYPE_DYNAMIC             0x02
+#define SNA_LS_TYPE_TEMP                0x04
+struct sna_ls_cb {
+        struct sna_ls_cb *next;
+        struct sna_ls_cb *prev;
+
+        __u32 proc_id;
+        __u16 flags;
+
+        struct sna_port_cb *port;
+        struct sna_dlc_cb *dlc;
+        struct sna_netid netid;
+        unsigned char auto_act;
+        unsigned char auto_deact;
+
+        char devname[8];
+        unsigned char sport;
+
+        /* Destination node information. This is still ugly. */
+	struct sna_netid plu_name;
+        char dname[MAX_ADDR_LEN];                 /* Mac Addr */
+        char daddr[SNA_PORT_ADDR_LEN];  /* Dst. Port */
+
+	unsigned char pc_id[8];
+	unsigned char tg_id;	/* TG used by this LS */
+
+/* Data below is questionable */
+        __u32                   node_act;
+        __u32                   ls_entered_act_state;
+        __u32                   ls_activation;  /* LS capabilities. */
+
+        __u32                   adj_node_type;
+        char                    adj_node_id[8];
+        __u32                   adj_node_session;
+
+        __u32                   bind_pacing_cnt;
+        __u32                   max_tx_btu_size;
+        __u32                   max_rx_btu_size;
+
+        __u32                   tx_win_size;
+        __u32                   rx_win_size;
+
+        __u32   direction;
+        __u32   adj_ls_id;
+
+        struct sna_session_initiation_info *session_initiation_info;
+        struct sna_activate_route *activate_route_list;
+};
+
+/*
+ * Port data structures.
+ */
+
+struct sna_port_cb {
+        struct sna_port_cb *next;
+        struct sna_port_cb *prev;
+
+        struct sna_ls_cb *ls_list;
+        __u32 ls_qlen;
+
+        struct sna_netid netid;
+        struct net_device *dev;
+        char saddr[12];
+
+        __u32   proc_id;
+        __u16   flags;
+        __u32   role;
+
+        __u32   btu;
+        __u32   mia;
+        __u32   moa;
+
+#ifdef CONFIG_SNA_LLC
+        struct datalink_proto *llc_dl;
+#endif
+#ifdef CONFIG_SNA_ATM
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+#endif
+#ifdef CONFIG_SNA_SDLC
+#endif
+#ifdef CONFIG_SNA_HDLC
+#endif
+
+/* Not used below */
+        unsigned long   max_adjacent_ls;
+        unsigned long   real_adjacent_ls;
+
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+        unsigned long   link_station_txrx;
+        unsigned long   max_nonack_xid;
+
+        unsigned long   xid_exchange_type;
+};
+
+/*
+ * DLC data structures.
+ */
+
+struct sna_dlc_cb {
+        struct sna_dlc_cb *next;
+        struct sna_dlc_cb *prev;
+
+        struct sna_port_cb *port_list;
+        __u32 port_qlen;
+
+        struct net_device *dev;
+        __u16 flags;
+        __u32 proc_id;
+};
+
+struct sna_cs_pinfo {
+        struct sna_cs_pinfo *next;
+        struct sna_cs_pinfo *prev;
+
+        struct sna_netid        netid;
+	struct sna_nodeid	nodeid;
+        struct sna_dlc_cb       *dlc_list;
+
+	unsigned char		node_type;
+	unsigned char		intranode_pc_id[8];
+
+
+/* Not used below */
+        struct sna_adj_node_cb  *adj_node_cb;
+        struct sna_fq_netid     *netid_cp;
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* DFC.
+ */
+
+struct sna_lulu_cb {
+	struct sna_lulu_cb *next;
+	struct sna_lulu_cb *prev;
+
+        struct sna_netid netid;
+	struct sna_netid plu_netid;
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned char polarity;
+	unsigned long proc_id;
+	unsigned char fqpcid[8];
+	
+
+/*	Not used anymore.
+
+        __u8    ps_id;
+        __u8    bracket_id;
+        __u8    first_speaker;
+
+        struct sna_ct   ct_rcv;
+        struct sna_ct   ct_send;
+
+        sna_snf sqn_send_cnt;
+        sna_snf phs_bb_register;
+        sna_snf shs_bb_register;
+        sna_snf current_bracket_sqn;
+
+        __u8    rqd_required_on_ceb;
+        __u8    deallocate_abend;
+
+        __u16   normal_flow_rq_cnt;
+
+        __u8    sig_received;
+        sna_snf sig_snf;
+
+        __u8    betc;
+        __u8    send_error_rsp_state;
+        __u8    bb_rsp_state;
+        __u32   bb_rsp_sense;
+
+        __u8    rtr_rsp_state;
+        __u32   rtr_rsp_sense;
+
+        __u8    sig_rq_outstanding;
+        __u8    alternate_code;
+        __u8    session_just_started;
+        struct sna_mu   *saved_mu_ptr;
+*/
+};
+
+#ifdef NOT
+
+#define SNA_DFC_RQD1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 0)
+#define SNA_DFC_RQE1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 1)
+#define SNA_DFC_RQ1(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQE1(X))
+#define SNA_DFC_RQD1_HEX        0x100
+#define SNA_DFC_RQE1_HEX        0x101
+
+#define SNA_DFC_SET_RQD1(X)     (X->dr1i = 1, X->dr2i = 0, X->eri = 0)
+
+#define SNA_DFC_RQD2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ2(X)          (SNA_DFC_RQD2(X) || SNA_DFC_RQE2(X))
+#define SNA_DFC_RQD2_HEX        0x010
+#define SNA_DFC_RQE2_HEX        0x011
+
+#define SNA_DFC_RQD3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ3(X)          (SNA_DFC_RQD3(req_h) || SNA_DFC_RQE3(req_h))
+#define SNA_DFC_RQD3_HEX        0x110
+#define SNA_DFC_RQE3_HEX        0x111
+
+#define SNA_DFC_RQD(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQD2(X) || SNA_DFC_RQD3(X))
+#define SNA_DFC_RQE(X)          (SNA_DFC_RQE1(X) || SNA_DFC_RQE2(X) || SNA_DFC_RQE3(X))
+
+#define SNA_DFC_POS_RSP(X)      (SNA_DFC_RQD(X))
+#define SNA_DFC_NEG_RSP(X)      (SNA_DFC_RQE(X))
+
+#define SNA_DFC_TRUE    0x1
+#define SNA_DFC_FALSE   0x0
+
+#define SNA_DFC_YES     0x1
+#define SNA_DFC_NO      0x0
+
+#define SNA_DFC_NEG     0x0
+#define SNA_DFC_POS     0x1
+
+#define SNA_DFC_SIG_CURRENT     0x0
+#define SNA_DFC_SIG_STRAY       0x1
+#define SNA_DFC_SIG_FUTURE      0x2
+
+#define SNA_DFC_RESET           0x0
+#define SNA_DFC_NEG_OWED        0x1
+#define SNA_DFC_POS_OWED        0x2
+
+#define SNA_CT_CRV      0x0
+#define SNA_CT_BIS      0x1
+#define SNA_CT_LUSTAT   0x2
+#define SNA_CT_RTR      0x3
+#define SNA_CT_SIG      0x4
+#define SNA_CT_OTHER    0x5
+
+#define SNA_CT_RQCODE_EC        0x6
+
+struct sna_ct {
+        __u8    entry_present;
+        sna_snf snf;
+        __u32   neg_rsp_sense;
+        struct sna_rh rh;
+        __u16   rq_code;
+};
+
+/* Finite State Machine definitions and structures. */
+#define SNA_DFC_FSM_CURRENT     0x0     /* Current FSM state. */
+
+#define SNA_DFC_FSM_R           0x0     /* MU is being received. */
+#define SNA_DFC_FSM_S           0x1     /* MU is being sent. */
+
+#define SNA_DFC_FSM_NO_CHAIN    0x0
+#define SNA_DFC_FSM_BEGIN_CHAIN 0x1
+#define SNA_DFC_FSM_END_CHAIN   0x2
+
+#define SNA_DFC_FSM_BETB        0x01
+#define SNA_DFC_FSM_BETC        0x01
+#define SNA_DFC_FSM_INB         0x02
+#define SNA_DFC_FSM_INC         0x02
+#define SNA_DFC_FSM_NEG         0x03
+#define SNA_DFC_FSM_RSP         0x03
+#define SNA_DFC_FSM_SENT        0x03
+#define SNA_DFC_FSM_PEND        0x04
+#define SNA_DFC_FSM_SEND        0x05
+
+#define SNA_DFC_FSM_PEND_SEND_REPLY     0x06
+#define SNA_DFC_FSM_PEND_RCV_REPLY      0x07
+#define SNA_DFC_FSM_PEND_REPLY          0x08
+
+#define SNA_DFC_FSM_BB                  0x0
+#define SNA_DFC_FSM_RQD                 0x0
+#define SNA_DFC_FSM_RQE                 0x1
+#define SNA_DFC_FSM_REPLY               0x2
+#define SNA_DFC_FSM_BIS                 0x3
+#define SNA_DFC_FSM_RTR                 0x4
+#define SNA_DFC_FSM_FMH5                0x5
+#define SNA_DFC_FSM_FMH12               0x6
+#define SNA_DFC_FSM_LUSTAT              0x7
+#define SNA_DFC_FSM_NOT_BID_REPLY       0x8
+#define SNA_DFC_FSM_CEB_UNCOND          0x9
+
+#endif
+
+/* DS.
+ */
+
+struct sna_ds_pinfo {
+        struct sna_ds_pinfo *next;
+        struct sna_ds_pinfo *prev;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* HS.
+ */
+
+#define SNA_LOCAL_CRV           0x00
+#define SNA_LOCAL_NO_CRV        0x01
+#define SNA_LOCAL_BIS           0x10
+#define SNA_LOCAL_NO_BIS        0x11
+#define SNA_LOCAL_LUSTAT        0x20
+#define SNA_LOCAL_NO_LUSTAT     0x21
+#define SNA_LOCAL_RTR           0x30
+#define SNA_LOCAL_NO_RTR        0x31
+#define SNA_LOCAL_SIG           0x40
+#define SNA_LOCAL_NO_SIG        0x41
+#define SNA_LOCAL_OTHER         0x50
+#define SNA_LOCAL_NO_OTHER      0x51
+
+#define SNA_HS_SEND             0x0
+#define SNA_HS_RECEIVE          0x1
+
+#ifdef NOT
+
+struct sna_hs_local {
+        __u8    hs_id;          /* ID of this HS. */
+        __u8    lu_id;          /* The LU for this HS. */
+        __u8    half_session;   /* SNA_PRI or SNA_SEC. */
+        __u32   sense;
+        __u8    perm_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    rq_code;
+
+        __u8    state;
+
+        struct sna_lulu_cb lulu;       /* Fields only used by DFC. */
+
+        /* Fields only used by TC. */
+        struct sna_tc_cb tcb;
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported:4,
+                crypto:4;
+
+        struct sna_mu *catch_mu;
+
+        struct sna_hs_local *next;
+        struct sna_hs_local *prev;
+};
+
+#endif
+
+/* IPC.
+ */
+
+struct sna_hs_ps_connected {
+        __u8    ps_id;
+        __u8    bracket_id;
+};
+
+struct sna_abend_notification {
+        unsigned char *abending_process;
+        __u8 process_id;
+        __u8 reason;
+};
+
+struct sna_abort_hs {
+        __u8 hs_id;
+        __u8 sense_code;
+};
+
+struct sna_activate_session_rsp {
+        __u8 correlator;
+        __u8 type;
+        __u8 session_information;
+        __u8 error_type;
+};
+
+struct sna_allocate_rcb {
+        __u8 tcb_id;
+        __u8 specific_conv_group;
+        __u8 conversation_group_id;
+        __u8 *lu_name;
+        __u8 *mode_name;
+        __u8 immediate_session;
+        __u8 sync_level;
+        __u8 security_select;
+};
+
+/* request and response structure */
+struct sna_assign_pcid {
+        unsigned short sm_proc_id;
+        unsigned char duplicate_pcid;	/* 0 = no, 1 = yes */
+	unsigned char fqpcid[8];
+};
+
+struct sna_bid {
+        __u8 hs_id;
+};
+
+struct sna_bid_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u32 sense;
+};
+
+struct sna_bid_without_attach {
+        /* Blame IBM */
+};
+
+struct sna_bis_reply {
+        __u8 hs_id;
+};
+
+struct sna_bis_rq {
+        __u8 hs_id;
+};
+
+struct sna_bracket_freed {
+        __u8 bracket_id;
+};
+
+struct sna_cos {
+	unsigned short	type;
+	unsigned char	rsv:5,
+			network_priority:1,
+			tx_priority:2;
+	unsigned char	len;
+	unsigned char	cos_name[8];
+};
+
+struct sna_cos_tpf_vector {
+	unsigned char	mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_cos	v;
+};
+
+/* Control vector 0x80 */
+struct sna_tg_id {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	pcp_len;
+	unsigned char	*pcp_name;
+	unsigned char	pcp_name_id_cn:1,
+			more_cfg_info:1,
+			hpr_support:1,
+			tg_type:2,
+			intersubnet_tg:1,
+			rsv1:1,
+			rtp_support:1;
+	unsigned short	subarea_number;
+};
+
+/* Control vector 0x81 */
+struct sna_tg_cn {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	ptg_number;
+	unsigned short	rsv1;
+};
+
+/* Control vector 0x82 */
+struct sna_tg_dlc_signal {
+	unsigned short	type;
+	unsigned char	mac[MAX_ADDR_LEN];
+	unsigned char	lsap;
+};
+
+/* Control vector 0x83 */
+struct sna_tg_cp_name {
+	unsigned char	type;
+	unsigned char	len;
+	unsigned char	*cp_name;
+	unsigned char	intersubnet_tg;
+};
+
+/* Control vector 0x46 */
+struct sna_tg_desc {
+	unsigned short	type;
+	struct sna_tg_id		id;
+	struct sna_tg_dlc_signal	dlc;
+};
+
+/* Control vector 0x47 */
+struct sna_tg_chars {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	status:1,
+			garbage:1,
+			quiescing:1,
+			cpcp_session:2,
+			rsv1:3;
+	unsigned char	effective_capacity;
+	unsigned char	rsv2[5];
+	unsigned char	cost_per_connect;
+	unsigned char	cost_per_byte;
+	unsigned char	rsv3;
+	unsigned char	security;
+	unsigned char	propagation_delay;
+	unsigned char	rsv4;
+	unsigned char	user1;
+	unsigned char	user2;
+	unsigned char	user3;
+};
+
+struct sna_tg_ttl {
+	unsigned short	type;
+	unsigned char	days;
+};
+
+/* Control vector 0x48 */
+struct sna_tg_trd {
+	unsigned short		type;
+	struct sna_tg_ttl	*ttl;
+};
+
+struct sna_tg_vector {
+	struct sna_tg_vector 	*next;
+	struct sna_tg_vector	*prev;
+
+	struct sna_tg_desc      desc;		/* Cv 0x46 */
+        struct sna_tg_chars     chars;		/* Cv 0x47 */
+	struct sna_tg_trd	trd;
+};
+
+struct sna_tg_update {
+	unsigned char		node_type;
+	unsigned char		routing;
+	struct net_device	*dev;
+	unsigned char		lsap;
+	struct sna_tg_desc	tg_desc;
+	struct sna_tg_chars	tg_chars;
+};
+
+/* Control vector 0x44 */
+struct sna_node_desc {
+	unsigned short	type;
+	unsigned char	cp_len;
+	struct sna_netid cp_name;
+	unsigned char	rsv_len;
+	unsigned char	cn:1,
+			rsv1:7;
+};
+
+/* Control vector 0x80 */
+struct sna_node_type {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	route_resistance;
+	unsigned char	congested:1,
+			interoute_depelted:1,
+			rsv1:1,
+			garbage:1,
+			rsv2:1,
+			quiescing:1,
+			rsv3:2;
+	unsigned char	gateway:1,
+			cds:1,
+			interoute:1,
+			rsv4:1,		/* Set to 1 */
+			rsv5:2,
+			rsv6:2;		/* Set to 11 */
+	unsigned char	peripheral:1,
+			interchange:1,
+			extended:1,
+			hpr:2,
+			rsv7:3;
+};
+
+/* Control vector 0x45 */
+struct sna_node_chars {
+	unsigned short		type;
+	struct sna_node_type	info;
+};
+
+struct sna_node_vector {
+	struct sna_node_desc	desc;
+	struct sna_node_chars	chars;
+};
+
+#define CO_TIMEOUT	3 * HZ
+#define CO_MAX_RETRIES	10
+
+typedef enum {
+	CO_FAIL = 0,
+	CO_RESET,
+	CO_ACTIVE,
+	CO_S_TEST_C,
+	CO_R_TEST_R,
+	CO_TEST_OK,
+} connect_out_status;
+
+struct sna_tg_cb {
+	struct sna_tg_cb	*next;
+	struct sna_tg_cb 	*prev;
+
+	connect_out_status	co_status;
+	struct timer_list	co_retry;
+	int			co_interval;
+	int			co_retries;
+	int			co_max_retries;
+
+	wait_queue_head_t       sleep;
+
+	unsigned char		lsap;
+	struct net_device 	*dev;
+
+	struct sna_xid_info 	*xid_info;
+
+	unsigned long		frsn;
+	struct timeval		updated;
+	unsigned char		tg_type;
+	unsigned char		partner_node_type;
+	unsigned char		intermediate_routing;
+
+	struct sna_tg_vector	tg_vector;
+	struct sna_cos_array	*cos_list;
+};
+
+struct sna_tdm_node_cb {
+	struct sna_tdm_node_cb	*next;
+	struct sna_tdm_node_cb	*prev;
+
+	struct sna_netid	netid;
+	unsigned long		frsn;
+	struct timeval		updated;
+
+	struct sna_node_vector	node_vector;
+	struct sna_tg_cb	*tg_list;
+	struct sna_cos_array	*cos_list;
+};
+
+struct sna_tdm_an_cb {
+	struct sna_tdm_an_cb	*next;
+	struct sna_tdm_an_cb	*prev;
+};
+
+struct sna_rss_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+};
+
+/* Control vector 0x0E */
+struct sna_cv_nn {
+	unsigned short		type;
+	unsigned char		nn_type;
+	struct sna_netid	nq_name;
+};
+
+/* Control vector 0x2B */
+struct sna_cv_rs {
+	unsigned short		type;
+	unsigned char		max_hops;
+	unsigned char		current_hops;
+	struct sna_cv_nn	nn;
+	struct sna_tg_desc	tg_desc;
+};
+
+
+struct sna_rq_single_hop_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid	dst_cp_name;
+	unsigned char		sscp;
+	unsigned char		tg_alive;
+	unsigned char		tg_types;
+	struct sna_cv_rs 	rs;
+};
+
+struct sna_rq_tg_vectors {
+	struct sna_netid	org_cp_name;
+	struct sna_netid	dst_cp_name;
+	unsigned char		type;
+	unsigned char		sscp;
+	unsigned char		tg_type;
+	unsigned char		tg_alive;
+	struct sna_tg_vector	*tg_vectors;
+};
+
+struct sna_cinit_signal {
+        __u8 fqpcid;
+        __u8 path_control_id;
+        struct sna_pc_characteristics *pc_characteristics;
+        __u8 cos_tpf_present;
+        struct sna_cos_tpf *cos_tpf;
+};
+
+struct sna_confirmed {
+        __u8 bracket_id;
+};
+
+struct sna_cosm_tg_cb {
+	struct sna_cosm_tg_cb *next;
+	struct sna_cosm_tg_cb *prev;
+
+	unsigned short  rsn;
+
+	unsigned short	min_cost_per_connect;
+	unsigned short	max_cost_per_connect;
+	unsigned short	min_cost_per_byte;
+	unsigned short	max_cost_per_byte;
+	unsigned short	min_security;
+	unsigned short	max_security;
+	unsigned short	min_propagation_delay;
+	unsigned short	max_propagation_delay;
+	unsigned short	min_effective_capacity;
+	unsigned short	max_effective_capacity;
+	unsigned short	min_user1;
+	unsigned short	max_user1;
+	unsigned short	min_user2;
+	unsigned short	max_user2;
+	unsigned short	min_user3;
+	unsigned short	max_user3;
+
+	unsigned char	operational;
+	unsigned char	quiescing;
+	unsigned char	garbage_collection;
+	unsigned char	cpcp_session_status;
+};
+
+struct sna_cosm_node_cb {
+	struct sna_cosm_node_cb *next;
+	struct sna_cosm_node_cb *prev;
+
+	unsigned short	rsn;
+
+	unsigned short	route_resistance;
+	unsigned short	node_congested;
+	unsigned short	inter_routing_depleted;
+	unsigned short	garbage_collection;
+	unsigned short	quiescing;
+	unsigned short	gateway_support;
+	unsigned short	central_directory;
+};
+
+/* Transmission Priorities */
+#define SNA_TP_LOW              0x0
+#define SNA_TP_MEDIUM           0x1
+#define SNA_TP_HIGH             0x2
+#define SNA_TP_NETWORK          0x3
+
+struct sna_cosm_cb {
+	struct sna_cosm_cb *next;
+	struct sna_cosm_cb *prev;
+
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+	unsigned short	weight;
+	unsigned short	tx_priority;
+
+	struct sna_cosm_tg_cb	*tg;
+	struct sna_cosm_node_cb	*node;
+
+	unsigned char	default_cos_invalid;
+	unsigned char	default_cos_null;
+};
+
+struct sna_conversation_failure {
+        __u8 rcb_id;
+        __u8 reason;
+};
+
+struct sna_deallocate_rcb {
+        __u8 tcb_id;
+        __u8 rcb_id;
+};
+
+struct sna_init_hs {
+        __u8    hs_id;
+        __u8    lu_id;
+        __u8    pc_id;
+        __u8    type;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        struct sna_lfsid lfsid;
+        __u8    tx_priority;
+
+        struct sna_ru_bind bind;
+};
+
+struct sna_init_hs_rsp {
+        __u8 type;
+        __u8 sense;
+        __u8 hs_id;
+};
+
+struct sna_init_signal_neg_rsp {
+        __u8 fqpcid;
+};
+
+struct sna_init_signal {
+        unsigned short sm_proc_id;
+        unsigned char fqpcid[8];
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid slu_name;
+	struct sna_netid plu_name;	/* Local netid */
+};
+
+struct sna_lfsid_in_use_rsp {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_lfsid_in_use {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_pc_hs_disconnect {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+};
+
+struct sna_rcb_deallocated {
+        /* Blame IBM */
+};
+
+struct sna_receive_error {
+        __u8 bracket_id;
+};
+
+struct sna_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rm_act_session_rq {
+        unsigned long tcb_id;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_sm_act_session_rq {
+	unsigned short correlator;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char polarity;
+};
+
+#define SNA_ACT_SESS_RETRY	0
+
+#define SNA_SESSION_ACTIVE		0
+#define SNA_SESSION_AT_LEAST_INIT_SENT	1
+#define SNA_SESSION_AT_LEAST_BIND_SENT	2
+
+struct sna_rm_deactivate_conv_group {
+        __u8 tcb_id;
+        __u8 gid;
+        __u8 sense;
+};
+
+struct sna_rm_deactivate_session {
+        __u8 tcb_id;
+        __u8 session_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_rm_hs_connected {
+        /* Blame IBM */
+};
+
+struct sna_rsp_to_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rtr_rq {
+        __u8 hs_id;
+};
+
+struct sna_rtr_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u8 sense;
+};
+
+struct sna_send_error {
+        /* Blame IBM */
+};
+
+struct sna_send_rtr {
+        /* Blame IBM */
+};
+
+struct sna_deactivate_session {
+        __u8 status;
+        __u8 correlator;
+        __u8 hs_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_sessend_signal {
+        __u8 sense;
+        __u8 fqpcid;
+        __u8 path_control_id;
+};
+
+struct sna_sessst_signal {
+        __u8 path_control_id;
+};
+
+struct sna_start_tp_reply {
+        __u8 rcode;
+        __u8 tcb_id;
+};
+
+struct sna_terminate_ps {
+        __u8 tcb_id;
+};
+
+struct sna_unbind_protocol_error {
+        __u8 tcb_id;
+        __u8 hs_id;
+        __u8 sense;
+};
+
+struct sna_yield_session {
+        /* Blame IBM */
+};
+
+/* IPM.
+ */
+
+#define SNA_RH_IPM_TYPE         0x830100
+
+struct sna_ipm {
+        __u8    type:2,
+                rscwrc:1,
+                rsv1:5;
+        __u16   format:1,
+                nws:15;
+};
+
+/* IPM type indicators */
+#define SNA_IPM_TYPE_SOL        0x0
+#define SNA_IPM_TYPE_UNSOL      0x1
+#define SNA_IPM_TYPE_RS_ACK     0x2
+#define SNA_IPM_TYPE_RSV        0x3
+
+/* Reset residual-count indicators */
+#define SNA_IPM_RS_CNT_FALSE    0x0
+#define SNA_IPM_RS_CNT_TRUE     0x1
+
+/* Next-window size format indicators. */
+#define SNA_IPM_NWS_FORMAT_0    0x0
+
+/* Path control
+ */
+#define SNA_BIND_RQ		0x01
+#define SNA_BIND_RSP		0x02
+#define SNA_UNBIND_RQ		0x03
+#define SNA_UNBIND_RSP		0x04
+
+#define SNA_LS_FLUSHED          0x0302
+#define SNA_FREE_LFSID          0x0305
+#define SNA_PC_TO_DLC           0x0306
+#define SNA_SEND_MU             0x0307
+#define SNA_FLUSH_LS            0x0308
+#define SNA_INIT_PC             0x0309
+#define SNA_LOCAL_BIND_RQ_SEND  0x030A
+#define SNA_LOCAL_BIND_RSP_SEND 0x030B
+#define SNA_LOCAL_FLUSH_LS      0x030C
+#define SNA_LOCAL_UNBIND_RQ_SEND        0x030D
+#define SNA_LOCAL_UNBIND_RSP_SEND       0x030E
+#define SNA_BIND_IPM_SEND               0x030F
+#define SNA_PC_HS_DISCONNECT            0x0310
+
+#define	SNA_PC_INTRANODE		0x0
+#define SNA_PC_INTERNODE		0x1
+
+struct sna_pc_pinfo {
+        struct sna_pc_pinfo *next;
+        struct sna_pc_pinfo *prev;
+
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;		/* Only for Internode */
+        struct sna_ls_cb        *ls;		/* Only for Internode */
+        struct sna_port_cb	*port;		/* Only for Internode */
+	unsigned char		pc_id[8];
+	unsigned char		type;
+
+	/* TG characteristics */
+	unsigned short	max_tx_btu;
+	unsigned short	max_rx_btu;
+	unsigned char	bind_seg;
+	unsigned char	limited_tg;
+	unsigned char   tg_number;
+
+	unsigned char	odai;		/* 0 pri or 1 sec */
+
+	unsigned char	local_seg;
+	unsigned char	godai;
+};
+
+struct sna_pc_create_parms {
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;
+        struct sna_ls_cb        *ls;
+        struct sna_port_cb      *port;
+	unsigned char		type;
+
+	unsigned char	pc_id[8];
+
+	/* TG characteristics */
+        unsigned short  max_tx_btu;
+        unsigned short  max_rx_btu;
+        unsigned char   bind_seg;
+        unsigned char   limited_tg;
+        unsigned char   tg_number;
+
+        unsigned char   odai;           /* 0 pri or 1 sec */
+        unsigned char   local_seg;
+        unsigned char   godai;
+};
+
+struct sna_pc_hs_table {
+        struct sna_pc_hs_table *next;
+        struct sna_pc_hs_table *prev;
+
+        __u8    odai;   /* OAF/DAF Assignor indicator. */
+        __u8    oaf;    /* Origin Address field. */
+        __u8    daf;    /* Destination Address field. */
+        __u8    sidh;   /* Session identifier high (OAF). */
+        __u8    sidl;   /* Session identifier low (DAF). */
+
+        /* These below may be garbage, we'll see what works best. */
+        __u8    hs_id;
+        __u8    sc_id;
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+/* PS.
+ */
+
+typedef enum {
+        ALLOCATE = 1,
+        CONFIRM,
+        CONFIRMED,
+        DEALLOCATE,
+        FLUSH,
+        GET_ATTRIBUTES,
+        POST_ON_RECEIPT,
+        PREPARE_TO_RECEIVE,
+        RECEIVE_AND_WAIT,
+        RECEIVE_IMMEDIATE,
+        REQUEST_TO_SEND,
+        SEND_DATA,
+        SEND_ERROR,
+        TEST,
+        MC_ALLOCATE,
+        MC_CONFIRM,
+        MC_CONFIRMED,
+        MC_DEALLOCATE,
+        MC_FLUSH,
+        MC_GET_ATTRIBUTES,
+        MC_POST_ON_RECEIPT,
+        MC_PREPARE_TO_RECEIVE,
+        MC_RECEIVE_AND_WAIT,
+        MC_REQUEST_TO_SEND,
+        MC_SEND_DATA,
+        MC_SEND_ERROR,
+        MC_TEST,
+        INITIALIZE_SESSION_LIMIT,
+        CHANGE_SESSION_LIMIT,
+        RESET_SESSION_LIMIT,
+        SET_LUCB,
+        SET_PARTNER_LU,
+        SET_MODE,
+        SET_MODE_OPTIONS,
+        SET_TRANSACTION_PROGRAM,
+        SET_PRIVILAEGED_FUNCTION,
+        SET_RESOURCE_SUPPORTED,
+        SET_SYNC_LEVEL_SUPPORTED,
+        SET_MC_FUNCTION_SUPPORTED_TP,
+        GET_LUCB,
+        GET_PARTNER_LU,
+        GET_MODE,
+        GET_LU_OPTION,
+        GET_MODE_OPTION,
+        GET_TRANSACTION_PROGRAM,
+        GET_PRIVILEGED_FUNCTION,
+        GET_RESOURCE_SUPPORTED,
+        GET_SYNC_LEVEL_SUPPORTED,
+        GET_MC_FUNCTION_SUPPORTED_LU,
+        GET_MC_FUNCTION_SUPPORTED_TP,
+        LIST_PARTNER_LU,
+        LIST_MODE,
+        LIST_LU_OPTION,
+        LIST_MODE_OPTION,
+        LIST_TRANSACTION_PROGRAM,
+        LIST_PRIVILEGED_FUNCTION,
+        LIST_RESOURCE_SUPPORTED,
+        LIST_SYNC_LEVEL_SUPPORTED,
+        LIST_MC_FUNCTION_SUPPORTED_LU,
+        LIST_MC_FUNCTION_SUPPORTED_TP,
+        PROCESS_SESSION_LIMIT,
+        ACTIVATE_SESSION,
+        DEACTIVATE_CONVERSATION_GROUP,
+        DEACTIVATE_SESSION,
+        SYNCPT,
+        BACKOUT,
+        GET_TP_PROPERTIES,
+        GET_TYPE,
+        WAIT
+} ps_verbs;
+
+/* RM.
+ */
+
+#define SNA_RM_FALSE    0x0
+#define SNA_RM_TRUE     0x1
+
+struct sna_lu_cb {
+        struct sna_lu_cb *next;
+        struct sna_lu_cb *prev;
+
+        struct sna_netid netid;
+        __u8    lu_name[SNA_RESOURCE_NAME_LEN];
+        __u8    sync_point;
+        __u32   lu_sess_limit;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_plu_cb {
+        struct sna_plu_cb *next;
+        struct sna_plu_cb *prev;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        struct sna_netid netid_fqcp;
+
+        __u8    parallel_ss;
+        __u8    cnv_security;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_lu_count {
+        __u16   sessions;
+        __u16   conwinners;
+        __u16   conlosers;
+};
+
+#define SNA_MODE_MAX_SESSIONS		1200
+#define SNA_MODE_MIN_CONWINNERS		10
+#define SNA_MODE_MIN_CONLOSERS		10
+
+struct sna_mode_cb {
+        struct sna_mode_cb *next;
+        struct sna_mode_cb *prev;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+	__u8	cos_name[SNA_RESOURCE_NAME_LEN];
+
+        __u32   tx_pacing;
+        __u32   rx_pacing;
+        __u32   max_tx_ru;
+        __u32   max_rx_ru;
+        __u32   crypto;         /* 0 = off / 1 = on */
+
+        __u16   flags;
+        __u32   proc_id;
+
+	struct 	sna_lu_count	active;
+	struct 	sna_lu_count	pending;
+
+	__u16	max_sessions;
+        __u16   min_conwinners;
+        __u16   min_conlosers;
+	__u16	auto_activation;
+};
+
+struct sna_tcb {
+        struct sna_tcb  *next;
+        struct sna_tcb  *prev;
+
+        __u32           tcb_id;
+        __u32           rcb_id;
+	pid_t		pid;
+
+        cpic_state      state;
+
+        __u8            oaf;
+        __u8            daf;
+
+        struct sk_buff_head     receive_queue;
+        struct sk_buff_head     transmit_queue;
+        wait_queue_head_t       sleep;
+
+        /* cmspln */
+        unsigned char   partner_lu_name[18];
+        int             partner_lu_name_length;
+
+        /* cmsmn */
+        unsigned char   mode_name[9];
+        int             mode_name_length;
+
+        /* cmstpn */
+        unsigned char   tp_name[65];
+        int             tp_name_length;
+
+        /* cmsid */
+        unsigned char   init_data[10000];
+        int	        init_data_length;
+
+        /* cmsld */
+        unsigned char   log_data[512];
+        int	        log_data_length;
+
+        /* cmsrt */
+        unsigned long	 receive_type;
+
+        /* cmsaeq */
+        unsigned char   ae_qualifier[1024];
+        unsigned long   ae_qualifier_length;
+        unsigned char   ae_qualifier_format;
+
+        unsigned char   allocate_confirm;
+
+        /* cmsapt */
+        unsigned char   ap_title[1024];
+        unsigned long   ap_title_length;
+        unsigned char   ap_title_format;
+
+        /* cmsacn */
+        unsigned char   application_context_name[256];
+        unsigned long   application_context_length;
+
+        /* cmsbt */
+        unsigned char   begin_transaction;
+
+        /* cmssrm */
+        unsigned long	send_receive_mode;
+
+        /* cmssl */
+        unsigned long	   sync_level;
+
+        /* cmsst */
+        unsigned long	    send_type;
+
+        /* cmsptr */
+        unsigned long	      prepare_to_receive_type;
+
+        /* cmsdt */
+        unsigned long	      deallocate_type;
+
+        /* cmsf */
+        unsigned long	         fill;
+};
+
+/* SCM.
+ */
+
+#define sna_scm_create(x)       sna_isr_create(x);
+#define sna_scm(x)              sna_isr(x);
+
+/* SM.
+ */
+
+#ifdef NOT
+struct sna_session_info {
+        __u8    hs_id;
+        __u8    hs_type;
+        __u8    bracket_type;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    session_id;
+        __u8    *random;
+        __u8    limit_resource;
+};
+
+struct sna_security {
+        __u8    *profile;
+        __u8    *passwd;
+        __u8    *user_id;
+};
+
+struct sna_abend_notify {
+        __u8    process;
+        __u8    process_id;
+        __u8    reason;
+};
+
+struct sna_free_lfsid {
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+struct sna_free_session {
+        __u8    hs_id;
+};
+
+struct sna_get_session {
+        __u8    tcb_id;
+        __u8    rcb_id;
+        __u8    type;
+        __u8    conv_gid;
+};
+
+struct sna_session_activated {
+        struct sna_session_info session_info;
+        __u8    *lu_name;
+        __u8    *mode_name;
+};
+
+struct sna_session_allocated {
+        __u16   send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    in_conver;
+        __u8    rcode;
+};
+
+struct sna_session_deactivated {
+        __u8    hs_id;
+        __u8    reason;
+        __u32   sense;
+};
+
+struct sna_session_route_inop {
+        __u8    pc_id;
+};
+
+struct sna_act_sess_rsp {
+        __u8    correlator;
+        __u8    type;
+        __u8    err_type;
+        struct  sna_session_info sess_info;
+};
+
+struct sna_rcb_allocated {
+        __u8    rcode;
+        __u8    rcb_id;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+};
+
+struct sna_change_sessions {
+        __u8    tcb_id;
+        __u8    rsp;
+        __u8    *lu_name;
+        __u8    *mode_name;
+        __u8    delta;
+};
+
+struct sna_luw {
+        __u8    *fq_lu_name;
+        __u8    instance;
+        __u8    sequence;
+};
+
+/* Transaction control block. */
+struct sna_tcb {
+        struct sna_tcb *next;
+        struct sna_tcb *prev;
+
+        __u8    tcb_id;
+        __u8    tp_name;
+        __u8    own_lu_id;
+
+        struct sna_luw luw_id;
+        struct sna_resource resource_list;
+
+        __u8    ctrl_cmpnt;
+
+        struct sna_security security;
+};
+
+struct sna_scb {
+        __u8    hs_id;
+        __u8    session_id;
+
+        struct sna_conver conversation;
+
+        __u8    *lu_name;
+        __u8    *mode_name;
+
+        __u8    rcb_id;
+        __u8    first_speaker;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    bracket_id;
+
+        __u8    rtr_owed;
+        __u8    *fq_name;
+        __u8    *random;
+
+        __u8    limit_resource;
+
+        struct timer *timer_unique_id;
+};
+
+struct sna_received_info {
+        __u8    type;
+};
+
+struct sna_conver {
+        __u8    correlator;
+        __u8    gid;
+};
+
+struct sna_post_cond {
+        __u8    fill;
+        __u8    max_length;
+};
+
+#endif
+
+typedef enum {
+        FSM_RCB_STATUS_FSP = 1
+} rcb_state;
+
+/* Resource control block. */
+struct sna_rcb {
+        struct sna_rcb *next;
+        struct sna_rcb *prev;
+
+        rcb_state       state;
+
+        unsigned long   rcb_id;
+        unsigned long   tcb_id;
+        unsigned long   hs_id;
+        unsigned long   bracket_id;
+
+        unsigned long   conversation_correlator;
+        unsigned long   session_id;
+
+        unsigned long   lfsid;          /* XXX */
+        unsigned char   oaf;            /* XXX */
+        unsigned char   daf;            /* XXX */
+
+        __u8    lu_name_length;
+        __u8    lu_name[SNA_FQCP_NAME_LEN];
+
+        __u8    mode_name_length;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+
+        __u8    tp_name_length;
+        __u8    tp_name[64];
+
+        union {
+                struct sna_ps_to_hs ps_to_hs;
+        } l;
+
+/* Everything below here is questionable */
+
+        __u8    sync_level;
+        __u8    security_select;
+
+//      struct sna_session_parm *sessions_parm_ptr;
+
+        __u8    conversation_type;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+
+//      struct sna_post_cond post_conditions;
+
+        __u8    locks;
+        __u16   send_ru_size;
+        __u8    rq_ro_send_rcvd;
+
+        __u32   mapper_save_area;
+        __u16   mc_max_send_size;
+        __u8    mc_rq_to_send_rcvd;
+};
+
+#ifdef NOT
+
+struct sna_tp {
+        struct sna_tp *next;
+        struct sna_tp *prev;
+
+        __u8    *tp_name;
+
+        struct sna_priv_funct priv_functs;
+        struct sna_rcb rcb;
+
+        __u8    verify_pip;
+        __u8    sub_pips;
+
+        struct sna_sync_level sync_level;
+
+        __u8    max_tp;
+        __u8    tp_cnt;
+        __u8    status;
+
+        struct sna_wait_init_rqs wait_init_rqs;
+
+        struct sna_mc_funct mc_funct;
+};
+
+struct sna_start_tp {
+        __u8    reply;
+        __u8    *tp_name;
+        __u8    security_select;
+        struct sna_security security;
+        __u8    tcb_id;
+        __u8    *pip_data;
+        __u8    fq_lu_name;
+};
+
+struct sna_plu {
+        struct sna_plu *next;
+        struct sna_plu *prev;
+
+        __u8    *lu_name;
+        __u8    *fq_name;
+        __u8    parallel_lus;
+
+        struct sna_mode mode;
+};
+
+struct sna_lucb {
+        struct sna_lucb *next;
+        struct sna_lucb *prev;
+
+        __u8    lu_id;          /* LU ID. */
+        __u8    *fq_lu_name;
+        __u8    slimit;         /* Session limit. */
+
+        struct sna_plu          plu;
+        struct sna_tp           tp;
+        struct sna_rand_data    random;
+};
+
+#endif
+
+/* SS.
+ */
+
+struct sna_ss_pinfo {
+        struct sna_ss_pinfo *next;
+        struct sna_ss_pinfo *prev;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* TC.
+ */
+
+#ifdef NOT
+
+#define SNA_PACING_TYPE_NONE            0x01
+#define SNA_PACING_TYPE_FIXED           0x02
+#define SNA_PACING_TYPE_ADAPTIVE        0x03
+
+struct sna_send_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    first_ws;
+        __u8    rlwi;
+};
+
+struct sna_receive_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    unsolicited_ipm_outstanding;
+        __u8    adjust_ipm_ack_outstanding;
+        __u8    unsolicited_nws;
+};
+
+#define SNA_COMMON_CB_RESERVE_NO        0x01
+#define SNA_COMMON_CB_RESERVE_ALL       0x02
+#define SNA_COMMON_CB_RESERVE_MORE      0x03
+
+#define SNA_CCB_NO_RLW          0x0
+#define SNA_CCB_RLW             0x1
+
+#define SNA_CCB_NO              0x0
+#define SNA_CCB_MORE            0x1
+#define SNA_CCB_ALL             0x2
+
+struct sna_common_cb {
+        __u8    caller;
+        __u8    pc_id;
+        struct sna_lfsid lfsid;
+        __u8    perm_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    tx_priority;
+        __u8    num_bufs_per_ru;
+        __u8    reserve_flag;
+
+        struct sna_send_pacing          send_pacing;
+        struct sna_receive_pacing       receive_pacing;
+};
+
+struct sna_tc_cb {
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported;
+        __u8    crypto;
+        struct sna_common_cb    ccb;
+};
+
+#define SNA_IPM_TYPE_SOLICITED          0x01
+#define SNA_IPM_TYPE_UNSOLICITED        0x02
+#define SNA_IPM_TYPE_RESET_ACK          0x03
+
+#define SNA_IPM_RWI_RESET_WINDOW        0x01
+#define SNA_IPM_RWI_NO_RESET_WINDOW     0x02
+
+#define SNA_IPM_FORMAT_0                0x01
+
+struct sna_ipm_extension {      /* Should only be 3 bytes long. */
+        __u8    type;
+        __u8    rwi;
+        __u8    format_indicator;
+        __u8    nws;
+};
+
+#endif
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_CBS_H */
diff -ruN linux-2.4.13/include/net/sna_errors.h linux/include/net/sna_errors.h
--- linux-2.4.13/include/net/sna_errors.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_errors.h	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,46 @@
+/* sna_errors.h: Linux-SNA Error codes and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_ERRORS_H
+#define __NET_SNA_ERRORS_H
+
+#ifdef __KERNEL__
+
+#define	RESOURCE_FAILURE_NO_RETRY	1008600B
+
+/* Allocation error codes */
+#define TPN_NOT_RECOGNIZED		10086021
+#define PIP_NOT_ALLOWED			10086031
+#define PIP_NOT_SPECIFIED_CORRECTLY	10086032
+#define CONVERSATION_TYPE_MISMATCH	10086034
+#define SYNC_LEVEL_NOT_SUPPORTED_BY_PGM	10086041
+#define ACCESS_DENIED			080F0983
+#define SECURITY_NOT_VALID		080F6051
+#define BACKED_OUT			08240000
+#define TP_NOT_AVAIL_RETRY		084B6031
+#define TP_NOT_AVAIL_NO_RETRY		084C0000
+#define DEALLOCATE_ABEND_PROG		08640000
+#define DEALLOCATE_ABEND_SVC		08640001
+#define DEALLOCATE_ABEND_TIMER		08640002
+#define PROG_ERROR_NO_TRUNC		08890000
+#define PROG_ERROR_PURGING		08890000
+#define PROG_ERROR_TRUNC		08890001
+#define SVC_ERROR_NO_TRUNC		08890100
+#define SVC_ERROR_PURGING		08890100
+#define SVC_ERROR_TRUNC			08890101
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_ERRORS_H */
diff -ruN linux-2.4.13/include/net/sna_externs.h linux/include/net/sna_externs.h
--- linux-2.4.13/include/net/sna_externs.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_externs.h	Wed Nov  7 11:11:31 2001
@@ -0,0 +1,261 @@
+/* sna_externs.h: Linux-SNA external function declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_EXTERNS_H
+#define __NET_SNA_EXTERNS_H
+
+#ifdef __KERNEL__
+
+extern int sna_netid_to_char(struct sna_netid *n, unsigned char *c);
+extern struct sna_netid *sna_char_to_netid(unsigned char *c);
+extern char *sna_pr_ether(unsigned char *ptr);
+extern char *sna_pr_netid(struct sna_netid *n);
+extern char *sna_pr_nodeid(struct sna_nodeid *n);
+
+/* ASM. */
+extern int sna_asm_assign_lfsid(struct sna_assign_lfsid *as);
+extern int sna_asm_create(struct sna_start_node *start);
+extern int sna_asm_destroy(struct sna_delete_node *delete);
+extern int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_activate_as(struct sna_activate_as *as);
+extern int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* Attach. */
+extern int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb);
+extern int sna_attach_create(struct sna_start_node *start);
+extern int sna_attach_destroy(struct sna_delete_node *delete);
+
+/* COSM. */
+extern int sna_cosm_query_cos(char *arg);
+extern int sna_cosm_create(struct sna_start_node *start);
+extern int sna_cosm_destroy(struct sna_delete_node *delete);
+extern void sna_cosm_init(void);
+extern void sna_cosm_cleanup(void);
+extern int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cosm_define_cos(struct sna_define_cos *cos);
+extern int sna_cosm_delete_cos(struct sna_delete_cos *cos);
+extern int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos);
+extern int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length);
+
+/* CPIC. */
+extern struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id);
+extern unsigned long sna_cpic_create_tcb(void);
+extern int sna_cpic_ioctl(int cmd, void *arg);
+extern int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length);
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+extern struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf);
+
+/* CS. */
+extern struct sna_port_cb *sna_cs_find_port(struct sna_port_cb *plist,
+        char *saddr);
+extern struct sna_dlc_cb *sna_cs_find_dlc_name(char *name);
+extern int sna_cs_connect_in(struct sk_buff *skb, struct net_device *dev);
+extern int sna_cs_rcv_xid(struct sk_buff *skb, struct net_device *dev);
+extern int sna_cs_query_dlc(char *arg);
+extern int sna_cs_query_port(char *arg);
+extern int sna_cs_query_ls(char *arg);
+extern int sna_cs_create(struct sna_start_node *start);
+extern int sna_cs_destroy(struct sna_delete_node *delete);
+extern int sna_cs_define_dlc(struct net_device *dev);
+extern int sna_cs_delete_dlc(struct net_device *dev);
+extern int sna_cs_define_port(struct sna_define_port *port);
+extern int sna_cs_delete_port(struct sna_delete_port *port);
+extern int sna_cs_start_port(struct sna_start_port *port);
+extern int sna_cs_stop_port(struct sna_stop_port *port);
+extern int sna_cs_define_ls(struct sna_define_link_station *dls);
+extern int sna_cs_delete_ls(struct sna_delete_link_station *dls);
+extern int sna_cs_start_ls(struct sna_start_link_station *sls);
+extern int sna_cs_stop_ls(struct sna_stop_link_station *sls);
+extern int sna_cs_activate_route(struct sna_activate_route *ar);
+extern void sna_cs_connect_out(unsigned long data);
+extern int sna_cs_xid_xchg_state(struct sk_buff *skb);
+
+#ifdef CONFIG_PROC_FS
+extern int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length);
+#endif
+
+#ifdef CONFIG_SNA_LLC
+extern int sna_dlc_llc_rcv(struct sk_buff *skb, struct net_device *dev,
+        struct packet_type *pt);
+extern int sna_dlc_llc_event(int rsp, struct sk_buff *skb);
+#endif
+
+/* DFC. */
+extern int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb);
+extern int sna_dfc_rcv(struct sk_buff *skb);
+
+/* DS. */
+extern int sna_ds_create(struct sna_start_node *start);
+extern int sna_ds_destroy(struct sna_delete_node *delete);
+
+/* EBCDIC. */
+extern unsigned char etor(unsigned char a);
+extern unsigned char etoa(unsigned char a);
+extern unsigned char atoe(unsigned char a);
+extern char *atoe_strcpy(char *dest, char *src);
+extern char *etoa_strcpy(char *dest, char *src);
+extern char *etor_strncpy(char *dest, char *src, size_t count);
+extern char *atoe_strncpy(char *dest, char *src, size_t count);
+extern char *etoa_strncpy(char *dest, char *src, size_t count);
+extern int atoe_strcmp(const char *acs, const char *ect);
+extern int etoa_strcmp(const char *ecs, const char *act);
+extern int atoe_strncmp(const char *acs, const char *ect, size_t count);
+extern int etoa_strncmp(const char *ecs, const char *act, size_t count);
+extern char *fatoe_strncpy(char *dest, char *src, size_t count);
+
+/* HS. */
+extern int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+        struct sna_rcb *rcb);
+
+/* ISR. */
+extern void sna_isr_init(void);
+extern void sna_isr_cleanup(void);
+
+/* NOF. */
+extern int sna_nof_ioctl(int cmd, void *arg);
+extern int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *len);
+extern int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_nof_define_dlc(struct net_device *dev);
+extern int sna_nof_delete_dlc(struct net_device *dev);
+extern struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n);
+
+/* PC. */
+extern void sna_pc_cleanup(void);
+extern void sna_pc_init_layer(void);
+extern int sna_pc_init(struct sna_pc_create_parms *npc);
+extern int sna_pc_destroy(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n);
+extern int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_pc_mu_error_checker(struct sk_buff *skb);
+extern int sna_pc_mu_rcv_router(struct sk_buff *skb);
+extern struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb);
+
+/* PS. */
+extern int sna_ps_conv(int verb, struct sna_tcb *tcb);
+extern int sna_ps_mc(int verb, struct sna_tcb *tcb);
+extern int sna_ps_copr(int verb, struct sna_tcb *tcb);
+extern int sna_ps_sync(int verb, struct sna_tcb *tcb);
+extern int sna_ps_verb_router(int verb, struct sna_tcb *tcb);
+extern int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb);
+
+/* RM. */
+extern struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id);
+extern __u8 sna_rm_allocate_rcb(struct sna_tcb *tcb);
+extern int sna_rm_process_hs_to_rm(struct sk_buff *skb);
+extern struct sna_rcb *sna_search_rcb(__u8 id);
+extern struct sna_tcb *sna_search_tcb(__u8 id);
+extern struct sna_scb *sna_search_scb(__u8 id);
+extern struct sna_tp *sna_search_tp(__u8 id);
+extern struct sna_partner_lu *sna_search_plu(__u8 id);
+extern struct sna_lucb *sna_search_lucb(__u8 id);
+extern struct sna_lu_lu_cb *sna_search_lulucb(__u8 id);
+extern int sna_rm_destroy(struct sna_delete_node *d);
+extern int sna_rm_define_mode(struct sna_define_mode *dm);
+extern int sna_rm_delete_mode(struct sna_delete_mode *dm);
+extern int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu);
+extern int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu);
+extern int sna_rm_define_local_lu(struct sna_define_local_lu *dlu);
+extern int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu);
+extern int sna_rm_query_mode(char *arg);
+extern int sna_rm_query_lu(char *arg);
+extern int sna_rm_query_plu(char *arg);
+extern int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_activate_session(struct sna_rm_act_session_rq *as);
+extern struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id);
+extern struct sna_mode_cb *sna_rm_find_mode(char *mode_name);
+
+/* RSS. */
+extern int sna_rss_create(struct sna_start_node *start);
+extern int sna_rss_destroy(struct sna_delete_node *delete);
+extern void sna_rss_init(void);
+extern void sna_rss_cleanup(void);
+extern int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r);
+
+/* SM. */
+extern int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l);
+extern int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal);
+extern int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as);
+
+/* SS. */
+extern int sna_ss_create(struct sna_start_node *start);
+extern int sna_ss_destroy(struct sna_delete_node *delete);
+extern int sna_ss_process_init_signal(struct sna_init_signal *init);
+extern int sna_ss_assign_pcid(struct sna_assign_pcid *pcid);
+extern int sna_ss_generate_pcid(char *net, char *name);
+extern int sna_ss_update_pcid(unsigned char *r);
+
+/* TC. */
+extern int sna_attach_rcv(struct sk_buff *skb);
+extern int sna_tc_transmit(struct sk_buff *skb);
+extern int sna_tc_send_data(struct sk_buff *skb);
+extern struct sk_buff *sna_tc_receive_data(void);
+extern int sna_tc_init(void);
+extern int sna_tc_send_mu(struct sk_buff *skb);
+extern int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* TDM. */
+extern int sna_tdm_create(struct sna_start_node *start);
+extern int sna_tdm_destroy(struct sna_delete_node *delete);
+extern void sna_tdm_init(void);
+extern void sna_tdm_cleanup(void);
+extern int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_define_node_chars(struct sna_define_node_chars *n);
+extern int sna_tdm_tg_update(struct sna_tg_update *utg);
+extern int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v);
+extern struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid);
+extern struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n,
+        unsigned char tg_num);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num);
+extern int sna_tdm_init_tg_update(struct sna_tg_update *tg);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac);
+
+/* TRS. */
+extern int sna_trs_create(struct sna_start_node *start);
+extern int sna_trs_destroy(struct sna_delete_node *delete);
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_EXTERNS_H */
diff -ruN linux-2.4.13/include/net/sna_formats.h linux/include/net/sna_formats.h
--- linux-2.4.13/include/net/sna_formats.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_formats.h	Wed Nov  7 11:01:22 2001
@@ -0,0 +1,4385 @@
+/* sna_formats.h: Linux-SNA data headers and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_FORMATS_H
+#define __NET_SNA_FORMATS_H
+
+#ifdef __KERNEL__
+
+/* MU.
+ */
+
+#ifdef NOT
+struct sna_sender {
+        __u8 id;
+        __u8 type;
+};
+
+struct sna_bind_rq_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        struct sna_lfsid *lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_send {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 path_id;
+        __u8 free_lfsid;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_unbind_rq {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptaive_pace;
+};
+
+struct sna_unbind_rsp_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_pc_character {
+        __u16 max_send_btu_size;
+        __u16 max_rcv_btu_size;
+        __u8 adjacent_node_bind_reasm;
+        __u8 limit_resource;
+};
+
+struct sna_bind_rq_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        struct sna_pc_character *pc_characteristics;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 tx_priority;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+#endif
+
+struct sna_hs_to_rm {
+        __u8 hs_id;
+};
+
+struct sna_rm_to_ps {
+        __u8 hs_id;
+        __u8 tcb_id;
+        __u8 rcb_id;
+        __u8 send_ru_size;
+        __u8 limit_buf_pool_id;
+        __u8 perm_buf_pool_id;
+        __u8 rcode;
+};
+
+struct sna_hs_to_ps {
+        __u8 bracket_id;
+        __u8 fmh;
+        __u8 type;
+};
+
+struct sna_ps_to_hs {
+        __u8 bracket_id;
+        __u8 ps_to_hs_variant;
+        __u8 allocate;
+        __u8 fmh;
+        __u8 type;
+};
+
+/* COMPRESSION.
+ */
+
+#ifdef NOT
+
+/* Compression algorithms */
+#define RU_COMPRESS_RLE 000
+#define RU_COMPRESS_LZ  001
+
+/* Compression header */
+struct sna_ru_compress
+{
+        unsigned char   compress:4,     /* Compression algorithm */
+                        length:4;       /* Uncmprssd data type/cmprssn hdr sz */        __u16           size;
+};
+
+/* SCB data type */
+#define RU_SCB_RAW      00
+#define RU_SCB_RESRV    01
+#define RU_SCB_MSTR_CHR 10
+#define RU_SCB_DUP_CHR  11
+
+struct sna_ru_compress_scb
+{
+        __u8    type:2,         /* SCB type */
+                count:6;        /* Uncompressed size of following data */
+};
+
+/* LZ command indicators */
+#define LZ_RESET        0x001
+#define LZ_FREEZE       0x002
+#define LZ_UNFREEZE     0x003
+
+/* LZ control sequence header */
+struct sna_lz_9bit
+{
+        __u16   cntl:9,         /* 9 bit LZ compression */
+                cmd:7;          /* LZ command */
+};
+
+struct sna_lz_10bit
+{
+        __u16   cntl:10,        /* 10 bit LZ compression */
+                cmd:6;          /* LZ command */
+};
+
+struct sna_lz_12bit
+{
+        __u16   cntl:12,        /* 12 but LZ compression  */
+                cmd:4;          /* LZ command */
+};
+
+struct sna_ru_compress_lz
+{
+        union {
+                struct sna_lz_9bit      9bit;
+                struct sna_lz_10bit     10bit;
+                struct sna_lz_12bit     12bit;
+        } size;
+};
+
+#endif
+
+/* EBCDIC.
+ */
+
+static unsigned char const ebcdic_to_rotated[256] = {
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,         /* 24 -   31 */
+         32,  33,  34,  35,  36,  37,  38,  39,         /* 32 -   39 */
+         40,  41,  42,  43,  44,  45,  46,  47,         /* 40 -   47 */
+         48,  49,  50,  51,  52,  53,  54,  55,         /* 48 -   55 */
+         56,  57,  58,  59,  60,  61,  62,  63,         /* 56 -   63 */
+         1,  65,  66,  67,  68,  69,  70,  71,          /* 64 -   71 */
+         72,  73,  74,  75,  76,  77,  78,  79,         /* 72 -   79 */
+         80,  81,  82,  83,  84,  85,  86,  87,         /* 80 -   87 */
+         88,  89,  90, 109,  92,  93,  94,  95,         /* 88 -   95 */
+         96,  97,  98,  99, 100, 101, 102, 103,         /* 96 -  103 */
+        104, 105, 106, 107, 108, 109, 110, 111,         /* 104 - 111 */
+        112, 113, 114, 115, 116, 117, 118, 119,         /* 112 - 119 */
+        120, 121, 122, 237, 241, 125, 126, 127,         /* 120 - 127 */
+        128, 129, 130, 131, 132, 133, 134, 135,         /* 128 - 135 */
+        136, 137, 138, 139, 140, 141, 142, 143,         /* 136 - 143 */
+        144, 145, 146, 147, 148, 149, 150, 151,         /* 144 - 151 */
+        152, 153, 154, 155, 156, 157, 158, 159,         /* 152 - 159 */
+        160, 161, 162, 163, 164, 165, 166, 167,         /* 160 - 167 */
+        168, 169, 170, 171, 172, 173, 174, 175,         /* 168 - 175 */
+        176, 177, 178, 179, 180, 181, 182, 183,         /* 176 - 183 */
+        184, 185, 186, 187, 188, 189, 190, 191,         /* 184 - 191 */
+        192,   7,  11,  14,  19,  23,  27,  31,         /* 192 - 199 */
+         35,  39, 202, 203, 204, 205, 206, 207,         /* 200 - 207 */
+        208,  71,  75,  79,  83,  87,  91,  95,         /* 208 - 215 */
+         99, 103, 218, 219, 220, 221, 222, 223,         /* 216 - 223 */
+        224, 225, 139, 143, 147, 151, 155, 159,         /* 224 - 231 */
+        163, 167, 234, 235, 236, 237, 238, 239,         /* 232 - 239 */
+        195, 199, 203, 207, 211, 215, 219, 223,         /* 240 - 247 */
+        227, 231, 250, 251, 252, 253, 254, 255          /* 248 - 255 */
+};
+
+static unsigned char const ebcdic_to_ascii_sna[256] =
+{
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,
+         32,  33,  34,  35,  36,  37,  38,  39,
+         40,  41,  42,  43,  44,  45,  46,  47,
+         48,  49,  50,  51,  52,  53,  54,  55,
+         56,  57,  58,  59,  60,  61,  62,  63,
+         32,  65,  66,  67,  68,  69,  70,  71,
+         72,  73,  74,  75,  76,  77,  78,  79,
+         80,  81,  82,  83,  84,  85,  86,  87,
+         88,  89,  90,  91,  92,  93,  94,  95,
+         96,  97,  98,  99, 100, 101, 102, 103,
+        104, 105, 106, 107, 108, 109, 110, 111,
+        112, 113, 114, 115, 116, 117, 118, 119,
+        120, 121, 122, 123, 124, 125, 126, 127,
+        128, 129, 130, 131, 132, 133, 134, 135,
+        136, 137, 138, 139, 140, 141, 142, 143,
+        144, 145, 146, 147, 148, 149, 150, 151,
+        152, 153, 154, 155, 156, 157, 158, 159,
+        160, 161, 162, 163, 164, 165, 166, 167,
+        168, 169, 170, 171, 172, 173, 174, 175,
+        176, 177, 178, 179, 180, 181, 182, 183,
+        184, 185, 186, 187, 188, 189, 190, 191,
+        192,  65,  66,  67,  68,  69,  70,  71,
+         72,  73, 202, 203, 204, 205, 206, 207,
+        208,  74,  75,  76,  77,  78,  79,  80,
+         81,  82, 218, 219, 220, 221, 222, 223,
+        224, 225,  83,  84,  85,  86,  87,  88,
+         89,  90, 234, 235, 236, 237, 238, 239,
+        240, 241, 242, 243, 244, 245, 246, 247,
+        248, 249, 250, 251, 252, 253, 254, 255
+};
+
+static unsigned char const ascii_to_ebcdic_sna[256] =
+{
+          0,   1,   2,   3,  55,  45,  46,  47,         /* 0  -    7 */
+         22,   5,  37,  11,  12,  13,  14,  15,         /* 8  -   15 */
+         16,   0,   0,   0,   0,  61,  50,  38,         /* 16 -   23 */
+         24,  25,  63,  39,   0,   0,   0,   0,         /* 24 -   31 */
+         64,   0, 127, 123,  80, 108,  91, 121,         /* 32 -   39 */
+         77,  93,  53,  78, 107,  96,  75,  97,         /* 40 -   47 */
+        240, 241, 242, 243, 244, 245, 246, 247,         /* 48 -   55 */
+        248, 249, 122,  94,  76, 126, 110, 111,         /* 56 -   63 */
+        124, 193, 194, 195, 196, 197, 198, 199,         /* 64 -   71 */
+        200, 201, 209, 210, 211, 212, 213, 214,         /* 72 -   79 */
+        215, 216, 217, 226, 227, 228, 229, 230,         /* 80 -   87 */
+        231, 232, 233,  74, 224,   0,  95, 109,         /* 88 -   95 */
+        125, 129, 130, 131, 132, 133, 134, 135,         /* 96 -  103 */
+        136, 137, 145, 146, 147, 148, 149, 150,         /* 104 - 111 */
+        151, 152, 153, 162, 163, 164, 165, 166,         /* 112 - 119 */
+        167, 168, 169, 192, 106, 208, 161,   7,         /* 120 - 127 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 128 - 135 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 136 - 143 */
+          0,   0,   0,   0,   0,   0,   0		/* 144 - 150 */
+};
+
+/* FM.
+ */
+
+/* FMH type indicators */
+#define FMH_1                   0x01            /* FMH-1 */
+#define FMH_2                   0x02            /* FMH-2 */
+#define FMH_3			0x03
+#define FMH_4                   0x04            /* FMH-4 */
+#define FMH_5                   0x05            /* FMH-5 */
+#define FMH_6                   0x06            /* FMH-6 */
+#define FMH_7                   0x07            /* FMH-7 */
+#define FMH_10                  0x0A       	/* FMH-10 */
+#define FMH_12                  0x0C            /* FMH-12 */
+#define FMH_18			0x12
+#define FMH_19			0x13
+
+/* FMH header descriptions. */
+#define SNA_FMH_HDR_ERROR       FMH_1
+#define SNA_FMH_HDR_ATTACH      FMH_1
+#define SNA_FMH_HDR_SECURITY    FMH_1
+
+/* FMH concatenation indicators */
+#define FMH_CONCAT_TRUE         1
+#define FMH_CONCAT_FALSE        0
+
+/* FMH media indicators */
+#define FMH_CONSOLE             0000    /* Console */
+#define FMH_XCHANGE             0001    /* Exchange */
+#define FMH_CARD                0010    /* Card */
+#define FMH_DOCUMENT            0011    /* Document */
+#define FMH_NXCHANGE_DISK       0100    /* Non-exchange disk */
+#define FMH_XDOCUMENT           0101    /* Extended document */
+#define FMH_XCARD               0110    /* Extended card */
+#define FMH_DATA_SELECT         0111    /* Data set name select destination */
+#define FMH_WP_1                1000    /* Word processing media 1 */
+#define FMH_WP_2                1001    /* Word processing media 2 */
+#define FMH_WP_3                1010    /* Word processing media 3 */
+#define FMH_RESRV_1             1011    /* Reserved */
+#define FMH_WP_4                1100    /* Word processing media 4 */
+#define FMH_RESRV_2             1101    /* Reserved */
+#define FMH_RESRV_3             1110    /* Reserved */
+#define FMH_RESRV_4             1111    /* Reserved */
+
+/* FMH data stream profile indicators */
+#define DSP_DEFAULT             0000    /* Default */
+#define DSP_BASE                0001    /* Base */
+#define DSP_GENERAL             0010    /* General */
+#define DSP_JOB                 0011    /* Job */
+#define DSP_WP_RAW              0100    /* WP raw-form text */
+#define DSP_WP_XCHANGE_DISK     0101    /* WP exchange diskette */
+#define DSP_RESRV_1             0110    /* Reserved */
+#define DSP_OII_2               0111    /* Office Info. Interchange level 2 */
+#define DSP_RESRV_2             1000    /* Reserved */
+#define DSP_RESRV_3             1001    /* Reserved */
+#define DSP_DOC_INTERCHANGE     1010    /* Document interchange */
+#define DSP_STRUCT              1011    /* Structured field */
+#define DSP_RESRV_4             1100    /* Reserved */
+#define DSP_RESRV_5             1101    /* Reserved */
+#define DSP_RESRV_6             1110    /* Reserved */
+#define DSP_RESRV_7             1111    /* Reserved */
+
+/* FMH destination selection indicators */
+#define DSSEL_RESUME            000     /* Resume */
+#define DSSEL_END               001     /* End */
+#define DSSEL_BEGIN             010     /* Begin */
+#define DSSEL_BEGIN_END         011     /* Begin/end */
+#define DSSEL_SUSPEND           100     /* Suspend */
+#define DSSEL_END_ABORT         101     /* End-abort */
+#define DSSEL_CONTINUE          110     /* Continue */
+#define DSSEL_RESRV_1           111     /* Reserved */
+
+/* FMH compaction indicators */
+#define FMH_COMPACT_TRUE        1       /* Compaction */
+#define FMH_COMPACT_FLASE       0       /* No compaction */
+
+/* SNA Function Managment 1 header */
+struct sna_fmh1
+{
+        __u8    medium:4,       /* Desired medium for data */
+                lsubaddr:4;     /* Logical subaddress */
+        __u8    sri:1,          /* Stack Reference indicator */
+                dmsel:1,        /* Demand select */
+                rsv_1:2,        /* Reserved */
+                dsp:4;          /* Data stream profiles */
+        __u8    dssel:3,        /* Destination selection */
+                dst:1,          /* Data set transmission */
+                rsv_2:1,        /* Reserved */
+                cmi:1,          /* FMH-1 SCB compression indicator */
+                cpi:1,          /* Compaction indicator */
+                rsv_3:1;        /* Reserved */
+        __u8    ecrl;           /* Exchange record length */
+        __u16   rsv_4;          /* Reserved */
+        __u8    dslen;          /* Length of destination name */
+
+        unsigned char *dsname;  /* Destination name, unlimited length */
+};
+
+/* FMH-2 function indicators */
+#define FMH2_PDIR               0x01    /* Peripheral data information record */#define FMH2_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH2_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH2_XCUTE_PG_OFFLN     0x07    /* Execute program offline */
+#define FMH2_CREATE_DATA_SET    0x20    /* Create data set */
+#define FMH2_SCRATCH_DATA_SET   0x21    /* Scratch data set */
+#define FMH2_ERASE_DATA_SET     0x22    /* Erase data set */
+#define FMH2_PASSWORD           0x23    /* Password */
+#define FMH2_ADD                0x24    /* Add */
+#define FMH2_REPLACE            0x25    /* Replace */
+#define FMH2_ADD_REPLICATE      0x26    /* Add replicate */
+#define FMH2_REPLACE_REPLIACTE  0x27    /* Replace replicate */
+#define FMH2_QUERY_DATA_SET     0x28    /* Query for data set */
+#define FMH2_NOTE               0x29    /* Note */
+#define FMH2_REC_ID             0x2B    /* Record ID */
+#define FMH2_ERASE_REC          0x2C    /* Erase record */
+#define FMH2_SCRATCH_ALL_SETS   0x2D    /* Scratch all data sets */
+#define FMH2_VOL_ID             0x2E    /* Volume ID */
+#define FMH2_NOTE_REPLY         0xAA    /* Note reply */
+
+/* FMH-3 function indicators */
+#define FMH3_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH3_QUERY_COMPACT_TBLE 0x03    /* Query for compaction table */
+#define FMH3_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH3_STATUS             0x05    /* Status */
+#define FMH3_SERIES_ID          0x06    /* Series ID */
+
+/* SNA Function Managment 2 and 3 header */
+struct sna_fmh2
+{
+        __u8    sri:1,          /* Stack reference indicator */
+                fmh2cmd:7;      /* FMH-2 function to be performed */
+
+        unsigned char *fmh2opt; /* Parameter fields, unlimited length */
+};
+
+/* FMH-4 block transmission type indicators */
+#define FMH4_INHERIT            0x00    /* Inherit code */
+/* FMH4 0x01 - 0x3F */                  /* Reserved */
+#define FMH4_FFR_FNI            0x40    /* FFR-FNI record */
+#define FMH4_FFR_FS             0x41    /* FFR-FS record */
+#define FMH4_FFR_FS2            0x42    /* FFR-FS2 record */
+/* FMH4 0x43 - 0x4F */                  /* Reserved */
+/* FMH4 0x50 - 0xFF */                  /* Reserved */
+
+/* FMH-4 command indicators */
+#define FMH4_CRT_NU_BLK         0x00    /* CRT-NU-BLK */
+#define FMH4_CRT_SU_BLK         0x02    /* CRT-SU-BLK */
+#define FMH4_CRT_SN_BLK         0x03    /* CRT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_DEL_SN_BLK         0x23    /* DEL-SN-BLK */
+#define FMH4_UPD_SU_BLK         0x32    /* UPD-SU-BLK */
+#define FMH4_UPD_SN_BLK         0x33    /* UPD-SN-BLK */
+#define FMH4_RPL_SU_BLK         0x42    /* RPL-SU-BLK */
+#define FMH4_RPL_SN_BLK         0x43    /* RPL-SN-BLK */
+
+/* SNA Function Managment 4 header */
+struct sna_fmh4
+{
+        __u8    fmh4fxct;       /* Length of fixed length parameters */
+        __u8    fmh4tt1;        /* Block transmission type */
+        __u8    fm4htt2;        /* Block transmission type qualifier */
+        __u8    fmh4cmd;        /* Command */
+        __u8    rsv1:2,         /* Reserved */
+                f4rdescr:2,     /* Record descriptor flag */
+                rsv2:2,         /* Reserved */
+                fmh4bdtf:1,     /* Block data transform flag */
+                fmh4rdtf:1;     /* Reserved */
+        __u8    fmh4lbn;        /* Length of FMH4BN */
+
+        __u8    *fmh4bn;        /* Name of block */
+
+        __u8    fmh4lbdt;       /* Length of FMH4BDT */
+
+        unsigned char fmh4bdt;  /* Block data transform */
+
+        __u8    fmh4lvid;       /* Length of FMH4VID */
+
+        unsigned char fmh4vid;  /* Version identifier */
+};
+
+struct fmh5_sec_access
+{
+        __u8    length;         /* Length */
+        __u8    type;           /* Subfield type */
+        unsigned char data;     /* Security data about receiver */
+};
+
+/* PIP header */
+struct piph
+{
+        __u16   length;
+        __u16   gds;            /* GDS indicator */
+
+        /* PIP sub-fields of structure piph, unlimited length */
+        unsigned char sub_pip;
+};
+
+/* SNA Function Managment 5 header (LU 6.2) */
+struct sna_fmh5
+{
+        __u16   cmd     __attribute__ ((packed));               /* Command code
+*/
+        __u8    vid:1,          /* Already-verified indicator */
+                pvid:2,         /* Persistent-verification indicator */
+                spwdi:1,        /* Substituted password indicator */
+                pipi:1,         /* Program init parameter (PIP) presence */
+                xaid:1,         /* Extended authentication indicator */
+                rsv1:2;         /* Reserved */
+        __u8    fxct    __attribute__ ((packed));               /* Fixed length
+parameters */
+
+        __u8    resrc_type      __attribute__ ((packed));
+        __u8    rsv2    __attribute__ ((packed));
+        __u8    sync_level:2,
+                rsv3:6;
+        /* The options start here */
+        __u8    raw;
+};
+
+#ifdef NOT_LU62
+
+/* SNA Function Managment 5 header (Not LU 6.2) */
+struct sna_fmh5
+{
+        __u8    length;         /* Length of FMH-5 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000101 */
+        __u8    fmh5cmd;        /* Command code */
+        __u8    fmh5mod;        /* Modifier */
+        __u8    fmh5fxct;       /* Fixed length parameters */
+        __u8    attdsp;
+        __u8    attdba;
+
+        unsigned char *names;   /* Resource names, unlimited length */
+};
+
+#endif  /* CONFIG_SNA_LU62 */
+
+/* SNA Function Managment 6 header */
+struct sna_fmh6
+{
+        __u8    length;         /* Length of FMH-6 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000110 */
+        __u8    fmh6cmd;        /* Command code */
+        __u8    fmh6lnsz:1,     /* Length of parameter length fields */
+                rsv1:7;         /* Reserved */
+
+        /* Many variable lenth params */
+};
+
+/* SNA Function Managment 7 header (LU 6.2) */
+struct sna_fmh7
+{
+        __u8    length;         /* Length of FMH-7 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0000111 */
+        __u32   erpsense;       /* Sense Data */
+        __u8    erplog:1,       /* Error log variable presence */
+                rsv2:7;         /* Reserved */
+};
+
+/* SNA Function Managment 8 header (LU 6.1) */
+struct sna_fmh8
+{
+        __u8    *raw;
+};
+
+/* SNA Function Managment 10 header */
+struct sna_fmh10
+{
+        __u8    length;         /* Length of FMH-10 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0001010 */
+        __u16   spccmd;         /* Sync point command */
+        __u16   spcmod;         /* Sync point modifier */
+};
+
+/* SNA Function Managment 12 header (LU 6.2) */
+struct sna_fmh12
+{
+        __u8    length;         /* Length of FMH-12 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0001100 */
+
+        unsigned char fmh12mac[7];      /* DES Message Authentication Code */
+};
+
+struct fmhdr {
+        __u8    len     __attribute__ ((packed));
+	__u8	type	__attribute__ ((packed));
+/*
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    type:7  __attribute__ ((packed));
+*/
+
+        union {
+                struct sna_fmh1         f1      __attribute__ ((packed));
+                struct sna_fmh2         f2      __attribute__ ((packed));
+                struct sna_fmh4         f4      __attribute__ ((packed));
+                struct sna_fmh5         f5      __attribute__ ((packed));
+                struct sna_fmh6         f6      __attribute__ ((packed));
+                struct sna_fmh7         f7      __attribute__ ((packed));
+                struct sna_fmh8         f8      __attribute__ ((packed));
+                struct sna_fmh10        f10     __attribute__ ((packed));
+                struct sna_fmh12        f12     __attribute__ ((packed));
+        } fm;
+};
+
+/* GDS.
+ */
+
+/*
+ * SNA GDS (Global Data Stream) definitions
+ *
+ * Identifer registery
+ * 0000 - 01FF          3270
+ * 03xx                 3270
+ * 06xx                 3270
+ * 09xx                 3270
+ * 0B00 - 0EFF          3270
+ * 0Fxx                 3270
+ * 101x                 3270
+ * 1030 - 1034          Print Job Restart
+ * 1058 - 105B          Workstation Platform/2
+ * 1100 - 1104          SNA Character String
+ * 12xx                 LU 6.2 and APPN
+ * 13xx                 SNA/Management Services
+ * 140x                 3820 Page Priner
+ * 1500                 Dependent LU Requester/Server
+ * 1501                 Subarea Routing Services
+ * 1520                 DLSw Capabilities eXchange
+ * 1521                 DLSw Capabilities eXchange Positive Response
+ * 1522                 DLSw Capabilities eXchange Negative Response
+ * 1530 - 1531          SNA File Services
+ * 1532                 SNA Condition Report
+ * 1533 - 154F          SNA File Services
+ * 1550 - 155F          SNA File Services
+ * 1570 - 158F          SNA/Distribution Services
+ * 4000 - 41FF          3270
+ * 4A00 - 4CFF          3270
+ * 71xx                 3250
+ * 8000 - 81FF          3270
+ * C00x                 Document Interchange Architecture
+ * C100 - C104          Document Interchange Architecture
+ * C105                 SNA/Distribution Services
+ * C10A - C122          Document Interchange Architecture
+ * C123 - C124          SNA/Distribution Services
+ * C219                 Document Interchange Architecture
+ * C300 - C345          Document Interchange Architecture
+ * C350 - C361          SNA/Distribution Services
+ * C366 - C46F          Document Interchange Architecture
+ * C500 - C56F          Document Interchange Architecture
+ * C600 - C66F          Document Interchange Architecture
+ * C7xx                 Graphical Display Data Manager
+ * C800 - C87F          Document Interchange Architecture
+ * C900 - CB0F          Document Interchange Architecture
+ * CC00 - CC3F          Document Interchange Architecture
+ * CF0x                 Document Interchange Architecture
+ * D0xx                 Distributed Data Management
+ * D3xx                 Document Content Architecture
+ * D6xx                 Intelligent Printer Data Stream
+ * D780 - D7BF          Facsimile Architecture
+ * D820 - D821          AS/400 (5250)
+ * D822 - D826          AS/400 (5394)
+ * D930 - D95F          AS/400 (5250)
+ * E10x                 Level-3 Document Content Architecture
+ * E20x                 Level-3 Document Content Architecture
+ * E30x                 Level-3 Document Content Architecture
+ * E40x                 Level-3 Document Content Architecture
+ * E50x                 Level-3 Document Content Architecture
+ * E60x                 Level-3 Document Content Architecture
+ * E70x                 Level-3 Document Content Architecture
+ * E80x                 Level-3 Document Content Architecture
+ * E90x                 Level-3 Document Content Architecture
+ * EA0x                 Level-3 Document Content Architecture
+ * EFFF                 IBM TokenRing Network PC Adapter
+ * F000 - FEFF          Non-IBM Reserve Block
+ * FFxx                 Context-Dependent Block
+ */
+
+/*
+ * SNA Service Transaction Programs (STPs)
+ */
+#define SNA_GDS_CHG_NUM_SESS            0x1210
+typedef struct {
+        __u8    rsv1:4,
+                service_flag:4;
+        __u8    reply_mod;
+        __u8    action;
+        __u8    rsv2:3,
+                src_lu_drain:1,
+                rsv3:3,
+                dst_lu_drain:1;
+        __u8    rsv4:7,
+                sess_deact_resp:1;
+        __u16   rsv5:1,
+                max_sess_cnt:15;
+        __u16   rsv6:1,
+                src_g_min_cont_win:15;
+        __u16   rsv7:1,
+                dst_g_min_cont_win:15;
+        __u8    rsv8:7,
+                affect_mode_names:1;
+        __u8    mode_name_len;
+        __u8    mode_name;                      /* Start of Mode Name */
+} gds_chg_num_sess;
+
+struct sna_gds {
+        __u16   cvlen:16;
+        __u16   cvid:16;
+
+        union {
+
+        } cv;
+};
+
+/* HPR.
+ */
+
+/* Switching mode defines */
+#define HPR_FUNCT_RT    101
+#define HPR_ANR         110
+
+/* NLP Time-Sensitivity */
+#define NLP_NOT_TIME_SENSE      0
+#define NLP_TIME_SENSE          1
+
+/* Congestion defines */
+#define NLP_SLOW1_TRUE          1
+#define NLP_SLOW1_FLASE         0
+#define NLP_SLOW2_TRUE          1
+#define NLP_SLOW2_FLASE         0
+
+/* HPR Network Layer Header (NHDR) */
+struct sna_nhdr
+{
+        __u8    sm:3,           /* Switching mode */
+                __pad1:2,
+                tpf:2,          /* Transmission priority field */
+                __pad2:1;
+        __u8    ftype:4,        /* Function type */
+                tsdata:1,       /* Time-sensitive packet indicator */
+                slow1:1,        /* Slowdown (minor) indicator */
+                slow2:1,        /* Slowdown (significant) indicator */
+                __pad3:1;
+
+        /* Variable length data fields */
+};
+
+/* PS.
+ */
+
+/* Flag structures for PS10 header */
+struct psh10_prepare
+{
+        __u8    luname:1,       /* LU names indicator */
+                wait:1,         /* Wait for outcome indicator */
+                __pad1:3,
+                locks:1,        /* LOCKS parameter indicator */
+                __pad2:2;
+};
+
+struct psh10_rqcommit
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                wait:1,         /* Wait for outcome indicator */
+                reliable:1,     /* Resource reliability indicator */
+                sprq:1,         /* OK to leave out sync-point request */
+                rreport:1,      /* Initiator read-only reporting */
+                locks:1,        /* LOCKS parameter indicator */
+                __pad1:2;
+};
+
+struct psh10_committed
+{
+        __u8    __pad1:1,
+                resync:1,       /* Resync processing status */
+                sluwid:1,       /* Source of next LUWID */
+                sprq:1,         /* OK to leave out sync-point request */
+                ifexcpt:1,      /* Implied Forget expectation indicator */
+                __pad2:3;
+};
+
+struct psh10_forget
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                resync:1,       /* Resync processing status */
+                __pad1:6;
+};
+
+struct psh10_hm
+{
+        __u8    __pad1:2,
+                sluwid:1,       /* Source of next LUWID */
+                __pad2:5;
+};
+
+struct psh10_nluwid
+{
+        __u8    __pad1;
+};
+
+/* PS10 header */
+struct sna_psh10
+{
+        __u8    length;         /* Length */
+
+        __u8    rsv:1,
+                type:7;
+
+        union {
+                struct psh10_prepare    prepare;
+                struct psh10_rqcommit   rqcommit;
+                struct psh10_committed  committed;
+                struct psh10_forget     forget;
+                struct psh10_hm         hm;
+                struct psh10_nluwid     nluwid;
+        } flags;
+
+        __u8    spptype;        /* Sync-point command type */
+
+        /* Command specific data here */
+
+        __u16   flowmod;        /* Modifier specifying next flow */
+
+        unsigned char sndlen[7];        /* Number of bytes sent */
+
+        /* All kinds of variable length structures */
+};
+
+/* TH.
+ */
+
+#define SNA_TH_FID0     0x0
+#define SNA_TH_FID1     0x1
+#define SNA_TH_FID2     0x2
+#define SNA_TH_FID3     0x3
+#define SNA_TH_FID4     0x4
+#define SNA_TH_FID5     0x5
+#define SNA_TH_FIDF     0xF
+
+#define SNA_TH_MPF_BBIU         0x2     /* 10 */
+#define SNA_TH_MPF_EBIU         0x1     /* 01 */
+#define SNA_TH_MPF_WHOLE_BIU    0x3     /* 11 */
+#define SNA_TH_MPF_NO_BIU       0x0     /* 00 */
+#define SNA_TH_MPF_MID_MIU      SNA_TH_MPF_NO_BIU
+
+#define SNA_TH_EFI_NORM         0x0
+#define SNA_TH_EFI_EXP          0x1
+
+typedef struct {
+        __u16   biui:1,
+                sqn:15;
+} sna_snf;
+
+/* FID0 and FID1 formats are used between adjacent subarea nodes when
+ * either or both nodes do not support ER and VR protocols.
+ */
+struct sna_fid0 {
+	__u8	ft:4;
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                 efi:1;         /* Expedited Flow Indicator. */
+        __u8    rsv2;
+        __u16   daf;            /* Destination Address Field. */
+        __u16   oaf;            /* Origin Address Field. */
+        sna_snf snf;            /* Sequence Number Field. */
+        __u16   dcf;            /* Data Count Field. */
+};
+
+struct sna_fid2_cheat {
+	__u8	bits[6];
+};
+
+struct sna_fid2 {
+	__u8    ft:4    __attribute__ ((packed));
+        __u8    mpf:2   __attribute__ ((packed));
+        __u8    odai:1  __attribute__ ((packed));
+        __u8    efi:1   __attribute__ ((packed));
+        __u8    rsv1    __attribute__ ((packed));
+        __u8    daf     __attribute__ ((packed));
+        __u8    oaf     __attribute__ ((packed));
+        sna_snf snf     __attribute__ ((packed));
+};
+
+struct sna_fid3 {
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                efi:1;          /* Expedited Flow indicator. */
+        __u8    lsid;           /* Local session identification. */
+};
+
+struct sna_fid4 {
+        __u8    tg_sweep:1,
+                er_vr_supp_ind:1,
+                vr_pac_cnt_ind:1,
+                ntwk_prty:1;
+
+        __u8    tgsf:2,
+                rsv1:2,
+                chk:1,
+                hft:1,
+                piubf:2;
+
+        __u8    nlpoi:1,
+                nlp_cnt:3,
+                ern:4;
+
+        __u8    vrn:4,
+                rsv2:2,
+                tpf:2;
+
+        __u16   vr_cwi:1,
+                tg_nonfifo_ind:1,
+                vr_sqti:2,
+                tg_snf:12;
+
+        __u16   vrprq:1,
+                vrprs:1,
+                vr_cwri:1,
+                vr_rwi:1,
+                vr_snf_send:12;
+
+        __u8    dsaf[4];
+        __u8    osaf[4];
+
+        __u8    rsv3:3,
+                snai:1,
+                mpf:2,
+                rsv4:1,
+                efi:1;
+
+        __u8    rsv5;
+
+        __u16   def;
+        __u16   oef;
+        sna_snf snf;
+        __u16   dcf;
+};
+
+struct sna_fid5 {
+        __u8    mpf:2,
+                rsv1:1,
+                efi:1;
+
+        __u8    rsv2;
+
+        sna_snf snf;
+
+        __u8    sa[8];
+};
+
+struct sna_fidf {
+        __u8    rsv1:4;
+        __u8    rsv2;
+        __u8    cmd_fmt;        /* 0x01. */
+        __u8    cmd_type;       /* 0x01. */
+        __u16   cmd_snf;
+        __u8    rsv3[18];
+        __u16   dcf;
+};
+
+struct snathdr {
+        union {
+                struct sna_fid0 f0      __attribute__ ((packed));
+                struct sna_fid2 f2      __attribute__ ((packed));
+                struct sna_fid3 f3      __attribute__ ((packed));
+                struct sna_fid4 f4      __attribute__ ((packed));
+                struct sna_fid5 f5      __attribute__ ((packed));
+                struct sna_fidf ff      __attribute__ ((packed));
+        } fid;
+};
+
+/* RH.
+ */
+
+#define SNA_RH_RRI_REQ          0x0
+#define SNA_RH_RRI_RSP          0x1
+
+#define SNA_RH_RU_FMD           0x0     /* 00 */
+#define SNA_RH_RU_NC            0x1     /* 01 */
+#define SNA_RH_RU_DFC           0x2     /* 10 */
+#define SNA_RH_RU_SC            0x3     /* 11 */
+
+#define SNA_RH_FI_NO_FMH        0x0
+#define SNA_RH_FI_FMH           0x1
+
+#define SNA_RH_SDI_NO_SD        0x0
+#define SNA_RH_SDI_SD           0x1
+
+#define SNA_RH_BCI_NO_BC        0x0
+#define SNA_RH_BCI_BC           0x1
+
+#define SNA_RH_ECI_NO_EC        0x0
+#define SNA_RH_ECI_EC           0x1
+
+#define SNA_RH_DR1I_NO_DR1      0x0
+#define SNA_RH_DR1I_DR1         0x1
+
+#define SNA_RH_LLCI_NO_LLC      0x0
+#define SNA_RH_LLCI_LLC         0x1
+
+#define SNA_RH_DR2I_NO_DR2      0x0
+#define SNA_RH_DR2I_DR2         0x1
+
+#define SNA_RH_RTI_POS          0x0
+#define SNA_RH_RTI_NEG          0x1
+
+#define SNA_RH_RLWI_NO_RLW      0x0
+#define SNA_RH_RLWI_RLW         0x1
+
+#define SNA_RH_QRI_NO_QR        0x0
+#define SNA_RH_QRI_QR           0x1
+
+#define SNA_RH_PI_NO_PAC        0x0
+#define SNA_RH_PI_PAC           0x1
+
+#define SNA_RH_BBI_NO_BB        0x0
+#define SNA_RH_BBI_BB           0x1
+
+#define SNA_RH_EBI_NO_EB        0x0
+#define SNA_RH_EBI_EB           0x1
+
+#define SNA_RH_CDI_NO_CD        0x0
+#define SNA_RH_CDI_CD           0x1
+
+#define SNA_RH_CSI_CODE0        0x0
+#define SNA_RH_CSI_CODE1        0x1
+
+#define SNA_RH_EDI_NO_ED        0x0
+#define SNA_RH_EDI_ED           0x1
+
+#define SNA_RH_PDI_NO_PD        0x0
+#define SNA_RH_PDI_PD           0x1
+
+#define SNA_RH_CEBI_NO_CEB      0x0
+#define SNA_RH_CEBI_CEB         0x1
+
+struct snarhdr {
+        /* 1st byte */
+        __u8    rri:1   __attribute__ ((packed));
+        __u8    ru:2    __attribute__ ((packed));
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    fi:1    __attribute__ ((packed));
+        __u8    sdi:1   __attribute__ ((packed));
+        __u8    bci:1   __attribute__ ((packed));
+        __u8    eci:1   __attribute__ ((packed));
+
+        /* 2nd byte */
+        __u8    dr1i:1  __attribute__ ((packed));
+        __u8    llci:1  __attribute__ ((packed));
+        __u8    dr2i:1  __attribute__ ((packed));
+        __u8    rti:1   __attribute__ ((packed));
+        __u8    rsv2:1  __attribute__ ((packed));
+        __u8    rlwi:1  __attribute__ ((packed));
+        __u8    qri:1   __attribute__ ((packed));
+        __u8    pi:1    __attribute__ ((packed));
+
+        /* 3rd byte */
+        __u8    bbi:1   __attribute__ ((packed));
+        __u8    ebi:1   __attribute__ ((packed));
+        __u8    cdi:1   __attribute__ ((packed));
+        __u8    rsv3:1  __attribute__ ((packed));
+        __u8    csi:1   __attribute__ ((packed));
+        __u8    edi:1   __attribute__ ((packed));
+        __u8    pdi:1   __attribute__ ((packed));
+        __u8    cebi:1  __attribute__ ((packed));
+};
+
+/* RU.
+ */
+
+/* ABCONN (Abandon Connection) */
+struct sna_abconn {
+        __u16 ena;
+};
+
+/* ABCONNOUT (Abandon Connect Out) */
+struct sna_abconnout {
+        __u16 ena;
+};
+
+/* Type of activation indicators */
+#define COLD    0x1
+#define ERP     0x2
+
+struct sna_sscp_id {
+        __u8    format:4,
+                pu_type:4;
+        char    id[4];
+};
+
+/* ACTDRM (Activate Cross-Domain Resource Manager) */
+struct sna_actcdrm {
+        __u8    request;        /* 0x14 */
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile;
+        __u8    ts_profile;
+        char    contents_id[7];
+        struct  sna_sscp_id *sscp_id;
+        __u8    __pad1:2,
+                primary_hs_rcv_win_size:6;
+};
+
+/* ACTCONNIN (Activate Conect In) */
+struct sna_actconnin {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    incoming_call:1,
+                info_rq:1,
+                __pad1:6;
+};
+
+/* ACTLINK (Activate Link) */
+struct sna_actlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    switched_subarea:1,
+                sub_llink:1,
+                __pad1:6;
+};
+
+/* ACTLU (Activate Logical Unit) */
+struct sna_actlu {
+        __u8    request_code;
+        __u8    eami:1,         /* Enhanced Addr. Management Indicator */
+                sdai:1,         /* Static/dynamic addr. indicator */
+                __pad1:4,
+                type_activation:2;
+        __u8    fm_profile:4,
+                ts_profile:4;
+};
+
+/* ACTPU (Activate Physical Unit) */
+struct sna_actpu {
+        __u8    request_code;
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile:4,
+                ts_profile:4;
+        struct sna_sscp_id *sscp_id;
+};
+
+/* ACTTRACE (Activate Trace) */
+struct sna_trace_bit {
+        __u8    tx_group:1,
+                piu:1,
+                __pad1:2,
+                scanner_internal:1,
+                __pad2:1,
+                all_frames:1,
+                link:1;
+};
+
+struct sna_acttrace {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct sna_trace_bit *trace;
+
+        /* Some trace specific trailers */
+};
+
+/* ADDLINK (Add Link) */
+struct sna_addlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u16   __pad1;
+        __u8    size_llink_id;
+        /* 8-n llink ID */
+};
+
+/* ADDLINKSTA (Add Link Station) */
+struct sna_fid_bit {
+        __u8    fid0:1,
+                fid1:1,
+                fid2:1,
+                fid3:1,
+                fid4:1,
+                __pad1:3;
+};
+
+struct sna_addlinksta {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct  sna_fid_bit *fid;
+        __u8    __pad1;
+        __u8    size_linksta_id;
+        /* 8-n Link station ID */
+};
+
+/* ANA (Assign Network Addresses) */
+struct sna_ana {
+        /* Retired */
+};
+
+/* BFCINIT (BF Control Initiate) */
+struct sna_bfcinit {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:1,
+                sub_source:1,
+                save_rscv:1,
+                copy_rscv:1,
+                sub_names:2,
+                ext_bind:1,
+                __pad3:1;
+        char    __pad4[4];
+        __u16   size_bind_image;
+        /* Bind Image */
+        /* Other variable length goodies */
+};
+
+/* BFCLEANUP (BF Cleanup) */
+struct sna_bfcleanup {
+        /* 0-2 NS header, 0x812629 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   __pad2;
+
+        /* Session keys */
+        /* Control Vectors */
+};
+
+/* BFINIT (BF Initiate) */
+struct sna_bfinit {
+        /* 0-2 NS header, 0x812681 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   size_bind_image;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSEND (BF Session Ended) */
+struct sna_bfsessend {
+        /* 0-2 NS header, 0x812688 */
+        __u16   ena;
+        __u8    format:4,
+                lu_role:1,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSINFO (BF Session Information) */
+struct sna_bfsessinfo {
+        /* 0-2 NS header, 0x81268C */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    als_takeover:1,
+                lu_takeover:1,
+                auth_lu:1,
+                sdai:1,
+                static_lu_addr_status:1,
+                __pad2:3;
+        __u16   __pad3;
+        __u8    size_lu_name;
+
+        /* Network Qualified LU name */
+        /* Control Vectors */
+};
+
+/* BFSESSST (BF Session Started) */
+struct sna_bfsessst {
+        /* 0-2 NS header, 0x812686 */
+        __u16   ena;
+        __u8    format:4,
+                __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFTERM (BF Terminate) */
+struct sna_bfterm {
+        /* 0-2 NS header, 0x812683 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BID (BID) Not for LU6.2 */
+struct sna_nonlu62_bid {
+        __u8    request_code;
+};
+
+/* BIND (BIND Session) */
+#define BIND_RQ			0x31
+
+#define BIND_FORMAT_NEG		0x00
+#define BIND_FORMAT_NONNEG	0x01
+
+#define TSH_2			0x02
+#define TSH_3			0x03
+#define TSH_4			0x04
+#define TSH_7			0x07
+
+#define CV_COS_TPF		0x2C
+#define CV_FQ_PCID		0x60
+#define CV_ROUTE_SEL		0x2B
+#define CV_TG_DESC		0x46
+#define CV_TG_ID		0x80
+
+#pragma pack(1)
+struct sna_bind {
+/* 0 */ __u8    request_code		__attribute__ ((packed));
+/* 1 */ __u8    format:4,
+                type:4			__attribute__ ((packed));
+/* 2 */ __u8    fm_profile		__attribute__ ((packed));
+/* 3 */ __u8    ts_profile		__attribute__ ((packed));
+/* 4 */ __u8	pri_flags		__attribute__ ((packed));
+/* 5 */ __u8 	sec_flags		__attribute__ ((packed));
+/* 6 */ __u8	cm1_flags		__attribute__ ((packed));
+/* 7 */	__u8	cm2_flags		__attribute__ ((packed));
+
+/* TS Usage */
+/* 8 */ __u8    sec_tx_win_size		__attribute__ ((packed));
+/* 9 */ __u8    sec_rx_win_size		__attribute__ ((packed));
+/*10 */ __u8    shs_max_ru_size		__attribute__ ((packed));
+/*11 */ __u8    phs_max_ru_size		__attribute__ ((packed));
+/*12 */ __u8    pri_tx_win_size		__attribute__ ((packed));
+/*13 */ __u8    pri_rx_win_size		__attribute__ ((packed));
+
+/* PS profile */
+/*14 */ __u8    lu_type			__attribute__ ((packed));
+
+/* PS usage */
+/*15 */ __u8    lu6_level		__attribute__ ((packed));
+/*16 */ __u8    __pad5[7]		__attribute__ ((packed));
+/*23 */ __u8    ps1_flags		__attribute__ ((packed));
+/*24 */ __u8    ps2_flags		__attribute__ ((packed));
+
+/* User data and control vectors */
+	__u8	raw;
+};
+#pragma pack()
+
+typedef struct {
+        __u8    chain_sel:1,
+                request_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                __pad1:1,
+                scbi:1,
+                send_end_bracket:1;
+} sna_fm_usage_bit;
+
+struct sna_reason_bit {
+        __u8    plu:1,
+                bind:1,
+                setup_rej_plu:1,
+                setup_rej_slu:1,
+                __pad1:4;
+};
+
+/* BINDF (Bind Failure) */
+struct sna_bindf {
+        /* 0-2 NS header, 0x810685 */
+        char    sense_data[3];
+        struct  sna_reason_bit *reason;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BIS (Bracket Initiation Stopped) */
+struct sna_bis {
+        __u8    request_code;
+};
+
+/* CANCEL (Cancel) */
+struct sna_cancel {
+        __u8    request_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate) */
+struct sna_cdcinit {
+        /* 0-2 NS header, 0x81864B */
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:7,
+                xrf_bind:1;
+        char    pcid[7];
+
+        /* Session pair identifiers */
+};
+
+/* CDINIT (Cross-Domain Initiate) */
+struct sna_cdinit {
+        /* 0-2 NS header, 0x818641 */
+        __u8    format:4,
+                __pad1:4;
+
+        /* A mess of stuff after here */
+};
+
+/* CDSESSEND (Cross-Domain Session Ended) */
+struct sna_cdsessend {
+        /* 0-2 NS header, 0x818648 */
+        char    pcid[7];
+        __u8    format:4,
+                __pad1:4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSSF (Cross-Domain Session Setup Failure) */
+struct sna_cdsesssf {
+        /* Retired */
+};
+
+/* CDSESSST (Cross-Domain Session Started) */
+struct sna_cdsessst {
+        /* 0-2 NS header, 0x818646 */
+        char    pcid[7];
+        __u8    __pad1;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSTF (Cross-Domain Session Takedown Failure) */
+struct sna_cdsesstf {
+        /* Retired */
+};
+
+struct sna_cdtaked {
+        /* 0-2 NS header, 0x818649 */
+        char    pcid[7];
+        __u8    type:2,
+                takedown:2,
+                sscp_sscp_term:1,
+                __pad1:3;
+        struct  sna_reason_bit *reason;
+};
+
+/* CDTAKEDC (Cross-Domain Takedown Complete) */
+struct sna_cdtakedc {
+        /* 0-2 NS header, 0x81864A */
+        char    pcid[7];
+        __u8    type;
+        __u8    status;
+};
+
+/* CDTERM (Cross-Domain Terminate) */
+struct sna_cdterm {
+        /* 0-2 NS header, 0x818643 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    type:2,
+                termination_type:1,
+                send_dactlu_to_dlu:1,
+                __pad2:1,
+                __pad3:2,
+                __termination:1;
+        char    pcid[7];
+        __u8    network:1,
+                normal:1,
+                reason_code:1,
+                sess_setup:1,
+                cinit_cterm_err:1,
+                bind_unbind_err:1,
+                setup_taked_rej:1,
+                setup_rej:1;
+        __u16   __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CHASE (Chase) */
+struct sna_chase {
+        __u8    request_code;
+};
+
+/* CINIT (Control Initiate) */
+struct sna_cinit {
+        /* 0-2 NS header, 0x810601 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    init_lu_olu:1,
+                sub_source:1,
+                lu_olu:1,
+                __pad2:1,
+                name_sub:2,
+                ext_bind:1,
+                bind_xrf:1;
+        char    sess_key[4];
+        __u16   size_bind_image;
+
+        /* Lots of variable length crap */
+};
+
+/* RU packet type */
+#define RU_RQ	0	/* Request Unit */
+#define RU_RSP	1	/* Response Unit */
+
+/* RU category */
+#define RU_FM_DATA_UNIT	00
+#define RU_NC_UNIT	01
+#define RU_DFC_UNIT	10
+#define RU_SC_UNIT	11
+
+/* RU format indicator */
+#define RU_FMH_TRUE	1
+#define RU_FMH_FALSE	0
+
+/* RU sense data indicator */
+#define RU_SDI_TRUE	1
+#define RU_SDI_FALSE	0
+
+/* Begin/End chain indicator */
+#define RU_BC_FIRST_TRUE	1
+#define RU_BC_FIRST_FALSE	0 
+#define RU_EC_LAST_TRUE		1
+#define RU_EC_LAST_FALSE	0
+
+/* Definite response 1 indicator */
+#define RU_DR1_TRUE	1
+#define RU_DR1_FALSE	0
+
+/* Length checked compression indicator */
+#define RU_LCC_TRUE	1
+#define RU_LCC_FALSE	0
+
+/* Definate response 2 indicator */
+#define RU_DR2_TRUE	1
+#define RU_DR2_FLASE	0
+
+/* Response type indicators */
+#define RU_RT_POSITIVE	0
+#define RU_RT_NEGATIVE	1
+
+/* Request larger window indicator */
+#define RU_RLW_TRUE	1
+#define RU_RLW_FLASE	0
+
+/* Queue response indicators */
+#define RU_QR_PASS_TC_QUEUE	0
+#define RU_QR_TC_QUEUE		1
+
+/* Pacing indicators */
+#define RU_PACE_TRUE	1
+#define RU_PACE_FLASE	0
+
+/* Begin bracket indicators */
+#define RU_BB_TRUE	1
+#define RU_BB_FLASE	0
+
+/* End bracket indicators */
+#define RU_EB_TRUE	1
+#define RU_EB_FLASE	0
+
+/* Change direction indicators */
+#define RU_CD_TRUE	1
+#define RU_CD_FALSE	0
+
+/* Code selection indicators */
+#define RU_CS_TRUE	1
+#define RU_CS_FASE	0
+
+/* Enciphered data indicators */
+#define RU_ED_TRUE	1
+#define RU_ED_FALSE	0
+
+/* Padded data indicators */
+#define RU_PD_TRUE	1
+#define RU_PD_FALSE	0
+
+/* Conditional end bracket indicator */
+#define RU_CEB_TRUE	1
+#define RU_CEB_FALSE	0
+
+/* Session-level crypto indicators. */
+#define SNA_RU_CRYPTO_NO	0x0
+#define SNA_RU_CRYPTO_SELECT	0x1
+#define SNA_RU_CRYPTO_MANDATORY	0x3
+
+struct sna_ru_ipm {
+	__u8	ipmtype:2,
+		rwi:1,
+		rsv1:5;
+	__u16	nwfmt:1,
+		nws:15;
+};
+
+struct sna_send_parm {
+	__u8	allocate;
+	__u8	fmh;
+	__u8	type;
+	__u8	*data;
+};
+
+struct sna_security_reply_2 {
+	struct sna_send_parm send_parm;
+};
+
+/* ABCONN (Abandon Connection). Request the PU to deactive the link connection
+ * for the specified link.
+ */
+struct sna_ru_abconn {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACONNOUT (Abandon Connection Out). Requests the PU to terminate a
+ * connect-out procedure on the designated link.
+ */
+struct sna_ru_abconnout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACTCDRM (Activate Cross-Domain Resource Manager). ACTCDRM is sent
+ * from one SSCP to another SSCP to activate a session between them and
+ * to exchange information about the SSCPs.
+ */
+struct sna_ru_actcdrm {
+	__u8	req_code;	/* 0x14 request code. */
+	__u8	format:4,	/* Format: 0x0. */
+		act_type:4;	/* Type of activation requested:
+				 * 0x1 - cold.
+				 * 0x2 - ERP.
+				 */
+	__u8	fm_profile;
+	__u8	ts_profile;
+	__u8	contents_id[8];
+	__u8	sscp_id[6];
+
+	__u8	rsv1:2,
+		pri_hs_rcv_window_size:6;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTCONNIN (Activate Connection In). ACTCONNIN requests the PU to enable
+ * the specified link to accept incomming calls. It can also be used to
+ * solicit information about an existing connection on the link.
+ */
+struct sna_ru_actconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	incomming_call:1,
+		info_reqi:1,
+		rsv1:6;
+	__u8	*ctrl_vectors;
+};
+
+/* ACTLINK (Activate Link). ACTLINK initiates a procedure at the PU to
+ * activate the protocol boundary between a link station in the node (as
+ * specified by the link network address parameter in the request) and
+ * the link connection attached to it.
+ */
+struct sna_ru_actlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	swsai:1,	/* Switched subarea support indicator. */
+		slli:1,		/* Subordinate logical link indicator. */
+		rsv1:6;
+};
+
+/* ACTLU (Activate Logical Unit). ACTLU is sent from an SSCP to an LU to
+ * activate a session betwrrn the SSCP and the LU and to establish common
+ * session parameters.
+ */
+struct sna_ru_actlu {
+	__u8	req_code;	/* 0x0D. */
+	__u8	eami:1,		/* Enhanced Address Managment indicator. */
+		sdai:1,		/* Static/Dynamic Address indicator. */
+		rsv1:4,
+		act_type:2;	/* Activation type request. */
+
+	__u8	fm_profile:4,
+		ts_profile:4;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTPU (Activate Physical Unit). ACTPU is sent by the SSCP to activate a
+ * session with the PU, and to obtain certain information about the PU.
+ */
+struct sna_ru_actpu {
+	__u8	req_code;		/* 0x11. */
+	__u8	format:4,
+		act_type:4;
+	__u8	fm_profile:4,
+		ts_profile:4;
+	__u8	sscp_id_format:4,	/* 0x0000. */
+		sscp_node_type:4;
+	__u8	sscp_id_desc[5];
+	__u8	*ctrl_vectors;
+};
+
+/* ACTTRACE (Activate Trace). ACTTRACE requests the PU to activate a
+ * specified type of trace for a specified resource or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_acttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* Trace type. */
+	__u8	tg_trace:1,	/* Transmission group trace. */
+		piu_trace:1,	/* Generalized PIU trace (GPT). */
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	/* Trace specific data. */
+};
+
+/* ADDLINK (Add Link). ADDLINK is sent from the SSCP to the PU to obtain a
+ * link network address that will be mapped to the locally-used link
+ * identifier specified in the request.
+ */
+struct sna_ru_addlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u16	rsv1;
+	__u8	llid_len;	/* Local Link ID length. */
+	__u8	*llid;		/* Local Link ID. */
+};
+
+/* ADDLINKSTA (Add Link Station). ADDLINKSTA is sent from the SSCP to the PU
+ * to obtain an adjacent link station network address to be associated with
+ * the locally-used link station identifier specified in the request.
+ */
+struct sna_ru_addlinksta {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* FID type supported. */
+	__u8	fid0:1,
+		fid1:1,
+		fid2:1,
+		fid3:1,
+		fid4:1,
+		rsv1:3;
+	__u8 	rsv2;
+	__u8	lsid_len;		/* Link Station ID length. */
+	__u8	*lsid;			/* Link Station ID. */
+};
+
+/* BFCINIT (BF Control Initiate). BCFINIT requests the BF(LU) to attempt to
+ * activate, via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_bfcinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+
+	__u8	rsv2:1,
+		sub_src:1,	/* Substitution source. */
+		save_rscv:1,
+		copy_rscv:1,
+		names_sub:2,
+		no_ext_bind:1,
+		ext_bind:1;
+
+	__u8	rsv3[5];
+
+	__u16	bind_image_len;
+
+	__u8	*bind_image;
+};
+
+/* BFCLEANUP (BF Cleanup). BFCLEANUP is sent with definite response
+ * requested to request that the BF(PLU) ot BF(SLU) attempt to deactivate
+ * the identified session.
+ */
+struct sna_ru_bfcleanup {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFINIT (BF Initiate). BFINIT from the BF(LU) requests the initiation of
+ * a session between the two LUs named in the BIND image.
+ */
+struct sna_ru_bfinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+};
+
+/* BFSESSEND (BF Session Ended). BFSESSEND notifies the SSCP that the LU-LU
+ * session identified has been deactivated.
+ */
+struct sna_ru_bfsessend {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESSINFO (BF Session Information). BFSESSINFO provides the SSCP with
+ * information about sessions with SSCP-independent LUs in a peripheral
+ * node taken over by the receiving SSCP.
+ */
+struct sna_ru_bfsessinfo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	als_takeover:1,
+		lu_takeover:1,
+		auth_lui:1,		/* Authorized LU indicator. */
+		sdai:1,			/* Static/Dynamic address indicator. */
+		slu_addr:1,		/* Static LU address. */
+		rsv2:2;
+	__u16	rsv3;
+
+	__u8	nq_lu_name_len;
+	__u8	*nq_lu_name;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESST (BF Session Started). BFSESSST informs the SSCP that a new LU-LU
+ * session has been activated and provides information about the active
+ * session.
+ */
+struct sna_ru_bfsessst {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		lu_role:1,
+		rsv1:3;
+
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFTERM (BF Terminate). BFTERM from the BF(LU) requests that the SSCP
+ * assist in the termination of the identified LU-LU session.
+ */
+struct sna_ru_bfterm {
+	__u8	ns_hdr[3];
+	__u16	element_type;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BID (BID). BID is used by the bidder to request permission to initiate
+ * a bracket, and is used only when using brackets. This RU is not used for
+ * LU 6.2.
+ */
+struct sna_ru_bid {
+	__u8	req_code;
+};
+
+/* BIND (BIND Session). BIND is sent from a primary LU to a seconday LU to
+ * activate a session between the LUs. The secondary LU uses the BIND
+ * parameters to help determine whether it will response positively or
+ * negativly to BIND.
+ */
+struct sna_ru_bind_fm_use {
+	__u8    chaining:1,
+                req_cntl_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                rsv1:1,
+                fmh1_scb_cmp:1,
+                sebi:1;                 /* Send end bracket indicator. */
+};
+
+struct sna_ru_bind_crypto {
+	__u8	opts:2,
+		sess_level_crypto:2,
+		sess_level_crypto_opts:4;
+	__u8	sess_crypto_key_meth:2,
+		rsv1:2,
+		crypto_cipher_meth:4;
+	__u8	*crypto_key;
+};
+
+struct sna_ru_bind_user_data {
+	__u8	urc_len;
+	__u8	*urc;
+
+	__u8	sec_lu_name_len;
+	__u8	*sec_lu_name;
+
+	__u8	*ctrl_vectors;
+};
+
+#define SNA_RU_BIND_ADAPT_NO_SUPP	0x0
+#define SNA_RU_BIND_ADAPT_SUPP		0x1
+
+struct sna_ru_bind {
+	__u8	req_code;
+	__u8	format:4,
+		type:4;
+	__u8	fm_profile;
+	__u8	ts_profile;
+
+	struct sna_ru_bind_fm_use	pri_lu_proto;
+	struct sna_ru_bind_fm_use	sec_lu_proto;
+
+	__u8	whole_biu:1,
+		fm_hdr:1,
+		bracket_use:1,
+		backet_term:1,
+		alt_code:1,
+		seq_avail_sync_point:1,
+		bis_send:1,
+		bind_queue:1;
+
+	__u8	normal_flow_mode:2,
+		recovery:1,
+		contention:1,
+		alt_code_proc:2,
+		ctrl_vect_include:1,
+		half_dup_ff_reset:1;
+
+	__u8	staging:1,
+		rsv1:1,
+		sec_sws:6;		/* Secondary send window size. */
+
+	__u8	adapt_pace:1,
+		rsv2:1,
+		sec_rws:6;		/* Secondary receive window size. */
+
+	__u8	pri_hs_max_ru_size_sent;
+	__u8	sec_hs_max_ru_size_sent;
+
+	__u8	pri_sec_staging:1,
+		rsv3:1,
+		pri_sws:6;	/* Primary send window size. */
+	__u8	rsv4:2,
+		pri_rws:6;	/* Primary receive window size. */
+
+	__u8	ps_use_format:1,
+		lu_type:7;
+
+	__u8	lu6_level;
+	__u8	rsv6[5];
+
+	__u8	ext_security:1,
+		ext_security_sense:1,
+		rsv7:6;
+
+	__u8	rsv8:3,
+		converstation_level_security:1,
+		lu_lu_verification:1,
+		passwd_sub:1,
+		already_verified:1,
+		persistent_verification:1;
+
+	__u8	rsv9:1,
+		sync_level:2,
+		rsv10:1,
+		reinit_responsibility:2,
+		parallel_sess:1,
+		chg_num_sess:1;
+
+	__u8	rsv11:1,
+		limit_resc_sess:1,
+		rsv12:4,
+		len_chk_compression:2;
+
+	/* End of short bind image. */
+
+	struct sna_ru_bind_crypto crypto;
+
+	__u8	pri_lu_name_len;
+	__u8	*pri_lu_name;
+
+	/* User data field. */
+	__u8	user_data_len;
+	__u8	user_data_key;
+
+	union {
+		__u8	*user_data;
+		struct	sna_ru_bind_user_data *struct_user_data;
+	} data;
+};
+
+/* BINDF (BIND Failure). BINDF is sent, with no-response requested, by the
+ * PLU to notify the SSCP that the attempt to activate the session between
+ * the specified LUs has failed.
+ */
+struct sna_ru_bindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	reason;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BIS (Bracket Initiation Stopped). BIS is sent by the half-session to
+ * indicate that it will not attempt to begin any more brackets.
+ */
+struct sna_ru_bis {
+	__u8	req_code;
+};
+
+/* CANCEL (Cancel). CANCEL may be sent by a half-session to terminate a
+ * partially sent chain of FMD requests. CANCEL may be sent only when
+ * a chain is in process. The sending half-session may send CANCEL to end
+ * a partially sent chain if a negative response is received for a request
+ * in the chain, or for some other reason. This RU is not used by LU 6.2.
+ */
+struct sna_ru_cancel {
+	__u8	req_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate). CDCINIT passes information about
+ * the SLU from the SSCP(SLU) to the SSCP(PLU) and requests that the SSCP(PLU)
+ * send CINIT to the PLU.
+ */
+struct sna_ru_cdcinit_format0 {
+	__u16	plu_addr;
+	__u16	slu_addr;
+};
+
+struct sna_ru_cdcinit_format1 {
+	__u8	*session_key;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	__u16	char_field;
+	__u8	char_format;
+	__u8	*desc;
+
+	__u8	sess_crypto_key_len;
+	__u8	*pri_sess_crypto_key;
+
+	__u8	*ctrl_vectors;
+};
+
+struct sna_ru_cdcinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:7,
+		xrf_slu_supp:1;
+	__u8	*sess_pair_id;
+
+	union {
+		struct sna_ru_cdcinit_format0 format0;
+		struct sna_ru_cdcinit_format1 format1;
+	} format1;
+};
+
+/* CDINIT (Cross-Domain Initiate). CDINIT requests another SSCP to assist in
+ * initiating an LU-LU session for the specified (OLU,DLU) pair.
+ */
+struct sna_ru_cdinit {
+	__u8	*raw;
+};
+
+/* CDSESSEND (Cross-Domain Session Ended). CDSESSEND notifies the SSCP that the
+ * LU-LU session identified by the session key has been successfully
+ * deactivated, or that knowledge of session deactivation has been lost due to
+ * session outage with one or more of the participating LUs, gatewat nodes, or
+ * adjacent SSCPs. In the latter case, the session may still be active, but
+ * explicit notification of session deactivation is no longer possible.
+ */
+struct sna_ru_cdsessend {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDSESSST (Cross-Domain Session Started). CDSESSST notifies the SSCP(SLU)
+ * that the LU-LU session identified by the Session Key content field and
+ * the specified PCID for the initiation procedure has been sucessfully
+ * activated.
+ */
+struct sna_ru_cdsessst {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	rsv1;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDTAKED (Cross-Domain Take Down). CDTAKED initiates a procedure to cause
+ * the takedown of all cross-domain LU-LU sessions (active, pending-active,
+ * and queued) involving the domains of both the sending and receiving SSCP.
+ * It also prevents the initiation of new LU-LU sessions between these domains.
+ */
+struct sna_ru_cdtaked {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	lu_lu_type:2,
+		takedown:2,
+		sscp_sscp_term:1,
+		rsv1:3;
+
+	/* Reason. */
+	__u8	user:1,
+		state:1,
+		rsv2:6;
+};
+
+/* CDTAKEDC (Cross-Domain Take-Down Complete). Except when the Cleanup
+ * option was specified, the SSCP that received CDTAKED (and responded
+ * positively to it) sends CDTAKEDC upon completion of its domain takedown
+ * procedure. The other SSCP, after completing its domain takedown procedure
+ * and receivinf a CDTAKEDC, also sends a CDTAKEDC.
+ */
+struct sna_ru_cdtakedc {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	type;
+	__u8	status;
+};
+
+/* CDTERM (Cross-Domain Terminate). CDTERM requests that the receiving SSCP
+ * assist in the termination of the cross-domain LU-LU session identified
+ * by the Session Key and the Type byte of the RU. Each SSCP executes that
+ * portion of termination processing that relates to the LU in its domain.
+ */
+struct sna_ru_cdterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	type;
+	__u8	pcid[8];
+	__u8	reason;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u16	rsv3;
+	__u8	*ctrl_vectors;
+};
+
+/* CHASE (Chase). CHASE is sent by a half-session to request the receiving
+ * half-session to return all outstanding normal-flow responses to requests
+ * previously received from the issuer of CHASE. The receiver of CHASE sends
+ * the response to CHASE after processing (and sending any necessary responses
+ * to) all requests received before the CHASE. This RU is not used for LU 6.2.
+ */
+struct sna_ru_chase {
+	__u8	req_code;
+};
+
+/* CINIT (Control Initiate). CINIT requests the PLU to attempt to activate,
+ * via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_cinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	init_origin:1,
+		sub_source:1,
+		slu_plu_olu:1,
+		rsv2:1,
+		name_sub_plu_slu:2,
+		ext_bind_slu:1,
+		xrf_supp_slu:1;
+	__u8	session_key[5];
+
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	/* There is more. */
+};
+
+/* CLEANUP (Clean Up session). CLEANUP is sent by the SSCP to an LU (in a
+ * subarea node or BF for peripheral LU) requesting that the LU of BF
+ * attempt to deactivate the session for the specified (PLU, SLU) network
+ * address pair.
+ */
+struct sna_ru_cleanup {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2;
+	__u8	user:1,
+		status:1,
+		rsv3:6;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CLEAR (Clear). CLEAR is sent by primary session control to reset the
+ * data traffic. FSMs and subtrees (for example, brackets, pacing, sequence
+ * numbers) in the primary and seconday half-session (and boundary function,
+ * if any). CLEAR also resets compression and decompression tables in sessions
+ * using length-checked compression. This RU is not used for LU 6.2.
+ */
+struct sna_ru_clear {
+	__u8	req_code;
+};
+
+/* CONNOUT (Connect Out). CONNOUT requests the PU to initiate a connect-out
+ * procedure on the specified link.
+ */
+struct sna_ru_connout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	ls_id;		/* Link station ID. */
+	__u8	connect_type:1,
+		connect_out_feature:2,
+		rsv1:2,
+		connect_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		sdai:1;		/* Static/Dynamic address indicator. */
+
+	__u8	retry_limit;
+	__u8	number;
+	__u8	*dial_digits;
+
+	__u8	id_number;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACT (Contact). CONTACT requests the initiation of a procedure at the
+ * PU to activate DLC-level contact with the adjacent link station specified
+ * in the request. The DLC-level contact must be activated before any PIUs
+ * can be exchanged with the adjacent node over the link.
+ */
+struct sna_ru_contact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1:1,
+		eami:1,		/* Enhanced addr managment indicator. */
+		sdai:1,
+		limit_resource:1,
+		cp_cp_sess_supp:1,
+		conn_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		nnn_id_usage:1;	/* Nonnative network id usage indicator. */
+
+	__u8	tg_num;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACTED (Contacted). CONTACTED is issued by the PU to indicate to the
+ * SSCP the completion of the DLC contact procedure. A status parameter
+ * conveyed by this request informs SSCP configuration services whether or
+ * not the contact procedure was successful; if not sucessful, the status
+ * indicates whether an adjacent node load is required or whether an error
+ * occured on the contact procedure.
+ */
+struct sna_ru_contacted {
+	__u8	*raw;
+};
+
+/* CRV (Cryptogrpahy Verification). CRV, a valid request only when
+ * session-level cryptography was selected in BIND, is sent by the primary
+ * LU sesion control to verify cryptography security and thereby enable
+ * sending and receiving of FMD requests by both half-sessions.
+ */
+struct sna_ru_crv {
+	__u8	rq_code;
+	__u8	crypto_seed[7];
+};
+
+/* CTERM (Control Terminate). CTERM requests that the PLU attempt to deactivate
+ * a session identified by the specified (PLU,SLU) network address pair.
+ */
+struct sna_ru_cterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:2,
+		type:2,
+		rsv3:4;
+	__u8	user:1,
+		status:1,
+		rsv4:6;
+	__u16	rsv5;
+	__u8	*session_key;
+	__u16	rsv6;
+};
+
+/* DACTCDRM (Deactivate Cross-Domain Resource Manager). DACTCDRM is sent
+ * to deactivate a SSCP-SSCP session.
+ */
+struct sna_ru_dactcdrm {
+	__u8	req_code;
+	__u8	format:4,
+		deact_type:4;
+
+	/* Type 2 cont. */
+	__u32	reason;
+
+	/* Type 3 cont. */
+	__u8	cause;
+	__u8	rsv1;
+
+	/* Type 4 cont. */
+	__u8	rsv2;
+};
+
+/* DACTCONNIN (Deactivate Connect In). DACTCONNIN requests the PU to
+ * disable the specified link from accepting incoming calls.
+ */
+struct sna_ru_dactconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DACTLINK (Deactivate Link). DACTLINK initiates a procedure at the PU to
+ * deactivate the protocol boundary between a link station in the node
+ * (as specified by the link network address parameter in the request) and
+ * the link connection attached to it. The normal type is used after all
+ * adjacent link stations on the specified link have been discontacted.
+ * The unconditional type may be used at any time to reset immediately a
+ * link and its attached stations, regardless of their current state. If any
+ * other control points were actively sharing control of the link at the time
+ * of reset, thy are notified via INOP with a unique code. The give-back type
+ * gives back link ownership without disrupting LU-LU sessions.
+ */
+struct sna_ru_dactlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dactlink_type;
+};
+
+/* DACTLU (Deactivate Logical Unit). DACTLU is sent to deactivate the session
+ * between the SSCP and the LU.
+ */
+struct sna_ru_dactlu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTPU (Deactivate Physical Unit). DACTPU is sent to deactivate the
+ * session between the SSCP and the PU.
+ */
+struct sna_ru_dactpu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTTRACE (Deactivate Trace). DACTTRACE requests the PU to deactivate
+ * a specified type of trace for a specified resource (or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_dacttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	tg_trace:1,
+		piu_trace:1,
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	__u8	*trace_data;
+};
+
+/* DELETENR (Delete Network Resource). DELETENR is sent to free a network
+ * address addigned to a link or adjacent link station.
+ */
+struct sna_ru_deletenr {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISCONTACT (Discontact). DISCONTACT requests the PU to deactivate DLC-level
+ * contact with the specified adjacent node. The discontact procedure is
+ * DLC-dependent; if applicable, polling is stopped. DISCONTACT may be used
+ * to terminate contact, IPL, or dump procedures before their completion. The
+ * PU responds negatively to DISCONTACT if any uninterruptable link-level
+ * procedure is in progress at the primary link station of the specified link.
+ */
+struct sna_ru_discontact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISPSTOR (Display Storage). DISPSTOR requests the PU to send a RECSTOR RU
+ * containing a specified number of bytes of storage beginning at a specified
+ * location, or the names and related information for load modules and dump
+ * (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_dispstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	target_addr_space:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	display_bytes;
+	__u32	begin_local_display;
+};
+
+/* DSRLST (Direct Search List). DSRLST specifies a list search argument to
+ * be used at the receiving SSCP to identify a control list type to be
+ * returned on RSP(DSRLST).
+ */
+struct sna_ru_dsrlst {
+	__u8	ns_hdr[3];
+	__u8	search_arg;
+	__u8	*ctrl_vectors;
+};
+
+/* DUMPFINAL (Dump Final). DUMPFINAL performs one of two functions depending
+ * on the address used in the request:
+ * - When the DUMPFINAL request contains the link station address of an
+ *   adjacent T4 node. DUMPFINAL terminates the dump sequence in progress
+ *   (whether DUMPTEST is used or not). A positive response by the T4/5 node
+ *   to this form of DUMPFINAL indicates that the dump sequence is complete.
+ * - Then the DUMPFINAL request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node) and a link station address of
+ *   0x0000, the DUMPFINAL request causes an ABEND at the T4 node. The T4
+ *   node then dumps to local disk. No response is returned to the requester
+ *   for this form of DUMPFINAL.
+ */
+struct sna_ru_dumpfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DUMPINIT (Dump Initial). DUMPINIT performs one of two functions, depending
+ * on the address used in the request:
+ * - When the node to be dumped is identified by an adjacent link station
+ *   address, DUMPINIT causes the receiving T4/5 node to initiate a DLC-level
+ *   dump from the adjacent T4 node (identified in the DUMPINIT) to the
+ *   receiving T4/5 node; this dump is sent to the SSCP on subsequent
+ *   RSP(DUMPTEXT)s.
+ * - When the DUMPINIT request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node), a link station address of 0x0000
+ *   and a Dump Control byte equal to 0x80, the DUMPINIT interrogates the
+ *   status of the receiving node's system-defined local options (to react
+ *   to a subsequent DUMPFINAL), and its capacity to store a dump of its own
+ *   contents to local disk storage. A positive response to the request
+ *   indicates that a DUMPFINAL request can be accepted ( and the local dump
+ *   be performed). A negative response indicates either that the system
+ *   defined local options conflict with those of the requester, or
+ *   insufficient disk capacity exists to at the DUMPINIT receiver hold the
+ *   dump.
+ */
+struct sna_ru_dumpinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dump_type;
+};
+
+/* DUMPTEXT (Dump Text). If further dump data is required, DUMPINIT may be
+ * followed by DUMPTEXT. DUMPTEXT causes the dump data specified by the
+ * starting-address parameter to be returned to the SSCP on the response.
+ * The T4/5 obtains the dump data from the T4 node, using a DLC-level
+ * interchange.
+ */
+struct sna_ru_dumptext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	start_dump_addr;
+	__u16	text_len;
+};
+
+/* ER_TESTED (Explicit Route Tested). ER_TESTED is sent by a subarea node
+ * to one or more SSCPs to provide the status of an ER as determined by
+ * explicit route test procedures.
+ */
+struct sna_ru_er_tested {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	er_max_len;
+	__u32	subarea_addr_dst;
+	__u8	rsv1;
+	__u8	rsv2:4,
+		ern_of_er:4;
+	__u32	subarea_addr_src;
+	__u16	rev_ern_mask;
+	__u16	max_piu_len;
+	__u16	max_piu_size;
+	__u16	ns_er_test_origin_sscp_subarea_num;
+	__u16	ns_er_test_origin_sscp_element_num;
+	__u8	req_corr[9];
+
+	/* More. */
+};
+
+/* ESLOW (Entering Slowdown) ESLOW informs the SSCP that the node of the
+ * sending PU has entered a slowdown state. This state is generally
+ * associated with buffer depletion, and requires traffic through the node
+ * to be selectively reduced or suspended.
+ */
+struct sna_ru_eslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* EXECTEST (Execute Test). EXECTEST requests the PU to activate the specified
+ * test type related to the specified network address. The test code specifies
+ * the test type and defines the contents of the test data field. The test may
+ * be for the PU, or for the LUs or links supported by the PU.
+ */
+struct sna_ru_exectest {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*test_data;
+};
+
+/* EXPD (Expedited Data). EXPD is an expediated-flow request that can be
+ * sent between half-sessions, regardless of the status of the normal flows,
+ * to carry TP-defined data. This RU is defined for LU 6.2 only.
+ */
+struct sna_ru_expd {
+	__u8	req_code;
+	__u8	rsv1;
+	__u16	exp_data_len;
+	__u8	*exp_data;
+};
+
+/* EXSLOW (Exiting Slowdown). EXSLOW informs the SSCP that the node of the
+ * sending PU is no longer in the slowdown state and regular traffic can
+ * resume.
+ */
+struct sna_ru_exslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* FNA (Free Network Addresses). FNA is sent from an SSCP to request the PU
+ * T4/5 to free the identified element address(es) associated with the
+ * target resource. If ENA is not supported, the entire network address is
+ * in each Element Address field throughout this RU.
+ */
+struct sna_ru_fna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	num_element_addrs;
+
+	__u8	rsv1:1,
+		eami:1,			/* Enhanced Address Managment Indi. */
+		sdai:1,			/* Static/Dynamic Addr Indi. */
+		rsv2:5;
+
+	__u16	first_element_addr;
+	__u16	*other_element_addrs;
+};
+
+/* INIT_OTHER (Initiate Other). INIT_OTHER from the ILU requests the initiation
+ * of a session between the two LUs named in the RU. The requester may be a
+ * third-party LU or one of the two named LUs. This RU is not used by LU 6.2
+ * although it can be used by a third-party LU for LU 6.2.
+ */
+struct sna_ru_init_other {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	iqi:2,		/* Initiate/Enqueue Indicator. */
+		rsv21:4,
+		pluslu_spec:1,
+		rsv2:1;
+};
+
+/* INITPROC (Initiate Procedure). INITPROC is sent to the subarea PU adjacent
+ * to a PU T2 in order to initiate a PU T4/5 PU T2 load operation.
+ */
+struct sna_ru_initproc {
+	__u8	ns_hdr[3];
+	__u8	rsv1[3];
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	*ipl_load_module;
+};
+
+/* IPLFINAL (IPL Final). IPLFINAL completes an IPL sequence and supplies the
+ * load-module entry point to the T4 node. A positive response to IPLFINAL
+ * indicates that the T4 node is successfully loaded, or the load module
+ * has been successfully added to or replaced on the T4 node's local disk.
+ */
+struct sna_ru_iplfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	entry_point;
+	__u8	ipl_sli:1,	/* IPL save load indicator. */
+		ui:1,		/* Usage indicator. */
+		daipli:1,	/* Disk automatic IPL indicator. */
+		dadi:1,		/* Disk automatic dump indicator. */
+		rsv1:4;
+};
+
+/* IPLINIT (IPL Initial). IPLINIT either initiates a DLC-level load of an
+ * adjacent T4 node from the T4 node receiving the IPLINIT, when the node to
+ * be loaded is identified by the adjacent link station address contained in
+ * the request, or initiates the adding, replacing, or purging of the load
+ * module on the local disk of the T4 node receiving the request when the
+ * address in the request is the network address of the PU T4 receiving the
+ * request. In the case of purging, no IPLFINAL is sent, a positive response
+ * to IPLINIT indicates that the load module has been successfully purged.
+ */
+struct sna_ru_iplinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dipli:1,	/* Disk IPL indicator. */
+		rsv1:7;
+	__u8	load_module_name[8];
+	__u8	lmi:2,
+		rsv2:6;
+};
+
+/* IPLTEXT (IPL Text). IPLTEXT transfers load module information to the PU T4,
+ * which passes it in a DLC-level load to the T4 adjacent node or adds or
+ * replaces the load module on its local disk. Following an IPLINIT, any
+ * number of IPLTEXT commands are valid, except that for purging and loading
+ * from local disk, IPLTEXT is not sent.
+ */
+struct sna_ru_ipltext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*text;
+};
+
+/* LCP (Lost Control Point). LCP notifies the SSCP that a subarea PU's session
+ * with another SSCP has failed. The SSCP displays the information for the
+ * network operator.
+ */
+struct sna_ru_lcp {
+	__u8	ns_hdr[3];
+	__u8	reason_code;
+	__u8	rsv1;
+	__u8	net_addr[5];
+};
+
+/* LUSTAT (Logical Unit Status). LUSTAT is used by one half-session to send
+ * up to four bytes of status information to its paired half-session. The
+ * RU format allows the sending of either end-user information or LU status
+ * information. If the high-order two bytes of the status information are 0,
+ * the low-order two bytes carry end-user information and may be set to any
+ * value. In general, LUSTAT is used to report about failures and error
+ * recovery conditions for a local device of an LU.
+ */
+struct sna_ru_lustat {
+	__u8	req_code;
+	__u32	status;
+};
+
+/* NC_ACTVR (Activate Virtual-Route). NC_ACTVR initializes the state and
+ * attributes of the VR at each of its end nodes.
+ */
+struct sna_ru_nc_actvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u16	rcv_ern_mask;
+	__u16	send_ern_mask;
+	__u16	rsv3:4,
+		init_vr_send_sqn:12;
+	__u8	rsv4;
+	__u8	max_vr_window;
+	__u8	rsv5;
+	__u8	min_vr_window;
+	__u16	max_piu_size;
+	__u16	max_piu_len;
+};
+
+/* NC_DACTVR (Deactivate Virtual Route). NC_DACTVR deactivates a virtual
+ * route.
+ */
+struct sna_ru_nc_dactvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+};
+
+/* NC_ER_ACT (Explicit Route Activate). NC_ER_ACT is sent by the ER manager
+ * in a subarea node in order to activate an explicit route.
+ */
+struct sna_ru_nc_er_act {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	route_def_cap:1,
+		rsv3:7;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	src_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_len;
+	__u8	rsv5[8];
+	__u8	act_req_sni[8];
+};
+
+/* NC_ER_INOP (Explicit Route Inoperative). NC_ER_INOP is initiated when the
+ * last remaining link of the transmission group has failed or is disconnected
+ * via a link-level procedure.
+ */
+struct sna_ru_nc_er_inop {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	reason_code;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	num_dst_subareas;
+	__u8	inop_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	inop_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_OP (Explicit Route Operative). NC_ER_OP is generated when a link of
+ * an inoperative transmission group becomes operative.
+ */
+struct sna_ru_nc_er_op {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	tg_number;
+	__u8	num_subarea_addrs;
+	__u8	op_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	op_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_TEST (Explicit Route Test). NC_ER_TEST is sent by a subarea node that
+ * requires testing of an explicit route to a specified destination subarea.
+ */
+struct sna_ru_nc_er_test {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv3;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	orig_subarea_addr;
+	__u16	reverse_er_mask;
+	__u16	max_piu_size;
+	__u16	rsv5;
+	__u8	orig_sscp_net_addr[6];
+	__u8	rq_cv[10];		/* Request Correlation Value. */
+};
+
+/* NC_ER_TEST_REPLY (Explicit Route Test Reply). NC_ER_TEST_REPLY is returned
+ * to signal the successful or unsuccessful completion of te NC_ER_TEST.
+ */
+struct sna_ru_nc_er_test_reply {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv2;
+	__u8	rsv3:4,
+		ern:4;
+	__u32	orig1_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_size_permit;
+	__u16	max_piu_size_accum;
+	__u8	orig_network_addr[6];
+	__u8	rq_cv[10];
+	__u32	orig2_subarea_addr;
+	__u32	subarea_addr_type;
+	__u8	tgn;
+	__u8	*ctrl_vectors;
+};
+
+/* NC_IPL_ABORT (NC IPL Abort). NC_IPL_ABORT contains sense data indicating
+ * the reason for a failure during IPL.
+ */
+struct sna_ru_nc_ipl_abort {
+	__u8	req_code;
+	__u32	sense;
+};
+
+/* NC_IPL_FINAL (NC IPL Final). NC_IPL_FINAL contains the entry point location
+ * of the IPL module.
+ */
+struct sna_ru_nc_ipl_final {
+	__u8	req_code;
+	__u32	entry_point;
+};
+
+/* NC_IPL_INIT (NC IPL Init). NC_IPL_INIT is sent from a PU T4/5 to a PU T2
+ * after the PU T4/5 processes an INITPROC (Type = IPL) RU.
+ */
+struct sna_ru_nc_ipl_init {
+	__u8	req_code;
+	__u8	rsv1;
+	__u8	ipl_load_module[8];
+};
+
+/* NC_IPL_TEXT (NC IPL Text). NC_IP_TEXT contains the IPL data. */
+struct sna_ru_nc_ipl_text {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* NMVT (Network Managment Vector Transport). NMVT carries management services
+ * (MS) requests and replies between an SSCP and a PU.
+ */
+struct sna_ru_nmvt {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	rsv2:2,
+		rsv3:2,
+		prid:12;
+	__u8	si:1,		/* Solicitation Indicator. */
+		sf:2,		/* Sequence field. */
+		sna_addr_list:1,
+		rsv4:4;
+	__u8	*ms_ctrl_vectors;
+};
+
+/* PROCSTAT (Procedure Status). PROCSTAT reports to the SSCP either the 
+ * successful completion or the failure of the load operation. If the procedure
+ * failed, the request code of the failing RU and sense data are included as
+ * parameters in the PROCSTAT RU.
+ */
+struct sna_ru_procstat {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	proc_status;
+	__u16	rsv2;
+	__u8	status_qualifier[5];
+	__u8	fail_ru_req_code;
+	__u32	sense;
+};
+
+/* QC (Quiesce Complete). QC is sent by a halfpsession after receving QEC, to
+ * indicate that it has quiesced. This RU is not used for LU 6.2
+ */
+struct sna_ru_qc {
+	__u8	req_code;
+};
+
+/* QEC (Quiesce at End of Chain). QEC is sent by a half session to quiesce its
+ * partner half-session after it (the partner) finishes sending the current
+ * chain (if any). This RU is not used for LU 6.2.
+ */
+struct sna_ru_qec {
+	__u8	req_code;
+};
+
+/* RECFMS (Record Formatted Maintenance Statistics). RECFMS permits the passing
+ * of maintenance related information from a PU to managment services at the
+ * SSCP.
+ */
+struct sna_ru_recfms {
+	__u8	ns_hdr[3];
+	__u16	cnm_target;
+	__u16	rsv1:2,
+		cnm_target_id:2,
+		prid:12;
+	__u8	si:1,
+		ntri:1,
+		req_type_code:6;
+	__u32	block_num:12,
+		id_num:20;
+	__u16	rsv2;
+
+	/* There is more. */
+};
+
+/* RECSTOR (Record Storage). RECSTOR carries the storage dump as requested by
+ * a DISPSTOR RU, or the names and related information for load modules and
+ * dump (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_recstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	display_src:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	size;
+	__u32	begin_location;
+	__u8	*storage_display;
+};
+
+/* RECTD (Record Test Data). RECTD returns the status and results of a test
+ * requested by EXECTEST to SSCP maintenance services.
+ */
+struct sna_ru_rectd {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*data;
+};
+
+/* RELQ (Release Quiesce). RELQ is used to release a half-session from a
+ * quiesced state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_relq {
+	__u8	req_code;
+};
+
+/* REQACTCDRM (Request Acitivation of Cross-Network Resource Manager).
+ * REQACTCDRM prompts the receiving SSCP to issue RNAA and SETCV to setup a
+ * cross-network address transform. ACTCDRM will then be sent to activate an
+ * SSCP-SSCP session with the other-network SSCP identified in this request.
+ */
+struct sna_ru_reqactcdrm {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format;
+	__u8	tsr:1,
+		vrid:1,
+		rsv2:6;
+	__u8	*session_key;
+	__u8	*bad_actcdrm;
+};
+
+/* REQACTLU (Request Activate Logical Unit). REQACTLU is sent from the PU to an
+ * SSCP to request that ACTLU be sent to the LU named in the RU.
+ */
+struct sna_ru_reqactlu {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	type;
+	__u8	len;
+	__u8	*symbol_name;
+};
+
+/* REQACTPU (Request Activate Physical Unit). REQACTPU is sent from the PU to
+ * SSCP to request that ACTPU be sent to the PU named in the corresponding
+ * FID2 Encapsulation (0x1500) GDS variable.
+ */
+struct sna_ru_reqactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+};
+
+/* REQCONT (Request Contact). REQCONT notifies the SSCP that a connection with
+ * an adjacent secondary link station (in a T1/2 node) has be activated via a
+ * successful connect-in or connect-out procedure. A DLC-level indentification
+ * exchange (XID) is required before issuing REQCONT.
+ */
+struct sna_ru_reqcontx {
+	__u16	vector_hdr;
+	__u8	tg_status:1,
+		rsv1:7;
+};
+
+struct sna_ru_reqcont {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*xid_ifield_image;
+	__u8	*ctrl_vectors;
+};
+
+/* REQDACTPU (Request Deactivate Physical Unit). REQDACTPU is sent from the PU
+ * to an SSCP to request that DACTPU be sent to the PU.
+ */
+struct sna_ru_reqdactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+	__u8	cause;
+};
+
+/* REQDISCONT (Request Discontact). With REQDISCONT, the PU T2 requests the
+ * SSCP to start a procedure that will ultimately discontact the secondary
+ * station in the T2 node.
+ */
+struct sna_ru_reqdiscont {
+	__u8	ns_hdr[3];
+	__u8	type:4,
+		contact:4;
+};
+
+/* REQFNA (Request Free Network Address). REQFNA is sent from a PU T4/5 to an
+ * SSCP to request the SSCP to send FNA to the PU T4/5 in order to free all
+ * addresses for the specified LU.
+ */
+struct sna_ru_reqfna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1;
+	__u8	req_type;
+};
+
+/* REQMS (Request Maintenance Statisitics). REQMS requests the managment
+ * services associated with the PU to provide maintenance statistics for the
+ * resource indicated by the CNM target ID in the CNM header.
+ */
+struct sna_ru_reqms {
+	__u8	*raw;
+};
+
+/* RNAA (Request Network Address Assignment). RNAA requests the PU to
+ * assign addresses:
+ * - To an adjacent link station, as identified in the RNAA request by a link
+ *   element address and secondary link station link-level address.
+ * - To a dependent LU, where the LU is identified in the RNAA by a adjacent
+ *   link station address and the LU local address.
+ * - To a subarea LU that supports parallel sessions; in order to assign an
+ *   additional element address, the LU is identified in the RNAA request
+ *   by the LU element address used for the SSCP-LU session.
+ * - As alias addresses for a cross-network SSCP-SSCP or LU-LU session, where
+ *   the name pair and session characteristics are identified in the RNAA
+ *   request.
+ * - To an LU to be used as a PLU address for an independent LU or to be used
+ *   as an indepenedent or depenedent LU, where the LU is identified by an ALS
+ *   address, an LU name, and an optional LU address.
+ *
+ * If ENA is not supported on this SSCP-to-PU T4/5 session, the entire network
+ * address is in each element address field throughout this RU.
+ */
+struct sna_ru_rnaa {
+	__u8	*raw;
+};
+
+/* ROUTE_INOP (Route Inoperative). ROUTE_INOP notifies the CP when either a
+ * virtual route or an explicit route has become inoperative as the result of
+ * a transmission group having become inoperative somewhere in the network.
+ * This RU is retired for route dynamics.
+ */
+struct sna_ru_route_inop {
+	__u8	*raw;
+};
+
+/* ROUTE_SETUP (Route Setup). ROUTE_SETUP is used between adjacent HPR CPs when
+ * at leat one of them does not support the Control Flows over RTP (1402) option
+ * set; it carries the Route Setup GDS variable and is preceded by a FID2 TH
+ * set to FID2, BBIU, EBIU, ODAI = 0, EFI = 1, DAF = 0, OAF - 0, and SNA = 0
+ * (ie, TH = 0x2D0000000000) and an RH set to RQ, NC, FI = 1, SDI = 0, BC, EC
+ * DR1 = DR2 = ECI = 0 (RQN or no-response requested), with all other bits
+ * 0 (ie RH = 0x2B0000).
+ */
+struct sna_ru_route_setup {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* ROUTE_TEST (Route Test). ROUTE_TEST requests the PC_ROUTE_MANAGER component
+ * of PU.SVC_MGR to return the status (for example, active, operative, not
+ * defined), as know in the control blocks in the node, of various explicit
+ * and/or virutal routes.
+ */
+struct sna_ru_route_test {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format;
+	__u8	test_code;
+	__u8	test_routes;
+	__u8	rsv1:6,
+		tx_priority:2;
+	__u8	rsv2:1,
+		congestion_data:1,
+		vrdi:1,
+		rsv3:5;
+	__u8	max_exp_er_len;
+	__u32	dst_subarea_addr;
+	__u16	bit_route_test;
+	__u8	req_cf[10];
+	__u8	network_id[8];
+};
+
+/* RPO (Remote Power Off). RPO Causes the receiving PU T4/5 to initiate a
+ * DLC-level power-off sequence to the T4 node specified by the adjacent link
+ * station address conveyed in the request. The node being powered off does not
+ * need to have an active SSCP-PU half-session not be contacted.
+ */
+struct sna_ru_rpo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* RQR (Request Recovery). RQR is sent by the secondary to request the primary
+ * to initiate recovery for the session by sending CLEAR or to deactivate the
+ * session. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rqr {
+	__u8	req_code;
+};
+
+/* RSHUTD (Request Shutdown). RSHUTD is sent from the secondary to the primary
+ * to indicate that the secondary is ready to have the session deactivated.
+ * RSHUTD does not request a shutdown; therefor, SHUTD is not a proper reply;
+ * RSHUTD requests an UNBIND. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rshutd {
+	__u8	req_code;
+};
+
+/* RTR (Ready to Receive). RTR indicates to the bidder that it is now allowed
+ * to initiate a bracket. RTR is sent only be the first speaker.
+ */
+struct sna_ru_rtr {
+	__u8	req_code;
+};
+
+/* SBI (Stop Bracket Indication). SBI is sent by either half-session to request
+ * that the receiving half-session stop initiating brackets by continued sending
+ * of BB and the BID request. This RU is not used by LU 6.2.
+ */
+struct sna_ru_sbi {
+	__u8	req_code;
+};
+
+/* SDT (Start Data Traffic). SDT is sent by the primary session control to the
+ * secondary session control to enable the sending and receiving of FMD and
+ * DFC requests and responses by both half-sessions. This RU is not used
+ * by LU 6.2.
+ */
+struct sna_ru_sdt {
+	__u8	req_code;
+};
+
+/* SESSEND (Session Ended). SESSEND is sent, with no-response requested, by
+ * the LU (or boundary function on behalf of the LU in a periheral node) to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully deactivated.
+ */
+struct sna_ru_sessend {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*raw;
+};
+
+/* SESSST (Session Started). SESSST is sent, with no response requested, to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully activated.
+ */
+struct sna_ru_sessst {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	*raw;
+};
+
+/* SHUTC (Shutdown Complete). SHUTC is sent by a secondary to indicate that it
+ * is in the shutdown (quiesced) state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutc {
+	__u8	req_code;
+};
+
+/* SHUTD (Shutdown). SHUTD is sent by the primary to request that the secondary
+ * shut down (quiesce) as soon as convenient. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutd {
+	__u8	req_code;
+};
+
+/* SIG (Signal). SIG is an expediated request that can be sent between
+ * half-sessions, regardless of the status of the normal flows. It carries a
+ * four-byte value, of which the first two bytes are the signal code and the
+ * last two bytes are the signal extension value.
+ */
+struct sna_ru_sig {
+	__u8	req_code;
+	__u16	signal_code;
+	__u16	signal_ext;
+};
+
+/* STSN (Set and Test Sequence Numbers). STSN is sent by the primary 
+ * half-session sync point manager to resynchronize the values of the 
+ * half-session sequence numbers, for one or both of the normal flows at both
+ * ends of the session. The RU is not used for LU 6.2.
+ */
+struct sna_ru_stsn {
+	__u8	req_code;
+	__u8	sp_act_code:2,
+		ps_act_code:2,
+		rsv1:4;
+	__u16	sp_snf;
+	__u16	ps_snf;
+};
+
+/* SWITCH (Switch Data Traffic). SWITCH is sent by the PLU to the SLU to change
+ * the (XRF) state of their LU-LU session from XRF-backup to XRF-active.
+ */
+struct sna_ru_switch {
+	__u8	req_code;
+	__u8	type;
+};
+
+/* TERM_OTHER (Terminate Other). TERM_OTHER from the TLU requests that the
+ * SSCP assist in terminating one or more sessions between the two LUs named in
+ * the RU. The requester may be a third-party LU or onr of the two named LUs.
+ * This RU is not used by LU 6.2, although it can be used by a third party
+ * LU for LU 6.2.
+ */
+struct sna_ru_term_other {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 0 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender
+ * of the request (TLU = OLU) and the DLU. This RU is not used for LU 6.2;
+ * refer to TERM_SELF FORMAT 1.
+ */
+struct sna_ru_term_self_fmt0 {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 1 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender of
+ * the request (TLU = OLU) and the DLU.
+ */
+struct sna_ru_term_self_fmt1 {
+	__u8	*raw;
+};
+
+/* TESTMODE (Test Mode). TESTMODE requests the management services associated
+ * with the PU to manage a test procedure. The test procedure begins with the
+ * TESTMODE request that initiates a test and ends when the test results and
+ * status are returned in a RECTR reply request corresponding to the initial
+ * TESTMODE request.
+ */
+struct sna_ru_testmode {
+	__u8	ns_hdr[3];
+	__u16	cnm_target_id;
+	__u16	rsv1:2,
+		cnm_target_id_desc:2,
+		prid:12;
+	__u8	*data;
+};
+
+/* UNBIND (Unbind Session). UNBIND is sent to deactivate an active session
+ * between the two LUs.
+ */
+struct sna_ru_unbind {
+	__u8	req_code;
+	__u8	unbind_type;
+	__u32	sense;
+	__u8	*ctrl_vectors;
+};
+
+/* UNBINDF (Unbind Failure). UNBINDF is sent, with no-response requested, by
+ * the PLU to notify the SSCP that the attempt to deactivate the session
+ * between the specified LUs has failed (for example, because of a path failure)
+ */
+struct sna_ru_unbindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	rsv1:1,
+		unbind_err_slu:1,
+		takedown_rej_plu:1,
+		rsv2:5;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* RU NS Header indicators. */
+#define SNA_RU_NS_CONTACT		0x010201
+#define SNA_RU_NS_DISCONTACT		0x010202
+#define SNA_RU_NS_IPLINIT		0x010203
+#define SNA_RU_NS_IPLTEXT		0x010204
+#define SNA_RU_NS_IPLFINAL		0x010205
+#define SNA_RU_NS_DUMPINIT		0x010206
+#define SNA_RU_NS_DUMPTEXT		0x010207
+#define SNA_RU_NS_DUMPFINAL		0x010208
+#define SNA_RU_NS_RPO			0x010209
+#define SNA_RU_NS_ACTLINK		0x01020A
+#define SNA_RU_NS_DACTLINK		0x01020B
+#define SNA_RU_NS_CONNOUT		0x01020E
+#define SNA_RU_NS_ABCONN		0x01020F
+#define SNA_RU_NS_SETCV			0x010211
+#define SNA_RU_NS_ESLOW			0x010214
+#define SNA_RU_NS_EXSLOW		0x010215
+#define SNA_RU_NS_ACTCONNIN		0x010216
+#define SNA_RU_NS_DACTCONNIN		0x010217
+#define SNA_RU_NS_ABCONNOUT		0x010218
+#define SNA_RU_NS_ANA			0x010219
+#define SNA_RU_NS_FNA			0x01021A
+#define SNA_RU_NS_REQDISCONT		0x01021B
+#define SNA_RU_NS_CONTACTED		0x010280
+#define SNA_RU_NS_INOP			0x010281
+#define SNA_RU_NS_REQCONT		0x010284
+#define SNA_RU_NS_NS_LSA		0x010285
+#define SNA_RU_NS_EXECTEST		0x010301
+#define SNA_RU_NS_ACTTRACE		0x010302
+#define SNA_RU_NS_DISPSTOR		0x010331
+#define SNA_RU_NS_RECSTOR		0x010334
+#define SNA_RU_NS_RECMS			0x010381
+#define SNA_RU_NS_RECTD			0x010382
+#define SNA_RU_NS_RECTRD		0x010383
+#define SNA_RU_NS_NSPE			0x010604
+#define SNA_RU_NS_INIT_SELF_FMT0	0x010681
+#define SNA_RU_NS_TERM_SELF_FMT0	0x010683
+#define SNA_RU_NS_RNAA			0x410210
+#define SNA_RU_NS_DELETENR		0x41021C
+#define SNA_RU_NS_ER_INOP		0x41021D
+#define SNA_RU_NS_ADDLINK		0x41021E
+#define SNA_RU_NS_ADDLINKSTA		0x410221
+#define SNA_RU_NS_VR_INOP		0x410223
+#define SNA_RU_NS_INITPROC		0x410235
+#define SNA_RU_NS_PROCSTAT		0x410236
+#define SNA_RU_NS_LDREQD		0x410237
+#define SNA_RU_NS_REQACTPU		0x41023E
+#define SNA_RU_NS_REQDACTPU		0x41023F
+#define SNA_RU_NS_REQACTLU		0x410240
+#define SNA_RU_NS_NS_IPL_INIT		0x410243
+#define SNA_RU_NS_NS_IPL_TEXT		0x410244
+#define SNA_RU_NS_NS_IPL_FINAL		0x410245
+#define SNA_RU_NS_NS_IPL_ABORT		0x410246
+#define SNA_RU_NS_REQFNA		0x410286
+#define SNA_RU_NS_LCP			0x410287
+#define SNA_RU_NS_ROUTE_INOP		0x410289
+#define SNA_RU_NS_REQACTCDRM		0x41028A
+#define SNA_RU_NS_REQMS			0x410304
+#define SNA_RU_NS_TESTMODE		0x410305
+#define SNA_RU_NS_ROUTE_TEST		0x410307
+#define SNA_RU_NS_RECFMS		0x410384
+#define SNA_RU_NS_RECTR			0x410385
+#define SNA_RU_NS_ER_TESTED		0x410386
+#define SNA_RU_NS_NMVT			0x41038D
+#define SNA_RU_NS_REQECHO		0x810387
+#define SNA_RU_NS_ECHOTEST		0x810389
+#define SNA_RU_NS_CINIT			0x810601
+#define SNA_RU_NS_CTERM			0x810602
+#define SNA_RU_NS_NOTIFY		0x810620
+#define SNA_RU_NS_CLEANUP		0x810629
+#define SNA_RU_NS_INIT_OTHER		0x810680
+#define SNA_RU_NS_INIT_SELF_FMT1	0x810681
+#define SNA_RU_NS_TERM_OTHER		0x810682
+#define SNA_RU_NS_TERM_SELF_FMT1	0x810683
+#define SNA_RU_NS_BINDF			0x810685
+#define SNA_RU_NS_SESSST		0x810686
+#define SNA_RU_NS_UNBINDF		0x810687
+#define SNA_RU_NS_SESSEND		0x810688
+#define SNA_RU_NS_FORWARD		0x810810
+#define SNA_RU_NS_DELIVER		0x810812
+#define SNA_RU_NS_BFCINIT		0x812601
+#define SNA_RU_NS_BFCLEANUP		0x812629
+#define SNA_RU_NS_BFINIT		0x812681
+#define SNA_RU_NS_BFTERM		0x812683
+#define SNA_RU_NS_BFSESSST		0x812686
+#define SNA_RU_NS_BFSESSEND		0x812688
+#define SNA_RU_NS_BFSESSINFO		0x81268C
+#define SNA_RU_NS_DSRLST		0x818627
+#define SNA_RU_NS_INIT_OTHER_CD		0x818640
+#define SNA_RU_NS_CDINIT		0x818641
+#define SNA_RU_NS_CDTERM		0x818643
+#define SNA_RU_NS_CDSESSF		0x818645
+#define SNA_RU_NS_CDSESST		0x818646
+#define SNA_RU_NS_CDSESSTF		0x818647
+#define SNA_RU_NS_CDSESSEND		0x818648
+#define SNA_RU_NS_CDTAKED		0x818649
+#define SNA_RU_NS_CDTAKEDC		0x81864A
+#define SNA_RU_NS_CDCINIT		0x81864B
+
+/* RU Request Codes. */
+#define SNA_RU_RC_NC_IPL_FINAL		0x02
+#define SNA_RU_RC_NC_IPL_INIT		0x03
+#define SNA_RU_RC_EXPD			0x03
+#define SNA_RU_RC_LUSTAT		0x04
+#define SNA_RU_RC_NC_IPL_TEXT		0x04
+#define SNA_RU_RC_RTR			0x05
+#define SNA_RU_RC_LSA			0x05
+#define SNA_RU_RC_NC_ER_INOP		0x06
+#define SNA_RU_RC_NC_ER_TEST		0x09
+#define SNA_RU_RC_NC_ER_TEST_REPLY	0x0A
+#define SNA_RU_RC_NC_ER_ACT		0x0B
+#define SNA_RU_RC_NC_ER_ACT_REPLY	0x0C
+#define SNA_RU_RC_ACTLU			0x0D
+#define SNA_RU_RC_NC_ACTVR		0x0D
+#define SNA_RU_RC_DACTLU		0x0E
+#define SNA_RU_RC_NC_DACTVR		0x0E
+#define SNA_RU_RC_NC_ER_OP		0x0F
+#define SNA_RU_RC_ROUTE_SETUP		0x10
+#define SNA_RU_RC_ACTPU			0x11
+#define SNA_RU_RC_DACTPU		0x12
+#define SNA_RU_RC_ACTCDRM		0x14
+#define SNA_RU_RC_DACTCDRM		0x15
+#define SNA_RU_RC_BIND			0x31
+#define SNA_RU_RC_UNBIND		0x32
+#define SNA_RU_RC_SWITCH		0x33
+#define SNA_RU_RC_NC_IPL_ABORT		0x46
+#define SNA_RU_RC_BIS			0x70
+#define SNA_RU_RC_SBI			0x71
+#define SNA_RU_RC_QEC			0x80
+#define SNA_RU_RC_QC			0x81
+#define SNA_RU_RC_RELQ			0x82
+#define SNA_RU_RC_CANCEL		0x83
+#define SNA_RU_RC_CHASE			0x84
+#define SNA_RU_RC_SDT			0xA0
+#define SNA_RU_RC_CLEAR			0xA1
+#define SNA_RU_RC_STSN			0xA2
+#define SNA_RU_RC_RQR			0xA3
+#define SNA_RU_RC_SHUTD			0xC0
+#define SNA_RU_RC_CRV			0xC0
+#define SNA_RU_RC_SHUTC			0xC1
+#define SNA_RU_RC_RSHUTD		0xC2
+#define SNA_RU_RC_BID			0xC8
+#define SNA_RU_RC_SIG			0xC9
+
+struct snaruhdr {
+	union {
+		struct sna_ru_abconn		abconn;
+		struct sna_ru_abconnout		abconnout;
+		struct sna_ru_actcdrm		actcdrm;
+		struct sna_ru_actconnin		actconnin;
+		struct sna_ru_actlink		actlink;
+		struct sna_ru_actlu		actlu;
+		struct sna_ru_actpu		actpu;
+		struct sna_ru_acttrace		acttrace;
+		struct sna_ru_addlink		addlink;
+		struct sna_ru_addlinksta	addlinksta;
+		struct sna_ru_bfcinit		bfcinit;
+		struct sna_ru_bfcleanup		bfcleanup;
+		struct sna_ru_bfinit		bfinit;
+		struct sna_ru_bfsessend		bfsessend;
+		struct sna_ru_bfsessinfo	bfsessinfo;
+		struct sna_ru_bfsessst		bfsessst;
+		struct sna_ru_bfterm		bfterm;
+		struct sna_ru_bid		bid;
+		struct sna_ru_bind		bind;
+		struct sna_ru_bindf		bindf;
+		struct sna_ru_bis		bis;
+		struct sna_ru_cancel		cancel;
+		struct sna_ru_cdcinit		cdcinit;
+		struct sna_ru_cdinit		cdinit;
+		struct sna_ru_cdsessend		cdsessend;
+		struct sna_ru_cdsessst		cdsessst;
+		struct sna_ru_cdtaked		cdtaked;
+		struct sna_ru_cdtakedc		cdtakedc;
+		struct sna_ru_cdterm		cdterm;
+		struct sna_ru_chase		chase;
+		struct sna_ru_cinit		cinit;
+		struct sna_ru_cleanup		cleanup;
+		struct sna_ru_clear		clear;
+		struct sna_ru_connout		connout;
+		struct sna_ru_contact		contact;
+		struct sna_ru_contacted		contacted;
+		struct sna_ru_crv		crv;
+		struct sna_ru_cterm		cterm;
+		struct sna_ru_dactcdrm		dactcdrm;
+		struct sna_ru_dactconnin	dactconnin;
+		struct sna_ru_dactlink		dactlink;
+		struct sna_ru_dactlu		dactlu;
+		struct sna_ru_dactpu		dactpu;
+		struct sna_ru_dacttrace		dacttrace;
+		struct sna_ru_deletenr		deletenr;
+		struct sna_ru_discontact	discontact;
+		struct sna_ru_dispstor		dispstor;
+		struct sna_ru_dsrlst		dsrlst;
+		struct sna_ru_dumpfinal		dumpfinal;
+		struct sna_ru_dumpinit		dumpinit;
+		struct sna_ru_dumptext		dumptext;
+		struct sna_ru_er_tested		er_tested;
+		struct sna_ru_eslow		eslow;
+		struct sna_ru_exectest		exectest;
+		struct sna_ru_expd		expd;
+		struct sna_ru_exslow		exslow;
+		struct sna_ru_fna		fna;
+		struct sna_ru_init_other	init_other;
+		struct sna_ru_initproc		initproc;
+		struct sna_ru_iplfinal		iplfinal;
+		struct sna_ru_iplinit		iplinit;
+		struct sna_ru_ipltext		ipltext;
+		struct sna_ru_lcp		lcp;
+		struct sna_ru_lustat		lustat;
+		struct sna_ru_nc_actvr		nc_actvr;
+		struct sna_ru_nc_er_act		nc_er_act;
+		struct sna_ru_nc_er_inop	nc_er_inop;
+		struct sna_ru_nc_er_op		nc_er_op;
+		struct sna_ru_nc_er_test	nc_er_test;
+		struct sna_ru_nc_er_test_reply	nc_er_test_reply;
+		struct sna_ru_nc_ipl_abort	nc_ipl_abort;
+		struct sna_ru_nc_ipl_final	nc_ipl_final;
+		struct sna_ru_nc_ipl_init	nc_ipl_init;
+		struct sna_ru_nc_ipl_text	nc_ipl_text;
+		struct sna_ru_nmvt		nmvt;
+		struct sna_ru_procstat		procstat;
+		struct sna_ru_qc		qc;
+		struct sna_ru_qec		qec;
+		struct sna_ru_recfms		recfms;
+		struct sna_ru_recstor		recstor;
+		struct sna_ru_rectd		rectd;
+		struct sna_ru_relq		relq;
+		struct sna_ru_reqactcdrm	reqactcdrm;
+		struct sna_ru_reqactlu		reqactlu;
+		struct sna_ru_reqactpu		reqactpu;
+		struct sna_ru_reqcontx		reqcontx;
+		struct sna_ru_reqcont		reqcont;
+		struct sna_ru_reqdactpu		reqdactpu;
+		struct sna_ru_reqdiscont	reqdiscont;
+		struct sna_ru_reqfna		reqfna;
+		struct sna_ru_reqms		reqms;
+		struct sna_ru_rnaa		rnaa;
+		struct sna_ru_route_inop	route_inop;
+		struct sna_ru_route_setup	route_setup;
+		struct sna_ru_route_test	route_test;
+		struct sna_ru_rpo		rpo;
+		struct sna_ru_rqr		rqr;
+		struct sna_ru_rshutd		rshutd;
+		struct sna_ru_rtr		rtr;
+		struct sna_ru_sbi		sbi;
+		struct sna_ru_sdt		sdt;
+		struct sna_ru_sessend		sessend;
+		struct sna_ru_sessst		sessst;
+		struct sna_ru_shutc		shutc;
+		struct sna_ru_shutd		shutd;
+		struct sna_ru_sig		sig;
+		struct sna_ru_stsn		stsn;
+		struct sna_ru_switch		ru_switch;
+		struct sna_ru_term_other	term_other;
+		struct sna_ru_term_self_fmt0	term_self_fmt0;
+		struct sna_ru_term_self_fmt1	term_self_fmt1;
+		struct sna_ru_testmode		testmode;
+		struct sna_ru_unbind		unbind;
+		struct sna_ru_unbindf		unbindf;
+		struct sna_security_reply_2	security_reply_2;
+		struct sna_fmh1			fmh1;
+		struct sna_fmh2			fmh2;
+		struct sna_fmh4			fmh4;
+		struct sna_fmh5			fmh5;
+		struct sna_fmh6			fmh6;
+		struct sna_fmh7			fmh7;
+		struct sna_fmh8			fmh8;
+		struct sna_fmh10		fmh10;
+		struct sna_fmh12		fmh12;
+		struct sna_ru_ipm		ipm;
+		__u16				*raw;
+	} ru;
+};
+
+/* MS.
+ */
+
+/* Solicitation indicators */
+#define NMVT_UNSOL      0x0
+#define NMVT_SOL        0x1
+
+/* NMVT sequence indicators */
+#define NMVT_SINGLE     0x00
+#define NMVT_LAST       0x01
+#define NMVT_FIRST      10
+#define NMVT_MIDDLE     11
+
+/* Network Managment Vector Transport (NMVT) header */
+struct sna_nmvt
+{
+//         sna_ru_request  *ru_request;
+
+        unsigned char __pad1[2];
+
+        __u16   __pad2:2,
+                __pad3:2,
+                prid:12;        /* Procedure related identifier */
+
+        __u8    si:1,           /* Solicitation indicator */
+                seqf:2,
+                sals:1,         /* SNA Address List subvector indicator */
+                __pad4:4;
+
+        unsigned char msvect;   /* One or more MS major vectors */
+};
+
+/* Record formatted maintenance statistics headers */
+
+/* CNM indicators */
+#define CNM_LSID        00
+#define CNM_ELEMENT     01
+
+/* Not last indicators */
+#define CNM_LAST_REQUEST_TRUE   0
+#define CNM_LAST_REQUEST_FALSE  1
+
+struct recfms_request
+{
+        __u8    solic:1,        /* Solicitation indicator */
+                nlri:1,         /* Not-last request indicator */
+                rqcode:6;       /* Request-specific type code */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+
+        __u16   __pad1;
+};
+
+#ifdef NOT
+
+/* Alert indicators */
+#define ALERT_EPERM             0x1     /* Permanent error */
+#define ALERT_ETEMP             0x2     /* Temporary error */
+#define ALERT_EPERFORMANCE      0x3     /* Performance error */
+#define ALERT_EINVALD           0x4     /* Unsupported or invalid use */
+#define ALERT_EBUSY             0x4     /* Busy */
+#define ALERT_EAPP              0x5     /* Application generated */
+#define ALERT_EOPRTR            0x6     /* Operator triggered */
+#define ALERT_SNA               0x7     /* SNA summary */
+
+/* Alert Major probable cause indicators */
+#define ALERT_MJ_HRDW           0x1     /* hardware */
+#define ALERT_MJ_SFTW           0x2     /* software */
+#define ALERT_MJ_LINK           0x3     /* link connection */
+#define ALERT_MJ_PROTO          0x4     /* protocol */
+#define ALERT_MJ_ENVIR          0x5     /* environment */
+#define ALERT_MJ_RMMEDIA        0x6     /* removable media */
+#define ALERT_MJ_HRDW_SFTW      0x7     /* hardware or software */
+#define ALERT_MJ_LOGIC          0x8     /* logical */
+#define ALERT_MJ_OPRTR_SNDPD    0x9     /* operator of sending product */
+#define ALERT_MJ_UNDEFINE       0xF     /* undetermined */
+
+/* Alert Minor probablt casue indicators */
+#define ALERT_MN_BPROCESSOR     0x01    /* base processor */
+#define ALERT_MN_SPROCESSOR     0x02    /* service processor */
+#define ALERT_MN_MICROCODE      0x03    /* microcode */
+#define ALERT_MN_MAINSTORAGE    0x04    /* main storage */
+#define ALERT_MN_DASD           0x05    /* DASD drive */
+#define ALERT_MN_PRINTER        0x06    /* printer */
+#define ALERT_MN_CARD           0x07    /* card reader/punch */
+#define ALERT_MN_TAPE           0x08    /* tape drive */
+#define ALERT_MN_KEYBOARD       0x09    /* keyboard */
+#define ALERT_MN_PEN            0x0A    /* selector pen */
+#define ALERT_MN_MAGREADER      0x0B    /* magnetic stripe reader */
+#define ALERT_MN_DIS_PRINTER    0x0C    /* display or printer */
+#define ALERT_MN_DISPLAY        0x0D    /* display unit */
+#define ALERT_MN_REMOTE         0x0E    /* remote product */
+#define ALERT_MN_POWER_INT      0x0F    /* power internal to this product */
+#define ALERT_MN_IOCTRLR        0x10    /* I/O attached controller */
+#define ALERT_MN_COMM_SCAN      0x11    /* communications controller scanner */
+#define ALERT_MN_COMM_ADPTR     0x12    /* communications link adapter  */
+#define ALERT_MN_LINK_ADPTR     0x13    /* link adapter */
+#define ALERT_MN_CHNL_ADPTR     0x14    /* channel adapter */
+#define ALERT_MN_LOOP_ADPTR     0x15    /* loop adapter */
+#define ALERT_MN_DIR_ADPTR      0x16    /* adapter for direct attach devices */
+#deifne ALERT_MN_MISC_ADPTR     0x17    /* miscellaneous adapter */
+#define ALERT_MN_S390_CHNL      0x18    /* System/390 channel */
+#define ALERT_MN_LINK           0x19    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LINK_COMN      0x1A    /* common carrier transmission medium */#define ALERT_MN_LINK_CUST      0x1B    /* customer transmission medium */
+#define ALERT_MN_LOOP           0x1C    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LOOP_COMN      0x1D    /* common carrier transmission medium */#define ALERT_MN_LOOP_CUST      0x1E    /* customer transmission medium */
+#define ALERT_MN_X21_EXT        0x1F    /* X.21 link conn ext to this prod */
+#define ALERT_MN_X25_EXT        0x20    /* X.25 link conn ext to this prod */
+#define ALERT_MN_X21_IFACE      0x21    /* local X.21 interface:  DTE-DCE */
+#define ALERT_MN_X25_IFACE      0x22    /* local X.25 interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_MODEM    0x23    /* local modem */
+#define ALERT_MN_REMOTE_MODEM   0x24    /* remote modem */
+#define ALERT_MN_MODEM_LIFACE   0x25    /* local modem interface:  DTE-DCE */
+#define ALERT_MN_MODEM_RIFACE   0x26    /* remote modem interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_PROBE    0x27    /* local probe */
+#define ALERT_MN_REMOTE_PROBE   0x28    /* remote probe */
+#define ALERT_MN_PROBE_LIFACE   0x29    /* local probe interface */
+#define ALERT_MN_PROBE_RIFACE   0x2A    /* remote probe interface */
+#define ALERT_MN_NETCONN        0x2B    /* network connection */
+#define ALERT_MN_IBM_HOST_PG    0x2C    /* IBM host program */
+#define ALERT_MN_IBM_HOST_APP   0x2D    /* IBM host application program */
+#define ALERT_MN_IBM_HOST_TELE  0x2E    /* IBM host telecommunication access */
+#define ALERT_MN_CUST_APP       0x2F    /* customer host application */
+#define ALERT_MN_IBM_COMM_CTRL  0x30    /* IBM comm controller program */
+#define ALERT_MN_IBM_CTRL_PG    0x31    /* IBM control program */
+#define ALERT_MN_RMT_IFMDM      0x32    /* remote modem iface or remote prod */
+#define ALERT_MN_RMT_MDM_TRANS  0x33    /* transmission med. or remote modem */
+#define ALERT_MN_SDLC_XFMT      0x34    /* SDLC format exception */
+#define ALERT_MN_BSC_XFMT       0x35    /* BSC format exception */
+#define ALERT_MN_SS_XFMT        0x36    /* start/stop format exception */
+#define ALERT_MN_SNA_XFMT       0x37    /* SNA format exception */
+#define ALERT_MN_POWER_EXT      0x38    /* power external to product */
+#define ALERT_MN_THERMAL        0x39    /* thermal */
+#define ALERT_MN_PAPER          0x3A    /* paper */
+#define ALERT_MN_TAPE           0x3B    /* tape */
+#define ALERT_MN_DASD           0x3C    /* DASD - removable media */
+#define ALERT_MN_CARD           0x3D    /* card */
+#define ALERT_MN_MAG_STRIP      0x3E    /* magnetic stripe card */
+#define ALERT_MN_NEG_SNA_RESP   0x3F    /* negative SNA response */
+#define ALERT_MN_SYS_DEF_ERR    0x40    /* system definition error */
+#define ALERT_MN_INSTALL_REST   0x41    /* installation restrictions */
+#define ALERT_MN_LS_OFFLINE     0x42    /* adjacent link station offline */
+#define ALERT_MN_LS_BUSY        0x43    /* adjacent link station busy */
+#define ALERT_MN_DEVICE         0x44    /* controller or device */
+#define ALERT_MN_LOCAL_PROBE    0x45    /* local probe or modem */
+#define ALERT_MN_DRIVE          0x46    /* tape or drive */
+#define ALERT_MN_CARD           0x47    /* card readr/punch or display/printr */#define ALERT_MN_CTRL_APP       0x48    /* controller application program */
+#define ALERT_MN_KEY_DISPLAY    0x49    /* keyboard or display */
+#define ALERT_MN_SCU            0x4A    /* storage control unit */
+#define ALERT_MN_CHNL_SCU       0x4B    /* channel or storage control unit */
+#define ALERT_MN_SCU_CTRL       0x4C    /* storage control unit or controller */#define ALERT_MN_CU             0x4D    /* control unit */
+#define ALERT_MN_DASD_M_D_D     0x4E    /* DASD data or media or drive */
+#define ALERT_MN_DASD_M_D       0x4F    /* DASD data or media */
+#define ALERT_MN_DISK           0x50    /* diskette */
+#define ALERT_MN_DISK_DRIVE     0x51    /* diskette or drive */
+#define ALERT_MN_UNDETERMINE    0xFF    /* undetermined */
+
+#endif
+
+struct recfms_alert
+{
+        __u8    alert:2,        /* 00 - Alert */
+                acode:6;        /* Alert type code - 0000 */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+        __u16   __pad1;
+
+        /* Alert classification */
+        __u8    aformat:2,      /* Alert Class Format */
+                __pad2:6;
+        __u8    atype:4,        /* Alert type, see Alert codes */
+                amjcause:4;     /* Alert major cause */
+        __u8    amncause;       /* Alert minor cause */
+        __u8    __pad3;
+        __u8    actcode;        /* User action code */
+        __u8    __pad4;
+
+        unsigned char cnmvectors;       /* Appended CNM vectors */
+};
+
+struct sna_sdlc_stats
+{
+        struct recfms_request *request; /* header */
+        __u16   wvfcs;
+        __u16   vfcs;
+};
+
+struct sna_summary_err
+{
+        struct recfms_request *request; /* header */
+        __u16   errcnt:1,       /* 1 if product error counter is valid */
+                commcnt:1,      /* 1 if comm adapter error counter is valid */
+                negcnt:1,       /* 1 if SNA neg response counter is valid */
+                __pad1:5;
+
+        __u8    __pad2;
+
+        __u8    __pad3:7,
+                commflag:1;     /* Comm adapter err flg RECFMS types 02 or 03 */
+        __u16   prodcnt;        /* Product error counter */
+        __u16   comadptr;       /* Communication adapter error counter */
+        __u16   snaneg;         /* SNA neg resps originating at this node */
+};
+
+/* Comm adapter error set indicators */
+#define COMM_ADPTR_SET1         0x01
+#define COMM_ADPTR_SET2         0x02
+#define COMM_ADPTR_SET3         0x03
+#define COMM_ADPTR_SET4         0x04
+#define COMM_ADPTR_SET5         0x05
+#define COMM_ADPTR_SET6         0x06
+
+/* Data for counters sets 1 and 2 */
+struct sna_comm_adptr_set1
+{
+        /* Communication adapter counter validity mask bytes */
+
+        __u8    nonprod_to:1,   /* Nonproductive time-out */
+                idle_to:1,      /* Idle time-out counter */
+                wrty:1,         /* Write retry counter */
+                ovrn:1,         /* Overrun counter */
+                undrn:1,        /* Underrun counter */
+                connprb:1,      /* Connection problem counter */
+                fcserr:1,       /* FCS error counter */
+                psabort:1;      /* Primary station abort counter */
+
+        __u8    cmdrej:1,       /* SDLC Command reject counter */
+                dceerr:1,       /* SDLC DCE error counter */
+                wto:1,          /* Write time-out counter */
+                inval:1,        /* Invalid status counter */
+                comm_chk:1,     /* Comm adapter machine check counter */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u8    nonprod_to_cnt; /* Nonproductive time-out counter */
+        __u8    idle_to_cnt;    /* Idle time-out counter */
+        __u8    wrty_cnt;       /* Write retry counter */
+        __u8    ovrn_cnt;       /* Overrun counter */
+        __u8    undrn_cnt;      /* Underrun counter */
+        __u8    connprb_cnt;    /* Connection problem counter */
+        __u8    fcserr_cnt;     /* FCS error counter */
+        __u8    psabort_cnt;    /* Primary station abort counter */
+        __u8    cmdrej_cnt;     /* SDLC command reject counter */
+        __u8    dceerr_cnt;     /* SDLC DCE error counter */
+        __u8    wto_cnt;        /* Write time-out counter */
+        __u8    inval_cnt;      /* Invalid status counter */
+        __u8    comm_chk_cnt;   /* Communication adapter machine check cntr */
+};
+
+/* Data for counters set 3 */
+struct sna_comm_adptr_set3
+{
+        __u8    tx_iframes:1,   /* Total transmitted I-frames counter */
+                wrty:1,         /* Write retry counter */
+                rx_iframes:1,   /* Total received I-frames counter */
+                fcserr:1,       /* FCS error counter */
+                cmdrej:1,       /* SDLC command reject counter */
+                dceerr:1,       /* DCE error counter */
+                noprod_to:1,    /* Nonproductive time-out counter */
+                __pad1;
+
+        __u16   __pad2;
+
+        __u16   tx_iframes_cnt; /* Total transmitted I-frames counter */
+        __u16   wrty_cnt;       /* Write retry counter */
+        __u16   rx_iframes_cnt; /* Total received I-frames counter */
+        __u16   fcserr_cnt;     /* FCS error counter */
+        __u16   cmdrej_cnt;     /* SDLC command reject counter */
+        __u16   dceerr_cnt;     /* DCE error counter */
+        __u16   noprod_to_cnt;  /* Nonproductive time-out counter */
+};
+
+struct sna_comm_adptr_set4
+{
+        __u8    cmdrejwni:1,    /* Command-reject-while-not-initialized cnt */
+                cmdnrec:1,      /* Command-not-recognized counter */
+                sensewni:1,     /* Sense-while-not-initialized counter */
+                chnlpcdss:1,    /* Channel-prty-chk-during-selection-seq cnt */
+                chnlpcddws:1,   /* Channel-parity-chk-during-data-wrt-seq cnt */                oppcacu:1,      /* Output-parity-check-at-control-unit cnt */
+                ippcacu:1,      /* Input-parity-check-at-control-unit counter */
+                ipcaac:1;       /* Input-parity-check-at-adapter counter */
+
+        __u8    dataeaa:1,      /* Data-error-at-adapter counter */
+                datasseq:1,     /* Data-stop-sequence counter */
+                shrtfolchk:1,   /* Short-frame-or-length-check counter */
+                connrcvwac:1,   /* Connect-rcvd-when-already-connected cnt */
+                disrcvwpuact:1, /* Disconnect-received-while-PU-active cnt */
+                longru:1,       /* Long-RU counter */
+                connprmold:1,   /* Connect-parameter-error counter */
+                rdstrtoldrcv:1; /* Read-Start-Old-received counter */
+
+        __u8    __pad1;
+
+        __u8    cmdrejwni_cnt;  /* Command-reject-while-not-initialized cnt */
+        __u8    cmdnrec_cnt;    /* Command-not-recognized counter */
+        __u8    sensewni_cnt;   /* Sense-while-not-initialized counter */
+        __u8    chnlpcdss_cnt;  /* Channel-prty-chk-during-selection-seq cnt */
+        __u8    chnlpcddws_cnt; /* Channel-parity-chk-during-data-wrt-seq cnt */        __u8    oppcacu_cnt;    /* Output-parity-check-at-control-unit cnt */
+        __u8    ippcacu_cnt;    /* Input-parity-check-at-control-unit counter */        __u8    ipcaac_cnt;     /* Input-parity-check-at-adapter counter */
+        __u8    dataeaa_cnt;    /* Data-error-at-adapter counter */
+        __u8    datasseq_cnt;   /* Data-stop-sequence counter */
+        __u8    shrtfolchk_cnt; /* Short-frame-or-length-check counter */
+        __u8    connrcvwac_cnt; /* Connect-rcvd-when-already-connected cnt */
+        __u8    disrcvwpuact_cnt;       /* Disconn-rcvd-while-PU-active cnt */
+        __u8    longru_cnt;     /* Long-RU counter */
+        __u8    connprmold_cnt; /* Connect-parameter-error counter */
+        __u8    rdstrtoldrcv_cnt;       /* Read-Start-Old-received counter */
+};
+
+struct sna_comm_adptr_set5
+{
+        __u8    tx_iframes:1,   /* I-frames transmitted counter */
+                rx_iframes:1,   /* I-frames received counter */
+                tx_rrframes:1,  /* RR frames transmitted counter */
+                rx_rrframes:1,  /* RR frames received counter */
+                tx_rnrframes:1, /* RNR frames transmitted counter */
+                rx_rnrframes:1, /* RNR frames received counter */
+                tx_rejframes:1, /* REJ frames transmitted counter */
+                rx_rejframes:1; /* REJ frames received counter */
+
+        __u8    retransmit:1,   /* Number of retransmissions counter */
+                fcs_frames:1,   /* Number of frames rcvd with FCS errors cnt */
+                rcverr:1,       /* Number of errors on receive side counter */
+                ovrn_rxs:1,     /* Number of overruns on receive side counter */                undrn_txs:1,    /* Number of underruns on transmit side cntr */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u16   tx_iframes_cnt; /* I-frames transmitted counter */
+        __u16   rx_iframes_cnt; /* I-frames received counter */
+        __u16   tx_rrframes_cnt;        /* RR frames transmitted counter */
+        __u16   rx_rrframes_cnt;        /* RR frames received counter */
+        __u16   tx_rnrframes_cnt;       /* RNR frames transmitted counter */
+        __u16   rx_rnrframes_cnt;       /* RNR frames received counter */
+        __u16   tx_rejframes_cnt;       /* REJ frames transmitted counter */
+        __u16   rx_rejframes_cnt;       /* REJ frames received counter */
+        __u16   retransmit_cnt; /* Number of retransmissions counter */
+        __u16   fcs_frames_cnt; /* Number of frames rcvd with FCS errors cnt */
+        __u16   rcverr_cnt;     /* Number of errors on receive side counter */
+        __u16   ovrn_rxs_cnt;   /* Number of overruns on receive side counter */        __u16   undrn_txs_cnt;  /* Number of underruns on transmit side cnt */
+};
+
+struct sna_comm_adptr_set6
+{
+        __u8    tx_ipackets:1,  /* data packets transmitted counter */
+                rx_ipackets:1,  /* data packets received counter */
+                tx_rrpackets:1, /* RR packets transmitted counter */
+                rx_rrpackets:1, /* RR packets received counter */
+                tx_rnrpackets:1,        /* RNR packets transmitted counter */
+                rx_rnrpackets:1,        /* RNR packets received counter */
+                tx_intpackets:1,        /* interrupt packets transmitted cnt */
+                rx_intpackets:1;        /* interrupt packets received counter */
+        __u8    connreq:1,      /* Number of connection requests counter */
+                conns:1,        /* Number of connections counter */
+                rstindic:1,     /* Number of reset indications counter */
+                clrindic:1,     /* Number of clear indications counter */
+                tx_dbit:1,      /* data packets with D-bit transmitted cnt */
+                rx_dbit:1,      /* data packets with D-bit received counter */
+                __pad1:2;
+
+        __u8    __pad2;
+
+        __u16   tx_ipackets_cnt;        /* I packets transmitted */
+        __u16   rx_ipackets_cnt;        /* I packets received */
+        __u16   tx_rrpackets_cnt;       /* RR packets transmitted */
+        __u16   rx_rrpackets_cnt;       /* RR packets received */
+        __u16   tx_rnrpackets_cnt;      /* RNR packets transmitted counter */
+        __u16   rx_rnrpackets_cnt;      /* RNR packets received counter */
+        __u16   tx_intpackets_cnt;      /* interrupt packets transmitted cnt */
+        __u16   rx_intpackets_cnt;      /* interrupt packets received counter */        __u16   connreq_cnt;    /* Total number of connection requests */
+        __u16   conns_cnt;      /* Total number of connections*/
+        __u16   rstindic_cnt;   /* Number of reset indications */
+        __u16   clrindic_cnt;   /* Number of clear indications */
+        __u16   tx_dbit_cnt;    /* Number of data pkts with D-bit transmitted */        __u16   rx_dbit_cnt;    /* Number of data packets with D-bit received */};
+
+struct sna_comm_adptr_stats
+{
+        struct recfms_request *request; /* header */
+        __u8    errset;         /* Comm adapter error counter sets */
+
+        union {         /* Data sets */
+                struct sna_comm_adptr_set1      set1;
+                struct sna_comm_adptr_set1      set2;
+                struct sna_comm_adptr_set3      set3;
+                struct sna_comm_adptr_set4      set4;
+                struct sna_comm_adptr_set5      set5;
+                struct sna_comm_adptr_set6      set6;
+        } counter;
+};
+
+struct sna_generic_stats
+{
+        struct recfms_request *request;
+        unsigned char *data;
+};
+
+/* Data selection indicators */
+#define LCSUB_LSC_SEQ           0x02
+#define LCSUB_RMT_DTE_STATS     0x03
+#define LCSUB_RMT_MDM_STEST     0x04
+
+/* Link connection subsystem type */
+#define LCSUB_TYPE1     0x01
+#define LCSUB_TYPE2     0x02
+
+/* Validity indicators */
+#define LCSUB_DATA_VALID        00
+#define LCSUB_NRSP_MDM          01
+#define LCSUB_ERSP_MDM          10
+#define LCSUB_DATA_NOTVALID     11
+
+struct sna_lcsub_stats
+{
+        struct recfms_request *request;
+
+        __u8    datasel;        /* Data selection */
+        __u8    lctype;         /* Link connection subsystem type */
+
+        /* Validity indicators */
+        __u16   rmodem_stat:2,  /* Remote modem status */
+                lmodem_stat:2,  /* Local modem status */
+                modem_stest:2,  /* Modem self test */
+                __pad1:2,
+                rdte_stat:2,    /* Remote DTE interface status */
+                __pad2:4,
+                lfmt:2;         /* Link conn subsystem data format indicator */
+
+        /* Remote modem status */
+        __u16   rhcount:6,      /* Hit count */
+                rrinit:1,       /* Modem reinitialization was performed */
+                rlrcvsig:1,     /* Loss of receive line signal */
+                rquaderr:4,     /* Quadratic error value */
+                rrdtepwroff:1,  /* Remote DTE power off detected */
+                rldtr:1,        /* Data Terminal Ready loss detected */
+                rswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                rdtestream:1;   /* DTE streaming condition detected */
+
+        /* Local modem status */
+        __u16   lhcount:6,      /* Hit count */
+                lrinit:1,       /* Modem reinitialization was performed */
+                llrcvsig:1,     /* Loss of receive line signal */
+                lquaderr:4,     /* Quadratic error value */
+                lrdtepwroff:1,  /* Remote DTE power off detected */
+                lspeed:1,       /* Speed */
+                lswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                ldtestream:1;   /* DTE streaming condition detected */
+
+        __u16   modelbits:3,    /* Model bits */
+                linktype:1,     /* Link connection type */
+                config:1,       /* Configuration */
+                mrole:1,        /* Modem role */
+                ctds:1,         /* Clear To Send delay */
+                rcvlsigdet:1,   /* Received line signal detector sensitivity */
+                modelbit1:1,    /* Model bit */
+                stest:1,        /* Modem self-test result */
+                rttest:1,       /* Remote tone test result */
+                fcarderr:1,     /* Feature card suspected in error */
+                rcvxcard:1,     /* Receiver card extension suspected in error */                frntcard:1,     /* Front end card is suspected in error */
+                modelbit2:1,    /* Model bit */
+                fcardinst:1;    /* Feature card installed */
+        __u8    swntwkbkup:1,   /* Switched-Network-Back-Up installed */
+                modelbit3:1,    /* Model bit */
+                modelbit4:1,    /* Model bit */
+                microcode:5;    /* Microcode EC level */
+
+        __u8    rts:1,          /* Request To Send */
+                cts:1,          /* Clear To Send */
+                __pad3:1,
+                td:1,           /* Transmit Data */
+                __pad4:1,
+                dtr:1,          /* Data Terminal Ready */
+                speed:1,        /* Speed */
+                dtepwrloss:1;   /* DTE power loss */
+
+        __u8    rtqc:1,         /* Request To Send changed at least once */
+                ctsc:1,         /* Clear To Send changed at least once */
+                rdc:1,          /* Received Data changed state */
+                tdc:1,          /* Transmit Data changed state */
+                rcvlsigc:1,     /* Received Line Signal loss was detected */
+                dtrd:1,         /* Data Terminal Ready dropped */
+                speedc:1,       /* Modem speed was changed */
+                dtepwrlossc:1;  /* DTE power loss was detected */
+
+                /* Channelization status */
+        __u8    channelized:1,  /* Is associated with a channelized modem */
+                tailed:1,       /* Is associated with a tailed link chnl mdm */
+                channela:1,     /* associated with channel A */
+                __pad5:5;
+
+        __u16   channelnum;     /* Channelization correlation number */
+
+        __u8    ldblvl;         /* Local modem receive dB level */
+        unsigned char __pad6[6];
+
+        __u8    rdblvl;         /* Remote modem receive dB level */
+        unsigned char __pad7[6];
+
+        __u8    lladdr;         /* Link-level addr used to addr the rmt modem */        __u8    rdteifacex;     /* Remote DTE Interface Extension */
+
+        unsigned char   __pad8[5];
+};
+
+/* CNM Vectors not included here */
+
+struct sna_recfms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {         /* Request specific information */
+                struct sna_sdlc_stats           sdlc;
+                struct sna_summary_err          sna;
+                struct sna_comm_adptr_stats     adptr;
+                struct sna_generic_stats        pulu;
+                struct sna_generic_stats        enginr;
+                struct sna_lcsub_stats          lcsub;
+        } stats;
+};
+
+struct sna_rms_gen_specific
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+};
+
+struct sna_rms_pulu
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        unsigned char *data;    /* PU- or LU-dependent request parameters */
+};
+
+struct sna_rms_lcsub
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        __u8    dselrq;         /* Data selection requested */
+
+};
+
+struct sna_rms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {
+                struct sna_rms_gen_specific     request;
+                struct sna_rms_gen_specific     sdlc;
+                struct sna_rms_gen_specific     sna;
+                struct sna_rms_gen_specific     adptr;
+                struct sna_rms_pulu             pulu;
+                struct sna_rms_gen_specific     enginr;
+                struct sna_rms_lcsub            lcsub;
+        } rms;
+};
+
+/* Control Vectors.
+ */
+
+typedef enum {
+	CV_NETNAME = 1,
+	CV_PRODUCT_ID
+} cv_type;
+
+#define CV_KEY_NETNAME		0x0E
+#define CV_KEY_PRODUCT_ID	0x10
+
+#define CV_CP_NAME		0xF4
+
+/* XID.
+ */
+
+/* Default timer values */
+#define SNA_XID_RETRY_LIMIT     10
+#define SNA_XID_IDLE_LIMIT      (60 * HZ)
+#define SNA_XID_RETRY_INTERVAL  (10 * HZ)
+
+/* XID I-field structures. The goal is to provide one set of XID headers
+ * for all device types, Eth, Tr, Sdlc, X.25, Channel, etc, etc..
+ */
+#define SNA_XID_TYPE_0          0x00    /* Xid Type 0 */
+#define SNA_XID_TYPE_1          0x01    /* Xid Type 1 */
+#define SNA_XID_TYPE_2          0x02    /* Xid Type 2 */
+#define SNA_XID_TYPE_3          0x03    /* Xid Type 3 */
+
+#define SNA_XID_NODE_T1         0x01    /* T1 node */
+#define SNA_XID_NODE_T2         0x02    /* T2.0 or T2.1 node */
+#define SNA_XID_NODE_T4         0x04    /* T4 or T5 node */
+#define SNA_XID_NODE_T5         SNA_XID_NODE_T4
+
+#define SNA_XID_XSTATE_NOSUPP	0x00
+#define SNA_XID_XSTATE_NONACT	0x01
+#define SNA_XID_XSTATE_NEG	0x02
+#define SNA_XID_XSTATE_PN	0x03
+
+typedef struct {
+        __u16   rsv1;
+        __u8    rsv2:2,
+                ls_role:1,
+                rsv3:1,
+                ls_txrx_cap:4;
+        __u8    rsv4:2,
+                seg_asm_cap:2,
+                rsv5:2,
+                sh_mode_status:1,
+                sh_mode_support:1;
+        __u16   format:1,
+                max_ifield_len:15;
+        __u8    rsv6:4,
+                sdlc_cmd_rsp_profile:4;
+        __u8    rsv7:2,
+                sdlc_init_mode:1,
+                rsv8:5;
+        __u16   rsv9;
+        __u8    rsv10:1,
+                max_rx_iframe_win:7;
+        __u8    rsv11;
+
+        /* SDLC address assignment field */
+        /*
+         * Not supported yet.
+         */
+} sna_xid1;
+
+typedef struct {
+        __u8    raw;
+} sna_xid2;
+
+typedef struct {
+        unsigned        rsv1:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+        unsigned        abm_nonact_xid:1        __attribute__ ((packed));
+        unsigned        rsv2:7                  __attribute__ ((packed));
+        unsigned        max_btu_len_format:1    __attribute__ ((packed));
+        __u16           max_btu_len:15          __attribute__ ((packed));
+        unsigned        rsv3                    __attribute__ ((packed));
+        unsigned        rsv4:2                  __attribute__ ((packed));
+        unsigned        dlc_init_mode:1         __attribute__ ((packed));
+        unsigned        rsv5:5                  __attribute__ ((packed));
+        __u16           rsv6                    __attribute__ ((packed));
+        unsigned        rsv7:1                  __attribute__ ((packed));
+        unsigned        max_rx_iframes:7        __attribute__ ((packed));
+} sna_xid_dlc_satf;
+
+typedef struct {
+        __u16   cdlc_chg:1,
+                attn_timeout_sup:1,
+                data_stream:1,
+                cdlc_chg_sup:1,
+                rsv1:12;
+        __u16   max_lpiu_len;
+        __u8    buf_prefetch;
+        __u16   num_read_cmds;
+        __u16   buf_size;
+        __u16   blocking_delay;
+        __u16   attn_timeout;
+        __u16   pre_num_read_cmds;
+        __u16   prev_pri_buf_size;
+        __u8    time_unit;
+} sna_xid_dlc_s390_channel;
+
+typedef struct {
+        __u8    rsv1:2,
+                xid_role:2,
+                rsv2:4;
+        __u8    rsv3;
+        __u16   max_btu_size;
+
+        /* Start of Control Vectors */
+        __u8    cv;
+} sna_xid_dlc_appn_channel;
+
+#pragma pack(1)
+typedef struct {
+	/* Byte 0 */
+	__u8    xid_node:4              	__attribute__ ((packed));
+        __u8    xid_type:4              	__attribute__ ((packed));
+
+	/* Byte 1 */
+        __u8    len:8                   	__attribute__ ((packed));
+
+	/* Byte 2 - 5 */
+        __u32   block_id:12,
+		pu_id:20			__attribute__ ((packed));
+
+	/* Byte 6 - 7 */
+        __u16   rsv1                            __attribute__ ((packed));
+
+	/* Byte 8 - 9 */
+	__u8		nc1			__attribute__ ((packed));
+	__u8		nc2			__attribute__ ((packed));
+/*
+        __u16        	init_self:1,
+                	stand_alone_bind:1,
+                	whole_bind:1,
+                	whole_bind_piu_req:1,
+        	        rsv2:4,
+        	        actpu_suppression:1,
+        	        network_node:1,
+        	        cp_services:1,
+        	        cp_cp_support:1,
+        	        xid_xstate:2,
+        	        nonact_xchg_sec:1,
+        	        cp_name_chg:1           __attribute__ ((packed));
+*/
+
+	/* Byte 10 */
+        /* Bind pacing support over TG */
+        __u8        	tx_adptv_bind_pacing:1,
+        		rx_adprv_bind_pacing:1,
+        		quiesce_tg_req:1,
+        		pu_cap_sup:1,
+        		appn_pbn:1,
+        		rsv3:1,
+        		adptv_bind_pacing:2     __attribute__ ((packed));
+
+	/* Byte 11 */
+        __u8        	rsv4:1,
+                	tg_sharing_prohibited:1,
+                	dedicated_scv:1,
+              		rsv5:5                  __attribute__ ((packed));
+
+	/* Byte 12 - 14 */
+	__u8		rsv6[3]			__attribute__ ((packed));
+
+	/* byte 15 */
+        __u8        	parallel_tg_sup:1,
+             		dlur_actpu:1,
+               		dlus_lu_reg:1,
+                	xhpr_bn:1,
+                	gen_odai_usage_opt_set:1,
+			rsv7:3			__attribute__ ((packed));
+
+	/* byte 16 */
+        __u8            tg_num                  __attribute__ ((packed));
+
+	/* Byte 17 */
+        __u8            dlc_type                __attribute__ ((packed));
+
+	/* Byte 18 */
+	__u8		dlc_len			__attribute__ ((packed));
+
+	/* byte 19 */
+	__u8		ls_flags		__attribute__ ((packed));
+
+/*
+	unsigned        rsv8:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+*/
+
+	/* byte 20 */
+        __u8		abm_nonact_xid:1,
+        		rsv9:7                  __attribute__ ((packed));
+
+	/* byte 21 - 22 */
+	__u16		max_btu_len		__attribute__ ((packed));
+/*
+        __u16		max_btu_len_format:1,
+        		max_btu_len:15          __attribute__ ((packed));
+*/
+
+	/* byte 23 */
+        __u8        	rsv10                   __attribute__ ((packed));
+
+	/* byte 24 */
+        __u8		rsv11:2,
+        		dlc_init_mode:1,
+        		rsv12:5                  __attribute__ ((packed));
+
+	/* byte 25 - 26 */
+        __u16           rsv13                    __attribute__ ((packed));
+
+	/* byte 27 */
+	__u8		max_rx_iframes		__attribute__ ((packed));
+/*
+        __u8		rsv14:1,
+        		max_rx_iframes:7        __attribute__ ((packed));
+*/
+} sna_xid3;
+#pragma pack()
+
+struct sna_xid {
+        __u8    xid_node:4              __attribute__ ((packed));
+        __u8    xid_type:4              __attribute__ ((packed));
+        __u8    len:8                   __attribute__ ((packed));
+        __u32   node_block_num:12       __attribute__ ((packed));
+        __u32   node_id_num:20          __attribute__ ((packed));
+
+        union {
+                sna_xid1        x1 __attribute__ ((packed));
+                sna_xid2        x2 __attribute__ ((packed));
+                sna_xid3        x3 __attribute__ ((packed));
+        } fmt;
+};
+
+#endif  /* __KERNEL__ */
+#endif  /* __NET_SNA_FORMATS_H */
diff -ruN linux-2.4.13/include/net/sock.h linux/include/net/sock.h
--- linux-2.4.13/include/net/sock.h	Tue Oct 23 21:59:33 2001
+++ linux/include/net/sock.h	Wed Nov  7 11:08:01 2001
@@ -656,6 +656,9 @@
 #if defined(CONFIG_WAN_ROUTER) || defined(CONFIG_WAN_ROUTER_MODULE)
                struct wanpipe_opt      *af_wanpipe;
 #endif
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+		struct sna_opt		*af_sna;
+#endif
 	} protinfo;  		
 
 
diff -ruN linux-2.4.13/net/Config.in linux/net/Config.in
--- linux-2.4.13/net/Config.in	Tue Mar  6 22:44:15 2001
+++ linux/net/Config.in	Sat Nov  3 13:18:54 2001
@@ -17,6 +17,9 @@
    bool '  Network packet filtering debugging' CONFIG_NETFILTER_DEBUG
 fi
 bool 'Socket Filtering'  CONFIG_FILTER
+bool 'Advanced Linux Network Buffers' CONFIG_ADV_SKB
+bool 'Common Programming Interface Communications (CPI-C)' CONFIG_CPIC
+bool 'Advanced Program-to-Program Communications (APPC)' CONFIG_APPC
 tristate 'Unix domain sockets' CONFIG_UNIX
 bool 'TCP/IP networking' CONFIG_INET
 if [ "$CONFIG_INET" = "y" ]; then
@@ -48,6 +51,11 @@
    fi
 fi
 
+comment ' '
+tristate 'SNA Networking' CONFIG_SNA
+if [ "$CONFIG_SNA" != "n" ]; then
+   source net/sna/Config.in
+fi
 comment ' '
 tristate 'The IPX protocol' CONFIG_IPX
 if [ "$CONFIG_IPX" != "n" ]; then
diff -ruN linux-2.4.13/net/Makefile linux/net/Makefile
--- linux-2.4.13/net/Makefile	Mon Jun 11 19:15:27 2001
+++ linux/net/Makefile	Sat Nov  3 13:18:54 2001
@@ -45,9 +45,10 @@
 subdir-$(CONFIG_ATM)		+= atm
 subdir-$(CONFIG_DECNET)		+= decnet
 subdir-$(CONFIG_ECONET)		+= econet
+subdir-$(CONFIG_SNA)            += sna
 
 
-obj-y	:= socket.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
+obj-y	:= socket.o cpic.o attach.o appc.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_MODULES)		+= netsyms.o
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
diff -ruN linux-2.4.13/net/README linux/net/README
--- linux-2.4.13/net/README	Mon Jun 11 19:15:27 2001
+++ linux/net/README	Sat Nov  3 13:18:54 2001
@@ -23,4 +23,4 @@
 unix			alan@lxorguk.ukuu.org.uk
 x25			g4klx@g4klx.demon.co.uk
 bluetooth		maxk@qualcomm.com
-
+sna			jschlst@samba.org
diff -ruN linux-2.4.13/net/appc.c linux/net/appc.c
--- linux-2.4.13/net/appc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/appc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,96 @@
+/* appc.c: Advanced Program-to-Program Communications.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+
+#include <linux/appc.h>
+
+static int appcs_in_use = 0;
+static struct appc_ops *appc_client_ops[NPROTO];
+
+#define MAX_APPC_ADDR   1024
+
+int appc_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_APPC_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int appc_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_APPC_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+		if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+asmlinkage void sys_appcall(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr)
+{
+	switch(opcode)
+	{
+
+	}
+}
+
+int appc_register(struct appc_ops *ops)
+{
+        int err;
+
+        if(ops->family >= NPROTO)
+        {
+                printk(KERN_CRIT "appc protocol %d >= NPROTO(%d)\n", ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+        err = -EEXIST;
+        if(appc_client_ops[ops->family] == NULL)
+        {
+                appc_client_ops[ops->family] = ops;
+                err = 0;
+        }
+
+        return (err);
+}
+
+int appc_unregister(int family)
+{
+        if(family < 0 || family >= NPROTO)
+                return (-1);
+        appc_client_ops[family] = NULL;
+        return (0);
+}
diff -ruN linux-2.4.13/net/attach.c linux/net/attach.c
--- linux-2.4.13/net/attach.c	Wed Dec 31 16:00:00 1969
+++ linux/net/attach.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,430 @@
+/* attach.c: Linux-SNA Attach Manager Kernel Stub.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+#include <linux/attach.h>
+
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} attach_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+
+static struct attach_ops *attach_client_ops[NPROTO];
+
+static struct vfsmount *attach_mnt;
+
+/* IDs for TPs connected to an attach manager */
+static unsigned long attach_tp_ids = 0;
+
+#define ATTACHFS_MAGIC 0x634F567B
+
+static int atfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type = ATTACHFS_MAGIC;
+        buf->f_bsize = 1024;
+        buf->f_namelen = 255;
+        return 0;
+}
+
+static struct super_operations atfs_ops = {
+        statfs:         atfs_statfs,
+};
+
+static struct super_block * atfs_read_super(struct super_block *sb, void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid = root->i_gid = 0;
+        root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize = 1024;
+        sb->s_blocksize_bits = 10;
+        sb->s_magic = ATTACHFS_MAGIC;
+        sb->s_op = &atfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "attach:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb = sb;
+        sb->s_root->d_parent = sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(attach_fs_type, "attachfs", atfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int atfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations atfs_dentry_operations = {
+        d_delete:       atfs_delete_dentry,
+};
+
+int attach_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return (-ENXIO);
+}
+
+int attach_close(struct inode *inode, struct file *flip);
+
+static struct file_operations attach_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		attach_no_open,         /* special open code to disallow open by proc */
+        release:	attach_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+extern __inline__ struct attach *ati_lookup(struct inode *inode)
+{
+        return &inode->u.attach_i;
+}
+
+int attach_map_fd(struct attach *at)
+{
+        int fd;
+	struct qstr this;
+	char name[32];
+
+        /*
+         *      Find a file descriptor suitable for return to the user.
+         */
+
+        fd = get_unused_fd();
+        if (fd >= 0) {
+                struct file *file = get_empty_filp();
+
+                if (!file) {
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", at->inode->i_ino);
+                this.name = name;
+                this.len = strlen(name);
+                this.hash = at->inode->i_ino;
+
+		file->f_dentry = d_alloc(attach_mnt->mnt_sb->s_root, &this);
+                if (!file->f_dentry) {
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+		file->f_dentry->d_op = &atfs_dentry_operations;
+                d_add(file->f_dentry, at->inode);
+                file->f_vfsmnt = mntget(attach_mnt);
+
+		at->file = file;
+                file->f_op = at->inode->i_fop = &attach_file_ops;
+                file->f_mode = 3;
+                file->f_flags = O_RDWR;
+                file->f_pos = 0;
+                fd_install(fd, file);
+        }
+
+out:
+        return fd;
+}
+
+struct attach *attachfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct attach *attach;
+
+        if(!(file = fget(fd)))
+        {
+                *err = -EBADF;
+                return NULL;
+        }
+
+        inode = file->f_dentry->d_inode;
+        if(!inode || !inode->i_attach || !(attach = ati_lookup(inode)))
+        {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+
+        if(attach->file != file)
+        {
+                printk(KERN_ERR "ati_lookup: attach file changed!\n");
+                attach->file = file;
+        }
+
+        return (attach);
+}
+
+struct attach *attach_alloc(void)
+{
+        struct inode *inode;
+        struct attach *at;
+
+        inode = get_empty_inode();
+        if(!inode)
+                return (NULL);
+
+        at = ati_lookup(inode);
+
+        inode->i_mode = S_IFSOCK|S_IRWXUGO;
+        inode->i_attach = 1;
+        inode->i_uid = current->fsuid;
+        inode->i_gid = current->fsgid;
+
+        init_waitqueue_head(&at->wait);
+        at->fasync_list = NULL;
+        at->inode     	= inode;
+        at->flags     	= 0;
+        at->ops       	= NULL;
+        at->file      	= NULL;
+
+	attach_in_use[smp_processor_id()].counter++;
+        return (at);
+}
+
+int attach_create(struct attach **a)
+{
+	struct attach *at;
+
+	if(!(at = attach_alloc()))
+		return (-ENOMEM);
+	at->ops	= attach_client_ops[PF_SNA];	/* Bad - I know */
+	*a 	= at;
+
+	return (0);
+}
+
+void attach_release(struct attach *at)
+{
+        attach_in_use[smp_processor_id()].counter--;
+        if(!at->file) {
+                iput(at->inode);
+                return;
+        }
+        at->file = NULL;
+}
+
+struct attach_tps *attach_find_tp(struct attach_tps *tps, char *name)
+{
+	struct attach_tps *t;
+	for(t = tps; t != NULL; t = t->next)
+		if(!strcmp(t->tp_name, name))
+			return (t);
+
+	return (NULL);
+}
+
+/* Returns TP fd, needs attch fd and tp_info */
+asmlinkage int sys_tp_register(int s, struct tp_info *tpi)
+{
+	int err;
+	struct attach *at;
+	struct tp_info tpii;
+	struct attach_tps *tp;
+
+	if((at = attachfd_lookup(s, &err)) == NULL)
+		return (-EBADF);
+
+	if(copy_from_user(&tpii, tpi, sizeof(struct tp_info)))
+                return (-EFAULT);
+
+	tp = attach_find_tp(at->tps, tpii.tp_name);
+	if(tp != NULL)
+		return (-EEXIST);
+
+	tp = (struct attach_tps *)kmalloc(sizeof(struct attach_tps),GFP_ATOMIC);
+	strncpy(tp->tp_name, tpii.tp_name, 64);
+	tp->state	= AT_INIT;
+	tp->flags	= 0;
+	tp->pid		= -1;
+	tp->id		= attach_tp_ids++;
+	tp->next	= at->tps;
+	at->tps		= tp;
+
+        return (err);
+}
+
+/* Needs attach fd, and tp fd to unregister */
+asmlinkage int sys_tp_unregister(int a, int b)
+{
+	struct attach_tps *tp, **clients;
+	struct attach *at;
+	int err;
+
+	if((at = attachfd_lookup(a, &err)) == NULL)
+                return (-EBADF);
+
+	clients = &at->tps;
+	while((tp = *clients) != NULL)
+	{
+		if(tp->id == b)
+		{
+			*clients = tp->next;
+			kfree(tp);
+			return (0);
+		}
+		clients = &tp->next;
+	}
+
+	return (-ENOENT);
+}
+
+/* Open an SNA Attach session, grab an unused FD and setup everything for
+ * the attach manager to start registering TPs.
+ */
+asmlinkage int sys_attach_open(void)
+{
+	int retval;
+	struct attach *a;
+
+	retval = attach_create(&a);
+	if(retval < 0)
+		goto out;
+
+	retval = attach_map_fd(a);
+	if(retval < 0)
+		goto out_release;
+
+out:
+	return (retval);
+
+out_release:
+	attach_release(a);
+	return (retval);
+}
+
+extern __inline__ void attachfd_put(struct attach *at)
+{
+        fput(at->file);
+}
+
+asmlinkage int sys_attach_listen(int s, void *ubuf, int len, unsigned int flags)
+{
+	struct attach *at;
+	int err;
+
+	at = attachfd_lookup(s, &err);
+	if(!at)
+		goto out;
+
+	err = at->ops->attach_listen(at, ubuf, len);
+	attachfd_put(at);
+
+out:
+	return (err);
+}
+
+asmlinkage int sys_tp_correlate(int s, pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+        struct attach *at;
+        int err;
+
+        printk("sys_tp_correlate %d %ld\n", pid, tcb_id);
+
+        at = attachfd_lookup(s, &err);
+        if(!at)
+                goto out;
+
+        err = at->ops->tp_correlate(pid, tcb_id, tp_name);
+
+out:
+        return (err);
+}
+
+asmlinkage int sys_attach_close(int s)
+{
+	struct attach *at;
+	int err;
+
+	if((at = attachfd_lookup(s, &err)) != NULL)
+		attach_release(at);
+        return (err);
+}
+
+int attach_close(struct inode *inode, struct file *flip)
+{
+        if(!inode)
+        {
+                printk(KERN_DEBUG "attach_close: NULL inode\n");
+                return (0);
+        }
+        unlock_kernel();
+//        cpic_fasync(-1, filp, 0);
+        attach_release(ati_lookup(inode));
+        lock_kernel();
+
+        return (0);
+}
+
+int attach_register(struct attach_ops *ops)
+{
+        int err;
+
+        if(ops->family >= NPROTO)
+        {
+                printk(KERN_CRIT "attach %d >= NPROTO(%d)\n", 
+			ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+        err = -EEXIST;
+        if(attach_client_ops[ops->family] == NULL)
+        {
+                attach_client_ops[ops->family] = ops;
+                err = 0;
+        }
+
+	register_filesystem(&attach_fs_type);
+        attach_mnt = kern_mount(&attach_fs_type);
+
+        return (err);
+}
+
+int attach_unregister(int family)
+{
+        if(family < 0 || family >= NPROTO)
+                return (-1);
+        attach_client_ops[family] = NULL;
+        return (0);
+}
diff -ruN linux-2.4.13/net/cpic.c linux/net/cpic.c
--- linux-2.4.13/net/cpic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/cpic.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,1068 @@
+/* cpic.c: Common Programming Interface Communications, v2.1 compliant.
+ *  - Protocol independent CPI-C functions. This file does all the
+ *    high-level work for a net layer using CPI-C, and condences the CPI-C
+ *    functions into a few protocol specific parts. Basicly that breaking
+ *    down into cpic.c doing error checking on the call and user-kernel
+ *    data structure transfers.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/sna.h>
+#include <linux/module.h>
+
+#include <linux/ctype.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} cpics_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+static struct cpic_ops *cpic_client_ops[NPROTO];
+
+#define MAX_CPIC_ADDR   1024
+
+static struct vfsmount *cpic_mnt;
+
+static int cpic_map_fd(struct cpic *cpic);
+
+#define CPICFS_MAGIC 0x634D128F
+
+static int cpicfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type = CPICFS_MAGIC;
+        buf->f_bsize = 1024;
+        buf->f_namelen = 255;
+        return 0;
+}
+
+static struct super_operations cpicfs_ops = {
+        statfs:         cpicfs_statfs,
+};
+
+static struct super_block * cpicfs_read_super(struct super_block *sb, 
+	void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid = root->i_gid = 0;
+        root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize = 1024;
+        sb->s_blocksize_bits = 10;
+        sb->s_magic = CPICFS_MAGIC;
+        sb->s_op = &cpicfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "cpic:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb = sb;
+        sb->s_root->d_parent = sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(cpic_fs_type, "cpicfs", cpicfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int cpicfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations cpicfs_dentry_operations = {
+        d_delete:       cpicfs_delete_dentry,
+};
+
+int cpic_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_CPIC_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int cpic_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_CPIC_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+                if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+int cpic_error(void *uaddr, __u32 return_code)
+{
+        return(cpic_ktou(&return_code, sizeof(return_code), uaddr));
+}
+
+int cpic_get_cvid(unsigned char CM_PTR conversation_id)
+{
+        __u32 cvid = 0;
+
+        copy_from_user(&cvid, conversation_id, sizeof(__u32));
+
+        return ((int)cvid);
+}
+
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare);
+int cpic_close(struct inode *inode, struct file *flip);
+
+static struct file_operations cpic_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		cpic_no_open,           /* special open code to disallow open via /proc
+*/
+        release:	cpic_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+void cpic_release(struct cpic *cpic)
+{
+	if(cpic->ops)
+		cpic->ops->release(cpic);
+	cpics_in_use[smp_processor_id()].counter--;
+}
+
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return (-ENXIO);
+}
+
+extern __inline__ struct cpic *cpici_lookup(struct inode *inode)
+{
+        return &inode->u.cpic_i;
+}
+
+extern struct cpic *cpicfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct cpic *cpic;
+
+        if(!(file = fget(fd)))
+        {
+                *err = -EBADF;
+                return NULL;
+        }
+
+        inode = file->f_dentry->d_inode;
+        if(!inode || !inode->i_cpic || !(cpic = cpici_lookup(inode)))
+        {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+
+        if(cpic->file != file)
+	{
+                printk(KERN_ERR "cpici_lookup: cpic file changed!\n");
+                cpic->file = file;
+        }
+
+	return (cpic);
+}
+
+/* Side information.
+ */
+
+static unsigned long cpic_side_id = 0;
+static struct cpic_side_info *cpic_side_list = NULL;
+
+struct cpic_side_info *cpic_find_side_info(unsigned char *name)
+{
+        struct cpic_side_info *cpic;
+
+        for(cpic = cpic_side_list; cpic != NULL; cpic = cpic->next)
+	{
+		printk("com -%s- -%s-\n", name, cpic->sym_dest_name);
+                if(!strncmp(cpic->sym_dest_name, name, 8))
+                        return (cpic);
+	}
+        return (NULL);
+}
+
+int cpic_unregister_side_info(struct cpic_delete_side_info *side)
+{
+        struct cpic_side_info *cs, **clients;
+
+        clients = &cpic_side_list;
+        while((cs = *clients) != NULL)
+        {
+                if(!strncmp(cs->sym_dest_name, side->sym_dest_name, 8))
+                {
+                        *clients = cs->next;
+                        kfree(cs);
+                        return (0);
+                }
+                clients = &cs->next;
+        }
+
+        return (-ENOENT);
+}
+
+struct netid *char_to_netid(unsigned char *b)
+{
+        struct netid *n;
+        unsigned char c[40];
+        int i;
+
+        strcpy(c, b);   /* always use protection */
+        n = (struct netid *)kmalloc(sizeof(struct netid), GFP_KERNEL);
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for(i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for(i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for(i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+        for(i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return (n);
+}
+
+char *pr_netid(struct netid *n)
+{
+        struct netid p;
+        char *buff;
+        int i;
+
+        buff = (char *)kmalloc(20, GFP_ATOMIC);
+        memcpy(&p, n, sizeof(struct netid));
+        for(i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for(i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+
+        return (buff);
+}
+
+int cpic_register_side_info(struct cpic_define_side_info *side)
+{
+        struct cpic_side_info *cs;
+	int i;
+
+        cs = cpic_find_side_info(side->sym_dest_name);
+        if(cs != NULL)
+                return (-EEXIST);
+        cs = (struct cpic_side_info *)kmalloc(sizeof(struct cpic_side_info),
+                GFP_ATOMIC);
+	memset(cs, '\0', sizeof(struct cpic_side_info));
+	memcpy(&cs->netid, char_to_netid(side->netid), sizeof(struct netid));
+	memcpy(&cs->netid_plu, char_to_netid(side->netid_plu), 
+		sizeof(struct netid));
+        strncpy(cs->sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+	for(i = strlen(cs->sym_dest_name); i < 8; i++)
+		cs->sym_dest_name[i] = 0x20;
+        strncpy(cs->mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cs->tp_name, side->tp_name, 65);
+        cs->service_tp 		= side->service_tp;
+        cs->security_level 	= side->security_level;
+        strncpy(cs->username, side->username, 11);
+        strncpy(cs->password, side->password, 11);
+        cs->proc_id             = cpic_side_id++;
+
+        /* Add to list */
+        cs->next                = cpic_side_list;
+        cpic_side_list      	= cs;
+
+        return (0);
+}
+
+int cpic_ginfo(struct cpic_side_info *side, char *buf, int len)
+{
+        struct cpicsreq cr;
+        int done = 0;
+
+        if(!buf)
+        {
+                done += sizeof(cr);
+                return (done);
+        }
+        if(len < (int)sizeof(cr))
+                return done;
+        memset(&cr, '\0', sizeof(struct cpicsreq));
+
+        /* Move the data here */
+	sprintf(cr.netid, "%s", pr_netid(&side->netid));
+	sprintf(cr.netid_plu, "%s", pr_netid(&side->netid_plu));
+        strncpy(cr.sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+        strncpy(cr.mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cr.tp_name, side->tp_name, 65);
+        strncpy(cr.username, side->username, 11);
+        strncpy(cr.password, side->password, 11);
+        cr.service_tp     = side->service_tp;
+        cr.security_level = side->security_level;
+        cr.proc_id        = side->proc_id;
+
+        if(copy_to_user(buf, &cr, sizeof(struct cpicsreq)))
+                return (-EFAULT);
+        buf += sizeof(struct cpicsreq);
+        len -= sizeof(struct cpicsreq);
+        done += sizeof(struct cpicsreq);
+
+        return (done);
+}
+
+int cpic_query_side_info(char *arg)
+{
+        struct cpicsconf cc;
+        struct cpic_side_info *side;
+        char *pos;
+        int len, total;
+
+        if(copy_from_user(&cc, arg, sizeof(cc)))
+                return (-EFAULT);
+
+        pos = cc.cpicsc_buf;
+        len = cc.cpics_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(side = cpic_side_list; side != NULL; side = side->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = cpic_ginfo(side, NULL, 0);
+                else
+                        done = cpic_ginfo(side, pos+total, len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        cc.cpics_len = total;
+        if(copy_to_user(arg, &cc, sizeof(cc)))
+                return (-EFAULT);
+        return (0);
+}
+
+/* CPI-C functions
+ */
+
+int cpic_close(struct inode *inode, struct file *flip)
+{
+	if(!inode)
+        {
+                printk(KERN_DEBUG "cpic_close: NULL inode\n");
+                return (0);
+        }
+        unlock_kernel();
+//        cpic_fasync(-1, filp, 0);
+        cpic_release(cpici_lookup(inode));
+        lock_kernel();
+
+        return (0);
+}
+
+struct cpic *cpic_alloc(void)
+{
+	struct inode *inode;
+	struct cpic *cpic;
+
+	inode = get_empty_inode();
+        if(!inode)
+                return (NULL);
+
+	cpic = cpici_lookup(inode);
+
+	inode->i_mode = S_IFSOCK|S_IRWXUGO;
+        inode->i_cpic = 1;
+        inode->i_uid = current->fsuid;
+        inode->i_gid = current->fsgid;
+
+        init_waitqueue_head(&cpic->wait);
+	cpic->fasync_list = NULL;
+	cpic->inode     = inode;
+	cpic->state	= CM_INIT;
+	cpic->flags	= 0;
+	cpic->side	= NULL;
+	cpic->file	= NULL;
+	cpic->pid	= 0;
+
+	cpic->ops = cpic_client_ops[PF_SNA];
+
+	cpics_in_use[smp_processor_id()].counter++;
+	return (cpic);
+}
+
+int cpic_create(struct cpic_side_info *side, struct cpic **cpic)
+{
+	struct cpic *c;
+
+	if(!(c = cpic_alloc()))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	c->side	= side;
+	*cpic 	= c;
+
+	if(side != NULL)
+		c->ops->create(c, 1);
+
+	return (CM_OK);
+}
+
+unsigned long cpic_cmaccp(unsigned char CM_PTR conversation_id, pid_t *p)
+{
+        struct cpic *cpic;
+	struct sna_tcb *tcb;
+	int fd;
+	__u32 rc;
+
+        /* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(NULL, &cpic);
+        if(rc != CM_OK)
+                goto out;
+
+	/* Now this is a local (server) tp being launched.
+	 * So we need to located the already allocated tcb and link
+	 * it to this cpic session. We do this by using the pid
+	 * provided by the user.
+	 */
+	cpic_utok(p, sizeof(pid_t), &cpic->pid);
+	tcb = cpic->vi.sna;
+	tcb = cpic->ops->find_tcb_by_pid(cpic->pid);
+	if(!tcb)
+	{
+		printk("No TCB found by PID %d\n", cpic->pid);
+		rc = CM_PRODUCT_SPECIFIC_ERROR;
+		goto out_release;
+	}
+
+	cpic->vi.sna = tcb;
+
+        fd = cpic_map_fd(cpic);
+        if(fd < 0)
+                goto out_release;
+        else
+                cpic_ktou(&fd, sizeof(int), conversation_id);
+
+	tcb->state = CM_INIT_INCOMING;
+
+out:
+        return (rc);
+
+out_release:
+        cpic_release(cpic);
+        return (rc);
+}
+
+unsigned long cpic_cmcnvi(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return (CM_OK);
+}
+
+unsigned long cpic_cmcnvo(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return (CM_OK);
+}
+
+static int cpic_map_fd(struct cpic *cpic)
+{
+	int fd;
+	struct qstr this;
+        char name[32];
+
+	/* Find a file descriptor suitable for return to the user. */
+        fd = get_unused_fd();
+        if(fd >= 0) 
+	{
+                struct file *file = get_empty_filp();
+
+                if(!file) 
+		{
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", cpic->inode->i_ino);
+                this.name = name;
+                this.len = strlen(name);
+                this.hash = cpic->inode->i_ino;
+
+                file->f_dentry = d_alloc(cpic_mnt->mnt_sb->s_root, &this);
+                if(!file->f_dentry)
+		{
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+
+		file->f_dentry->d_op = &cpicfs_dentry_operations;
+                d_add(file->f_dentry, cpic->inode);
+                file->f_vfsmnt = mntget(cpic_mnt);
+
+		cpic->file = file;
+                file->f_op = cpic->inode->i_fop = &cpic_file_ops;
+                file->f_mode = 3;
+                file->f_flags = O_RDWR;
+                file->f_pos = 0;
+                fd_install(fd, file);
+        }
+
+out:
+        return (fd);
+}
+
+unsigned long cpic_cminit(unsigned char CM_PTR conversation_id,
+	unsigned char CM_PTR sym_dest_name)
+{
+	struct cpic_side_info *side;
+	struct cpic *cpic;
+	unsigned char sdn[9];
+	__u32 rc;
+	int fd, err;
+
+	/* Locate the side information entry */
+	err = cpic_utok(sym_dest_name, sizeof(sdn), &sdn);
+	if(err < 0)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	side = cpic_find_side_info(sdn);
+	if(side == NULL)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	/* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(side, &cpic);
+        if(rc != CM_OK)
+		goto out;
+
+	fd = cpic_map_fd(cpic);
+	if(fd < 0)
+		goto out_release;
+	else
+		cpic_ktou(&fd, sizeof(int), conversation_id);
+
+out:
+	return (rc);
+
+out_release:
+        cpic_release(cpic);
+	return (rc);
+}
+
+CM_ENTRY sys_cmrltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	ops->cmrltp(tp_name, tp_name_length, return_code);
+}
+
+CM_ENTRY sys_cmsltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	cpic_client_ops[PF_SNA]->cmsltp(tp_name, tp_name_length, return_code);
+}
+
+CM_ENTRY sys_cmwcmp(unsigned char CM_PTR ooid_list,
+	CM_INT32 CM_PTR ooid_list_count,
+	CM_INT32 CM_PTR timeout,
+	unsigned char CM_PTR completed_op_index_list,
+	CM_INT32 CM_PTR completed_op_count,
+	unsigned char CM_PTR user_field_list,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+
+}
+
+unsigned long cpic_cmembs(__u32 *max_buffer_size)
+{
+	__u32 size = sizeof(__u32);
+        cpic_ktou(&size, sizeof(__u32), max_buffer_size);
+
+	return (CM_OK);
+}
+
+asmlinkage CM_ENTRY sys_cpicall(unsigned char CM_PTR conversation_id, 
+	unsigned short opcode, void *uaddr, CM_RETURN_CODE CM_PTR return_code) 
+{
+	struct cpic *cpic = NULL;
+	cpic_args *args = NULL;
+	unsigned long rc = CM_OK;
+	int err;
+
+	/* Copy call arguments from user space */
+	args = (cpic_args *)kmalloc(sizeof(cpic_args), GFP_ATOMIC);
+	cpic_utok(uaddr, sizeof(cpic_args), args);
+
+	/* Get the local cpic structure if available. */
+	if((opcode != CM_CMINIT && opcode != CM_CMCNVI && opcode != CM_CMCNVO
+		&& opcode != CM_CMEMBS && opcode != CM_CMRLTP
+		&& opcode != CM_CMSLTP && opcode != CM_CMWCMP
+		&& opcode != CM_CMACCP)
+		&& ((cpic = cpicfd_lookup(cpic_get_cvid(conversation_id), &err))
+		== NULL))
+	{
+		rc = CM_PROGRAM_PARAMETER_CHECK;
+		goto out;
+	} 
+
+	switch(opcode)
+	{
+		case (CM_CMACCI):
+			rc = cpic->ops->cmacci(cpic);
+			break;
+
+		case (CM_CMACCP):
+			rc = cpic_cmaccp(conversation_id, (pid_t *)args->a1);
+			break;
+
+		case (CM_CMALLC):
+			rc = cpic->ops->cmallc(cpic);
+			break;
+
+		case (CM_CMCANC):
+			rc = cpic->ops->cmcanc(cpic);
+			break;
+
+		case (CM_CMCFM):
+			rc = cpic->ops->cmcfm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMCFMD):
+			rc = cpic->ops->cmcfmd(cpic);
+			break;
+
+		case (CM_CMCNVI):	/* No Cvid */
+			rc = cpic_cmcnvi((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+
+		case (CM_CMCNVO):	/* No Cvid */
+			rc = cpic_cmcnvo((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+
+		case (CM_CMDEAL):
+			rc = cpic->ops->cmdeal(cpic);
+			break;
+
+		case (CM_CMDFDE):
+			rc = cpic->ops->cmdfde(cpic);
+			break;
+
+		case (CM_CMEACN):
+			rc = cpic->ops->cmeacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEAEQ):
+			rc = cpic->ops->cmeaeq(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMEAPT):
+			rc = cpic->ops->cmeapt(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMECS):
+			rc = cpic->ops->cmecs(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMECT):
+			rc = cpic->ops->cmect(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMECTX):
+			rc = cpic->ops->cmectx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEID):
+			rc = cpic->ops->cmeid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMEMBS):	/* No Cvid */
+			rc = cpic_cmembs((__u32 *)args->a1);
+			break;
+
+		case (CM_CMEMN):
+			rc = cpic->ops->cmemn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEPID):
+			rc = cpic->ops->cmepid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6, (__u32 *)args->a7);
+			break;
+
+		case (CM_CMEPLN):
+			rc = cpic->ops->cmepln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMESI):
+			rc = cpic->ops->cmesi(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMESL):
+			rc = cpic->ops->cmesl(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMESRM):
+			rc = cpic->ops->cmesrm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMESUI):
+			rc = cpic->ops->cmesui(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMETC):
+			rc = cpic->ops->cmetc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMETPN):
+			rc = cpic->ops->cmetpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMFLUS):
+			rc = cpic->ops->cmflus(cpic);
+			break;
+
+		case (CM_CMINCL):
+			rc = cpic->ops->cmincl(cpic);
+			break;
+
+		case (CM_CMINIC):
+			rc = cpic->ops->cminic(cpic);
+			break;
+
+		case (CM_CMINIT):	/* No Cvid */
+			rc = cpic_cminit(conversation_id, (__u8 *)args->a1);
+			break;
+
+		case (CM_CMPREP):
+			rc = cpic->ops->cmprep(cpic);
+			break;
+
+		case (CM_CMPTR):
+			rc = cpic->ops->cmptr(cpic);
+			break;
+
+		case (CM_CMRCV):
+			rc = cpic->ops->cmrcv(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5,
+				(__u32 *)args->a6);
+			break;
+
+		case (CM_CMRCVX):
+			rc = cpic->ops->cmrcvx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5);
+			break;
+
+		case (CM_CMRLTP):	/* No Cvid */
+			break;
+
+		case (CM_CMRTS):
+			rc = cpic->ops->cmrts(cpic);
+			break;
+
+		case (CM_CMSAC):
+			rc = cpic->ops->cmsac(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSACN):
+			rc = cpic->ops->cmsacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSAEQ):
+			rc = cpic->ops->cmsaeq(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSAPT):
+			rc = cpic->ops->cmsapt(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSBT):
+			rc = cpic->ops->cmsbt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCSP):
+			rc = cpic->ops->cmscsp(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSCST):
+			rc = cpic->ops->cmscst(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCSU):
+			rc = cpic->ops->cmscsu(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSCT):
+			rc = cpic->ops->cmsct(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCU):
+			rc = cpic->ops->cmscu(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSDT):
+			rc = cpic->ops->cmsdt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSED):
+			rc = cpic->ops->cmsed(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSEND):
+			rc = cpic->ops->cmsend(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSERR):
+			rc = cpic->ops->cmserr(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSF):
+			rc = cpic->ops->cmsf(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSID):
+			rc = cpic->ops->cmsid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSLD):
+			rc = cpic->ops->cmsld(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSLTP):	/* No Cvid */
+			break;
+
+		case (CM_CMSMN):
+			rc = cpic->ops->cmsmn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSNDX):
+			rc = cpic->ops->cmsndx(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSPDP):
+			rc = cpic->ops->cmspdp(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSPID):
+			rc = cpic->ops->cmspid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6);
+			break;
+
+		case (CM_CMSPLN):
+			rc = cpic->ops->cmspln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSPM):
+			rc = cpic->ops->cmspm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSPTR):
+			rc = cpic->ops->cmsptr(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSQCF):
+			rc = cpic->ops->cmsqcf(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMSQPM):
+			rc = cpic->ops->cmsqpm(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMSRC):
+			rc = cpic->ops->cmsrc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSRT):
+			rc = cpic->ops->cmsrt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSSL):
+			rc = cpic->ops->cmssl(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSSRM):
+			rc = cpic->ops->cmssrm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSST):
+			rc = cpic->ops->cmsst(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSTC):
+			rc = cpic->ops->cmstc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSTPN):
+			rc = cpic->ops->cmstpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMTRTS):
+			rc = cpic->ops->cmtrts(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMWAIT):
+			rc = cpic->ops->cmwait(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMWCMP):	/* No Cvid */
+			break;
+
+		default:
+			rc = CM_PROGRAM_PARAMETER_CHECK;
+			goto out;
+	}
+
+out:
+	cpic_error(return_code, rc);
+	return;
+}
+
+int cpic_register(struct cpic_ops *ops)
+{
+	int err;
+
+	if(ops->family >= NPROTO)
+	{
+		printk(KERN_CRIT "cpic protocol %d >= NPROTO(%d)\n", ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+	err = -EEXIST;
+	if(cpic_client_ops[ops->family] == NULL)
+	{
+		cpic_client_ops[ops->family] = ops;
+		err = 0;
+	} 
+
+	register_filesystem(&cpic_fs_type);
+        cpic_mnt = kern_mount(&cpic_fs_type);
+
+	return (err);
+}
+
+int cpic_unregister(int family)
+{
+	struct cpic_side_info *cpic;
+
+	if(family < 0 || family >= NPROTO)
+		return (-1);
+
+        for(cpic = cpic_side_list; cpic != NULL; cpic = cpic->next)
+		kfree(cpic);
+	cpic_side_list = NULL;
+
+	cpic_client_ops[family] = NULL;
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct cpic_side_info *side;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-18s%-18s%-9s%-10s%-s\n",
+                "netid.node", "netid.plu", "sym_name", "mode_name", "tp_name");
+
+        for(side = cpic_side_list; side != NULL; side = side->next)
+        {
+                len += sprintf(buffer + len, "%-18s", 
+			pr_netid((struct netid *)&side->netid));
+                len += sprintf(buffer + len, "%-18s",
+			pr_netid((struct netid *)&side->netid_plu));
+                len += sprintf(buffer + len, "%-9s", side->sym_dest_name);
+		len += sprintf(buffer + len, "%-10s", side->mode_name);
+		len += sprintf(buffer + len, "%-s\n", side->tp_name);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+#endif	/* CONFIG_PROC_FS */
diff -ruN linux-2.4.13/net/netsyms.c linux/net/netsyms.c
--- linux-2.4.13/net/netsyms.c	Tue Sep 18 13:39:51 2001
+++ linux/net/netsyms.c	Sat Nov  3 13:18:54 2001
@@ -53,6 +53,12 @@
 #include <linux/mroute.h>
 #include <linux/igmp.h>
 
+#include <net/cpic.h>
+
+/* linux-SNA attach */
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+
 extern struct net_proto_family inet_family_ops;
 
 #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE) || defined (CONFIG_KHTTPD) || defined (CONFIG_KHTTPD_MODULE)
@@ -157,6 +163,15 @@
 EXPORT_SYMBOL(put_cmsg);
 EXPORT_SYMBOL(sock_kmalloc);
 EXPORT_SYMBOL(sock_kfree_s);
+
+EXPORT_SYMBOL(cpic_register_side_info);
+EXPORT_SYMBOL(cpic_unregister_side_info);
+EXPORT_SYMBOL(cpic_query_side_info);
+EXPORT_SYMBOL(cpic_get_info_side);
+EXPORT_SYMBOL(cpic_register);
+EXPORT_SYMBOL(cpic_unregister);
+EXPORT_SYMBOL(attach_register);
+EXPORT_SYMBOL(attach_unregister);
 
 #ifdef CONFIG_FILTER
 EXPORT_SYMBOL(sk_run_filter);
diff -ruN linux-2.4.13/net/sna/Config.in linux/net/sna/Config.in
--- linux-2.4.13/net/sna/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/Config.in	Wed Nov  7 10:53:55 2001
@@ -0,0 +1,12 @@
+#
+# Linux-SNA Configuration
+#
+
+bool '  SNA: IEEE 802.2 device support' CONFIG_SNA_LLC
+bool '  SNA: Loopback device support' CONFIG_SNA_LOOPBACK
+bool '  SNA: ATM device support (EXPERIMENTAL)' CONFIG_SNA_ATM
+bool '  SNA: IBM compliant channel device support (EXPERIMENTAL)' CONFIG_SNA_CHANNEL
+bool '  SNA: SDLC device support (EXPERIMENTAL)' CONFIG_SNA_SDLC
+bool '  SNA: X.25 device support (EXPERIMENTAL)' CONFIG_SNA_X25
+bool '  SNA: TwinAxial device support (EXPERIMENTAL)' CONFIG_SNA_TWINAX
+bool '  SNA: Coaxial device supprt (EXPERIMENTAL)' CONFIG_SNA_COAX
diff -ruN linux-2.4.13/net/sna/Makefile linux/net/sna/Makefile
--- linux-2.4.13/net/sna/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/Makefile	Wed Nov  7 10:53:46 2001
@@ -0,0 +1,27 @@
+#
+# Makefile for the Linux Systems Network Architecture layer.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := sna.o
+
+export-objs := af_sna.o 
+
+obj-y := af_sna.o sna_ebcdic.o sna_nof.o sna_cs.o sna_asm.o sna_cosm.o \
+	    sna_ds.o sna_isr.o sna_pc.o sna_rss.o sna_ss.o sna_tdm.o \
+	    sna_dlc.o sna_trs.o sna_rm.o sna_sm.o \
+	    sna_hsr.o sna_tc.o sna_dfc.o sna_appc.o sna_attach.o \
+	    sna_cpic.o sna_ps_main.o sna_ps_conv.o sna_ps_copr.o sna_ps_mc.o \
+	    sna_ps_sync.o
+obj-m := $(O_TARGET)
+
+obj-$(CONFIG_SYSCTL) += sysctl_net_sna.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+		tar -cvf /dev/f1 .
diff -ruN linux-2.4.13/net/sna/af_sna.c linux/net/sna/af_sna.c
--- linux-2.4.13/net/sna/af_sna.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/af_sna.c	Wed Nov  7 11:02:29 2001
@@ -0,0 +1,697 @@
+/* af_sna.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/ctype.h>
+
+#include <linux/sna.h>
+#include <linux/cpic.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <linux/llc.h>
+#include <net/llc.h>
+#endif
+
+#ifdef CONFIG_SYSCTL
+extern inline void sna_register_sysctl(void);
+extern inline void sna_unregister_sysctl(void);
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_net_sna = NULL;
+#endif
+
+static struct proto_ops sna_ops;
+
+char sna_version[] = "1.00pre14";
+char sna_maintainer[] = "Jay Schulist <jschlst@samba.org>";
+char sna_product_id[] = "WiskClean";
+char sna_product_name[] = "Linux-SNA";
+
+__u32	sysctl_max_link_stations_cnt;
+__u32	sysctl_max_lu_cnt;
+__u32	sysctl_max_mode_cnt;
+__u32	sysctl_max_inbound_activations;
+__u32	sysctl_max_outbound_activations;
+__u32	sysctl_max_retry_limit;
+__u32	sysctl_max_btu_size;
+__u32	sysctl_max_tx_ru_size;
+__u32	sysctl_max_rx_ru_size;
+__u32	sysctl_max_auto_activation_limit;
+__u32	sysctl_bind_pacing_cnt;
+__u32	sna_debug_level = 0;
+
+#define MAX_SNA_ADDR		1024
+
+/* Display an Ethernet address in readable format. */
+char *sna_pr_ether(unsigned char *ptr)
+{
+  	static char buff[64];
+
+  	sprintf(buff, "%02X%02X%02X%02X%02X%02X",
+        	(ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+        	(ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377));
+  	return(buff);
+}
+
+char *sna_pr_nodeid(struct sna_nodeid *n)
+{
+        static char buff[20];
+
+        sprintf(buff, "%03X%05X", n->block_id, n->pu_id);
+
+        return (buff);
+}
+
+/* display a padded netid correctly */
+char *sna_pr_netid(struct sna_netid *n)
+{
+        struct sna_netid p;
+	char *buff;
+        int i;
+
+	buff = (char *)kmalloc(20, GFP_ATOMIC);
+        memcpy(&p, n, sizeof(struct sna_netid));
+        for(i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for(i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+
+        return (buff);
+}
+
+int sna_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_SNA_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_SNA_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+                if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+struct sna_netid *sna_char_to_netid(unsigned char *b)
+{
+        struct sna_netid *n;
+	unsigned char c[40];
+        int i;
+
+	sna_debug(5, "sna_char_to_netid %s\n", b);
+	strcpy(c, b);	/* always use protection */
+        n = (struct sna_netid *)kmalloc(sizeof(struct sna_netid), GFP_KERNEL);
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for(i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for(i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for(i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+	for(i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return (n);
+} 
+
+int sna_netid_to_char(struct sna_netid *n, unsigned char *c)
+{
+	int len = 0, i;
+
+	sna_debug(5, "sna_netid_to_char %s.%s\n", n->net, n->name);
+	for(i = 0; i < 8 && (n->net[i] != 0x20); i++)
+		/* Nothing */ ;
+	len = i;
+	strncpy(c, n->net, i);
+	len = i + 1;
+	strncpy(c + i, ".", 1);
+	for(i = 0; i < 8 && (n->name[i] != 0x20); i++)
+		/* Nothing */ ;
+	strncpy(c + len, n->name, i);
+	len += i;
+	strncpy(c + len, "\0", 1);
+	sna_debug(5, "finished string is (%s) length is (%d) (%d)\n",
+		c, strlen(c), len);
+
+	return (len);
+}
+
+/* Temporary HexDump function. */
+int hexdump(unsigned char *pkt_data, int pkt_len)
+{
+        int i;
+
+        while(pkt_len>0)
+        {
+                printk("  ");   /* Leading spaces. */
+
+                /* Print the HEX representation. */
+                for(i=0; i<8; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i] & 0xFF);
+                        else
+                                printk("  ");
+                }
+
+                printk(":");
+
+                for(i=8; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i]&0xFF);
+                        else
+                                printk("  ");
+                }
+
+                /* Print the ASCII representation. */
+                printk("  ");
+
+                for(i=0; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                        {
+                                if(isprint(pkt_data[i]))
+                                        printk("%c", pkt_data[i]);
+                                else
+                                        printk(".");
+                        }
+                }
+
+                printk("\n");
+                pkt_len -= 16;
+                pkt_data += 16;
+        }
+
+        printk("\n");
+
+	return (0);
+}
+
+/* Create a SNA socket. */
+static int sna_create(struct socket *sock, int protocol)
+{
+	struct sock *sk = sock->sk;
+
+	sna_debug(5, "sna_create\n");
+	sk = sk_alloc(PF_SNA, GFP_KERNEL, 1);
+	if(sk == NULL)
+		return (-ENOMEM);
+
+	switch(sock->type)
+	{
+		case (SOCK_STREAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_DGRAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_RAW):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_SEQPACKET):
+			sock->ops = &sna_ops;
+			break;
+
+		default:
+			sk_free((void *)sk);
+			return (-ESOCKTNOSUPPORT);
+	}
+
+	MOD_INC_USE_COUNT;
+
+	sock_init_data(sock, sk);
+
+	sk->destruct = NULL;
+        sk->zapped = 1;
+
+        return (0);
+}
+
+static int sna_destroy_socket(struct sock *sk)
+{
+	sna_debug(5, "sna_destroy_socket\n");
+
+	MOD_DEC_USE_COUNT;
+
+	return (0);
+}
+
+static int sna_release(struct socket *sock)
+{
+	struct sock *sk=sock->sk;
+
+	sna_debug(5, "sna_release\n");
+
+        if(sk == NULL)
+                return (0);
+
+        if(!sk->dead)
+                sk->state_change(sk);
+
+        sk->dead = 1;
+        sock->sk = NULL;
+	sna_destroy_socket(sk);
+
+	return (0);
+}
+
+static int sna_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	return (0);
+}
+
+static int sna_connect(struct socket *sock, struct sockaddr *uaddr,
+	int addr_len, int flags)
+{
+	return (0);
+}
+
+static int sna_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return (0);
+}
+
+static unsigned int sna_poll(struct file * file, struct socket *sock,
+	poll_table *pt)
+{
+	return (0);
+}
+
+static int sna_getname(struct socket *sock, struct sockaddr *uaddr,
+	int *uaddr_len, int peer)
+{
+	return (0);
+}
+
+static int sna_transmit(struct sock *sk, struct sk_buff *skb, int size)
+{
+	sna_debug(5,"SNA tx'd packet!/n");
+
+	kfree_skb(skb);
+
+	return (0);
+}
+
+/* This is the Linux frontend to the SNA transmit code.
+ * For now this is just a fake sendmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */ 
+static int sna_sendmsg(struct socket *sock, struct msghdr *msg, int size,
+	struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+        int flags = msg->msg_flags;
+        struct sk_buff *skb;
+	int err;
+
+	if(size > 10000)	/* Fake max. */
+		return (-EMSGSIZE);
+	if(flags&~MSG_DONTWAIT)
+                return (-EINVAL);
+
+	cli();
+        skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &err);
+        if(skb == NULL)
+                return (err);
+        sti();
+
+        skb->sk = sk;
+
+	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+        if(err)
+        {
+                kfree_skb(skb);
+                return (-EFAULT);
+        }
+
+	err = sna_transmit(sk, skb, size);
+	if(err)
+		return (-EAGAIN);
+
+	return (size);
+}
+
+#ifdef NOT
+static int sna_rcv(struct sk_buff *skb, struct net_device *dev, 
+	struct packet_type *pt)
+{
+	sna_debug(5, "SNA rx'd packet!\n");
+
+	kfree_skb(skb);
+
+	return (0);
+}
+#endif
+
+/* This function is the Linux frontend to the SNA receive code.
+ * For now this is just a fake recvmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */
+static int sna_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+	int flags, struct scm_cookie *scm)
+{
+	return (-EINVAL);
+	return (0);
+}
+
+static int sna_shutdown(struct socket *sk, int how)
+{
+	return (-EOPNOTSUPP);
+}
+
+/* SNA ioctl calls. */
+static int sna_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd)
+	{
+		case (SIOCGNODE):
+		case (SIOCGDLC):
+		case (SIOCGPORT):
+		case (SIOCGLS):
+		case (SIOCGMODE):
+		case (SIOCGLU):
+		case (SIOCGPLU):
+		case (SIOCGCOS):
+			return (sna_nof_ioctl(cmd, (void *)arg));
+
+		case (SIOCGCPICS):
+			return (sna_cpic_ioctl(cmd, (void *)arg));
+
+#ifdef NOT
+		case (SIOPS):
+			return (sna_ps_ioctl(cmd, (void *)arg));
+#endif
+
+		default:
+			return (-EOPNOTSUPP);
+	}
+
+	return (0);
+}
+
+static int sna_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+	sna_debug(5, "sna_setsockopt\n");
+
+        switch(level)
+        {
+		case (SOL_SNA_NOF):
+			err = sna_nof_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef NOT
+		case (SOL_SNA_PS):
+			err = sna_ps_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		case (SOL_SNA_CPIC):
+			err = sna_cpic_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+		default:
+			return (-ENOPROTOOPT);
+	}
+
+	return (err);
+}
+
+static int sna_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+	int err;
+
+	sna_debug(5, "sna_getsockopt\n");
+
+        switch(level)
+        {
+		case (SOL_SNA_NOF):
+			err = sna_nof_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef NOT
+		case (SOL_SNA_PS):
+			err = sna_ps_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		default:
+			return (-ENOPROTOOPT);
+        }
+
+	return (err);
+}
+
+void sna_mod_inc_use_count(void)
+{
+	MOD_INC_USE_COUNT;
+}
+
+void sna_mod_dec_use_count(void)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static struct net_proto_family sna_family_ops =
+{
+	PF_SNA,
+	sna_create
+};
+
+static struct proto_ops sna_ops =
+{
+	PF_SNA,
+	sna_release,
+	sna_bind,
+	sna_connect,
+	sock_no_socketpair,
+	sna_accept,
+	sna_getname,
+	sna_poll,
+	sna_ioctl,
+	sock_no_listen,
+	sna_shutdown,
+	sna_setsockopt,		/* Okay. */
+	sna_getsockopt,		/* Okay. */
+	sna_sendmsg,
+	sna_recvmsg,
+	sock_no_mmap
+};
+
+#ifdef CONFIG_PROC_FS
+static void sna_proc_init(void)
+{
+        if(!proc_net_sna)
+        {
+                struct proc_dir_entry *ent;
+                ent = proc_mkdir("net/sna", 0);
+                if(ent)
+                {
+                        ent->owner = THIS_MODULE;
+                        proc_net_sna = ent;
+                }
+        }
+}
+
+static void sna_proc_cleanup(void)
+{
+        if(proc_net_sna)
+        {
+                proc_net_sna = NULL;
+                remove_proc_entry("net/sna", 0);
+        }
+}
+
+inline struct proc_dir_entry *proc_sna_create(const char *name,
+        mode_t mode, get_info_t *get_info)
+{
+        return create_proc_info_entry(name,mode,proc_net_sna,get_info);
+}
+
+inline void proc_sna_remove(const char *name)
+{
+        remove_proc_entry(name,proc_net_sna);
+}
+#endif
+
+/* Watch the network devices to see if we need to add/delete/start/stop
+ * a data link control. (Device)
+ */
+int sna_netdev_event(struct notifier_block *self, unsigned long event,
+        void *data)
+{
+        struct net_device *dev = (struct net_device *)data;
+
+        if(event == NETDEV_UP)
+                sna_nof_define_dlc(dev);
+        if(event == NETDEV_DOWN)
+                sna_nof_delete_dlc(dev);
+
+        return (NOTIFY_DONE);
+}
+
+struct notifier_block nb_sna =
+{
+        sna_netdev_event,
+        NULL,
+        0
+};
+
+int __init sna_init(void)
+{
+	struct net_device *dev;
+
+	/* Scan all the existing interfaces for SNA
+         * compatible devices, add the device to our list if it
+         * is available for sna transfers.
+         */
+        rtnl_lock();
+        for(dev = dev_base; dev != NULL; dev = dev->next)
+        {
+                if(dev->flags & IFF_UP)
+                        sna_nof_define_dlc(dev);
+        }
+        rtnl_unlock();
+
+        /* Attach a device notifier so we can watch for devices
+         * going up and down.
+         */
+        register_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_PROC_FS
+        sna_proc_init();
+	proc_sna_create("virtual_nodes", 0, sna_nof_get_info);
+	proc_sna_create("devices", 0, sna_cs_get_info_dlc);
+	proc_sna_create("ports", 0, sna_cs_get_info_port);
+	proc_sna_create("link_stations", 0, sna_cs_get_info_ls);
+	proc_sna_create("modes", 0, sna_rm_get_info_mode);
+
+	proc_sna_create("local_lus", 0, sna_rm_get_info_local_lu);
+	proc_sna_create("remote_lus", 0, sna_rm_get_info_remote_lu);
+
+	proc_sna_create("cpic_side_information", 0, sna_cpic_get_info_side);
+	proc_sna_create("cpic_conversations", 0, sna_cpic_get_info);
+
+	proc_sna_create("cos_levels", 0, sna_cosm_get_info);
+	proc_sna_create("cos_tg_characteristics", 0, sna_cosm_get_info_tg);
+	proc_sna_create("cos_node_characteristics", 0, sna_cos_get_info_node);
+
+	proc_sna_create("node_map", 0, sna_tdm_get_info);
+	proc_sna_create("transmission_groups", 0, sna_tdm_get_info_tg);
+
+	proc_sna_create("path_controls", 0, sna_pc_get_info_tg);
+
+	proc_sna_create("asm_active_address_space", 0, sna_asm_get_info);
+	proc_sna_create("asm_active_lfsids", 0, sna_asm_get_active_lfsids);
+#endif
+
+        printk(KERN_INFO "Linux-SNA (System Network Architecture) "
+		"v%s for Linux NET4.0\n", sna_version);
+
+	(void) sock_register(&sna_family_ops);
+
+#ifdef CONFIG_SYSCTL
+        sna_register_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+        return (0);
+}
+
+void __exit sna_exit(void)
+{
+	/* Remove out notifier from the netdevice layer. */
+        unregister_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_SYSCTL
+        sna_unregister_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+	proc_sna_remove("cpic_conversations");
+	proc_sna_remove("cpic_side_information");
+	proc_sna_remove("remote_lus");
+	proc_sna_remove("local_lus");
+	proc_sna_remove("modes");
+	proc_sna_remove("link_stations");
+	proc_sna_remove("ports");
+	proc_sna_remove("devices");
+	proc_sna_remove("virtual_nodes");
+        sna_proc_cleanup();
+#endif
+
+	sock_unregister(PF_SNA);
+
+        return;
+}
+
+EXPORT_SYMBOL(hexdump);
+EXPORT_SYMBOL(sna_utok);
+EXPORT_SYMBOL(sna_ktou);
+
+module_init(sna_init);
+module_exit(sna_exit);
+#endif /* CONFIG_SNA || CONFIG_SNA_MODULE */
diff -ruN linux-2.4.13/net/sna/sna_appc.c linux/net/sna/sna_appc.c
--- linux-2.4.13/net/sna/sna_appc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_appc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,41 @@
+/* sna_appc.c: Linux Systems Network Architecture implementation
+ * - SNA Advanced Program to Program Communications (APPC).
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
diff -ruN linux-2.4.13/net/sna/sna_asm.c linux/net/sna/sna_asm.c
--- linux-2.4.13/net/sna/sna_asm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_asm.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,341 @@
+/* sna_asm.c: Linux Systems Network Architecture implementation
+ * - Linux-SNA Address Space Manager (Connect HS to PC).
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_asm_pinfo *asm_clients = NULL;
+
+/* Display a Path Control ID */
+char *sna_asm_pr_pcid(unsigned char *ptr)
+{
+        static char buff[64];
+
+        sprintf(buff, "%02X%02X%02X%02X%02X%02X%02X%02X",
+                (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+                (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377),
+                (ptr[6] & 0377), (ptr[7] & 0377));
+        return(buff);
+}
+
+struct sna_asm_pinfo *sna_asm_find_by_pcid(unsigned char *pc_id)
+{
+	struct sna_asm_pinfo *a;
+
+	sna_debug(5, "sna_asm_find_by_pcid\n");
+	for(a = asm_clients; a != NULL; a = a->next)
+		if(!memcmp(&a->pc_id, pc_id, 8))
+			return (a);
+
+	return (NULL);
+}
+
+struct sna_lfsid_block *sna_asm_find_lblk_by_lfsid(struct sna_lfsid *lfsid)
+{
+        struct sna_asm_pinfo *a;
+        struct sna_lfsid_block *l;
+	int i;
+
+	sna_debug(5, "sna_asm_find_lfsid_by_lfsid\n");
+        for(a = asm_clients; a != NULL; a = a->next)
+                for(l = a->l_blks; l != NULL; l = l->next)
+			for(i = 0; i < 256; i++)
+                        	if(!memcmp(lfsid, &l->l[i].lfsid, 
+					sizeof(struct sna_lfsid)))
+                                	return (l);
+        return (NULL);
+}
+
+int sna_asm_activate_as(struct sna_activate_as *as)
+{
+	struct sna_asm_pinfo *a;
+
+	sna_debug(5, "sna_asm_activate_asm\n");
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if(a)
+		return (-EEXIST);
+
+	a = (struct sna_asm_pinfo *)kmalloc
+		(sizeof(struct sna_asm_pinfo), GFP_ATOMIC);
+	memcpy(&a->pc_id, &as->pc_id, 8);
+	a->intranode			= as->intranode;
+	a->odai				= as->odai;
+	a->max_btu			= as->max_btu;
+	a->tx_rx_bind_pacing		= as->tx_rx_bind_pacing;
+	a->dependent_lulu		= as->dependent_lulu;
+	a->adp_bind_pacing_dep_lulu	= as->adp_bind_pacing_dep_lulu;
+	a->generalized_oadi		= as->generalized_oadi;
+	a->next				= asm_clients;
+	asm_clients			= a;
+	kfree(as);
+
+        return (0);
+}
+
+int sna_asm_deactivate_as(unsigned char *pc_id)
+{
+	struct sna_asm_pinfo *a, **clients = &asm_clients;
+
+	sna_debug(5, "sna_asm_deactivate_as\n");
+        while((a = *clients) != NULL)
+        {
+		if(!memcmp(&a->pc_id, pc_id, 8))
+                {
+                        *clients = a->next;
+                        kfree(a);
+                        return (0);
+                }
+                clients = &a->next;
+        }
+
+        return (-ENOENT);
+}
+
+/* Locate address space, look for a free lfsid, if not in any of the
+ * existing blocks, then allocate a new block, return a fresh lfsid.
+ */
+int sna_asm_assign_lfsid(struct sna_assign_lfsid *as)
+{
+	struct sna_asm_pinfo *a;
+	struct sna_lfsid_block *l;
+	int i, blk_num = 0;
+
+	sna_debug(5, "sna_asm_assign_lfsid (%s)\n", sna_asm_pr_pcid(as->pc_id));
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if(!a)
+		return (-ENOENT);
+
+restart:
+	/* search for a free lfsid */
+	for(l = a->l_blks; l != NULL; l = l->next)
+	{
+		blk_num++;
+		for(i = 0; i < 256; i++)
+		{
+			if(l->l[i].active)	/* lfsid is in use */
+				continue;
+
+			/* found a non-active lfsid */
+			l->l[i].active 		= 1;
+			l->l[i].sm_id		= as->sm_id;
+
+			/* We dynamicly assign the lfsid on request */
+			l->l[i].lfsid.odai	= a->odai;
+			l->l[i].lfsid.sid.raw	= ((blk_num * 256) - 256) + i;
+			memcpy(&as->lfsid, &l->l[i].lfsid, 
+				sizeof(struct sna_lfsid));
+			return (0);
+		}
+	}
+
+	/* could not find any non-active lfsids in already alloc'd blocks */
+	l = (struct sna_lfsid_block *)kmalloc(sizeof(struct sna_lfsid_block),
+		GFP_ATOMIC);
+	if(!l)
+		return (-ENOMEM);
+	memset(&l, 0, sizeof(struct sna_lfsid_block));
+	l->next		= a->l_blks;
+	a->l_blks 	= l;
+	a->blk_count++;
+	goto restart;	/* just added 256 addresses, lets try it again */
+}
+
+int sna_asm_free_lfsid(struct sna_free_lfsid *f)
+{
+	struct sna_asm_pinfo *a;
+        struct sna_lfsid_block *l;
+        int i;
+
+	sna_debug(5, "sna_asm_free_lfsid (%s)\n", sna_asm_pr_pcid(f->pc_id));
+        a = sna_asm_find_by_pcid(f->pc_id);
+        if(!a)
+                return (-ENOENT);
+
+	/* locate the lfsid */
+        for(l = a->l_blks; l != NULL; l = l->next)
+        {
+		for(i = 0; i < 256; i ++)
+		{
+			if(l->l[i].active && (l->l[i].sm_id == f->sm_id)
+				&& (l->l[i].lfsid.odai == f->lfsid.odai)
+				&& (l->l[i].lfsid.sid.raw == f->lfsid.sid.raw))
+			{
+				l->l[i].active 	= 0;
+				l->l[i].sm_id	= 0;
+				memset(&l->l[i].lfsid, 0, 
+					sizeof(struct sna_lfsid));
+				return (0);
+			}
+		}
+	}
+
+	return (-ENOENT);
+}
+
+int sna_asm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_asm_create %s\n", start->netid.name);
+
+        return (0);
+}
+
+int sna_asm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_asm_pinfo *a;
+	struct sna_lfsid_block *l;
+
+	sna_debug(5, "sna_asm_destroy\n");
+	for(a = asm_clients; a != NULL; a = a->next)
+	{
+		for(l = a->l_blks; l != NULL; l = l->next)
+			kfree(l);
+		kfree(a);
+	}
+
+        return (0);
+}
+
+/* receive and process bind data */
+int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	struct sna_lfsid_block *l;
+
+	sna_debug(5, "sna_asm_rcv_bind\n");
+	l = sna_asm_find_lblk_by_lfsid(lfsid);
+	if(!l)
+	{
+		kfree(lfsid);
+		kfree_skb(skb);
+		return (-ENOENT);
+	}
+
+	/* for now we kinda cheat and just send to sm rightaway... */
+	sna_sm_process_mu(skb, l);
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_asm_pinfo *a;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-9s%-8s%-6s%-5s%-6s%-9s%-8s%-9s\n", 
+		"pc_id", "max_btu", "intra", "odai", "godai", 
+		"dep_lulu", "bpacing", "dbpacing");
+
+        for(a = asm_clients; a != NULL; a = a->next)
+        {
+                len += sprintf(buffer + len, "%9s%8d%6d%5d%6d%9d%8d%9d",
+			sna_asm_pr_pcid(a->pc_id), a->max_btu, a->intranode,
+			a->odai, a->generalized_oadi, a->dependent_lulu,
+			a->tx_rx_bind_pacing, a->adp_bind_pacing_dep_lulu);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_asm_pinfo *a;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%-6s%-6s%-5s%-6s%-5s\n", 
+		"pc_id", "intra", "sm_id", "odai", "sidh", "sidl");
+
+        for(a = asm_clients; a != NULL; a = a->next)
+        {
+		struct sna_lfsid_block *l;
+
+		for(l = a->l_blks; l != NULL; l = l->next)
+		{
+			int i;
+			for(i = 0; i < 256; i++)
+			{
+				if(l->l[i].active)
+				{
+                			len += sprintf(buffer + len, 
+						"%9s%6d%6d%5d%6d%5d\n",
+						sna_asm_pr_pcid(a->pc_id),
+						a->intranode,
+						l->l[i].sm_id,
+						l->l[i].lfsid.odai,
+						l->l[i].lfsid.sid.hl.sidh,
+						l->l[i].lfsid.sid.hl.sidl);
+				}
+			}
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.13/net/sna/sna_attach.c linux/net/sna/sna_attach.c
--- linux-2.4.13/net/sna/sna_attach.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_attach.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,134 @@
+/* sna_attach.c: Linux Systems Network Architecture implementation
+ * - SNA Attach Manager Kernel Backend.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+struct sk_buff_head attach_queue;
+wait_queue_head_t attach_wait;
+
+int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_attach_execute_tp\n");
+	memcpy(&skb->cb, &tcb_id, sizeof(unsigned long));
+	skb_queue_head(&attach_queue, skb);
+	wake_up_interruptible(&attach_wait);
+
+	return (0);
+}
+
+int sna_attach_tp_correlate(pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_attach_tp_correlate %d %ld\n", pid, tcb_id);
+	tcb = sna_cpic_find_tcb_by_id(tcb_id);
+	if(!tcb)
+		return (-1);
+	tcb->pid = pid;
+
+	return (0);
+}
+
+/* Get an attach from the SNA stack, then pass it to a manager. */
+int sna_attach_listen(struct attach *at, void *buf, int len)
+{
+	struct sk_buff *skb;
+	struct fmhdr *fm;
+	struct tp_attach tp;
+	__u8 tp_len;
+	__u8 *ptr;
+
+	sna_debug(5, "sna_attach_listen\n");
+
+restart:
+        while(skb_queue_empty(&attach_queue))      /* No data */
+        {
+		/* handle signals */
+                if(signal_pending(current))
+			return (-ERESTARTSYS);
+
+                if(skb_peek(&attach_queue) == NULL)
+                        interruptible_sleep_on(&attach_wait);
+        }
+
+        skb = skb_dequeue(&attach_queue);
+        if(skb == NULL)
+                goto restart;
+
+	fm = skb->f.fm;
+	ptr = &fm->fm.f5.raw;
+	memcpy(&tp_len, ptr, sizeof(__u8));
+	printk("len of name is %d\n", tp_len);
+	printk("Hex is %02X\n", *ptr);
+	tp.tp_len = tp_len;
+	strncpy(tp.tp_name, ptr + 1, tp_len);
+	memcpy(&tp.tcb_id, &skb->cb, sizeof(unsigned long));
+	printk("TCB ID of the incomming attach id %ld\n", tp.tcb_id);
+
+	if(copy_to_user(buf, &tp, sizeof(tp)))
+		return (-EFAULT);
+
+	kfree_skb(skb);
+	return (sizeof(tp));
+}
+
+static struct attach_ops aops = {
+	PF_SNA,
+	sna_attach_tp_correlate,
+	sna_attach_listen,
+};
+
+int sna_attach_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_attach_create\n");
+        skb_queue_head_init(&attach_queue);
+	init_waitqueue_head(&attach_wait);
+	attach_register(&aops);
+
+	return (0);
+}
+
+int sna_attach_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "sna_attach_destroy\n");
+	attach_unregister(0);
+
+	return (0);
+};
diff -ruN linux-2.4.13/net/sna/sna_cosm.c linux/net/sna/sna_cosm.c
--- linux-2.4.13/net/sna/sna_cosm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cosm.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,569 @@
+/* sna_cosm.c: Linux Systems Network Architecture implementation
+ * - Class-of-Service Manager
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Jay Please Look 00
+ *		  [==]
+ *
+ * o You probably are not handling the BLANK and NULL mode names properly.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_cosm_cb *cosm_list = NULL;
+
+struct sna_cosm_cb *sna_cosm_find(unsigned char *name)
+{
+	struct sna_cosm_cb *c;
+
+	for(c = cosm_list; c != NULL; c = c->next)
+		if(!strncmp(c->name, name, SNA_RESOURCE_NAME_LEN))
+			return (c);
+
+	return (NULL);
+}
+
+struct sna_cosm_tg_cb *sna_cosm_find_tg_weight(struct sna_cosm_cb *c,
+	unsigned short rsn)
+{
+	struct sna_cosm_tg_cb *t;
+
+	for(t = c->tg; t != NULL; t = t->next)
+		if(t->rsn == rsn)
+			return (t);
+	return (NULL);
+}
+
+struct sna_cosm_node_cb *sna_cosm_find_node_weight(struct sna_cosm_cb *c,
+        unsigned short rsn)
+{
+        struct sna_cosm_node_cb *n;
+
+        for(n = c->node; n != NULL; n = n->next)
+                if(n->rsn == rsn)
+                        return (n);
+        return (NULL);
+}
+
+/* Add a COS definition to the table, this function will create a new
+ * entry or update and existing entry.
+ */
+int sna_cosm_define_cos(struct sna_define_cos *cos)
+{
+	struct sna_cosm_cb *c;
+	struct sna_cosm_node_cb *n;
+	struct sna_cosm_tg_cb *t;
+
+	sna_debug(5, "sna_cosm_define_cos %s\n", cos->name);
+	c = sna_cosm_find(cos->name);
+	if(!c)
+	{
+		c = (struct sna_cosm_cb *)kmalloc(sizeof(struct sna_cosm_cb), 
+			GFP_ATOMIC);
+		memset(c, 0, sizeof(struct sna_cosm_cb));
+		strncpy(c->name, cos->name, SNA_RESOURCE_NAME_LEN);
+		c->tg			= NULL;
+		c->node			= NULL;
+		c->prev			= NULL;
+		c->next			= cosm_list;
+		cosm_list		= c;
+	}
+	c->weight               = cos->weight;
+        c->tx_priority          = cos->tx_priority;
+        c->default_cos_invalid  = cos->default_cos_invalid;
+        c->default_cos_null     = cos->default_cos_null;
+
+	/* now append tg cos records */
+	t = sna_cosm_find_tg_weight(c, cos->tg_rsn);
+	if(!t)
+	{
+		t = (struct sna_cosm_tg_cb *)kmalloc(sizeof(struct sna_cosm_tg_cb), GFP_ATOMIC);
+		memset(t, 0, sizeof(struct sna_cosm_tg_cb));
+		t->prev = NULL;
+		t->next	= c->tg;
+		c->tg	= t;
+	}
+	t->rsn				= cos->tg_rsn;
+        t->min_cost_per_connect		= cos->min_cost_per_connect;
+        t->max_cost_per_connect		= cos->max_cost_per_connect;
+        t->min_cost_per_byte		= cos->min_cost_per_byte;
+        t->max_cost_per_byte		= cos->max_cost_per_byte;
+        t->min_security			= cos->min_security;
+        t->max_security			= cos->max_security;
+        t->min_propagation_delay	= cos->min_propagation_delay;
+        t->max_propagation_delay	= cos->max_propagation_delay;
+        t->min_effective_capacity	= cos->min_effective_capacity;
+        t->max_effective_capacity	= cos->max_effective_capacity;
+        t->min_user1			= cos->min_user1;
+        t->max_user1			= cos->max_user1;
+        t->min_user2			= cos->min_user2;
+        t->max_user2			= cos->max_user2;
+        t->min_user3			= cos->min_user3;
+        t->max_user3			= cos->max_user3;
+
+	/* now append node cos records */
+	n = sna_cosm_find_node_weight(c, cos->node_rsn);
+	if(!n)
+	{
+		n = (struct sna_cosm_node_cb *)kmalloc(sizeof(struct sna_cosm_node_cb), GFP_ATOMIC);
+		memset(n, 0, sizeof(struct sna_cosm_node_cb));
+		n->prev = NULL;
+		n->next	= c->node;
+		c->node	= n;
+	}
+	n->rsn				= cos->node_rsn;
+	n->route_resistance		= cos->max_route_resistance;
+	n->node_congested		= cos->max_node_congested;
+//	n->inter_routing_depleted	= cos->inter_routing_depleted;
+
+	return (0);
+}
+
+int sna_cosm_delete_cos(struct sna_delete_cos *cos)
+{
+	struct sna_cosm_cb *c, **clients;
+
+	sna_debug(5, "sna_cosm_delete_cos\n");
+	clients = &cosm_list;
+        while((c = *clients) != NULL)
+        {
+                if(!strcmp(c->name, cos->name))
+                {
+			struct sna_cosm_tg_cb *t;
+			struct sna_cosm_node_cb *n;
+
+                        *clients = c->next;
+			for(t = c->tg; t != NULL; t = t->next)
+				kfree(t);
+			for(n = c->node; n != NULL; n = n->next)
+				kfree(n);
+                        kfree(c);
+                        return (0);
+                }
+                clients = &c->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos)
+{
+	struct sna_cosm_cb *c;
+	int i;
+
+	sna_debug(5, "sna_cosm_cos_tpf_vector\n");
+	c = sna_cosm_find(cos->mode_name);
+	if(!c)
+		return (-ENOENT);
+	memset(&cos->v, 0, sizeof(struct sna_cos));
+	cos->v.type		= 0x2C;
+	cos->v.tx_priority	= c->tx_priority;
+	i = strlen(c->name);
+	memcpy(cos->v.cos_name, c->name, i);
+	for(i = strlen(cos->v.cos_name); i < 8; i++)
+		cos->v.cos_name[i] = 0x40;
+	cos->v.len = sizeof(struct sna_cos);
+
+	return (0);
+}
+
+/* Slick little way to initialize all of the default COS records. */
+struct sna_define_cos cos_defaults[] = {
+	{"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 120, 0, 0, 0, 0, 0x01, 0xFF,
+	0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 180, 0, 128, 0, 128, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCH", 10, SNA_TP_LOW      , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#INTER", 20, SNA_TP_HIGH     , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1}
+};
+
+int sna_cosm_init_default_cos(void)
+{
+	struct sna_cosm_cb *c;
+	int i;
+
+	sna_debug(5, "sna_cosm_init_default_cos\n");
+	for(i = 0; i < 56; i++)
+		sna_cosm_define_cos(&cos_defaults[i]);
+	for(c = cosm_list; c != NULL; c = c->next)
+		sna_debug(5, "cos_name %s\n", c->name);
+
+	return (0);
+}
+
+int sna_cos_ginfo(struct sna_cosm_cb *cos, char *buf, int len)
+{
+	struct cosreq cr;
+	int done = 0;
+
+	sna_debug(10, "sna_cos_ginfo\n");
+	if(!buf)
+        {
+                done += sizeof(cr);
+                return (done);
+        }
+        if(len < (int)sizeof(cr))
+                return done;
+        memset(&cr, 0, sizeof(struct cosreq));
+
+        /* Move the data here */
+	strncpy(cr.name, cos->name, SNA_RESOURCE_NAME_LEN);
+	cr.weight		= cos->weight;
+	cr.tx_priority		= cos->tx_priority;
+	cr.default_cos_invalid	= cos->default_cos_invalid;
+	cr.default_cos_null	= cos->default_cos_null;
+
+	if(copy_to_user(buf, &cr, sizeof(struct cosreq)))
+                return (-EFAULT);
+        buf += sizeof(struct cosreq);
+        len -= sizeof(struct cosreq);
+        done += sizeof(struct cosreq);
+
+        return (done);
+}
+
+int sna_cosm_query_cos(char *arg)
+{
+	struct cosconf cc;
+	struct sna_cosm_cb *cos;
+	char *pos;
+	int len, total;
+
+	sna_debug(5, "sna_cosm_query_cos\n");
+	if(copy_from_user(&cc, arg, sizeof(cc)))
+                return (-EFAULT);
+
+        pos = cc.cosc_buf;
+        len = cc.cos_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(cos = cosm_list; cos != NULL; cos = cos->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = sna_cos_ginfo(cos, NULL, 0);
+                else
+                        done = sna_cos_ginfo(cos, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        cc.cos_len = total;
+	if(copy_to_user(arg, &cc, sizeof(cc)))
+                return (-EFAULT);
+        return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	/* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%5s%5s"
+                "%5s%5s%4s%4s%4s%4s%4s%4s%4s"
+                "%4s%4s%4s%5s%6s\n",
+                "name", "lcpc",
+                "hcpc", "lcpb",
+                "hcpb", "lpd",
+                "hpd", "lec",
+                "lec", "lu1", "hu1",
+                "lu2", "hu2", "lu3", "hu3",
+                "stat", "quisc");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		struct sna_cosm_tg_cb *t;
+
+		for(t = c->tg; t != NULL; t = t->next)
+		{
+			len += sprintf(buffer + len, "%-9s%5d%5d"
+                	"%5d%5d%4d%4d%4d%4d%4d%4d%4d"
+                	"%4d%4d%4d%5d%6d\n",
+			c->name, t->min_cost_per_connect, 
+			t->max_cost_per_connect, t->min_cost_per_byte,
+			t->max_cost_per_byte, t->min_propagation_delay,
+			t->max_propagation_delay, t->min_effective_capacity,
+			t->max_effective_capacity, t->min_user1, t->max_user1,
+			t->min_user2, t->max_user2, t->min_user3, t->max_user3,
+			t->operational, t->quiescing);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%4s%4s%4s%7s%8s%10s\n",
+                "name", "rr", "nc",
+		"ird", "quiesc", "gateway",
+		"directory");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		struct sna_cosm_node_cb *n;
+
+		for(n = c->node; n != NULL; n = n->next)
+		{
+			len += sprintf(buffer + len, "%-9s%4d%4d%4d%7d%8d%10d\n",
+			c->name, n->route_resistance, n->node_congested,
+			n->inter_routing_depleted, n->quiescing, 
+			n->gateway_support, n->central_directory);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%7s%12s%17s%20s\n",
+		"name", "weight", "tx_priority", "default_cos_null",
+		"default_cos_invalid");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		len += sprintf(buffer+len, "%-9s%7d%12d%17d%20d\n",
+		c->name, c->weight, c->tx_priority, c->default_cos_null,
+		c->default_cos_invalid);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+int sna_cosm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_cosm_create\n");
+	sna_cosm_init_default_cos();
+
+	return (0);
+}
+
+int sna_cosm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_cosm_cb *c;
+
+	sna_debug(5, "sna_cosm_destroy\n");
+
+	for(c = cosm_list; c != NULL; c = c->next)
+	{
+		struct sna_cosm_tg_cb *t;
+                struct sna_cosm_node_cb *n;
+
+                for(t = c->tg; t != NULL; t = t->next)
+	                kfree(t);
+                for(n = c->node; n != NULL; n = n->next)
+                        kfree(n);
+		kfree(c);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_cpic.c linux/net/sna/sna_cpic.c
--- linux-2.4.13/net/sna/sna_cpic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cpic.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,1152 @@
+/* sna_cpic.c: Linux Systems Network Architecture implementation
+ * - SNA CPI Communications (CPI-C) Pure processing backend.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static struct sna_tcb *sna_tcb_clients = NULL;
+static unsigned long tcb_ids = 0;
+
+#define MAX_CPIC_ADDR	1024
+
+struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_id\n");
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %ld\n", tcb->tcb_id, tcb_id);
+		if(tcb->tcb_id == tcb_id)
+			return (tcb);
+	}
+
+	return (NULL);
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_pid(pid_t pid)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_pid %d\n", pid);
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %d\n", tcb->pid, pid);
+		if(tcb->pid == pid)
+			return (tcb);
+	}
+	return (NULL);
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_daf %d\n", daf);
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %d\n", tcb->oaf, daf);
+		if(tcb->oaf == daf)
+			return (tcb);
+	}
+	return (NULL);
+}
+
+struct sna_cpic *sna_cpic_find_client(unsigned long conversation_id)
+{
+	struct sna_cpic *cpic;
+
+	sna_debug(5, "sna_cpic_find_client\n");
+
+/*
+	for(cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next)
+		if(cpic->conversation_id == conversation_id)
+				return (cpic);
+*/
+
+	return (NULL);
+}
+
+int sna_cpic_release_session(struct cpic *cpic)
+{
+	struct sna_tcb *sc = cpic->vi.sna;
+
+	sna_debug(5, "sna_cpic_release_session\n");
+
+	if(sc == NULL)
+		return (0);
+
+	cpic->vi.sna = NULL;
+	kfree(sc);
+
+        return (0);
+}
+
+unsigned long sna_cpic_create_tcb(void)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_create_tcb\n");
+	tcb = (struct sna_tcb *)kmalloc(sizeof(struct sna_tcb), GFP_ATOMIC);
+	tcb->state 	= CM_INIT;
+	tcb->tcb_id	= tcb_ids++;
+	tcb->pid	= 0;
+	init_waitqueue_head(&tcb->sleep);
+	skb_queue_head_init(&tcb->receive_queue);
+	skb_queue_head_init(&tcb->transmit_queue);
+
+	/* Temporary hack to do without PC. */
+	tcb->oaf = 5;
+	tcb->daf = 4;
+
+        tcb->prev        = NULL;
+        tcb->next        = sna_tcb_clients;
+        sna_tcb_clients	 = tcb;
+
+	return (tcb->tcb_id);
+}
+
+int sna_cpic_create_session(struct cpic *cpic, int s)
+{
+	struct sna_tcb *sc;
+
+	sna_debug(5, "sna_cpic_create_session\n");
+	sc = (struct sna_tcb *)kmalloc(sizeof(struct sna_tcb), GFP_ATOMIC);
+	sc->state	= CM_INIT;
+	sc->tcb_id	= tcb_ids++;
+	init_waitqueue_head(&sc->sleep);
+	skb_queue_head_init(&sc->receive_queue);
+	skb_queue_head_init(&sc->transmit_queue);
+
+	if(s)	/* Client, copy TP name  */
+	{
+		sc->tp_name_length = strlen(cpic->side->tp_name);
+		if(sc->tp_name_length > 0)
+			strncpy(sc->tp_name, cpic->side->tp_name, sc->tp_name_length);
+		sc->partner_lu_name_length = sprintf(sc->partner_lu_name, "%s", 
+			sna_pr_netid((struct sna_netid *)&cpic->side->netid_plu));
+
+		sc->mode_name_length = strlen(cpic->side->mode_name);
+		if(sc->mode_name_length > 0)
+			strncpy(sc->mode_name, cpic->side->mode_name,
+				sc->mode_name_length);
+
+		sc->oaf	= 4;
+		sc->daf	= 5;
+	}
+	else
+	{
+		sc->oaf	= 5;
+		sc->daf	= 4;
+	}
+
+
+	cpic->vi.sna 	= sc;
+	sc->prev	= NULL;
+	sc->next	= sna_tcb_clients;
+	sna_tcb_clients	= sc;
+
+        return (0);
+}
+
+__u32 sna_cmsaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ae_len;
+	__u8 ae_title;
+
+	sna_debug(5, "sna_cmsaeq\n");
+	copy_from_user(&ae_len, ae_qualifier_length, sizeof(__u32));
+	copy_from_user(&ae_title, ap_title_format, sizeof(__u8));
+        if((ae_len < 0 || ae_len > 1024)
+		|| (ae_title != CM_DN ))
+//		&& ae_title != CM_INT_DIGITS))
+	{
+                return(CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+        if(copy_from_user(&tcb->ae_qualifier, ae_qualifier, ae_len))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+        tcb->ae_qualifier_length = ae_len;
+	tcb->ae_qualifier_format = ae_title;
+
+        return (CM_OK);
+}
+
+__u32 sna_cmsac(struct cpic *c, __u32 *allocate_confirm)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ap_context_len;
+
+        sna_debug(5, "sna_cmsacn\n");
+	copy_from_user(&ap_context_len,appl_context_name_length,sizeof(__u32));
+        if((ap_context_len < 1 || ap_context_len > 256))
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+        if(copy_from_user(&tcb->application_context_name, 
+		application_context_name, ap_context_len))
+	{
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	}
+        tcb->application_context_length = ap_context_len;
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsapt\n");
+	sna_utok(ap_title_length, sizeof(__u32), &cpic->ap_title_length);
+        sna_utok(ap_title_format, sizeof(__u8), &cpic->ap_title_format);
+	if((cpic->ap_title_length < 0 || cpic->ap_title_length > 1024)
+                || (cpic->ap_title_format != CM_DN
+                && cpic->ap_title_format != CM_OID))
+        {
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	if(sna_utok(ap_title, cpic->ap_title_length, cpic->ap_title))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsbt(struct cpic *c, __u32 *begin_transaction)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsbt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_utok(begin_transaction, sizeof(__u8), &cpic->begin_transaction);
+	return (CM_OK);
+}
+
+__u32 sna_cmscsp(struct cpic *c, __u32 *password, __u32 *password_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscst(struct cpic *c, __u32 *conv_security_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscsu(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsct(struct cpic *c, __u32 *conversation_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscu(struct cpic *c, __u32 *confirmation_urgency)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsdt(struct cpic *c, __u32 *deallocate_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsdt\n");
+	if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do error checking on this later */
+	sna_utok(deallocate_type, sizeof(CM_DEALLOCATE_TYPE),
+		&cpic->deallocate_type);
+	switch(cpic->deallocate_type)
+	{
+		case (CM_DEALLOCATE_SYNC_LEVEL):
+			break;
+
+		case (CM_DEALLOCATE_FLUSH):
+			break;
+
+		case (CM_DEALLOCATE_CONFIRM):
+			break;
+
+		case (CM_DEALLOCATE_ABEND):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsed(struct cpic *c, __u32 *error_direction)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsend(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+	struct sk_buff *skb;
+	int err, slen;
+
+	sna_debug(5, "sna_cmsend\n");
+	sna_utok(send_length, sizeof(__u32), &slen);
+
+	skb = alloc_skb(slen + 250, GFP_ATOMIC);
+	skb_reserve(skb, sizeof(struct snarhdr));
+        skb_reserve(skb, sizeof(struct sna_fid2) + 8);
+	err = sna_utok(buffer, slen, skb_put(skb, slen));
+        if(err)
+        {
+                kfree_skb(skb);
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+        }
+
+	hexdump(skb->data, skb->len);
+
+	skb_queue_tail(&tcb->transmit_queue, skb);
+	sna_ps_verb_router(SEND_DATA, tcb);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmrcv(struct cpic *c, __u32 *buffer, __u32 *requested_length,
+	__u32 *data_received, __u32 *received_length, __u32 *status_received,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+        struct sk_buff *skb;
+        int err, copied, rlen;
+	__u32 wr, sr;
+
+	sna_debug(5, "sna_cmrcv\n");
+	sna_ps_verb_router(RECEIVE_AND_WAIT, cpic);
+        skb = skb_dequeue(&cpic->receive_queue);
+        if(skb == NULL)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	printk("got backed in cmrcv !!!!!!!!!\n");
+	hexdump(skb->data, skb->len);
+
+        sna_utok(requested_length, sizeof(__u32), &rlen);
+	wr = CM_DATA_RECEIVED;
+	sna_utok(data_received, sizeof(__u32), &wr);
+	sr = CM_SEND_RECEIVED;
+	sna_utok(status_received, sizeof(__u32), &sr);
+
+        copied  = skb->len;
+        if(copied > rlen)
+        {
+                copied = rlen;
+        }
+
+	err = sna_ktou(&skb->data[9], copied, buffer);
+	if(err)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmserr(struct cpic *c, __u32 *control_information_recevied)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsf(struct cpic *c, __u32 *fill)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsf\n");
+	sna_utok(fill, sizeof(CM_FILL), &cpic->fill);
+	if(cpic->fill != CM_FILL_LL && cpic->fill != CM_FILL_BUFFER)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsid(struct cpic *c, __u32 *initialization_data, 
+	__u32 *init_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsid\n");
+	sna_utok(init_data_length, sizeof(CM_INT32), &cpic->init_data_length);
+	if(cpic->init_data_length < 0 || cpic->init_data_length > 10000)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT && cpic->state != CM_RCV 
+		&& cpic->state != CM_SEND_RCV)
+        {
+		return (CM_PROGRAM_STATE_CHECK);
+        }
+
+	if(sna_utok(initialization_data,cpic->init_data_length,cpic->init_data))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsld(struct cpic *c, __u32 *log_data, __u32 *log_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsld\n");
+	sna_utok(log_data_length, sizeof(CM_INT32), &cpic->log_data_length);
+ 	if(cpic->log_data_length < 0 || cpic->log_data_length > 512)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	if(sna_utok(log_data, cpic->log_data_length, cpic->log_data))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsltp(__u32 *tp, __u32 *tp_name_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsmn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsmn\n");
+	sna_utok(mode_name_length, sizeof(CM_INT32), &cpic->mode_name_length);
+	if(cpic->mode_name_length < 0 || cpic->mode_name_length > 8)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(mode_name, cpic->mode_name_length, cpic->mode_name))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsndx(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspdp(struct cpic *c, __u32 *prepare_data_permitted)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *partner_id_length, __u32 *partner_id_scope, 
+	__u32 *directory_syntax, __u32 *directory_encoding)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspln(struct cpic *c, __u32 *partner_lu_name, 
+	__u32 *partner_lu_name_length)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmspln\n");
+	sna_utok(partner_lu_name_length, sizeof(CM_INT32), 
+		&cpic->partner_lu_name_length);
+	if(cpic->partner_lu_name_length<1 || cpic->partner_lu_name_length>17)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(partner_lu_name, cpic->partner_lu_name_length,
+		cpic->partner_lu_name))
+	{
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmspm(struct cpic *c, __u32 *processing_mode)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsptr(struct cpic *c, __u32 *prepare_to_receive_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsptr\n");
+	if(cpic->state != CM_INIT_INCOMING)	/* Should be just CM_INIT_INCOMING */
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do error checking on this later. */
+	sna_utok(prepare_to_receive_type, sizeof(CM_PREPARE_TO_RECEIVE_TYPE),
+		&cpic->prepare_to_receive_type);
+	switch(cpic->prepare_to_receive_type)
+	{
+		case (CM_PREP_TO_RECEIVE_SYNC_LEVEL):
+			break;
+
+		case (CM_PREP_TO_RECEIVE_FLUSH):
+			break;
+
+		case (CM_PREP_TO_RECEIVE_CONFIRM):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsqcf(struct cpic *c, __u32 *conversation_queue, 
+	__u32 *callback_function, __u32 *callback_info, __u32 *user_field)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmcanc(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmprep(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsqpm(struct cpic *c, __u32 *conversation_queue,
+	__u32 *queue_processing_mode, __u32 *user_field, __u32 *ooid)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsrc(struct cpic *c, __u32 *return_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsrt(struct cpic *c, __u32 *receive_type)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmsrt\n");
+	sna_utok(receive_type, sizeof(CM_RECEIVE_TYPE), &cpic->receive_type);
+	if(cpic->receive_type != CM_RECEIVE_AND_WAIT
+		&& cpic->receive_type != CM_RECEIVE_IMMEDIATE)
+        {
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+
+	return (CM_OK);
+}
+
+__u32 sna_cmssl(struct cpic *c, __u32 *sync_level)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmssl\n");
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Preform some error checking on this later. */
+	sna_utok(sync_level, sizeof(__u32), &cpic->sync_level);
+	switch(cpic->sync_level)
+	{
+		case (CM_NONE):
+			break;
+/*
+		case (CM_CONFIRM):
+			break;
+
+		case (CM_SYNC_POINT):
+			break;
+*/
+		case (CM_SYNC_POINT_NO_CONFIRM):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmssrm(struct cpic *c, __u32 *send_receive_mode)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmssrm\n");
+	sna_utok(send_receive_mode, sizeof(CM_SEND_RECEIVE_MODE), 
+		&cpic->send_receive_mode);
+        if(cpic->send_receive_mode != CM_HALF_DUPLEX 
+		&& cpic->send_receive_mode != CM_FULL_DUPLEX)
+	{
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsst(struct cpic *c, __u32 *send_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsst\n");
+	if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do some error checking on this later. */
+	sna_utok(send_type, sizeof(CM_SEND_TYPE), &cpic->send_type);
+	switch(cpic->send_type)
+	{
+		case (CM_BUFFER_DATA):
+			break;
+
+		case (CM_SEND_AND_FLUSH):
+			break;
+
+		case (CM_SEND_AND_CONFIRM):
+			break;
+
+		case (CM_SEND_AND_PREP_TO_RECEIVE):
+			break;
+
+		case (CM_SEND_AND_DEALLOCATE):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmstc(struct cpic *c, __u32 *transaction_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmstpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmstpn\n");
+	sna_utok(tp_name_length, sizeof(CM_INT32), &cpic->tp_name_length);
+        if(cpic->tp_name_length < 1 || cpic->tp_name_length > 64)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT && cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(tp_name, cpic->tp_name_length, cpic->tp_name))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeaeq\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->ae_qualifier, cpic->ae_qualifier_length, ae_qualifier);
+	sna_ktou(&cpic->ae_qualifier_length, sizeof(cpic->ae_qualifier_length),
+		ae_qualifier_length);
+	sna_ktou(&cpic->ae_qualifier_format, sizeof(cpic->ae_qualifier_format),
+		ap_title_format);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeapt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->ap_title, cpic->ap_title_length, ap_title);
+	sna_ktou(&cpic->ap_title_length, sizeof(cpic->ap_title_length),
+		ap_title_length);
+	sna_ktou(&cpic->ap_title_format, sizeof(cpic->ap_title_format),
+		ap_title_format);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeapt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->application_context_name, 
+		cpic->application_context_length, application_context_name);
+	sna_ktou(&cpic->application_context_length, 
+		sizeof(cpic->application_context_length), 
+		appl_context_name_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmecs(struct cpic *c, __u32 *conversation_state)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmecs\n");
+	sna_ktou(&cpic->state, sizeof(cpic->state), conversation_state);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmect(struct cpic *c, __u32 *conversation_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmectx(struct cpic *c, __u32 *context_id, __u32 *context_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmeid(struct cpic *c, __u32 *initialization_data,
+	__u32 *requested_length, __u32 *initialization_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+	CM_INT32 len;
+	
+        sna_debug(5, "sna_cmeid\n");
+	sna_utok(requested_length, sizeof(CM_INT32), &len);
+ 	if(len < 0)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->init_data, len, initialization_data);
+	sna_ktou(&len, sizeof(len), initialization_data_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmemn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmemn\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->mode_name, cpic->mode_name_length, mode_name);
+	sna_ktou(&cpic->mode_name_length, sizeof(cpic->mode_name_length),
+		mode_name_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmepid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *requested_length, __u32 *partner_id_length, 
+	__u32 *partner_id_scope, __u32 *directory_syntax,
+	__u32 *directory_encoding)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmepln(struct cpic *c, __u32 *partner_lu_name,
+	__u32 *partner_lu_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmepln\n");
+
+/*
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->partner_lu_name, cpic->partner_lu_name_length, 
+		partner_lu_name);
+	sna_ktou(&cpic->partner_lu_name_length, 
+		sizeof(cpic->partner_lu_name_length), partner_lu_name_length);
+*/
+	return (CM_OK);
+}
+
+__u32 sna_cmesi(struct cpic *c, __u32 *call_id, __u32 *buffer,
+	__u32 *requested_length, __u32 *data_received)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesl(struct cpic *c, __u32 *sync_level)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesrm(struct cpic *c, __u32 *send_receive_mode)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesui(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmetc(struct cpic *c, __u32 *transaction_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmetpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmetpn\n");
+
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->tp_name, cpic->tp_name_length, tp_name);
+	sna_ktou(&cpic->tp_name_length, sizeof(cpic->tp_name_length),
+		tp_name_length);
+
+	return (CM_OK);
+}
+
+/* Build SKB, send on for further processing. */
+__u32 sna_cmallc(struct cpic *c)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+
+	sna_debug(5, "sna_cmallc\n");
+	if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ps_verb_router(ALLOCATE, tcb);
+	tcb->state = CM_INIT_INCOMING;
+
+	return (CM_OK);
+}
+
+__u32 sna_cmcfmd(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmcfmd\n");
+
+	return (CM_OK);
+}
+
+__u32 sna_cmdfde(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmacci(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmwait(struct cpic *c, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmflus(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmincl(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmptr(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmrts(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmtrts(struct cpic *c, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cminic(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmcfm(struct cpic *cpic, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmrcvx(struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmdeal(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmdeal\n");
+
+	return (CM_OK);
+}
+
+int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+                         char *optval, int optlen)
+{
+        int err = 0;
+
+        switch(level)
+        {
+                case SOL_SNA_CPIC:
+			switch(optname)
+			{
+				case (CPIC_DEFINE_SIDE):
+				{
+					struct cpic_define_side_info c;
+					if(optlen < sizeof(c))
+						return (-EINVAL);
+					if(copy_from_user(&c, optval,
+						sizeof(c)))
+						return (-EFAULT);
+					err = cpic_register_side_info(&c);
+					break;
+				}
+
+				case (CPIC_DELETE_SIDE):
+				{
+					struct cpic_delete_side_info c;
+					if(optlen < sizeof(c))
+                                                return (-EINVAL);
+                                        if(copy_from_user(&c, optval,
+                                                sizeof(c)))
+                                                return (-EFAULT);
+                                        err = cpic_unregister_side_info(&c);
+					break;
+				}
+
+				default:
+					return (-EINVAL);
+			}
+			break;
+
+		default:
+			return (-EINVAL);
+	}
+
+	return (err);
+}
+
+int sna_cpic_ioctl(int cmd, void *arg)
+{
+        switch(cmd)
+        {
+                case (SIOCGCPICS):
+                        cpic_query_side_info(arg);
+                        break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (0);
+}
+
+static struct cpic_ops sna_cpic_ops = {
+        PF_SNA,
+	sna_cpic_find_tcb_by_pid,
+        sna_cpic_release_session,
+        sna_cpic_create_session,
+	sna_cmsaeq,
+	sna_cmsac,			/* 5 */
+	sna_cmsacn,
+	sna_cmsapt,
+	sna_cmsbt,
+	sna_cmscsp,
+	sna_cmscst,			/* 10 */
+	sna_cmscsu,
+	sna_cmsct,
+	sna_cmscu,
+	sna_cmsdt,
+	sna_cmsed,			/* 15 */
+	sna_cmsend,
+	sna_cmserr,
+	sna_cmsf,
+	sna_cmsid,
+	sna_cmsld,			/* 20 */
+	sna_cmsmn,
+	sna_cmsndx,
+	sna_cmspdp,
+	sna_cmspid,
+	sna_cmspln,			/* 25 */
+	sna_cmspm,
+	sna_cmsptr,
+	sna_cmsqcf,
+	sna_cmsqpm,
+	sna_cmsrc,			/* 30 */
+	sna_cmsrt,
+	sna_cmssl,
+	sna_cmssrm,
+	sna_cmsst,
+	sna_cmstc,			/* 35 */
+	sna_cmstpn,
+	sna_cmeaeq,
+	sna_cmeapt,
+	sna_cmeacn,
+	sna_cmecs,			/* 40 */
+	sna_cmect,
+	sna_cmectx,
+	sna_cmeid,
+	sna_cmemn,
+	sna_cmepid,			/* 45 */
+	sna_cmepln,
+	sna_cmesi,
+	sna_cmesl,
+	sna_cmesrm,
+	sna_cmesui,			/* 50 */
+	sna_cmetc,
+	sna_cmetpn,
+	sna_cmallc,
+	sna_cmcanc,
+	sna_cmcfmd,			/* 55 */
+	sna_cmcfm,
+	sna_cmdeal,
+	sna_cmrcv,
+	sna_cmdfde,
+	sna_cmacci,			/* 60 */
+	sna_cmwait,			
+	sna_cmsltp,
+	sna_cmflus,
+	sna_cmincl,
+	sna_cmprep,			/* 65 */
+	sna_cmptr,	
+	sna_cmrcvx,
+	sna_cmrts,
+	sna_cmtrts,
+	sna_cminic			/* 70 */
+};
+
+int sna_cpic_create(struct sna_start_node *start)
+{
+        cpic_register(&sna_cpic_ops);
+        return (0);
+}
+
+int sna_cpic_destroy(struct sna_delete_node *delete)
+{
+        cpic_unregister(PF_SNA);
+        return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+	return (cpic_get_info_side(buffer, start, offset, length));
+}
+
+int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	struct sna_tcb *cpic;
+	off_t pos = 0, begin = 0;
+	int len = 0;
+
+	len += sprintf(buffer, "%-5s%-6s%-6s\n", "cvid", "state", "flags");
+#ifdef NOT
+	for(cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next)
+        {
+		len += sprintf(buffer + len, "%04X %02X %04X\n",
+			cpic->conversation_id, cpic->state, cpic->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+#endif
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.13/net/sna/sna_cs.c linux/net/sna/sna_cs.c
--- linux-2.4.13/net/sna/sna_cs.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cs.c	Wed Nov  7 10:55:20 2001
@@ -0,0 +1,1810 @@
+/* sna_cs.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/if_arp.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+extern char sna_version[];
+extern char sna_product_id[];
+extern char sna_product_name[];
+
+__u32	sysctl_xid_idle_limit		= SNA_XID_IDLE_LIMIT;
+__u32	sysctl_xid_retry_interval	= SNA_XID_RETRY_INTERVAL;
+__u32	sysctl_xid_retry_limit		= SNA_XID_RETRY_LIMIT;
+
+static struct sna_cs_pinfo	*cs_clients 	= NULL;
+static struct sna_dlc_cb 	*dlc_clients 	= NULL;
+
+static __u32	sna_dlc_system_id	= 0;
+static __u32	sna_port_system_id 	= 0;
+static __u32	sna_ls_system_id 	= 0;
+
+int sna_cs_insert_cs(struct sna_cs_pinfo *ics)
+{
+        sna_debug(5, "sna_cs_insert_cs\n");
+        ics->next 	= cs_clients;
+        cs_clients 	= ics;
+
+        return (0);
+}
+
+int sna_cs_delete_dlc(struct net_device *dev)
+{
+	struct sna_dlc_cb *dlc, **clients = &dlc_clients;
+
+	sna_debug(5, "sna_cs_delete_dlc %s\n", dev->name);
+
+        while((dlc = *clients) != NULL)
+        {
+		if(!strncmp(dlc->dev->name, dev->name, 8))
+		{
+			*clients = dlc->next;
+                        kfree(dlc);
+                        return (0);
+		}
+		clients = &dlc->next;
+        }
+
+	return (-ENOENT);
+}
+
+struct sna_cs_pinfo *sna_cs_find(char *name)
+{
+        struct sna_cs_pinfo *f;
+
+	sna_debug(5, "sna_cs_find %s\n", name);
+        for(f = cs_clients; f != NULL; f = f->next)
+		if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                       	return (f);
+
+        return (NULL);
+}
+
+struct sna_dlc_cb *sna_cs_find_dlc_name(char *name)
+{
+        struct sna_dlc_cb *f;
+
+	sna_debug(5, "sna_cs_find_dlc_name\n");
+        for(f = dlc_clients; f != NULL; f = f->next)
+                if(!strcmp(f->dev->name, name))
+			break;
+
+        return (f);
+}
+
+struct sna_port_cb *sna_cs_find_port(struct sna_port_cb *plist,
+	char *saddr)
+{
+        struct sna_port_cb *f;
+
+	sna_debug(5, "sna_cs_find_port\n");
+        for(f = plist; f != NULL; f = f->next)
+		if(!strncmp(f->saddr, saddr, 1))
+			break;
+        return (f);
+}
+
+struct sna_ls_cb *sna_cs_find_ls(struct sna_ls_cb *list, char *dname,
+	char *daddr)
+{
+        struct sna_ls_cb *f;
+
+        sna_debug(5, "sna_cs_find_ls_name\n");
+        for(f = list; f != NULL; f = f->next)
+	{
+		sna_debug(5, "%s %s\n", f->dname, dname);
+                if(!strncmp(f->dname, dname, 6) && f->daddr[0] == daddr[0])
+			break;
+	}
+
+        return (f);
+}
+
+int sna_cs_shutdown(void)
+{
+        return (0);
+}
+
+int sna_cs_create(struct sna_start_node *start)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_pc_create_parms *pc;
+	struct sna_rm_act_session_rq *as;
+
+	sna_debug(5, "sna_cs_create %s\n", start->netid.name);
+	cs = sna_cs_find(start->netid.name);
+	if(cs)
+		return (-EEXIST);
+	cs = (struct sna_cs_pinfo *)kmalloc(sizeof(struct sna_cs_pinfo), 
+		GFP_ATOMIC);
+	memcpy(&cs->netid, &start->netid, sizeof(struct sna_netid));
+        memcpy(&cs->nodeid, &start->nodeid, sizeof(struct sna_nodeid));
+	cs->next = NULL;
+	cs->prev = NULL;
+        sna_cs_insert_cs(cs);
+
+	/* Create the intranode Path Control - One per Node */
+	pc = (struct sna_pc_create_parms *)kmalloc(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memset(pc, 0, sizeof(struct sna_pc_create_parms));
+	pc->type 	= SNA_PC_INTRANODE;
+	pc->dlc		= NULL;
+	pc->port	= NULL;
+	pc->ls		= NULL;
+	memcpy(&pc->fqcp, &cs->netid, sizeof(struct sna_netid));
+	sna_pc_init(pc);
+	memcpy(&cs->intranode_pc_id, &pc->pc_id, 8);
+	kfree(pc);
+	cs->node_type		= start->type;
+
+	/* Activate the loopback link - hidden */
+	as = (struct sna_rm_act_session_rq *)kmalloc(sizeof(struct sna_rm_act_session_rq), GFP_ATOMIC);
+	memcpy(&as->plu_netid, &cs->netid, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "CONNECT");
+	sna_rm_activate_session(as);
+
+	return (0);
+}
+
+int sna_cs_destroy(struct sna_delete_node *delete)
+{
+	struct sna_cs_pinfo *cs, **clients = &cs_clients; 
+
+	sna_debug(5, "sna_cs_destroy\n");
+	while((cs = *clients) != NULL)
+        {
+                if(!strncmp(cs->netid.name, delete->netid.name, 8))
+                {
+			struct sna_dlc_cb *dlc;
+			struct sna_port_cb *port, **pclients;
+			struct sna_ls_cb *ls;
+
+                        *clients = cs->next;
+			for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+			{
+				pclients = &dlc->port_list;
+				while((port = *pclients) != NULL)
+				{
+					if(strncmp(port->netid.name, delete->netid.name, 8))
+					{
+						pclients = &port->next;
+						break;
+					}
+					else
+						*pclients = port->next;
+
+					for(ls = port->ls_list; ls != NULL; ls = ls->next)					
+					{
+						ls->port 	= NULL;
+						ls->dlc 	= NULL;
+						kfree(ls);
+						port->ls_qlen--;
+						sna_mod_dec_use_count();
+					}
+
+					switch(port->dev->type)
+		                        {
+#ifdef CONFIG_SNA_LLC
+                		                case (ARPHRD_ETHER):
+                        		        case (ARPHRD_IEEE802):
+                        		        case (ARPHRD_FDDI):
+                        		                unregister_8022_client(port->saddr[0]);
+                                		        break;
+#endif
+					}
+					
+					port->ls_list 	= NULL;
+					port->dev 	= NULL;
+#ifdef CONFIG_SNA_LLC
+					port->llc_dl	= NULL;
+#endif
+					kfree(port);
+					dlc->port_qlen--;
+					sna_mod_dec_use_count();
+				}
+			}
+
+			cs->dlc_list = NULL;
+			sna_pc_destroy(cs->intranode_pc_id);
+                        kfree(cs);
+                        return (0);
+                }
+                clients = &cs->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cs_query_connection_network(int type, 
+	struct sna_query_connection_network *query_connection_network)
+{
+
+	return (0);
+}
+
+int sna_cs_query_link_station(struct sna_query_link_station *query_link_station)
+{
+#ifdef NOT
+	struct sna_ls_cb *ls_cb;
+        struct sna_cs_pinfo *cs
+                = sna_cs_find(query_link_station->connection_name);
+
+        printk("sna_cs_query_link_station\n");
+
+        if(cs == NULL)
+		return (-1);
+
+        printk("cs != NULL\n");
+	ls_cb = sna_cs_find_ls_name(query_link_station->ls_name);
+		return (-1);
+
+	query_link_station->adj_node_type	= ls_cb->adj_node_type;
+	query_link_station->fsm_ls_state	= 0;
+	query_link_station->ls_entered_act_state= ls_cb->ls_entered_act_state;
+	query_link_station->node_act		= ls_cb->node_act;
+	query_link_station->ls_activation	= ls_cb->ls_activation;
+	memcpy(query_link_station->dest_addr, ls_cb->dest_addr, 6);
+	query_link_station->tx_win_size		= ls_cb->tx_win_size;
+	query_link_station->rx_win_size		= ls_cb->rx_win_size;
+	query_link_station->fsm_xid_state	= 0;
+	query_link_station->fsm_nonact_xid_state= 0;
+	query_link_station->fsm_ls_role_state	= 0;
+#endif
+
+	return (0);
+}
+
+int sna_cs_define_connection_network(
+	struct sna_define_connection_network *define_connection_network)
+{
+
+	return (0);
+}
+
+int sna_cs_define_dlc(struct net_device *dev)
+{
+	sna_debug(5, "sna_cs_define_dlc %s\n", dev->name);
+	switch(dev->type)
+	{
+#ifdef CONFIG_SNA_LOOPBACK
+		case (ARPHRD_LOOPBACK):
+		{
+			struct sna_dlc_cb *dlc = (struct sna_dlc_cb *)
+                                kmalloc(sizeof(struct sna_dlc_cb),
+                                GFP_KERNEL);
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+                        dlc->port_list  = NULL;
+                        dlc->port_qlen  = 0;
+                        dlc->next       = dlc_clients;
+                        dlc_clients     = dlc;
+			break;
+		}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+		case (ARPHRD_IEEE802):
+		case (ARPHRD_FDDI):
+		{
+			struct sna_dlc_cb *dlc = (struct sna_dlc_cb *)
+				kmalloc(sizeof(struct sna_dlc_cb),
+				GFP_KERNEL);
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+			dlc->port_list	= NULL;
+			dlc->port_qlen	= 0;
+                        dlc->next 	= dlc_clients;
+                        dlc_clients 	= dlc;
+                        break;
+		}
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+
+		default:
+			return (-EINVAL);
+	}
+
+	return (0);
+}
+
+int sna_cs_delete_ls(struct sna_delete_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls, **clients;
+
+	sna_debug(5, "sna_cs_delete_link_station\n");
+        cs = sna_cs_find(dls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if(!dlc)
+                return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dls->saddr);
+	if(!port)
+		return (-ENOENT);
+        clients = &port->ls_list;
+        while((ls = *clients) != NULL)
+        {
+                if(!strcmp(ls->daddr, dls->daddr)
+			&& !strcmp(ls->dname, dls->dname))
+                {
+                        *clients = ls->next;
+			sna_pc_destroy(ls->pc_id);
+                        kfree(ls);
+			port->ls_qlen--;
+			sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &ls->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_cs_define_ls(struct sna_define_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls;
+	struct sna_pc_create_parms *pc;
+	struct sna_tg_update *tg;
+	unsigned char name[20];
+        int len = 0, err;
+
+	sna_debug(5, "sna_cs_define_link_station\n");
+	cs = sna_cs_find(dls->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dls->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dls->saddr);
+	if(!port)
+		return (-ENOENT);
+	ls = sna_cs_find_ls(port->ls_list, dls->dname, dls->daddr);
+	if(ls)
+		return (-EEXIST);
+
+	ls = (struct sna_ls_cb *)kmalloc(sizeof(struct sna_ls_cb),
+		GFP_KERNEL);
+	memset(ls, '0', sizeof(struct sna_ls_cb));
+	memcpy(&ls->netid, &dls->netid, sizeof(struct sna_netid));
+	memcpy(&ls->plu_name, &dls->plu_name, sizeof(struct sna_netid));
+	memcpy(ls->dname, dls->dname, MAX_ADDR_LEN);
+	memcpy(ls->daddr, dls->daddr, SNA_PORT_ADDR_LEN);
+	ls->sport	= dls->saddr[0];
+	memcpy(ls->devname, dls->name, 8);
+	ls->auto_act	= dls->autoact;
+	ls->auto_deact	= dls->autodeact;
+	ls->port	= port;
+	ls->dlc		= dlc;
+	ls->flags	= (SNA_UP | SNA_STOPPED);
+	ls->proc_id	= sna_ls_system_id++;
+	ls->next      	= port->ls_list;
+        port->ls_list  	= ls;
+	port->ls_qlen++;
+
+	/* Update this TG */
+	tg = (struct sna_tg_update *)kmalloc(sizeof(struct sna_tg_update),
+                GFP_ATOMIC);
+        if(!ls->tg_id)
+                sna_tdm_init_tg_update(tg);
+        memcpy(&tg->tg_desc.dlc.mac, &ls->dname, MAX_ADDR_LEN);
+	tg->dev				= port->dev;
+	tg->lsap			= port->saddr[0];
+        tg->node_type                   = cs->node_type;
+        tg->tg_desc.dlc.lsap            = ls->daddr[0];
+        tg->tg_desc.id.pcp_len = len = sna_netid_to_char(&port->netid, name);
+        tg->tg_desc.id.pcp_name = (unsigned char *)kmalloc(len + 1, GFP_ATOMIC);        strcpy(tg->tg_desc.id.pcp_name, name);
+        err = sna_tdm_tg_update(tg);
+        if(err < 0)
+                return (err);
+
+	/* Create Internode PC instance - our side of the link */
+	pc = (struct sna_pc_create_parms *)kmalloc(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memset(pc, 0, sizeof(struct sna_pc_create_parms));
+
+	/* Used to be memcpy( , &ls->netid, ); */
+	memcpy(&pc->fqcp, &ls->netid, sizeof(struct sna_netid));
+	pc->type 	= SNA_PC_INTERNODE;
+	pc->dlc		= dlc;
+	pc->ls		= ls;
+	pc->port	= port;
+	pc->max_tx_btu	= dlc->dev->mtu;
+	pc->max_rx_btu	= dlc->dev->mtu;
+	sna_pc_init(pc);
+	memcpy(&ls->pc_id, &pc->pc_id, 8);
+	kfree(pc);
+
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_cs_delete_port(struct sna_delete_port *dport)
+{
+	struct sna_port_cb *port, **clients;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "sna_cs_delete_port (%s, %s)\n", dport->name,dport->saddr);
+	cs = sna_cs_find(dport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dport->name);
+        if(!dlc)
+                return (-ENOENT);
+
+	clients = &dlc->port_list;
+        while((port = *clients) != NULL)
+        {
+                if(!strcmp(port->saddr, dport->saddr))
+                {
+                        *clients = port->next;
+			switch(port->dev->type)
+			{
+#ifdef CONFIG_SNA_LLC
+				case (ARPHRD_ETHER):
+				case (ARPHRD_IEEE802):
+				case (ARPHRD_FDDI):
+					unregister_8022_client(port->saddr[0]);
+					break;
+#endif
+#ifdef CONFIG_SNA_ATM
+				case (ARPHRD_ATM):
+					break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+				case (ARPHRD_CHANNEL):
+					break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+				case (ARPHRD_HDLC):
+					break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+				case (ARPHRD_SDLC):
+					break;
+#endif
+				default:
+					break;
+			}
+                        kfree(port);
+			dlc->port_qlen--;
+			sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &port->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cs_define_port(struct sna_define_port *dport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "sna_cs_define_port\n");
+	cs = sna_cs_find(dport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dport->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dport->saddr);
+	if(port)
+		return (-EEXIST);
+	port = (struct sna_port_cb *)kmalloc(sizeof(struct sna_port_cb), 
+		GFP_KERNEL);
+	memset(port, '0', sizeof(struct sna_port_cb));
+	memcpy(&port->netid, &dport->netid, sizeof(struct sna_netid));
+	memcpy(&port->saddr, &dport->saddr, SNA_PORT_ADDR_LEN);
+	port->dev	= dlc->dev;
+	port->proc_id	= sna_port_system_id++;
+	port->flags	= (SNA_UP | SNA_STOPPED);
+	port->ls_list	= NULL;
+	port->ls_qlen	= 0;
+	port->btu	= dport->btu;
+	port->mia	= dport->mia;
+	port->moa	= dport->moa;
+
+	switch(dport->role)
+	{
+		case (SNA_PORT_ROLE_PRI):
+		case (SNA_PORT_ROLE_SEC):
+		case (SNA_PORT_ROLE_NEG):
+			port->role = dport->role;
+			break;
+		default:
+			return (-EINVAL);
+	}
+
+	/* Link to data link control block port list */
+        port->next      = dlc->port_list;
+        dlc->port_list  = port;
+        dlc->port_qlen++;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_cs_query_statistics(struct sna_query_stats *qs)
+{
+
+	return (0);
+}
+
+int sna_cs_start_ls(struct sna_start_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+//	struct sna_tg_update *tg;
+	struct sna_rm_act_session_rq *as;
+//	unsigned char name[20];
+//	int len = 0, err;
+
+        sna_debug(5, "sna_cs_start_ls\n");
+        cs = sna_cs_find(dls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, dls->saddr);
+        if(!port)
+                return (-ENOENT);
+        ls = sna_cs_find_ls(port->ls_list, dls->dname, dls->daddr);
+        if(!ls)
+                return (-ENOENT);
+
+	ls->flags     &= ~SNA_STOPPED;
+        ls->flags     |= SNA_RUNNING;
+
+/*	This has been moved to define_ls() probably permanantly
+
+	tg = (struct sna_tg_update *)kmalloc(sizeof(struct sna_tg_update),
+                GFP_ATOMIC);
+	if(!ls->tg_id)
+        	sna_tdm_init_tg_update(tg);
+	memcpy(&tg->tg_desc.dlc.mac, &ls->dname, MAX_ADDR_LEN);
+        tg->node_type                   = cs->node_type;
+        tg->tg_desc.dlc.lsap            = ls->daddr[0];
+	tg->tg_desc.id.pcp_len = len = sna_netid_to_char(&port->netid, name);
+	tg->tg_desc.id.pcp_name = (unsigned char *)kmalloc(len + 1, GFP_ATOMIC);
+	strcpy(tg->tg_desc.id.pcp_name, name);
+	err = sna_tdm_tg_update(tg);
+	if(err < 0)
+		return (err);
+
+*/
+
+	as = (struct sna_rm_act_session_rq *)kmalloc(sizeof(struct sna_rm_act_session_rq), GFP_ATOMIC);
+	as->tcb_id	= ls->proc_id;
+	memcpy(&as->plu_netid, &dls->netid_plu, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "#BATCH");
+	sna_rm_activate_session(as);
+
+	return (0);
+}
+
+/* Start the "port". Depending on the underlying device and
+ * network type and what DLC support we have enabled we will
+ * start the DLC specific actions to start the DLC to send up
+ * packets. We mux all similar DLC types into the same rx
+ * handlers and demux it there. Actual specific DLC handlers are
+ * located in sna_dlc.c.
+ */
+int sna_cs_start_port(struct sna_start_port *sport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "sna_cs_start_port\n");
+	cs = sna_cs_find(sport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(sport->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, sport->saddr);
+	if(!port)
+		return (-ENOENT);
+
+	switch(port->dev->type)
+	{
+#ifdef CONFIG_SNA_LOOPBACK
+		case (ARPHRD_LOOPBACK):
+			break;
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+		case (ARPHRD_IEEE802):
+		case (ARPHRD_FDDI):
+			port->flags |= SNA_UP;
+			port->llc_dl = register_8022_client(port->saddr[0],
+				sna_dlc_llc_rcv, sna_dlc_llc_event);
+			if(port->llc_dl == NULL)
+			{
+				printk("Unable to register 8022 client\n");
+				return (-1);
+			}
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+
+		default:
+			return (-EINVAL);
+	}
+
+	port->flags	&= ~SNA_STOPPED;
+	port->flags	|= SNA_RUNNING;
+
+	return (0);
+}
+
+int sna_cs_stop_ls(struct sna_stop_link_station *sls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+	struct sna_tg_cb *tg;
+
+        sna_debug(5, "sna_cs_stop_ls\n");
+        cs = sna_cs_find(sls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(sls->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, sls->saddr);
+        if(!port)
+                return (-ENOENT);
+        ls = sna_cs_find_ls(port->ls_list, sls->dname, sls->daddr);
+        if(!ls)
+                return (-ENOENT);
+	tg = sna_tdm_find_tg_by_id(ls->tg_id);
+	if(tg)
+	{
+		del_timer(&tg->co_retry);
+		tg->co_status = CO_RESET;
+		tg->co_retries = 0;
+	}
+
+	ls->flags &= ~SNA_RUNNING;
+	ls->flags |= SNA_STOPPED;
+
+#ifdef NOT
+	/* Send formal disconnect to partner if link is active */
+	if(tg->xid_info != NULL)
+	{
+		if(tg->xid_info->xid_status == XID_ACTIVE)
+			llc_disconnect(port->llc_dl, port->dev, 
+				tg->tg_vector.desc.dlc.mac,
+				tg->tg_vector.desc.dlc.lsap, 0);
+	}
+#endif
+
+	return (0);
+}
+
+int sna_cs_stop_port(struct sna_stop_port *sport)
+{
+	struct sna_port_cb *port;
+        struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+
+        sna_debug(5, "sna_cs_stop_port\n");
+        cs = sna_cs_find(sport->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(sport->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, sport->saddr);
+        if(!port)
+                return (-ENOENT);
+
+        switch(port->dev->type)
+        {
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+                case (ARPHRD_IEEE802):
+                case (ARPHRD_FDDI):
+			port->flags &= ~SNA_RUNNING;
+			port->flags |= SNA_STOPPED;
+			if((llc_disconnect(port->llc_dl, port->dev, 0,0,0)) < 0)
+				break;	/* Already disconnected. */
+			/* Need to wait for the correct event response. */
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+	}
+
+	return (0);
+}
+
+int sna_dlc_ginfo(struct sna_dlc_cb *dlc, char *buf, int len)
+{
+	struct dlcreq dr;
+	int done = 0;
+
+	sna_debug(5, "sna_dlc_ginfo\n");
+	if(!buf)
+        {
+                done += sizeof(dr);
+                return (done);
+        }
+        if(len < (int)sizeof(dr))
+                return done;
+        memset(&dr, 0, sizeof(struct dlcreq));
+
+        /* Move the data here */
+//	strncpy(dr.dlc_net, cs->netid.net, 8);
+//	strncpy(dr.dlc_name, cs->netid.name, 8);
+	strncpy(dr.devname, dlc->dev->name, SNA_RESOURCE_NAME_LEN);
+	dr.port_qlen		= dlc->port_qlen;
+	dr.proc_id 		= dlc->proc_id;
+	dr.flags 		= dlc->flags;
+
+        if(copy_to_user(buf, &dr, sizeof(struct dlcreq)))
+                return (-EFAULT);
+        buf += sizeof(struct dlcreq);
+        len -= sizeof(struct dlcreq);
+        done += sizeof(struct dlcreq);
+
+	return (done);
+}
+
+int sna_cs_query_dlc(char *arg)
+{
+        struct sna_dlc_cb *dlc;
+        struct dlconf dc;
+        char *pos;
+        int len, total;
+
+        sna_debug(5, "sna_cs_query_dlc\n");
+        if(copy_from_user(&dc, arg, sizeof(dc)))
+                return (-EFAULT);
+
+        pos = dc.dlc_buf;
+        len = dc.dlc_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = sna_dlc_ginfo(dlc, NULL, 0);
+                else
+                        done = sna_dlc_ginfo(dlc, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        dc.dlc_len = total;
+        if(copy_to_user(arg, &dc, sizeof(dc)))
+                return (-EFAULT);
+
+        return (0);
+}
+
+int sna_port_ginfo(struct sna_port_cb *port, char *buf, int len)
+{
+        struct portreq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_port_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(pr);
+                return (done);
+        }
+        if(len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct portreq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &port->netid, sizeof(struct sna_netid));
+	strncpy(pr.devname, port->dev->name, SNA_RESOURCE_NAME_LEN);
+	memcpy(&pr.saddr, port->saddr, 12);
+	pr.ls_qlen	= port->ls_qlen;
+	pr.proc_id	= port->proc_id;
+	pr.flags	= port->flags;
+	pr.role		= port->role;
+	pr.btu		= port->btu;
+	pr.mia		= port->mia;
+	pr.moa		= port->moa;
+
+        if(copy_to_user(buf, &pr, sizeof(struct portreq)))
+                return (-EFAULT);
+        buf += sizeof(struct portreq);
+        len -= sizeof(struct portreq);
+        done += sizeof(struct portreq);
+
+        return (done);
+}
+
+int sna_cs_query_port(char *arg)
+{
+	struct portconf pc;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        char *pos;
+        int len, total;
+
+        sna_debug(10, "sna_cs_query_port\n");
+        if(copy_from_user(&pc, arg, sizeof(pc)))
+                return (-EFAULT);
+
+        pos = pc.portc_buf;
+        len = pc.port_len;
+
+	/*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+        	for(port = dlc->port_list; port != NULL; port = port->next)
+        	{
+        	        int done;
+	
+	                if(pos == NULL)
+	                        done = sna_port_ginfo(port, NULL, 0);
+	                else
+	                        done = sna_port_ginfo(port,pos+total,len-total);
+	                if(done < 0)
+	                        return (-EFAULT);
+	                total += done;
+	        }
+	}
+
+        pc.port_len = total;
+        if(copy_to_user(arg, &pc, sizeof(pc)))
+                return (-EFAULT);
+	return (0);
+}
+
+int sna_ls_ginfo(struct sna_ls_cb *ls, char *buf, int len)
+{
+        struct lsreq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_ls_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(lr);
+                return (done);
+        }
+        if(len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lsreq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &ls->netid, sizeof(struct sna_netid));
+	memcpy(&lr.devname, ls->devname, SNA_RESOURCE_NAME_LEN);
+	memcpy(&lr.dname, ls->dname, SNA_FQCP_NAME_LEN);
+	memcpy(&lr.daddr, ls->daddr, 12);
+	lr.sport	= ls->sport;
+	lr.proc_id	= ls->proc_id;
+	lr.flags	= ls->flags;
+	lr.auto_act	= ls->auto_act;
+	lr.auto_deact	= ls->auto_deact;
+
+        if(copy_to_user(buf, &lr, sizeof(struct lsreq)))
+                return (-EFAULT);
+        buf += sizeof(struct lsreq);
+        len -= sizeof(struct lsreq);
+        done += sizeof(struct lsreq);
+
+        return (done);
+}
+
+int sna_cs_query_ls(char *arg)
+{
+        struct lsconf lc;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+        char *pos;
+        int len, total;
+
+       	sna_debug(10, "sna_cs_query_ls\n");
+        if(copy_from_user(&lc, arg, sizeof(lc)))
+                return (-EFAULT);
+
+        pos = lc.lsc_buf;
+        len = lc.ls_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+		for(port = dlc->port_list; port != NULL; port = port->next)
+		{
+        		for(ls = port->ls_list; ls != NULL; ls = ls->next)
+        		{
+	                	int done;
+	
+		                if(pos == NULL)
+		                        done = sna_ls_ginfo(ls, NULL, 0);
+		                else
+			                done = sna_ls_ginfo(ls,pos+total,len-total);
+		                if(done < 0)
+		                        return (-EFAULT);
+		                total += done;
+		        }
+		}
+	}
+
+        lc.ls_len = total;
+        if(copy_to_user(arg, &lc, sizeof(lc)))
+                return (-EFAULT);
+        return (0);
+}
+
+/* Build a specified Xid control vector at the specified memory location,
+ * we build it using dynamic data were applicable.
+ */
+int sna_cs_build_xid_cv(struct sna_tg_cb *tg, struct sk_buff *skb, __u8 type)
+{
+	int len = 0, size;
+	unsigned char name[50], scratch[50];
+	__u8 l, s, r, *cv_start;
+
+	sna_debug(10, "sna_cs_build_xid_cv %d -%s-\n",
+		tg->tg_vector.desc.id.pcp_len, 
+		tg->tg_vector.desc.id.pcp_name);
+
+	switch(type)
+	{
+		case (CV_KEY_NETNAME):
+			size = 1 + 3 + tg->tg_vector.desc.id.pcp_len;
+			cv_start = (__u8 *)skb_put(skb, size);
+			len = 1;
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+			l = tg->tg_vector.desc.id.pcp_len + 1;
+                        memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+			r = CV_CP_NAME;
+			memcpy(cv_start + len, &r, sizeof(__u8));
+			len += sizeof(__u8);
+			fatoe_strncpy(name, tg->tg_vector.desc.id.pcp_name,
+				tg->tg_vector.desc.id.pcp_len);
+			memcpy(cv_start + len, name, 
+				tg->tg_vector.desc.id.pcp_len);
+			len += tg->tg_vector.desc.id.pcp_len;
+			break;
+
+		case (CV_KEY_PRODUCT_ID):
+			memset(scratch, 0, 50);
+			sprintf(scratch, "%s %s", sna_product_name,sna_version);
+			size = 10 + strlen(sna_product_id) + strlen(scratch);
+                        cv_start = (__u8 *)skb_put(skb, size);
+
+			/* Cv type */
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* entire length of cv */
+			l = (6 + strlen(sna_product_id))+(2 + strlen(scratch));
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* Length of data fields */
+			l = 2 + strlen(sna_product_id) + 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* Common SV code */
+			s = 0x11;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* version length */
+			l = 2 + strlen(sna_product_id);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* version codec */
+			s = 0x02;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual version */
+			atoe_strncpy(name, sna_product_id, 
+				strlen(sna_product_id));
+			memcpy(cv_start + len, name, strlen(sna_product_id));
+			len += strlen(sna_product_id);
+
+			/* Product Name length */
+			l = 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* product name codec */
+			s = 0x06;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual product name */
+			memset(name, 0, 50);
+			fatoe_strncpy(name, scratch, strlen(scratch));
+                        memcpy(cv_start + len, name, strlen(scratch));
+			len += strlen(scratch);
+			break;
+	}
+
+	return (len);
+}
+
+/* Initialize an XID, we load any defaults and initialize any fields
+ * that we have the data provided in sna_tg_cb. The xid is not valid
+ * when this function finishes, we return the length of data added.
+ */
+sna_xid3 *sna_cs_init_xid(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	struct sna_nodeid *n;
+	sna_xid3 *xid;
+
+	sna_debug(5, "sna_cs_init_xid\n");
+	xid = (sna_xid3 *)skb_push(skb, sizeof(sna_xid3));
+        xid->xid_node           = SNA_XID_NODE_T2;
+        xid->xid_type           = SNA_XID_TYPE_3;
+        xid->nc1                = 0x00;
+	xid->nc2		= 0x00;
+        xid->tx_adptv_bind_pacing= 1;
+        xid->rx_adprv_bind_pacing= 1;
+        xid->quiesce_tg_req      = 0;
+        xid->pu_cap_sup          = 1;
+        xid->appn_pbn            = 0;
+        xid->adptv_bind_pacing   = 0x01;
+        xid->tg_sharing_prohibited = 0;
+        xid->dedicated_scv       = 0;
+        xid->parallel_tg_sup     = 0;
+        xid->dlur_actpu          = 0;
+        xid->dlus_lu_reg         = 1;
+        xid->gen_odai_usage_opt_set = 0;
+        xid->dlc_type           = 0x01;
+        xid->dlc_len            = 11;
+	xid->ls_flags		= 0x00;
+	xid->dlc_init_mode      = 1;
+
+	/* only dynamic inits for now. */
+	n = sna_nof_find_nodeid(sna_char_to_netid
+		(tg->tg_vector.desc.id.pcp_name));
+	if(n)
+	{
+		xid->block_id	= n->block_id;
+		xid->pu_id	= n->pu_id;
+	}
+
+	sna_debug(5, "Nodeid is %X %X\n", xid->block_id, xid->pu_id);
+	xid->tg_num             = tg->tg_vector.desc.id.tg_number;
+        xid->max_btu_len	= htons(tg->dev->mtu);
+        xid->max_rx_iframes 	= 0x07;
+
+	return (xid);
+}
+
+/* Build a complete XID header. This is done by using the data we
+ * have saved and by using the existing state information.
+ * We receive an SKB will space allocated for the MAC header, we need
+ * to push on enough space for the DL header and XID header, then we
+ * return the skb.
+ */
+int sna_cs_build_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+	struct net_device *dev = tg->dev;
+	struct sk_buff *skb;
+	int size, len;
+
+	sna_debug(5, "sna_cs_build_xid\n");
+
+#ifdef CONFIG_SNA_LLC
+	/* compute total packet size, we lie for now and make bigger */
+	size = dev->hard_header_len + LLC_XID_SIZE + 150;
+	skb = alloc_skb(size, GFP_ATOMIC);
+	skb->dev = dev;
+
+	/* build the actual xid information for a specific xid type */
+	switch(xid->xid_status)
+	{
+		case (XID_S_NULL):
+		{
+			llchdr *llc;
+			skb_reserve(skb, LLC_XID_SIZE);
+        		skb_reserve(skb, dev->hard_header_len);
+			llc = (llchdr *)skb_push(skb, LLC_XID_SIZE);
+                        llc->dsap       = tg->tg_vector.desc.dlc.lsap;
+                        llc->ssap       = tg->lsap;
+                        llc->ctrl.ctrl  = LLC_CTRL_XID_CMD;
+			llc->ctrl.uctrl.pf = xid->xid_direction;
+			break;
+		}
+
+		case (XID_S_NEG):
+		{
+			llchdr *llc;
+			sna_xid3 *x3;
+			skb_reserve(skb, 80);	/* may need to make correct */
+			skb_reserve(skb, LLC_XID_SIZE);
+                        skb_reserve(skb, dev->hard_header_len);
+			x3 = sna_cs_init_xid(tg, skb);
+			len = sizeof(sna_xid3);
+			len += sna_cs_build_xid_cv(tg, skb, CV_KEY_NETNAME);
+                        len += sna_cs_build_xid_cv(tg, skb, CV_KEY_PRODUCT_ID);
+			x3->len 	= len;
+			x3->nc2        	= 0xF7;
+			x3->ls_flags   	= 0x41;
+			llc = (llchdr *)skb_push(skb, LLC_XID_SIZE);
+                        llc->dsap       = tg->tg_vector.desc.dlc.lsap;
+                        llc->ssap       = tg->lsap;
+                        llc->ctrl.ctrl  = LLC_CTRL_XID_CMD;
+			break;
+		}
+
+		/* this should never happen, but if it does we can handle it */
+		case (XID_ACTIVE):
+			kfree_skb(skb);
+			return (0);
+
+		case (XID_S_PN):
+		case (XID_S_PRI):
+		case (XID_S_SEC):
+		case (XID_FAIL):
+		default:
+			kfree_skb(skb);
+			return (-1);
+	}
+
+	if(sna_debug_level > 5)
+        {
+                printk("Jay, check out the Xids on that packet ;)\n");
+                hexdump(skb->data, skb->len);
+        }
+
+	/* add the physical header to the packet */
+        dev->hard_header(skb, skb->dev, ETH_P_802_3,
+                tg->tg_vector.desc.dlc.mac, NULL, skb->len);
+
+	/* save a copy of this Xid */
+	if(xid->last_tx_xid != NULL)
+		kfree_skb(xid->last_tx_xid);
+	xid->last_tx_xid = skb_copy(skb, GFP_ATOMIC);
+
+	/* transmit xid */
+	xid->xid_count++;
+        dev_queue_xmit(skb);
+#endif	/* CONFIG_SNA_LLC */
+
+	return (0);
+}
+
+int sna_cs_xid_xchg_state(struct sk_buff *skb)
+{
+	sna_xid3 *xid = (sna_xid3 *)&skb->data[3];
+
+	sna_debug(5, "sna_cs_xid_xchg_state %02X\n", xid->nc2);
+	if(xid->len == 0)
+		return (XID_NULL);
+
+	if(xid->nc2 == 0xFB)
+		return (XID_PN);
+
+	if(xid->nc2 == 0xF7)
+		return (XID_NEG);
+	else
+		return (-1);
+
+	return (0);
+}
+
+int sna_cs_fsm_tgn_neg(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_fsm_tgn_neg\n");
+
+	return (0);
+}
+
+int sna_cs_validate_adjacent_node_id(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_validate_adjacent_node_id\n");
+
+	return (0);
+}
+
+int sna_cs_xid_error_chk(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_xid_error_chk\n");
+
+	return (0);
+}
+
+int sna_cs_process_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "sna_cs_process_xid\n");
+	switch(xid->xid_status)
+	{
+		case (XID_RESET):	/* Send XID PN Cmd or Rsp */
+		case (XID_S_NULL):	/* last tx xnull timed out, retry */
+			xid->xid_status = XID_S_NULL;
+			sna_cs_build_xid(tg);
+			break;
+
+		/* received a xid null, this could be a poll or a resposne */
+		case (XID_R_NULL):
+			sna_debug(5, "Received an XID_R_NULL can proceed\n");
+			if(xid->xid_initiator)			/* rx poll */
+			{
+				printk("Sending an Null Xid Response\n");
+				xid->xid_status = XID_S_NULL;	/* tx final */
+				sna_cs_build_xid(tg);
+			}
+			else	/* rx final, proceed to next state */
+			{
+				xid->xid_status = XID_S_NEG;
+				/* Will be followed by a Xid Poll sent by the
+				 * remote side, then we will proceed to actually
+				 * sending the NEG xid in case (XID_S_NEG).
+				 * sna_cs_build_xid(tg);
+				 */
+			}
+			break;
+
+		/* At this point we have verified the host exists and have
+		 * exchanged NULL Xids. We now start to negotiate the options.
+		 */
+		case (XID_S_NEG):
+			sna_debug(5, "Permission to send NEG XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_R_NEG):
+			sna_debug(5, "Responding with another NEG\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_ACTIVE):
+                        sna_debug(5, "Active XID estabilished\n");
+                        xid->xid_retries = 0;
+			wake_up_interruptible(&tg->sleep);
+			break;
+
+		case (XID_R_PN):
+			sna_debug(5, "I see a Pre Neg XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_S_PN):
+		case (XID_FAIL):
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return (-1);
+	}
+
+	return (0);
+}
+
+/* Only called if we have an incomming XID, this is basicly the same as
+ * connect_out(), just from the other side.
+ */
+int sna_cs_connect_in(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ethhdr *eth_hdr = skb->mac.ethernet;
+	struct sna_xid_info *xid;
+	struct sna_tg_cb *tg;
+
+	if(sna_debug_level > 5)
+	{
+		printk("sna_cs_connect_in\n");
+		hexdump(skb->data, skb->len);
+	}
+
+        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+	if(!tg)
+	{
+		kfree_skb(skb);
+		return (-ENOENT);
+	}
+
+	/* xid is one of ours increase the count */
+	xid = tg->xid_info;
+	xid->xid_count++;
+
+	/* determine type of xid packet */
+        switch(sna_cs_xid_xchg_state(skb))
+        {
+                case (XID_NULL):
+			/* Reveived Null Xid Poll, send response */
+			if(xid->xid_status == XID_RESET)
+			{
+				tg->co_status = CO_TEST_OK;
+				xid->xid_initiator = 1;		/* remote */
+				xid->xid_direction = XID_INBOUND;
+				xid->xid_status = XID_R_NULL;
+				break;
+			}
+
+			if(!xid->xid_initiator && xid->xid_status == XID_S_NEG)
+			{
+				sna_debug(5, "Some funky shit happen'n here\n");
+                        	break;
+			}
+			else
+			{
+				sna_debug(5, "Can't handle NULL XID\n");
+				kfree_skb(skb);
+				return (-1);
+			}
+
+                case (XID_NEG):
+			sna_debug(5, "Received an XID NEG\n");
+			xid->xid_direction = XID_INBOUND;
+			xid->xid_status = XID_S_NEG;
+			break;
+
+                case (XID_PN):
+			xid->xid_direction = XID_INBOUND;
+			xid->xid_status = XID_S_NEG;
+			break;
+
+		default:
+        		sna_debug(5, "Got XID not handle ignoring\n");
+			kfree_skb(skb);
+			return (-1);
+	}
+
+	/* we need to do further processing on this xid, save then do it. */
+	if(xid->last_rx_xid != NULL)
+        	kfree_skb(xid->last_rx_xid);
+        xid->last_rx_xid = skb;
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+
+	return (0);
+}
+
+/* Complete any necessary DLC processing to bring up a link 
+ *
+ * One could argue that this is a nasty little function. It is
+ * not only called by other functions but is also a timer-expire
+ * backend.
+ */
+void sna_cs_connect_out(unsigned long data)
+{
+	struct sna_tg_cb *tg = (struct sna_tg_cb *)data;
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "sna_cs_connect_out (test %d %d) (xid %d %d)\n", 
+		tg->co_retries, tg->co_max_retries, xid->xid_retries, 
+		xid->xid_retry_limit);
+
+	del_timer(&tg->co_retry);
+	switch(tg->co_status)
+	{
+		case (CO_RESET):
+		case (CO_S_TEST_C):
+			if(tg->co_retries < tg->co_max_retries)
+			{
+#ifdef CONFIG_SNA_LLC
+				struct sk_buff *skb;
+				struct net_device *dev = tg->dev;
+
+				skb = alloc_skb(dev->hard_header_len
+					+ LLC_TYPE1_SIZE + 20, GFP_ATOMIC);
+				if(!skb)
+					return;
+				skb_reserve(skb, LLC_TYPE1_SIZE);
+				skb_reserve(skb, dev->hard_header_len);
+				skb->dev = dev;
+
+				tg->co_status = CO_S_TEST_C;
+				tg->co_retries++;
+				llc_test(tg->lsap, tg->tg_vector.desc.dlc.lsap, 
+					tg->tg_vector.desc.dlc.mac, skb, dev);
+				tg->co_retry.expires = jiffies+tg->co_interval;
+				add_timer(&tg->co_retry);
+#endif	/* CONFIG_SNA_LLC */
+			}
+			else
+				tg->co_status = CO_FAIL;
+			return;
+
+		case (CO_R_TEST_R):	/* Received valid TEST rsp */
+			tg->co_status = CO_TEST_OK;
+			/* Fall through */
+
+		case (CO_TEST_OK):
+			tg->co_retries = 0;
+			break;
+
+		case (CO_FAIL):
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return;
+	}
+
+	switch(xid->xid_status)
+	{
+		/* Null Xid poll failed, retry */
+		case (XID_S_NULL):
+			xid->xid_direction = XID_OUTBOUND;
+			xid->xid_status = XID_S_NULL;
+			break;
+
+		case (XID_R_NEG):
+			xid->xid_direction = XID_OUTBOUND;
+			break;
+		default:
+//                      printk("Got XID not handle ignoring\n");
+//			xid->xid_status = XID_RESET;
+			break;
+	}
+
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+	return;
+}
+
+/* Finally activate the actual connection (XIDs) and return to the call
+ * a nice shinny pcid.
+ */
+int sna_cs_activate_route(struct sna_activate_route *ar)
+{
+	struct sna_tdm_node_cb *nc;
+	struct sna_tg_cb *tc;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_pc_pinfo *pc;
+	struct sna_pc_create_parms *pp;
+	struct sna_activate_as *as;
+	char tsap[3];		/* XXX */
+
+	sna_debug(5,"sna_cs_activate_route to %s\n",sna_pr_netid(&ar->cp_name));
+	pc = sna_pc_find_by_netid(&ar->cp_name);
+	if(pc)
+	{
+		sna_debug(5, "found an already active route\n");
+		/* route is already active, this can be either a loopback
+		 * connection or an actual physical connection. No further
+		 * XID negotiation is needed. We just return the Path Control
+		 * ID.
+		 */
+		memcpy(&ar->pc_id, &pc->pc_id, 8);
+		return (0);
+	}
+
+/*
+	nc = sna_tdm_find_node_entry(&ar->cp_name);
+	if(!nc)
+		return (-ENOENT);
+	tc = sna_tdm_find_tg(nc, ar->tg_id);
+*/
+	tc = sna_tdm_find_tg_by_id(ar->tg_id);
+	if(!tc)
+		return (-ENOENT);
+	cs = sna_cs_find("EHEAD   ");
+//	cs = sna_cs_find(ar->cp_name.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name("eth0");
+	if(!dlc)
+		return (-ENOENT);
+	tsap[0] = 0x04;
+	port = sna_cs_find_port(dlc->port_list, tsap);
+	if(!port)
+		return (-ENOENT);
+
+	tc->co_status 			= CO_RESET;
+	tc->xid_info->xid_status 	= XID_RESET;
+	tc->xid_info->xid_initiator 	= 0x00;		/* US */
+	tc->xid_info->xid_direction	= XID_OUTBOUND;
+	sna_cs_connect_out((unsigned long)tc);
+
+	sna_debug(5, "returned from connect_out to sleep\n");
+
+	/* Now we must wait for the link activation to complete */
+	cli();
+	interruptible_sleep_on(&tc->sleep);
+        if(signal_pending(current))
+        {
+        	sti();
+		return (-ERESTARTSYS);
+	}
+	sti();
+
+	sna_debug(5, "woke from sleep.. why?\n");
+
+	/* check reason for being woken up.. test/xid failed, or success */
+	if(tc->co_status != CO_TEST_OK 
+		&& tc->xid_info->xid_status != XID_ACTIVE)
+	{
+		sna_debug(5, "failed activation\n");
+		return (-ENONET);	/* test/xid link activation failed */
+	}
+
+	/* we now have an activated link, lets finish her up */
+	pp = (struct sna_pc_create_parms *)kmalloc
+		(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memcpy(&pp->fqcp, &cs->netid, sizeof(struct sna_netid));
+	pp->dlc		= dlc;
+	pp->ls		= NULL;
+	pp->port	= port;
+	pp->type	= 0;
+	pp->max_tx_btu	= 0; 
+	pp->max_rx_btu	= 0;
+	pp->bind_seg	= 0;
+	pp->limited_tg	= 0;
+	pp->tg_number	= ar->tg_id;
+	pp->odai	= 0;
+	pp->local_seg	= 0;
+	pp->godai	= 0;
+	sna_pc_init(pp);
+	memcpy(&ar->pc_id, &pp->pc_id, 8);
+	kfree(pp);
+
+	/* lets finally activate this links address space and return */
+	as = (struct sna_activate_as *)kmalloc
+		(sizeof(struct sna_activate_as), GFP_ATOMIC);
+	memcpy(&as->pc_id, &ar->pc_id, 8);
+	as->intranode			= 0;
+	as->odai			= 0;
+	as->max_btu			= 0;
+	as->tx_rx_bind_pacing 		= 0;
+	as->dependent_lulu 		= 0;
+	as->adp_bind_pacing_dep_lulu 	= 0;
+	as->generalized_oadi 		= 0;
+	sna_asm_activate_as(as);
+	kfree(as);
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_dlc_cb *dlc;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-7s%-8s%-6s%-10s\n", "dlc_id", 
+		"name", "flags", "port_qlen");
+
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+                len += sprintf(buffer + len, "%-7d%-8s%02X    %-10d\n", 
+			dlc->proc_id, dlc->dev->name, dlc->flags,
+			dlc->port_qlen);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the Port data for the /proc filesystem. */
+        len += sprintf(buffer, "%-17s%-8s%-7s%-5s%-5s%-5s%-5s%-6s%-8s\n", 
+		"NetID.Node",
+		"port_id", "device", "port", "btu", "mia", "moa", "flags", 
+		"ls_qlen");
+
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+        	for(port = dlc->port_list; port != NULL; port = port->next)
+        	{
+			len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&port->netid));
+        	        len += sprintf(buffer + len, "%-8d%-7s%02X   %-5d%-5d%-5d%02X    %-8d\n", 
+				port->proc_id,
+        	                port->dev->name, port->saddr[0], port->btu,
+				port->mia, port->moa, port->flags,
+				port->ls_qlen);
+	
+			pos = begin + len;
+	                if(pos < offset)
+	                {
+	                        len = 0; 
+				begin = pos;
+       	         	}
+                	if(pos > offset + length)
+                        	break;
+        	}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the Link Station data for the /proc filesystem. */
+        len += sprintf(buffer, "%-18s%6s%7s%5s%13s%6s%5s%7s%6s\n", 
+		"NetID.Node", "ls_id", "device", "port", "adjacent_mac",
+		"aport", "aact", "adeact", "flags");
+
+	/* Triple linked lists are always fun. */
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+		for(port = dlc->port_list; port != NULL; port = port->next)
+		{
+        		for(ls = port->ls_list; ls != NULL; ls = ls->next)
+        		{
+                        	len += sprintf(buffer + len, "%-18s",
+					sna_pr_netid(&ls->netid));
+                		len += sprintf(buffer + len, 
+					"%6d%7s   %02X %6s"
+					"    %02X%5d%7d  %04X\n", 
+					ls->proc_id, ls->dlc->dev->name,
+					ls->sport, sna_pr_ether(ls->dname),
+					ls->daddr[0],
+					ls->auto_act, ls->auto_deact,
+					ls->flags);
+
+                			if(pos < offset)
+                			{
+                        			len = 0;
+						begin = pos;
+                			}
+                			if(pos > offset + length) 
+                        			break;
+        		}
+		}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.13/net/sna/sna_dfc.c linux/net/sna/sna_dfc.c
--- linux-2.4.13/net/sna/sna_dfc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_dfc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,1540 @@
+/* sna_dfc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Data Flow Control (DFC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if_ether.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+/* Needs to put data right on the rx_queue of the local listener
+ * corresponding with the bracket ID in the packet.
+ */
+static int sna_dfc_send_to_ps(struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+	struct snathdr *th;
+	__u32 lfsid;
+
+	sna_debug(5, "sna_dfc_send_to_ps\n");
+/*
+	lfsid = sna_pc_find_lfsid_by_daf(skb->th.fm.f5.daf);
+	if(!lfsid)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	rcb = sna_asm_find_rcb_by_lfsid(lfsid);
+	if(!rcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	tcb = sna_cpic_find_tcb_by_id(rcb->tcb_id);
+	if(!tcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+*/
+	th = (struct snathdr *)skb->data;
+	printk("DAF is %02X\n", th->fid.f2.daf);
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if(tcb == NULL)
+	{
+		printk("Not client found\n");
+		return (-1);
+	}
+
+	skb_queue_tail(&tcb->receive_queue, skb);
+	wake_up_interruptible(&tcb->sleep);
+        return (0);
+}
+
+static int sna_dfc_process_ru_data(struct sk_buff *skb)
+{
+	struct snarhdr *rh = (struct snarhdr *)&skb->data[6];
+	struct fmhdr *fm = NULL;
+
+	sna_debug(5, "sna_dfc_process_ru_data\n");
+	/* User Data */
+	if(rh->fi != SNA_RH_FI_FMH)
+	{
+		printk("inside user data if\n");
+
+		/* will never fail for now */
+		if(rh->eci == SNA_RH_ECI_EC || skb->data != NULL)
+                        sna_dfc_send_to_ps(skb);
+                else
+			kfree_skb(skb);
+
+                return (0);
+	}
+
+	/* Control data */
+	fm = (struct fmhdr *)&skb->data[9];
+	printk("FM type is %02X %02X %02X\n", fm->len, fm->type, skb->data[10]);
+        switch(fm->type)
+        {
+                case (FMH_5):    /* ATTACH */
+			sna_rm_process_hs_to_rm(skb);
+
+#ifdef NOT
+                        sna_build_hs_to_ps_header(mu);
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+
+                        /* Received HS_PS_CONNECTED from RM */
+                        lulu->ps_id      = hs_ps_connected->ps_id;
+                        lulu->bracket_id = hs_ps_connected->bracket_id;
+
+                        sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+                        kfree(hs_ps_connected);
+
+                        if(local->half_session == SNA_HS_PRI)
+                                lulu->current_bracket_sqn
+                                        = lulu->shs_bb_register;
+                        else
+                                lulu->current_bracket_sqn
+                                        = lulu->phs_bb_register;
+#endif
+                        break;
+
+                case (FMH_7):    /* Error Description. */
+			sna_dfc_send_to_ps(skb);
+                        break;
+
+                case (FMH_12):    /* Security. */
+#ifdef NOT
+                        mu->layer.hs_to_ps = *(struct sna_hs_to_ps *)kmalloc(sizeof(struct sna_hs_to_ps), GFP_KERNEL);
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+#endif
+                        break;
+
+		default:
+			printk("packet does NOT match anything!!!!!!\n");
+			kfree_skb(skb);
+			break;
+        }
+
+        return (0);
+}
+
+int sna_dfc_send_rsp_to_rm_or_ps(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_send_rsp_to_rm_or_ps\n");
+
+	return (0);
+}
+
+int sna_dfc_generate_rm_ps_inputs(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_generate_rm_ps_inputs\n");
+	sna_dfc_process_ru_data(skb);
+
+	return (0);
+}
+
+int sna_dfc_rcv_fsms(struct sk_buff *skb)
+{
+	sna_dfc_generate_rm_ps_inputs(skb);
+
+	/* if normal flow response */
+//	sna_dfc_send_rsp_to_rm_or_ps(skb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *llucb = &local->lulu;
+        int err;
+
+        err = sna_rcv_state_error(mu);
+        if(err)
+                sna_free_buffer(mu);
+        else
+                llucb->saved_mu_ptr = mu;
+#endif
+
+        return (0);
+}
+
+int sna_dfc_rcv(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_rcv\n");
+	sna_dfc_rcv_fsms(skb);
+
+	return (0);
+}
+
+/* Maintain states by invoking the appropriate FSM while sending requests
+ * and responses.
+ */
+int sna_dfc_send_fsms(struct sk_buff *skb)
+{
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+        struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+        lulu->direction = SNA_HS_SEND;
+        th->snf = lulu->ct_rcv.snf;
+
+        if(req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_NORM)
+        {
+                if(lulu->rqd_required_on_ceb == SNA_DFC_NO)
+                {
+                        lulu->normal_flow_rq_cnt++;
+                        if(lulu->normal_flow_rq_cnt > 24)
+                                lulu->rqd_required_on_ceb = SNA_DFC_YES;
+                }
+                sna_ct_update(mu);
+
+                if(req_h->cebi == SNA_RH_CEBI_CEB)
+                {
+                        if(SNA_DFC_RQE1(req_h))
+                                SNA_DFC_SET_RQD1(req_h);
+
+                        if(SNA_DFC_RQD(req_h))
+                        {
+                                lulu->rqd_required_on_ceb = SNA_DFC_NO;
+                                lulu->normal_flow_rq_cnt = 0;
+                        }
+
+/*
+                        if(rq = SNA_DEALLOCATE_ABEND)
+                                SNA_DFC_SET_RQD1(req_h);
+*/
+                }
+
+                if(sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT)
+                        == SNA_DFC_FSM_PEND_SEND_REPLY)
+                        sna_fsm_chain_rcv_fmp19(mu, 0);
+
+                if(req_h->bbi == SNA_RH_BBI_BB)
+                {
+                        if(lulu->direction == SNA_HS_SEND)
+                        {
+                                if(local->half_session == SNA_HS_PRI)
+                                {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_PRI;
+                                }
+                                else
+                                {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_SEC;
+                                }
+                        }
+                        else
+                        {
+                                if(local->half_session == SNA_HS_PRI)
+                                {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_SEC;
+                                }
+                                else
+                                {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_PRI;
+                                }
+                        }
+
+                        if(req_h->bci == SNA_RH_BCI_BC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_BEGIN_CHAIN);
+                        if(req_h->eci == SNA_RH_ECI_EC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_END_CHAIN);
+                }
+        }
+
+        if(req_h->rri == SNA_RH_RRI_RSP && th->efi == SNA_TH_EFI_NORM)
+        {
+                sna_ct_update(mu);
+                sna_fsm_chain_rcv_fmp19(mu, 0);
+        }
+
+        if(req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_EXP)
+                lulu->sig_rq_outstanding = SNA_DFC_YES;
+#endif
+
+        sna_tc_send_mu(skb);
+
+        return (0);
+}
+
+/* Initialize the TH and RH fields of an MU record. */
+int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snathdr *th;
+	struct snarhdr *rh;
+
+	sna_debug(5, "sna_dfc_init_th_rh\n");
+	skb->h.raw = skb_push(skb, sizeof(struct snarhdr));
+	rh = skb->h.rh;
+	rh->rri		= SNA_RH_RRI_REQ;
+	rh->ru		= SNA_RH_RU_FMD;
+	rh->fi		= SNA_RH_FI_NO_FMH;
+	rh->sdi		= SNA_RH_SDI_NO_SD;
+	rh->rti		= SNA_RH_RTI_POS;
+	rh->bci		= SNA_RH_BCI_NO_BC;
+        rh->eci      	= SNA_RH_ECI_NO_EC;
+        rh->rlwi     	= SNA_RH_RLWI_NO_RLW;
+        rh->qri      	= SNA_RH_QRI_NO_QR;
+        rh->pi       	= SNA_RH_PI_NO_PAC;
+        rh->bbi      	= SNA_RH_BBI_NO_BB;
+        rh->ebi      	= SNA_RH_EBI_NO_EB;
+        rh->cdi      	= SNA_RH_CDI_NO_CD;
+        rh->csi      	= SNA_RH_CSI_CODE0;
+        rh->edi      	= SNA_RH_EDI_NO_ED;
+        rh->cebi     	= SNA_RH_CEBI_NO_CEB;
+
+	if(rcb == NULL)
+	{
+		skb->h.raw[0] = 0x6B;
+		skb->h.raw[1] = 0x81;
+		skb->h.raw[2] = 0;
+	}
+
+	skb->nh.raw = skb_push(skb, sizeof(struct sna_fid2));
+        th = skb->nh.fidh;
+        th->fid.f2.efi          = SNA_TH_EFI_NORM;
+        th->fid.f2.snf.sqn      = 0;
+        th->fid.f2.snf.biui     = 0;
+	if(rcb != NULL)
+	{
+		th->fid.f2.oaf = rcb->oaf;
+		th->fid.f2.daf = rcb->daf;
+	}
+	else
+	{
+		struct sna_fid2_cheat *t = (struct sna_fid2_cheat *)skb->nh.raw;
+		t->bits[0] = 0x2F;	/* 0x2D */
+		t->bits[1] = 0;
+		t->bits[2] = 0;
+		t->bits[3] = 0x02;
+		t->bits[4] = 0x80;
+		t->bits[5] = 0x03;
+/*
+		th->fid.f2.ft  = 0x02;
+		th->fid.f2.mpf = 1;
+		th->fid.f2.efi = 1;
+		th->fid.f2.oaf = 0x02;
+		th->fid.f2.daf = 0x00;
+*/
+	}
+
+        return (0);
+}
+
+/* Send an MU according to passed instructions. */
+static int sna_dfc_send_fmd_mu(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snarhdr *rh;
+	struct sna_ps_to_hs op = rcb->l.ps_to_hs;
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+#endif
+
+	sna_debug(5, "sna_dfc_send_fmd_mu %d %d\n", rcb->oaf, rcb->daf);
+        sna_dfc_init_th_rh(skb, rcb);
+	rh = skb->h.rh;
+
+	if(op.fmh)
+	{
+		printk("putting on FI_FMH\n");
+		rh->fi = SNA_RH_FI_FMH;
+/*
+		if(op.type == SNA_DEALLOCATE_ABEND)
+		{
+			lulu->deallocate_abend = SNA_DFC_YES;
+		}
+*/
+	}
+
+#ifdef NOT
+
+        if(lulu->ct_send.rq_code == SNA_CT_RQCODE_EC)
+        {
+                req_h->bci = SNA_RH_BCI_BC;
+                lulu->betc = SNA_DFC_NO;
+                if(mu->layer.ps_to_hs.allocate == SNA_DFC_YES)
+                        req_h->bbi = SNA_RH_BBI_BB;
+        }
+
+        if(mu->layer.ps_to_hs.type != SNA_MU_FLUSH)
+        {
+        /*      mu->rh = rh_stuff_in_ps_to_hs;  */
+                lulu->betc = SNA_DFC_YES;
+        }
+
+        if(req_h->bci && req_h->eci && mu->biu->ru.ru.raw == NULL)
+        {
+                mu->biu->ru.ru.lustat
+                        = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+        }
+#endif
+
+        sna_dfc_send_fsms(skb);
+        return (0);
+}
+
+/* Process the record received from presentation services (PS) and determine
+ * the proper response (positive or negative) or MU (data or signal) that needs
+ * to be sent to the partner HS via transmission control (TC). If an error
+ * is found while processing the PS_TO_HS record, the buffer will be freed
+ * by this procedure.
+ */
+int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	sna_debug(5, "sna_dfc_send_from_ps\n");
+
+	/* SNA_MU_SEND_DATA_RECORD */
+	sna_dfc_send_fmd_mu(skb, rcb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_ru *ru = &mu->biu->ru;
+
+        if(mu->layer.ps_to_hs.bracket_id == local->lulu.bracket_id)
+        {
+                sna_free_buffer(mu);
+                return (0);
+        }
+
+        switch(mu->layer.ps_to_hs.ps_to_hs_variant)
+        {
+                case (SNA_MU_SEND_DATA_RECORD):
+                        sna_dfc_send_fmd_mu(skb);
+                        break;
+
+                case (SNA_MU_CONFIRMED):
+                        if(lulu->ct_rcv.rq_code == SNA_DFC_RQD2_HEX
+                                || lulu->ct_rcv.rq_code == SNA_DFC_RQD3_HEX)
+                        {
+                                sna_send_rsp_mu(NULL, SNA_NORMAL, SNA_DFC_POS, 0);
+                        }
+                        else
+                                sna_free_buffer(mu);
+                        break;
+
+                case (SNA_MU_SEND_ERROR):
+                        if(local->state == SNA_DFC_FSM_BETC)
+                        {
+                                lulu->send_error_rsp_state = SNA_DFC_NEG_OWED;
+                                sna_free_buffer(mu);
+                        }
+                        else
+                                sna_send_rsp_mu(NULL, SNA_TH_EFI_NORM
+                                        ,SNA_DFC_NEG, 0x08460000);
+                        break;
+
+                case (SNA_MU_REQUEST_TO_SEND):
+                        sna_init_th_rh(mu);
+                        ru->ru.sig = *(struct sna_ru_sig *)kmalloc(sizeof(struct sna_ru_sig), GFP_KERNEL);
+                        local->rq_code = SNA_LOCAL_SIG;
+                        sna_dfc_send_fsms(mu);
+                        break;
+
+                default:
+                        return (-1);
+        }
+#endif
+
+        return (0);
+}
+
+#ifdef NOT
+
+static int sna_try_to_rcv_signal(struct sna_mu *mu);
+static int sna_build_hs_to_ps_header(struct sna_mu *mu);
+static int sna_ct_update(struct sna_mu *mu);
+static int sna_format_error(struct sna_mu *mu);
+static int sna_format_error_exp_rsp(struct sna_mu *mu);
+static int sna_format_error_norm_rsp(struct sna_mu *mu);
+static int sna_format_error_rq_dfc(struct sna_mu *mu);
+static int sna_format_error_rq_fmd(struct sna_mu *mu);
+static int sna_invalid_sense_code(struct sna_mu *mu);
+static int sna_ok_to_reply(struct sna_mu *mu);
+static int sna_rcv_state_error(struct sna_mu *mu);
+static int sna_reply_to_bid(struct sna_mu *mu);
+static int sna_send_bid_pos_rsp(struct sna_mu *mu);
+static int sna_send_rsp_if_required(struct sna_mu *mu);
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense);
+static int sna_signal_status(struct sna_mu *mu);
+static int sna_stray_rsp(struct sna_mu *mu);
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal);
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu);
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu);
+
+/* Process records received from the resource manager (RM). This procedure
+ * is called by the half session router.
+ */
+int sna_dfc_send_from_rm(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_ru *ru = &mu->biu->ru;
+
+	switch(mu->record_type)
+	{
+		case (SNA_REC_BID_WITHOUT_ATTACH):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM, 
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.lustat = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_REPLY):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.bis = *(struct sna_ru_bis *)kmalloc(sizeof(struct sna_ru_bis), GFP_KERNEL);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BRACKET_FREED):
+			sna_free_buffer(mu);
+			break;
+
+		case (SNA_REC_HS_PS_CONNECTED):
+			lulu->ps_id = hs_ps_connected->ps_id;
+			local->lulu.bracket_id = hs_ps_connected->bracket_id;
+
+			sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			else
+			{
+				lulu->current_bracket_sqn.number
+					= lulu->sqn_send_cnt.number++;
+				lulu->current_bracket_sqn.bracket_started_by
+					= local->half_session;
+				if(local->half_session == SNA_HS_PRI)
+					lulu->phs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+				else
+					lulu->shs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+			}
+			break;
+
+		case (SNA_REC_RTR_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.rtr = *(struct sna_ru_rtr *)kmalloc(sizeof(struct sna_ru_rtr), GFP_KERNEL);
+			local->rq_code = SNA_LOCAL_RTR;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_YIELD_SESSION):
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.lustat = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+			local->rq_code = SNA_LOCAL_LUSTAT;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_SECURITY_REPLY_2):
+			if(ru->ru.security_reply_2.send_parm.type 
+				== SNA_MU_DEALLOCATE_FLUSH)
+			{
+				lulu->session_just_started = SNA_DFC_NO;
+			}
+
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			ru->ru.security_reply_2 = *(struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_KERNEL);
+			sna_send_fmd_mu(mu);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+/* This procedure determines if a REQUEST_TO_SEND record should be sent
+ * to PS to indicate a SIGNAL has been received. This procedure is called
+ * by the half-session router.
+ */
+static int sna_try_to_rcv_signal(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+
+	if(sna_fsm_bsm_fmp19(0, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB
+		&& lulu->sig_received == SNA_DFC_YES)
+	{
+		switch(sna_signal_status(mu))
+		{
+			case (SNA_DFC_SIG_CURRENT):
+				sna_dfc_send_to_ps(NULL);
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_STRAY):
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_FUTURE):
+				break;
+		}
+	}
+
+	return (0);
+}
+
+/* Process MUs received from TC. This procedure is called by TC. */
+int sna_dfc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u32 err;
+
+	lulu->direction = SNA_HS_RECEIVE;
+	if(local->sense == 0x00000000)
+	{
+		if(req_h->ru == SNA_RH_RU_DFC)
+		{
+			local->rq_code = req_h->rri;
+			if(local->rq_code == SNA_LOCAL_NO_CRV
+				|| local->rq_code == SNA_LOCAL_NO_BIS
+				|| local->rq_code == SNA_LOCAL_NO_LUSTAT
+				|| local->rq_code == SNA_LOCAL_NO_RTR
+				|| local->rq_code == SNA_LOCAL_NO_SIG)
+			{
+				local->rq_code = SNA_LOCAL_OTHER;
+			}
+		}
+		else
+			local->rq_code = SNA_LOCAL_OTHER;
+
+		err = sna_format_error(mu);
+		if(err)
+		{
+			sna_free_buffer(mu);
+			local->sense = err;
+			return (0);
+		}
+
+		if(req_h->rri == SNA_RH_RRI_REQ)
+		{
+			if(th->efi == SNA_TH_EFI_NORM)
+				sna_dfc_rcv_fsms(mu);
+			else
+			{
+				lulu->sig_received = SNA_DFC_YES;
+				lulu->sig_snf = th->snf;
+				sna_send_rsp_mu(mu, SNA_TH_EFI_EXP, 
+					SNA_DFC_POS, 0);
+				sna_free_buffer(mu);
+			}
+		}
+		else
+		{
+			if(sna_stray_rsp(mu))
+				sna_free_buffer(mu);
+			else
+				sna_dfc_rcv_fsms(mu);
+		}
+	}
+
+	return (0);
+}
+
+int sna_dfc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_mu *mu = NULL;
+
+	lulu->first_speaker 				= init_hs->type;
+	lulu->alternate_code				= SNA_DFC_TRUE;
+	lulu->sqn_send_cnt.number			= 0;
+	lulu->current_bracket_sqn.bracket_started_by 	= SNA_HS_PRI;
+	lulu->current_bracket_sqn.number 		= 0;
+	lulu->phs_bb_register.bracket_started_by 	= SNA_HS_PRI;
+	lulu->phs_bb_register.number 			= 0;
+	lulu->shs_bb_register.bracket_started_by 	= SNA_HS_SEC;
+	lulu->shs_bb_register.number 			= 0;
+	lulu->rqd_required_on_ceb 			= SNA_DFC_NO;
+	lulu->normal_flow_rq_cnt 			= 0;
+	lulu->sig_received 				= SNA_DFC_NO;
+	lulu->sig_snf.number 				= 0;
+	lulu->ps_id 					= 0;
+
+	/* Reset all FSMs to state 1 */
+
+	lulu->betc 			= SNA_DFC_YES;
+	lulu->send_error_rsp_state 	= 1; 
+	lulu->bb_rsp_state 		= 1;
+	lulu->rtr_rsp_state 		= 1;
+	lulu->sig_rq_outstanding 	= SNA_DFC_NO;
+
+	if(local->half_session == SNA_HS_PRI)
+		lulu->session_just_started = SNA_DFC_YES;
+	else
+		lulu->session_just_started = SNA_DFC_NO;
+
+	lulu->saved_mu_ptr = mu;
+	sna_dfc_send_to_ps(mu);
+
+        return (0);
+}
+
+/* Fill in mu->hs_to_ps_header based on the contents of mu->rh. */
+static int sna_build_hs_to_ps_header(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu->header_type = SNA_MU_HS_TO_PS;
+	mu->layer.hs_to_ps.fmh = SNA_DFC_NO;
+
+	if(req_h->fi == SNA_RH_FI_FMH)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			mu->layer.hs_to_ps.fmh = SNA_DFC_YES;
+		else
+			mu->dcf = sizeof(mu->biu->rh);
+	}
+
+	if(req_h->eci == SNA_RH_ECI_EC)
+	{
+		if(SNA_DFC_RQE1(req_h) && req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_FLUSH;
+
+		if(SNA_DFC_RQ1(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_FLUSH;
+		
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cdi != SNA_RH_CDI_CD
+			&& req_h->cebi != SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_CONFIRM;
+
+		if((SNA_DFC_RQ2(req_h) || SNA_DFC_RQ3(req_h)) 
+			&& req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_CONFIRM;
+
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_CONFIRM;
+	}
+	else
+		mu->layer.hs_to_ps.type = SNA_MU_NOT_END_OF_DATA;
+
+	return (0);
+}
+
+/* Record information about the last chain sent or received. This is done by
+ * updating the correlation table entry.
+ */
+static int sna_ct_update(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ct *ct = &local->lulu.ct_rcv;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->bci == SNA_RH_BCI_BC)
+		{
+			ct->entry_present	= SNA_DFC_YES;
+			ct->snf 		= th->snf;
+			ct->neg_rsp_sense 	= 0;
+			ct->rh.rh.req_h.ru 	= req_h->ru;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+				ct->rq_code = local->rq_code;
+			else
+				ct->rq_code = SNA_CT_OTHER;
+
+		}
+
+		if(req_h->eci == SNA_RH_ECI_EC)
+			ct->rh.rh.req_h.ru = req_h->ru;
+	}
+	else
+	{
+		if(rsp_h->sdi == SNA_RH_SDI_SD)
+			ct->neg_rsp_sense = local->sense;
+	}
+
+	return (0);
+}
+
+/* Perform format checks on all requests and responses for LU-LU session.
+ * These checks are optional. If an error is detected, the local->sense
+ * is set to the appropriate sense data. None, some, or all of these checks
+ * may be done.
+ */
+static int sna_format_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int rcode;
+
+	rcode = SNA_DFC_FALSE;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			sna_format_error_rq_fmd(mu);
+		else
+			sna_format_error_rq_dfc(mu);
+	}
+
+	if(th->efi == SNA_TH_EFI_NORM)
+		sna_format_error_norm_rsp(mu);
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		sna_format_error_exp_rsp(mu);
+
+	if(local->sense != 0x00000000)
+		rcode = SNA_DFC_TRUE;
+
+	return (rcode);
+}
+
+/* Perform format checks on expedited-flow responses. These checks are
+ * optional.
+ */
+static int sna_format_error_exp_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x40110000;
+
+	if(req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->qri == SNA_RH_QRI_QR)
+		local->sense = 0x40150000;
+
+	if(local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x40120000;
+
+	if(rsp_h->rti == SNA_RH_RTI_NEG)
+		memcpy(&local->sense, &mu->biu->ru, 4);
+
+	return (0);
+}
+
+/* Perform format checks on normal-flow responses. These checks are optional. */
+static int sna_format_error_norm_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC && req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F000;
+
+	if(req_h->ru == SNA_RH_RU_FMD && rsp_h->rti == SNA_RH_RTI_POS 
+		&& req_h->fi == SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if((rsp_h->rti == SNA_RH_RTI_NEG
+		&& *(__u32 *)mu->biu->ru.ru.raw != 0x08130000)
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08140000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08190000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08460000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x088B0000)
+	{
+		local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+	}
+
+	return (0);
+}
+
+/* Perform format checks for data flow control (DFC) request. These checks
+ * are optional.
+ */
+static int sna_format_error_rq_dfc(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(th->efi == SNA_TH_EFI_NORM && (local->rq_code != SNA_LOCAL_BIS 
+		|| local->rq_code != SNA_LOCAL_LUSTAT
+		|| local->rq_code != SNA_LOCAL_RTR))
+	{
+		local->sense = 0x10030000;
+	}
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x10030000;
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code == SNA_LOCAL_SIG)
+	{
+		local->sense = 0x10050000;
+	}
+
+	if(req_h->fi != SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->edi == SNA_RH_EDI_ED)
+		local->sense = 0x40160000;
+
+	if(req_h->pdi == SNA_RH_PDI_PD)
+		local->sense = 0x40170000;
+
+	/* Other wise. */
+	if(local->rq_code == SNA_LOCAL_LUSTAT)
+	{
+		if(mu->dcf > sizeof(struct sna_ru_lustat))
+		{
+			if(mu->biu->ru.ru.lustat.status)
+				sna_format_error_rq_fmd(mu);
+			else
+				return (0);
+		}
+	}
+
+	return (0);
+}
+
+/* Perform format checks on FM data (FMD) requests. The checks are optional. */
+static int sna_format_error_rq_fmd(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_fmh1 *fmh = &mu->biu->ru.ru.fmh1;
+	int fmh_type;
+
+	fmh_type = fmh->type;
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		local->sense = 0x40110000;
+
+	if(!SNA_DFC_RQD(req_h) || !SNA_DFC_RQE(req_h))
+		local->sense = 0x40140000;
+
+	if(1)	/* See SNA formats RH formats 5.2-2 */
+		local->sense = 0x40070000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		local->sense = 0x40030000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->ru == SNA_RH_RU_FMD
+		&& req_h->fi != SNA_RH_FI_FMH)
+	{
+		local->sense = 0x40003000;
+	}
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->ebi == SNA_RH_EBI_EB)
+		local->sense = 0x40040000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40090000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && SNA_DFC_RQD1(req_h))
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40040000;
+
+	if(req_h->bci == SNA_RH_BCI_BC && ((req_h->bbi == SNA_RH_BBI_BB
+		&& req_h->qri == SNA_RH_QRI_NO_QR) 
+		||(req_h->bbi == SNA_RH_BBI_BB || req_h->qri == SNA_RH_QRI_QR)))
+		local->sense = 0x40180000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->cdi == SNA_RH_CDI_CD)
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB 
+		&& (SNA_DFC_RQE2(req_h) || SNA_DFC_RQE3(req_h)))
+		local->sense = 0x40040000;
+
+	if(req_h->cebi == SNA_RH_CEBI_NO_CEB && req_h->cdi == SNA_RH_CDI_NO_CD
+		&& req_h->eci == SNA_RH_ECI_EC && SNA_DFC_RQE(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_NO_CEB
+		&& SNA_DFC_RQD1(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->cebi == SNA_RH_CEBI_CEB
+		&& SNA_DFC_RQE1(req_h))
+		local->sense = 0x40040000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_CEB
+		&& fmh->type == SNA_FMH_HDR_ERROR && SNA_DFC_RQE(req_h))
+		local->sense = 0x40060000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->ru == SNA_RH_RU_FMD
+		&& (fmh->type != SNA_FMH_HDR_ATTACH 
+		|| fmh->type != SNA_FMH_HDR_ERROR))
+	{
+		if(fmh->type == SNA_FMH_HDR_SECURITY)
+		{
+			if(req_h->eci == SNA_RH_ECI_EC 
+				&& req_h->cebi == SNA_RH_CEBI_NO_CEB)
+				local->sense = 0x080F6051;
+		}
+		else
+			local->sense = 0x10084001;
+	}
+
+	return (0);
+}
+
+/* Determine if sense data on a negative response is valid. */
+static int sna_invalid_sense_code(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(req_h->rri == SNA_RH_RRI_RSP && req_h->bbi == SNA_RH_BBI_BB)
+	{
+		if(local->half_session == SNA_HS_PRI)
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x08140000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x0814000
+				|| local->sense != 0x088B0000)
+			{
+				return (SNA_DFC_TRUE);
+			}
+		}
+	}
+	else
+	{
+		if(req_h->rri == SNA_RH_RRI_RSP 
+			&& req_h->bbi == SNA_RH_BBI_NO_BB)
+		{
+			if(local->sense == 0x08190000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(req_h->rri == SNA_RH_RRI_RSP)
+				return (SNA_DFC_TRUE);
+			else
+			{
+				if(local->sense == 0x08460000)
+					return (SNA_DFC_TRUE);
+			}
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine whether or not a request is a valid reply. A reply is a request
+ * sent (or received) after receiving (or sending) an (RQE,CD) request.
+ */
+static int sna_ok_to_reply(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_BIS || local->rq_code == SNA_LOCAL_RTR)
+		return (SNA_DFC_FALSE);
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		return (SNA_DFC_FALSE);
+
+	if((sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_SEND_REPLY)
+		|| (sna_fsm_chain_send_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_RCV_REPLY))
+		return (SNA_DFC_FALSE);
+
+	if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB)
+		return (SNA_DFC_FALSE);
+
+	return (SNA_DFC_TRUE);
+}
+
+/* Perform state error checking on received RQ/RSP. The types of errors
+ * found here are protocol violations by the sender of the RQ/RSP. These
+ * checks are optional. None, some, or all of the checks may be made.
+ */
+static int sna_rcv_state_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(th->efi == SNA_TH_EFI_EXP && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		{
+			local->sense = 0x200E0000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal Flow request. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_BB 
+			&& mu->biu->ru.ru.fmh1.type != FMH_5)
+		{
+			if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+				return (SNA_DFC_TRUE);	/* local->sense set. */
+		}
+
+		if(SNA_DFC_RQE(req_h) && req_h->bbi == SNA_RH_BBI_BB 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+		{
+			local->sense = 0x40040000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal flow response. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(rsp_h->ru != req_h->ru)
+		{
+			local->sense = 0x40110000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->ru == SNA_RH_RU_DFC
+			&& rsp_h->rri != req_h->rri)
+		{
+			local->sense = 0x40120000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->qri != req_h->qri)
+		{
+			local->sense = 0x40210000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(sna_invalid_sense_code(mu))
+		{
+			local->sense = 0x20120000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine if a normal-flow request is a reply to a BID request. A reply
+ * is a request sent (or received) immediately after receving (or sending) a
+ * request carrying (RQE, CD. A reply implies a positive response to the
+ * (RQE, CD) request.
+ */
+static int sna_reply_to_bid(struct sna_mu *mu)
+{
+//	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(sna_ok_to_reply(mu))
+		return (SNA_DFC_TRUE);
+	else
+		return (SNA_DFC_FALSE);
+}
+
+/* Send RM a positive reponse to a BID, and receive the HS_PS_CONNECTED
+ * record that will result in this half-session being connected to a PS.
+ */
+static int sna_send_bid_pos_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_bid_rsp *pos_bid;
+
+	pos_bid = (struct sna_bid_rsp *)kmalloc(sizeof(struct sna_bid_rsp), 
+		GFP_KERNEL);
+	pos_bid->hs_id = local->hs_id;
+	pos_bid->sense = 0;
+	sna_send_to_rm(mu);
+
+	/* Receive the hs_ps_connected record. */
+	lulu->ps_id 		= hs_ps_connected->ps_id;
+	lulu->bracket_id 	= hs_ps_connected->bracket_id;
+
+	sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+	kfree(hs_ps_connected);
+
+	lulu->current_bracket_sqn.number = 0;
+
+	return (0);
+}
+
+/* Send a response to the passed MU if required. */
+static int sna_send_rsp_if_required(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_TH_EFI_NORM, SNA_DFC_POS, 0);
+		else
+		{
+			if(SNA_DFC_RQE(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+				printk("error\n");
+			else
+				sna_send_rsp_mu(mu, SNA_TH_EFI_NORM,SNA_DFC_NEG,
+					lulu->bb_rsp_sense);
+		}
+
+		lulu->bb_rsp_state = 0;
+		lulu->bb_rsp_sense = 0;
+	}
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+		else
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG,
+				lulu->rtr_rsp_sense);
+
+		lulu->rtr_rsp_state = 0;
+	}
+
+	if(SNA_DFC_NEG_RSP(req_h))
+	{
+		if((req_h->bci == SNA_RH_BCI_BC && req_h->ru == SNA_RH_RU_FMD)
+			|| (req_h->ru == SNA_RH_RU_DFC
+			&& req_h->bbi != SNA_RH_BBI_BB))
+		{
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG, 0x08460000);
+			lulu->send_error_rsp_state = 0;
+		}
+	}
+
+	if(sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		== SNA_DFC_FSM_PEND_REPLY)
+		sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+
+	return (0);
+}
+
+/* Create and send a response. The response is based on the request MU (if
+ * passed by the caller) or on information about the last chain received
+ * (if a null MU is passed).
+ */
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_ct *ct = &lulu->ct_send;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int direction;
+	int null_mu = 0;
+
+	if(mu == NULL)
+	{
+		null_mu = 1;
+		mu = sna_get_buffer(SNA_BM_TYPE_PERM, local->perm_buf_pool_id,
+			0, SNA_BM_NO_WAIT);
+	}
+
+	sna_init_th_rh(mu);
+	mu->dcf 	= sizeof(struct sna_req_h);
+	req_h->rri 	= SNA_RH_RRI_RSP;
+	req_h->bci 	= SNA_RH_BCI_BC;
+	req_h->eci 	= SNA_RH_ECI_EC;
+
+	if(rsp == SNA_DFC_NEG)
+	{
+		req_h->sdi 	= SNA_RH_SDI_SD;
+		rsp_h->rti 	= SNA_RH_RTI_NEG;
+		mu->dcf 	+= sizeof(mu->biu->ru.ru);
+		local->sense 	= sense;
+	}
+	else
+		rsp_h->rti = SNA_RH_RTI_POS;
+
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		if(null_mu)
+		{
+			req_h->ru 	= ct->rh.rh.rsp_h.ru;
+			req_h->dr1i 	= ct->rh.rh.rsp_h.dr1i;
+			req_h->dr2i 	= ct->rh.rh.rsp_h.dr2i;
+			req_h->qri 	= ct->rh.rh.rsp_h.qri;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+				local->rq_code = ct->rq_code;
+			}
+		}
+		else
+		{
+			req_h->ru 	= req_h->ru;
+			req_h->dr1i 	= req_h->dr1i;
+			req_h->dr2i 	= req_h->dr2i;
+			req_h->qri 	= req_h->qri;
+			local->rq_code 	= req_h->csi;
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+			}
+		}
+	}
+	else
+	{
+		th->efi = SNA_TH_EFI_EXP;
+		req_h->ru = SNA_RH_RU_DFC;
+		req_h->dr1i = req_h->dr1i;
+		local->rq_code = SNA_LOCAL_SIG;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC)
+		req_h->fi = SNA_RH_FI_FMH;
+
+	direction = lulu->direction;
+	lulu->direction = SNA_HS_SEND;
+	if(!sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		sna_dfc_send_fsms(mu);
+	else
+		sna_free_buffer(mu);
+
+	lulu->direction = direction;
+
+	return (0);
+}
+
+/* Determine if a SIGNAL is for a past, current, or future bracket. The
+ * in-bracket (INB) state exists when this procedure is called.
+ */
+static int sna_signal_status(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	int result, reg;
+
+	if(lulu->current_bracket_sqn.number 
+		== lulu->current_bracket_sqn.number)
+		return (SNA_DFC_SIG_CURRENT);
+
+	if(SNA_HS_PRI)
+		reg = lulu->phs_bb_register.number;
+	else
+		reg = lulu->shs_bb_register.number;
+
+	result = (lulu->sig_snf.number -  reg) % 25;
+	if(result < 0)
+	{
+		result += 25;
+		if(result == 0)
+			return (SNA_DFC_SIG_STRAY);
+		if(result == 24)
+			return (SNA_DFC_SIG_FUTURE);
+		if(result > 24)
+			return (SNA_DFC_SIG_STRAY);
+	}
+
+	return (0);
+}
+
+/* Determines if a response is stray. (A stray response is one that was sent
+ * in a bracket (conversation) but recevied in a different (later bracket).
+ */
+static int sna_stray_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_RTR)
+	{
+		local->sense = 0x200E0000;
+		return (SNA_DFC_TRUE);
+	}
+
+	if(local->rq_code == SNA_LOCAL_SIG)
+		return (SNA_DFC_TRUE);
+
+	if(local->rq_code == SNA_LOCAL_LUSTAT || req_h->ru == SNA_RH_RU_FMD)
+	{
+		/* More. */
+		return (SNA_DFC_TRUE);
+	}
+
+	/* More. */
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Enforce the bracket protocol. State transitions are forced via the input
+ * signals INB (go in brackets) and BETB (go between bracket). The inputs R,
+ * RQ, ... are used for error checking only. INB state means DFC (the half
+ * session) is connected to a PS; BETB state means DFC is not connected to a
+ * PS.
+ */
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(local->state == SNA_DFC_FSM_BETB)
+	{
+		if(signal == SNA_DFC_FSM_INB)
+			local->state = SNA_DFC_FSM_INB;
+		else
+			local->sense = 0x20030000;
+		return (0);
+	}
+
+	if(local->state == SNA_DFC_FSM_INB)
+	{
+		if(signal == SNA_DFC_FSM_BETB)
+			local->state = SNA_DFC_FSM_BETB;
+		
+		return (0);
+	}
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for received chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been received and any required
+ * associated response or reply has been sent. A reply is a request sent after
+ * receiving an (RQE, CD) chain that has not been negatively responsed to. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for sending chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been sent and any required associated
+ * response or reply has been received. A reply is a request recevied after
+ * sending an (RQE, CD) chain that has not received a negative response. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the setting of the QRI indicator in the RH. This indicator is
+ * set the same for all MUs in a chain; ie. all MUs in a chain have QRI = QR
+ * or have QRI = -QR.
+ */
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+/* Maintain a purging state for received BB chains that have been negatively
+ * responded to indicating a bracket error (0813, 0814, 088B). It is called
+ * with a PURGE signal when the negative response is sent and reset when
+ * the end-of-chain (EC) RU is received. When in the purging state, no records
+ * are generated for PS or RM as a result of receiving a request RU in the
+ * BB chain (ie. the remainder of the BB chain is purged).
+ */
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_dlc.c linux/net/sna/sna_dlc.c
--- linux-2.4.13/net/sna/sna_dlc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_dlc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,267 @@
+/* sna_dlc.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif
+
+#ifdef CONFIG_SNA_LOOPBACK
+int sna_loopback_xmit(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_loopback_xmit\n");
+	netif_rx(skb);
+	return (0);
+}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+int sna_dlc_gen_rsp(int type, struct sk_buff *skb)
+{
+	llchdr *llc;
+        struct sk_buff *newskb;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct net_device *dev = skb->dev;
+        int size;
+
+        sna_debug(5, "sna_dlc_gen_rsp\n");
+	switch(type)
+	{
+		case (LLC_STATE_REMOTE_RESET_INDICATION):	/* Out */
+		case (LLC_STATE_RECEIVE_SABME_CMD):		/* In */
+		{
+			struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc SAMBE cmd received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+                                struct sna_xid_info *xid = tg->xid_info;
+                                del_timer(&xid->xid_timer);
+				xid->xid_status = XID_ACTIVE;
+				sna_cs_connect_out((unsigned long)tg);
+			}
+
+			/* Send SAMBE response */
+			size = dev->hard_header_len + 3;
+        		newskb = alloc_skb(size, GFP_ATOMIC);
+        		skb_reserve(newskb, 3);
+        		skb_reserve(newskb, dev->hard_header_len);
+        		newskb->dev = dev;
+			llc = (llchdr *)skb_push(newskb, 3);
+                        llc->dsap       = 0x04;
+                        llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_UA_RSP;
+			llc->ctrl.uctrl.pf = 1;
+			break;
+		}
+
+		case (LLC_STATE_RECEIVE_RR_CMD):
+			size = dev->hard_header_len + 3 + 2;
+                        newskb = alloc_skb(size, GFP_ATOMIC);
+                        skb_reserve(newskb, 3 + 2);
+                        skb_reserve(newskb, dev->hard_header_len);
+                        newskb->dev = dev;
+			llc = (llchdr *)skb_push(newskb, 3 + 2);
+                        llc->dsap       = 0x04;
+                        llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_RR_RSP;
+			llc->ctrl.ictrl.ns = 1;
+			llc->ctrl.ictrl.nr = 1;
+			llc->ctrl.ictrl.pf = 1;
+                        break;
+
+		case (LLC_STATE_RECEIVE_DISC_CMD):
+		{
+                        struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc SAMBE cmd received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+                                struct sna_xid_info *xid = tg->xid_info;
+                                del_timer(&xid->xid_timer);
+                                xid->xid_status = XID_RESET;
+                        }
+
+                        /* Send DISC/UA response */
+                        size = dev->hard_header_len + 3;
+                        newskb = alloc_skb(size, GFP_ATOMIC);
+                        skb_reserve(newskb, 3);
+                        skb_reserve(newskb, dev->hard_header_len);
+                        newskb->dev = dev;
+                        llc = (llchdr *)skb_push(newskb, 3);
+                        llc->dsap       = 0x04;
+			llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_UA_RSP;
+                        llc->ctrl.uctrl.pf = 1;
+                        break;
+                }
+
+		default:
+			kfree_skb(skb);
+			return (0);
+	}
+
+	if(sna_debug_level > 5)
+        {
+                printk("Lets see a nice LLC RSP for SNA\n");
+                hexdump(newskb->data, newskb->len);
+        }
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+        dev_queue_xmit(newskb);
+        kfree_skb(skb);
+
+	return (0);
+}
+
+int sna_dlc_llc_rcv(struct sk_buff *skb, struct net_device *dev,
+	struct packet_type *pt)
+{
+	llchdr *llc_hdr = (llchdr *)skb->data;
+	int err;
+
+	sna_debug(5, "sna_dlc_llc_rcv\n");
+	switch(llc_decode_pdu(llc_hdr))
+	{
+		case (LLC_XID_CMD):
+                        sna_debug(5, "llc XID cmd received passing to cs\n");
+			sna_cs_connect_in(skb, dev);
+			break;
+
+		case (LLC_XID_RSP):
+		{
+                        struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc XID rsp received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+				struct sna_xid_info *xid = tg->xid_info;
+
+				del_timer(&xid->xid_timer);
+				if(xid->last_rx_xid != NULL)
+                                	kfree_skb(xid->last_rx_xid);
+				xid->last_rx_xid = skb;
+				xid->xid_count++;
+
+				/* determine type of xid packet */
+				switch(sna_cs_xid_xchg_state(skb))
+				{
+					case (XID_NULL):
+						xid->xid_status = XID_R_NULL;
+						break;
+
+					case (XID_NEG):
+						xid->xid_status = XID_R_NEG;
+						break;
+
+					case (XID_PN):
+						xid->xid_status = XID_R_PN;
+						break;
+
+					default:
+						sna_debug(5, "Got XID not handle reset\n");
+						xid->xid_status = XID_RESET;
+						break;
+				}
+
+                                sna_cs_connect_out((unsigned long)tg);
+                        }
+                        break;
+
+                }
+
+		case (LLC_I_CMD):
+			sna_debug(5, "llc I cmd received \n");
+			err = sna_pc_mu_error_checker(skb);
+			if(err < 0)
+			{
+				/* Should send proper sense code */
+				kfree_skb(skb);
+				return (-1);
+			}
+			sna_pc_mu_rcv_router(skb);
+			break;
+
+		case (LLC_TEST_CMD):
+			sna_debug(5, "Got TEST_CMD\n");
+			break;
+
+		case (LLC_TEST_RSP):
+		{
+			struct ethhdr *eth_hdr = skb->mac.ethernet;
+			struct sna_tg_cb *tg;
+
+			sna_debug(5, "Got TEST RSP\n");
+			tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+			if(tg)
+			{
+				kfree_skb(skb);
+				del_timer(&tg->co_retry);
+				tg->co_status = CO_R_TEST_R;
+				sna_cs_connect_out((unsigned long)tg);
+			}
+			break;
+		}
+
+		default:
+			kfree_skb(skb);
+			break;
+	}
+
+	return (0);
+}
+
+int sna_dlc_llc_event(int rsp, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dlc_llc_event %02X\n", rsp);
+	sna_dlc_gen_rsp(rsp, skb);
+
+	return (0);
+}
+#endif	/* CONFIG_SNA_LLC */
diff -ruN linux-2.4.13/net/sna/sna_ds.c linux/net/sna/sna_ds.c
--- linux-2.4.13/net/sna/sna_ds.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ds.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,142 @@
+/* sna_ds.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_ds_pinfo *ds_clients = NULL;
+
+int sna_ds_insert(struct sna_ds_pinfo *ds)
+{
+	sna_debug(5, "sna_ds_insert\n");
+        ds->next = ds_clients;
+        ds_clients = ds;
+
+        return (0);
+}
+
+struct sna_ds_pinfo *sna_ds_find(__u8 *name)
+{
+	struct sna_ds_pinfo *f;
+
+	for(f = ds_clients; f != NULL; f = f->next)
+                if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                        break;
+
+        return (f);
+}
+
+int sna_ds_shutdown(void)
+{
+        struct sna_ds_pinfo *d;
+        struct sna_ds_pinfo **clients = &ds_clients;
+        unsigned long flags;
+
+        printk("sna_ds_shutdown\n");
+
+        save_flags(flags);
+        cli();
+
+        while((d = *clients) != NULL)
+        {
+                *clients = d->next;
+                kfree(d);
+        }
+
+        restore_flags(flags);
+
+        return (0);
+}
+
+int sna_ds_create(struct sna_start_node *start)
+{
+	struct sna_ds_pinfo *ds;
+
+	sna_debug(5, "sna_ds_create %s\n", start->netid.name);
+	ds = sna_ds_find(start->netid.name);
+	if(ds)
+		return (-EEXIST);
+	ds = (struct sna_ds_pinfo *)kmalloc(sizeof(struct sna_ds_pinfo), 
+		GFP_ATOMIC);
+	memcpy(&ds->netid, &start->netid, sizeof(struct sna_netid));
+	ds->next = NULL;
+	ds->prev = NULL;
+
+        sna_ds_insert(ds);
+	return (0);
+}
+
+int sna_ds_destroy(struct sna_delete_node *delete)
+{
+        struct sna_ds_pinfo *ds, **clients = &ds_clients;
+
+        sna_debug(5, "sna_ds_destroy\n");
+        while((ds = *clients) != NULL)
+        {
+                if(!strncmp(ds->netid.name, delete->netid.name, 8))
+                {
+                        *clients = ds->next;
+                        kfree(ds);
+                        return (0);
+                }
+                clients = &ds->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_ds_update_directory(void)
+{
+
+	return (0);
+}
+
+int sna_ds_update_cp_status(void)
+{
+
+	return (0);
+}
+
+int sna_ds_locate_message(void)
+{
+
+	return (0);
+}
+
+int sna_ds_request_local_search(void)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_ebcdic.c linux/net/sna/sna_ebcdic.c
--- linux-2.4.13/net/sna/sna_ebcdic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ebcdic.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,186 @@
+/* sna_ebcdic.c: Linux-SNA EBCDIC/ASCII converter.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+
+#include <linux/sna.h>
+
+unsigned char etor(unsigned char a)
+{
+        return(ebcdic_to_rotated[a]);
+}
+
+char *etor_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = etor(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+/* Convert a single charater from EBCDIC to ASCII */
+unsigned char etoa(unsigned char a)
+{
+        return(ebcdic_to_ascii_sna[a]);
+}
+
+/* Convert a single character from ASCII to EBCDIC */
+unsigned char atoe(unsigned char a)
+{
+	return(ascii_to_ebcdic_sna[a]);
+}
+
+char *atoe_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while((*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *etoa_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while((*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *atoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *fatoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count--)
+		(*dest++ = atoe(*src++));
+
+	return (tmp);
+}
+
+char *etoa_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+int atoe_strcmp(const char *acs, const char *ect)
+{
+        register signed char __res;
+
+        while(1)
+        {
+                if((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+        }
+
+        return (__res);
+}
+
+int etoa_strcmp(const char *ecs, const char *act)
+{
+        register signed char __res;
+
+        while(1)
+        {
+                if((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+        }
+
+        return (__res);
+}
+
+int atoe_strncmp(const char *acs, const char *ect, size_t count)
+{
+        register signed char __res = 0;
+
+        while(count)
+        {
+                if((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+                count--;
+        }
+
+        return (__res);
+}
+
+int etoa_strncmp(const char *ecs, const char *act, size_t count)
+{
+        register signed char __res = 0;
+
+        while(count)
+        {
+                if((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+                count--;
+        }
+
+        return (__res);
+}
+
+#define nibble(v, w)    ((v >> (w * 4)) & 0x0F)
+
+static unsigned char rbits[16] = {
+        0x00, 0x08, 0x04, 0x0C, 0x02, 0x0A, 0x06, 0x0E,
+        0x01, 0x09, 0x05, 0x0D, 0x03, 0x0B, 0x07, 0x0F
+};
+
+unsigned char flip_nibble(unsigned char v)
+{
+        return (rbits[v & 0x0F]);
+}
+
+unsigned char flip_byte(unsigned char v)
+{
+        return ((flip_nibble(nibble(v, 0)) << 4) | flip_nibble(nibble(v, 1)));
+}
diff -ruN linux-2.4.13/net/sna/sna_hsr.c linux/net/sna/sna_hsr.c
--- linux-2.4.13/net/sna/sna_hsr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_hsr.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,165 @@
+/* sna_hsr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Half Session Router (HSR)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+#include <linux/uio.h>
+#include <linux/unistd.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/sna.h>
+
+#ifdef NOT
+struct sna_hs_local *hs_local_list = NULL;
+
+__u16	sys_snf_ids = 0;
+
+int sna_hs_local_queue_head(struct sna_hs_local *local);
+
+/* This procedure causes the half-session to be initialized. */
+int sna_hs_create(struct sna_init_hs *hs)
+{
+	struct sna_hs_local *local;
+	struct sna_init_hs_rsp *hs_rsp;
+
+	local = SNA_HS_MALLOC(struct sna_hs_local);
+	memset(local, 0, sizeof(struct sna_hs_local));
+	local->hs_id 			= hs->hs_id;
+	local->lu_id 			= hs->lu_id;
+	local->half_session 		= hs->type;
+	local->sense 			= 0;
+	local->perm_buf_pool_id 	= hs->perm_buf_pool_id;
+	local->limit_buf_pool_id	= hs->limit_buf_pool_id;
+	local->dynamic_buf_pool_id	= hs->dynamic_buf_pool_id;
+	local->catch_mu			= NULL;
+	sna_hs_local_queue_head(local);
+
+	sna_tc_init(hs);
+	sna_dfc_init(hs);
+
+	hs_rsp = SNA_HS_MALLOC(struct sna_init_hs_rsp);
+	hs_rsp->sense = local->sense;
+	hs_rsp->hs_id = local->hs_id;
+
+	if(local->sense == 0)
+		hs_rsp->type = 1;
+	else
+		hs_rsp->type = 0;
+
+	sna_send_to_sm((struct sna_mu *)hs_rsp);
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return (0);
+}
+
+/* Does processing for the half-session (FM profile 19). Message units
+ * received from RM and PS are routed to DFC. Message units received from
+ * PC are routed to TC. THe half-session continues to operate until and error
+ * condition occurs or the half session process is destroyed. If an error
+ * condition occurs, local->sense is set (by DFC or TC) with the sense
+ * data indicating what kind of error occured. When this field is set, the
+ * half-session sends an ABORT message to SM. This causes SM to send an
+ * UNBIND(protocol error) for this session. HS recevies BUFFERS_RESERVED
+ * signals from buffer manager and builds and sends the appropriate pacing
+ * response.
+ *
+ * sna_process_lu_lu_session();
+ */
+int sna_hs_local_queue_head(struct sna_hs_local *local)
+{
+	struct sna_hs_local *next, *prev;
+
+	prev 		= hs_local_list;
+	next 		= prev->next;
+	local->next	= next;
+	local->prev	= prev;
+	next->prev	= local;
+	prev->next	= local;
+
+	return (0);
+}
+
+struct sna_hs_local *sna_hs_find_local(__u8 hs_id)
+{
+	struct sna_hs_local *local;
+
+        for(local = hs_local_list; local != NULL; local = local->next)
+        {
+		if(local->hs_id == hs_id)
+			return (local);
+        }
+
+        return (NULL);
+}
+
+struct sna_mu *sna_catch_mu(struct sna_hs_local *local)
+{
+	while(local->catch_mu == NULL)
+		schedule();
+
+	return (local->catch_mu);
+}
+#endif
+
+extern int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb);
+
+int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+	struct sna_rcb *rcb)
+{
+	sna_debug(5, "sna_hs_process_lu_lu_session\n");
+	switch(who)
+	{
+		case (SNA_PS):
+			sna_dfc_send_from_ps(skb, rcb);
+			break;
+
+#ifdef NOT
+		case (SNA_RM):
+			sna_dfc_send_from_rm(skb);
+			break;
+
+		case (SNA_PC):
+			sna_tc_rcv(skb);
+			break;
+#endif
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_isr.c linux/net/sna/sna_isr.c
--- linux-2.4.13/net/sna/sna_isr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_isr.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,106 @@
+/* sna_isr.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_isr_create(struct sna_cp_create_parms *newisr)
+{
+
+	return (0);
+}
+
+int sna_isr_assign_lfsid_rsp(void)
+{
+
+	return (0);
+}
+
+int sna_isr_lfsid_in_use(void)
+{
+
+	return (0);
+}
+
+int sna_isr_session_route_inop(void)
+{
+
+	return (0);
+}
+
+int sna_isr_update_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_delete_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_query_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_abort_sc(void)
+{
+
+	return (0);
+}
+
+int sna_isr_assign_pcid_rsp(void)
+{
+
+	return (0);
+}
+
+int sna_isr_cinit(void)
+{
+
+	return (0);
+}
+
+int sna_isr_init_neg_rsp(void)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_nof.c linux/net/sna/sna_nof.c
--- linux-2.4.13/net/sna/sna_nof.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_nof.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,1104 @@
+/* sna_nof.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif	/* CONFIG_SNA_LLC */
+
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+
+/* One entry for each "node" started. */
+static struct sna_nof_pinfo *nof_node_list = NULL;
+
+struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n)
+{
+	struct sna_nof_pinfo *p;
+
+	sna_debug(5, "sna_nof_find_nodeid\n");
+	for(p = nof_node_list; p != NULL; p = p->next)
+		if(!strcmp(n->net, p->netid.net) 
+			&& !strcmp(n->name, p->netid.name))
+				return (&p->nodeid);
+
+	return (NULL);
+}
+
+int sna_nof_insert(struct sna_nof_pinfo *nof)
+{
+        sna_debug(5, "sna_nof_insert\n");
+        nof->next = nof_node_list;
+        nof_node_list = nof;
+
+        return (0);
+}
+
+struct sna_nof_pinfo *sna_nof_find(char *node_name)
+{
+        struct sna_nof_pinfo *f;
+
+        for(f = nof_node_list; f != NULL; f = f->next)
+        {
+		if(!strncmp(f->netid.name, node_name, SNA_NODE_NAME_LEN))
+                        continue;
+        }
+
+        return (f);
+}
+
+int sna_nof_delete_dlc(struct net_device *dev)
+{
+        sna_debug(5, "sna_nof_delete_dlc %s\n", dev->name);
+        return (sna_cs_delete_dlc(dev));
+}
+
+int sna_nof_define_dlc(struct net_device *dev)
+{
+        sna_debug(5, "sna_nof_define_dlc %s\n", dev->name);
+	return(sna_cs_define_dlc(dev));
+}
+
+static int sna_nof_delete_node(struct sna_delete_node *delete)
+{
+	struct sna_nof_pinfo *tmp; 
+	struct sna_nof_pinfo **clients = &nof_node_list;
+	int err = -ENOENT;
+
+        sna_debug(5, "sna_nof_delete_node %s\n", delete->netid.name);
+	sna_attach_destroy(delete);
+	sna_cpic_destroy(delete);
+	sna_rm_destroy(delete);
+	sna_trs_destroy(delete);
+	sna_cs_destroy(delete);
+	sna_ds_destroy(delete);
+	sna_ss_destroy(delete);
+	sna_asm_destroy(delete);
+
+
+        while((tmp = *clients) != NULL)
+        {
+                if(!strncmp(tmp->netid.name, delete->netid.name, 8))
+                {
+                        *clients = tmp->next;
+			tmp->next = NULL;
+			tmp->prev = NULL;
+                        kfree(tmp);
+			sna_mod_dec_use_count();
+			err = 0;
+                }
+		else
+                	clients = &tmp->next;
+        }
+
+        return (err);
+}
+
+static int sna_nof_stop_node(struct sna_stop_node *stop)
+{
+	sna_debug(5, "sna_nof_stop_node %s\n", stop->netid.name);
+	printk("Function not implemented use delete\n");
+
+	return (-EINVAL);
+}
+
+static int sna_nof_start_node(struct sna_start_node *start)
+{
+	struct sna_nof_pinfo *nof;
+
+	sna_debug(5, "sna_nof_start_node %s\n", start->netid.name);
+	if(sna_nof_find(start->netid.name) != NULL)
+		return (-EINVAL);
+	nof = (struct sna_nof_pinfo *)kmalloc(sizeof(struct sna_nof_pinfo),
+		GFP_ATOMIC);
+	memset(nof, '\0', sizeof(struct sna_nof_pinfo));
+        memcpy(&nof->netid, &start->netid, sizeof(struct sna_netid));
+	nof->nodeid.block_id	= start->nodeid.block_id;
+	nof->nodeid.pu_id	= start->nodeid.pu_id;
+	nof->type	= start->type;
+	nof->lu_seg	= start->lu_seg;
+	nof->bind_seg	= start->bind_seg;
+	nof->max_lus	= start->max_lus;
+
+	switch(start->type)
+	{
+		case (SNA_LEN_END_NODE):
+		case (SNA_APPN_END_NODE):
+		case (SNA_APPN_NET_NODE):
+			nof->type = start->type;
+			break;
+
+		default:
+			return (-EINVAL);
+	}
+	nof->status	= (SNA_UP | SNA_RUNNING);
+	nof->prev       = NULL;
+        nof->next       = nof_node_list;
+        nof_node_list   = nof;
+
+	sna_asm_create(start);
+	sna_ss_create(start);
+	sna_ds_create(start);
+	sna_cs_create(start);
+	sna_trs_create(start);
+	sna_cpic_create(start);
+	sna_attach_create(start);
+	sna_tc_init();
+
+	sna_mod_inc_use_count();
+
+#ifdef NOT
+	nof->netid_registered			= start->netid_registered;
+	nof->ls_supp_type			= start->ls_supp_type;
+	nof->resource_registration		= start->resource_registration;
+	nof->segment_generation_lvl		= start->segment_generation_lvl;
+	nof->mode_to_cos_mapping		= start->mode_to_cos_mapping;
+	nof->ms_node_type			= start->ms_node_type;
+	nof->mj_vector_file			= start->mj_vector_file;
+	nof->ms_log_file			= start->ms_log_file;
+	nof->peer_resource_registration		
+		= start->peer_resource_registration;
+	nof->network_node_type			= start->network_node_type;
+	nof->directory_type_supp		= start->directory_type_supp;
+	nof->rs_tree_update_type		= start->rs_tree_update_type;
+	nof->tdm_node_name			= start->tdm_node_name;
+	nof->cosdm_node_name			= start->cosdm_node_name;
+	nof->max_rs_cache_trees			= start->max_rs_cache_trees;
+	nof->max_oos_tdm_updates		= start->max_oos_tdm_updates;
+	nof->resource_service_search		
+		= start->resource_service_search;
+	nof->general_odai_usage_supp		
+		= start->general_odai_usage_supp;
+#endif
+
+	return (0);
+}
+
+static int sna_nof_reset_session_limit(struct sna_reset_session_limit *rsl)
+{
+
+	return (0);
+}
+
+static int sna_nof_delete_link_station(struct sna_delete_link_station *dls)
+{
+	int err;
+
+	sna_debug(5, "sna_nof_delete_link_station\n");
+	err = sna_cs_delete_ls(dls);
+	return (err);
+}
+
+static int sna_nof_deactivate_control_sessions(struct sna_deactivate_control_sessions *dcs)
+{
+
+	return (0);
+}
+
+static int sna_nof_delete_port(struct sna_delete_port *dp)
+{
+	sna_debug(5, "sna_nof_delete_port\n");
+	return (sna_cs_delete_port(dp));
+}
+
+static int sna_nof_define_mode(struct sna_define_mode *dm)
+{
+	sna_debug(5, "sna_nof_define_mode\n");
+	return (sna_rm_define_mode(dm));
+}
+
+static int sna_nof_activate_control_sessions(struct sna_activate_control_sessions *acs)
+{
+	return (0);
+}
+
+static int sna_nof_change_session_limit(struct sna_change_session_limit *csl)
+{
+
+	return (0);
+}
+
+static int sna_nof_define_adjacent_node(struct sna_define_adjacent_node *daj)
+{
+	return (0);
+}
+
+static int sna_nof_define_class_of_service(struct sna_define_cos *cos)
+{
+	sna_debug(5, "sna_nof_define_class_of_service\n");
+	return (sna_cosm_define_cos(cos));
+}
+
+static int sna_nof_define_connection_network(struct sna_define_connection_network *dcn)
+{
+	return (0);
+}
+
+static int sna_nof_define_directory_entry(struct sna_define_directory_entry *de)
+{
+	return (0);
+}
+
+static int sna_nof_define_isr_tuning(struct sna_define_isr_tuning *dit)
+{
+	return (0);
+}
+
+static int sna_nof_define_link_station(struct sna_define_link_station *dls)
+{
+	sna_debug(5, "sna_nof_define_link_station\n");
+	return (sna_cs_define_ls(dls));
+}
+
+static int sna_nof_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	sna_debug(5, "sna_nof_define_local_lu\n");
+	return (sna_rm_define_local_lu(dlu));
+}
+
+static int sna_nof_define_node_chars(struct sna_define_node_chars *dnc)
+{
+	sna_debug(5, "sna_nof_define_node_chars\n");
+	return (sna_tdm_define_node_chars(dnc));
+}
+
+static int sna_nof_define_partner_lu(struct sna_define_partner_lu *dplu)
+{
+	sna_debug(5, "sna_nof_define_partner_lu\n");
+	return (sna_rm_define_remote_lu(dplu));
+}
+
+static int sna_nof_define_port(struct sna_define_port *dp)
+{
+	sna_debug(5, "sna_nof_define_port\n");
+	return (sna_cs_define_port(dp));
+}
+
+static int sna_nof_define_tp(struct sna_define_tp *dtp)
+{
+	return (0);
+}
+
+static int sna_nof_delete_adjacent_node(struct sna_delete_adjacent_node *dan)
+{
+	return (0);
+}
+
+static int sna_nof_delete_class_of_service(struct sna_delete_cos *cos)
+{
+	sna_debug(5, "sna_nof_delete_class_of_service\n");
+	return (sna_cosm_delete_cos(cos));
+}
+
+static int sna_nof_delete_connection_network(struct sna_delete_connection_network *dcn)
+{
+	return (0);
+}
+
+static int sna_nof_delete_directory_entry(struct sna_delete_directory_entry *dde)
+{
+	return (0);
+}
+
+static int sna_nof_delete_isr_tuning(struct sna_delete_isr_tuning *dit)
+{
+	return (0);
+}
+
+static int sna_nof_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+	sna_debug(5, "sna_nof_delete_local_lu\n");
+	return (sna_rm_delete_local_lu(dlu));
+}
+
+static int sna_nof_delete_mode(struct sna_delete_mode *dm)
+{
+	sna_debug(5, "sna_nof_delete_mode\n");
+	return (0);
+//	return (sna_rm_delete_mode(dm));
+}
+
+static int sna_nof_delete_partner_lu(struct sna_delete_partner_lu *dplu)
+{
+	sna_debug(5, "sna_nof_delete_partner_lu\n");
+	return (sna_rm_delete_remote_lu(dplu));
+}
+
+static int sna_nof_delete_tp(struct sna_delete_tp *dtp)
+{
+	return (0);
+}
+
+static int sna_nof_initialize_session_limit(struct sna_initialize_session_limit *isl)
+{
+	return (0);
+}
+
+static int sna_nof_start_link_station(struct sna_start_link_station *sls)
+{
+	sna_debug(5, "sna_nof_start_link_station\n");
+	return (sna_cs_start_ls(sls));
+}
+
+static int sna_nof_start_port(struct sna_start_port *sp)
+{
+	sna_debug(5, "sna_nof_start_port\n");
+	return (sna_cs_start_port(sp));
+}
+
+static int sna_nof_start_tp(struct sna_start_tp *stp)
+{
+	return (0);
+}
+
+static int sna_nof_stop_link_station(struct sna_stop_link_station *sls)
+{
+	sna_debug(5, "sna_nof_stop_link_station\n");
+	return (sna_cs_stop_ls(sls));
+}
+
+static int sna_nof_stop_port(struct sna_stop_port *sp)
+{
+	sna_debug(5, "sna_nof_stop_port\n");
+	return (sna_cs_stop_port(sp));
+}
+
+/*
+ * NOF: Operators facility into the SNA node.
+ *
+ * setsockopt:
+ *  - 
+ * getsockopt:
+ *  -
+ */
+
+#ifdef CONFIG_PROC_FS
+int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_nof_pinfo *nof;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%s%s %s\n%-17s%-5s%-7s%-9s%-8s\n", 
+		"Linux-SNA v", sna_version, sna_maintainer, "NetID.Node",
+		"type", "lu_seg", "bind_seg", "max_lus");
+
+        for(nof = nof_node_list; nof != NULL; nof = nof->next)
+        {
+		len += sprintf(buffer + len, "%-18s",sna_pr_netid(&nof->netid));
+		len += sprintf(buffer + len, "%02X   %-7d%-9d%-8ld\n",
+			nof->type, nof->lu_seg, nof->bind_seg, nof->max_lus);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+        switch(optname)
+        {
+                case (SNA_ACTIVATE_CONTROL_SESSIONS):
+                {
+                        struct sna_activate_control_sessions act_ctrl_sess;
+                        if(optlen<sizeof(struct sna_activate_control_sessions))
+                                return (-EINVAL);
+                        if(copy_from_user(&act_ctrl_sess, optval,
+                                sizeof(struct sna_activate_control_sessions)))
+                                return (-EFAULT);
+                        err = sna_nof_activate_control_sessions(&act_ctrl_sess);
+                        break;
+                }
+
+                case (SNA_CHANGE_SESSION_LIMIT):
+                {
+                        struct sna_change_session_limit chg_sess_limit;
+                        if(optlen < sizeof(struct sna_change_session_limit))
+                                return (-EINVAL);
+                        if(copy_from_user(&chg_sess_limit, optval,
+                                sizeof(struct sna_change_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_change_session_limit(&chg_sess_limit);
+                        break;
+                }
+
+                case (SNA_DEACTIVATE_CONTROL_SESSIONS):
+                {
+                        struct sna_deactivate_control_sessions deact_cntrl_sess;
+                        if(optlen < sizeof(struct sna_deactivate_control_sessions))
+                                return (-EINVAL);
+                        if(copy_from_user(&deact_cntrl_sess, optval,
+                                sizeof(struct sna_deactivate_control_sessions)))                                return (-EFAULT);
+			err = sna_nof_deactivate_control_sessions(&deact_cntrl_sess);
+                        if(err)
+                                return (err);
+                        break;
+                }
+
+                case (SNA_DEFINE_ADJACENT_NODE):
+                {
+                        struct sna_define_adjacent_node define_adjacent_node;
+                        if(optlen < sizeof(struct sna_define_adjacent_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_adjacent_node, optval,
+                                sizeof(struct sna_define_adjacent_node)))
+                                return (-EFAULT);
+                        err = sna_nof_define_adjacent_node(&define_adjacent_node);
+                        break;
+                }
+
+                case (SNA_DEFINE_CLASS_OF_SERVICE):
+                {
+                        struct sna_define_cos cos;
+                        if(optlen < sizeof(struct sna_define_cos))
+                                return (-EINVAL);
+                        if(copy_from_user(&cos, optval,
+                                sizeof(struct sna_define_cos)))
+                                return (-EFAULT);
+                        err = sna_nof_define_class_of_service(&cos);
+                        break;
+                }
+
+                case (SNA_DEFINE_CONNECTION_NETWORK):
+                {
+                        struct sna_define_connection_network define_cn;
+                        if(optlen < sizeof(struct sna_define_connection_network))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_cn, optval,
+                                sizeof(struct sna_define_connection_network)))
+                                return (-EFAULT);
+                        err = sna_nof_define_connection_network(&define_cn);
+                        break;
+                }
+
+                case (SNA_DEFINE_DIRECTORY_ENTRY):
+                {
+                        struct sna_define_directory_entry define_dir_entry;
+                        if(optlen < sizeof(struct sna_define_directory_entry))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_dir_entry, optval,
+                                sizeof(struct sna_define_directory_entry)))
+                                return (-EFAULT);
+                        err = sna_nof_define_directory_entry(&define_dir_entry);
+                        break;
+                }
+
+                case (SNA_DEFINE_ISR_TUNING):
+                {
+                        struct sna_define_isr_tuning define_isr_tuning;
+                        if(optlen < sizeof(struct sna_define_isr_tuning))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_isr_tuning, optval,
+                                sizeof(struct sna_define_isr_tuning)))
+                                return (-EFAULT);
+                        err = sna_nof_define_isr_tuning(&define_isr_tuning);
+                        break;
+                }
+
+                case (SNA_DEFINE_LINK_STATION):
+                {
+                        struct sna_define_link_station define_ls;
+                        if(optlen < sizeof(struct sna_define_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_ls, optval,
+                                sizeof(struct sna_define_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_define_link_station(&define_ls);
+                        break;
+                }
+
+                case (SNA_DEFINE_LOCAL_LU):
+                {
+                        struct sna_define_local_lu define_llu;
+                        if(optlen < sizeof(struct sna_define_local_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_llu, optval,
+                                sizeof(struct sna_define_local_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_define_local_lu(&define_llu);
+                        break;
+                }
+
+                case (SNA_DEFINE_MODE):
+                {
+                        struct sna_define_mode define_mode;
+                        if(optlen < sizeof(struct sna_define_mode))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_mode, optval,
+                                sizeof(struct sna_define_mode)))
+                                return (-EFAULT);
+                       	err = sna_nof_define_mode(&define_mode);
+                        break;
+                }
+
+                case (SNA_DEFINE_NODE_CHARS):
+                {
+                        struct sna_define_node_chars define_node_chars;
+                        if(optlen < sizeof(struct sna_define_node_chars))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_node_chars, optval,
+                                sizeof(struct sna_define_node_chars)))
+                                return (-EFAULT);
+                        err = sna_nof_define_node_chars(&define_node_chars);
+                        break;
+                }
+
+                case (SNA_DEFINE_PARTNER_LU):
+                {
+                        struct sna_define_partner_lu define_plu;
+                        if(optlen < sizeof(struct sna_define_partner_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_plu, optval,
+                                sizeof(struct sna_define_partner_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_define_partner_lu(&define_plu);
+                        break;
+                }
+
+                case (SNA_DEFINE_PORT):
+                {
+                        struct sna_define_port define_port;
+                        if(optlen < sizeof(struct sna_define_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_port, optval,
+                                sizeof(struct sna_define_port)))
+                                return (-EFAULT);
+                        err = sna_nof_define_port(&define_port);
+                        break;
+                }
+
+                case (SNA_DEFINE_TP):
+                {
+                        struct sna_define_tp define_tp;
+                        if(optlen < sizeof(struct sna_define_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_tp, optval,
+                                sizeof(struct sna_define_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_define_tp(&define_tp);
+                        break;
+                }
+
+                case (SNA_DELETE_ADJACENT_NODE):
+                {
+                        struct sna_delete_adjacent_node delete_adjacent_node;
+                        if(optlen < sizeof(struct sna_delete_adjacent_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_adjacent_node, optval,
+                                sizeof(struct sna_delete_adjacent_node)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_adjacent_node(&delete_adjacent_node);
+                        break;
+                }
+
+                case (SNA_DELETE_CLASS_OF_SERVICE):
+                {
+                        struct sna_delete_cos cos;
+                        if(optlen < sizeof(struct sna_delete_cos))
+                                return (-EINVAL);
+                        if(copy_from_user(&cos, optval,
+                                sizeof(struct sna_delete_cos)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_class_of_service(&cos);
+                        break;
+                }
+
+                case (SNA_DELETE_CONNECTION_NETWORK):
+                {
+                        struct sna_delete_connection_network delete_cn;
+                        if(optlen < sizeof(struct sna_delete_connection_network))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_cn, optval,
+                                sizeof(struct sna_delete_connection_network)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_connection_network(&delete_cn);
+                        break;
+                }
+
+                case (SNA_DELETE_DIRECTORY_ENTRY):
+                {
+                        struct sna_delete_directory_entry delete_dir_entry;
+                        if(optlen < sizeof(struct sna_delete_directory_entry))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_dir_entry, optval,
+                                sizeof(struct sna_delete_directory_entry)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_directory_entry(&delete_dir_entry);
+                        break;
+                }
+
+                case (SNA_DELETE_ISR_TUNING):
+                {
+                        struct sna_delete_isr_tuning delete_isr_tuning;
+                        if(optlen < sizeof(struct sna_delete_isr_tuning))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_isr_tuning, optval,
+                                sizeof(struct sna_delete_isr_tuning)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_isr_tuning(&delete_isr_tuning);
+                        break;
+                }
+
+                case (SNA_DELETE_LINK_STATION):
+                {
+                        struct sna_delete_link_station delete_ls;
+                        if(optlen < sizeof(struct sna_delete_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_ls, optval,
+                                sizeof(struct sna_delete_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_link_station(&delete_ls);
+                        break;
+                }
+
+                case (SNA_DELETE_LOCAL_LU):
+                {
+                        struct sna_delete_local_lu delete_llu;
+                        if(optlen < sizeof(struct sna_delete_local_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_llu, optval,
+                                sizeof(struct sna_delete_local_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_local_lu(&delete_llu);
+                        break;
+                }
+
+                case (SNA_DELETE_MODE):
+                {
+                        struct sna_delete_mode delete_mode;
+                        if(optlen < sizeof(struct sna_delete_mode))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_mode, optval,
+                                sizeof(struct sna_delete_mode)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_mode(&delete_mode);
+                        break;
+                }
+
+                case (SNA_DELETE_PARTNER_LU):
+                {
+                        struct sna_delete_partner_lu delete_plu;
+                        if(optlen < sizeof(struct sna_delete_partner_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_plu, optval,
+                                sizeof(struct sna_delete_partner_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_partner_lu(&delete_plu);
+                        break;
+                }
+
+                case (SNA_DELETE_PORT):
+                {
+                        struct sna_delete_port delete_port;
+                        if(optlen < sizeof(struct sna_delete_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_port, optval,
+                                sizeof(struct sna_delete_port)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_port(&delete_port);
+                        break;
+                }
+
+                case (SNA_DELETE_TP):
+                {
+                        struct sna_delete_tp delete_tp;
+                        if(optlen < sizeof(struct sna_delete_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_tp, optval,
+                                sizeof(struct sna_delete_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_tp(&delete_tp);
+                        break;
+                }
+
+                case (SNA_INITIALIZE_SESSION_LIMIT):
+                {
+                        struct sna_initialize_session_limit init_sess_limit;
+                        if(optlen < sizeof(struct sna_initialize_session_limit))                                return (-EINVAL);
+                        if(copy_from_user(&init_sess_limit, optval,
+                                sizeof(struct sna_initialize_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_initialize_session_limit(&init_sess_limit);
+                        break;
+                }
+
+                case (SNA_RESET_SESSION_LIMIT):
+                {
+                        struct sna_reset_session_limit reset_sess_limit;
+                        if(optlen < sizeof(struct sna_reset_session_limit))
+                                return (-EINVAL);
+                        if(copy_from_user(&reset_sess_limit, optval,
+                                sizeof(struct sna_reset_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_reset_session_limit(&reset_sess_limit);
+                        break;
+                }
+
+                case (SNA_START_LINK_STATION):
+                {
+                        struct sna_start_link_station start_link_station;
+                        if(optlen < sizeof(struct sna_start_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_link_station, optval,
+                                sizeof(struct sna_start_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_start_link_station(&start_link_station);
+                        break;
+                }
+
+                /* Start the SNA Node. */
+                case (SNA_START_NODE):
+                {
+                        struct sna_start_node start_node;
+                        if(optlen < sizeof(struct sna_start_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_node, optval,
+                                sizeof(struct sna_start_node)))
+                                return (-EFAULT);
+                        err = sna_nof_start_node(&start_node);
+                        break;
+                }
+
+		case (SNA_STOP_NODE):
+		{
+			struct sna_stop_node stop_node;
+                        if(optlen < sizeof(struct sna_stop_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_node, optval,
+                                sizeof(struct sna_stop_node)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_node(&stop_node);
+                        break;
+                }
+
+		case (SNA_DELETE_NODE):
+		{
+			struct sna_delete_node delete_node;
+                        if(optlen < sizeof(struct sna_delete_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_node, optval,
+                                sizeof(struct sna_delete_node)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_node(&delete_node);
+                        break;
+                }
+
+                case (SNA_START_PORT):
+                {
+                        struct sna_start_port start_port;
+                        if(optlen < sizeof(struct sna_start_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_port, optval,
+                                sizeof(struct sna_start_port)))
+                                return (-EFAULT);
+                        err = sna_nof_start_port(&start_port);
+                        break;
+                }
+
+                case (SNA_START_TP):
+                {
+                        struct sna_start_tp start_tp;
+                        if(optlen < sizeof(struct sna_start_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_tp, optval,
+                                sizeof(struct sna_start_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_start_tp(&start_tp);
+                        break;
+                }
+
+                case (SNA_STOP_LINK_STATION):
+                {
+                        struct sna_stop_link_station stop_ls;
+                        if(optlen < sizeof(struct sna_stop_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_ls, optval,
+                                sizeof(struct sna_stop_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_link_station(&stop_ls);
+                        break;
+                }
+
+                case (SNA_STOP_PORT):
+                {
+                        struct sna_stop_port stop_port;
+                        if(optlen < sizeof(struct sna_stop_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_port, optval,
+                                sizeof(struct sna_stop_port)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_port(&stop_port);
+                        break;
+                }
+
+                default:
+                        return (-EINVAL);
+        }
+
+	return (err);
+}
+
+int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+        int len;
+
+        if(get_user(len, optlen))
+                return (-EFAULT);
+
+        switch(optname)
+        {
+                case (SNA_QUERY_CLASS_OF_SERVICE):
+                {
+                        struct sna_query_class_of_service *cos;
+
+                        len = min(len, sizeof(cos));
+                        if(copy_to_user((void *)optval, &cos, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_CONNECTION_NETWORK):
+                {
+                        struct sna_query_connection_network *cn;
+
+                        len = min(len, sizeof(cn));
+                        if(copy_to_user((void *)optval, &cn, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_DLC):
+                {
+                        struct sna_query_dlc *dlc;
+
+                        len = min(len, sizeof(dlc));
+                        if(copy_to_user((void *)optval, &dlc, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_ISR_TUNING):
+                {
+                        struct sna_query_isr_tuning *isr;
+
+                        len = min(len, sizeof(isr));
+                        if(copy_to_user((void *)optval, &isr, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_LINK_STATION):
+                {
+                        struct sna_query_link_station *ls;
+
+                        len = min(len, sizeof(ls));
+                        if(copy_to_user((void *)optval, &ls, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_PORT):
+                {
+                        struct sna_query_port *port;
+
+                        len = min(len, sizeof(port));
+                        if(copy_to_user((void *)optval, &port, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_STATISTICS):
+                {
+                        struct sna_query_statistics *stats;
+
+                        len = min(len, sizeof(stats));
+                        if(copy_to_user((void *)optval, &stats, len))
+                                return (-EFAULT);
+                }
+
+                default:
+			return (-EINVAL);
+        }
+
+        if(put_user(len, optlen))
+                return (-EFAULT);
+
+        return (0);
+}
+
+int sna_nof_ginfo(struct sna_nof_pinfo *nof, char *buf, int len)
+{
+	struct snareq sr;
+	int done = 0;
+
+	sna_debug(10, "sna_nof_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(sr);
+                return (done);
+        }
+        if(len < (int)sizeof(sr))
+                return done;
+        memset(&sr, 0, sizeof(struct snareq));
+
+        /* Move the data here */
+	strncpy(sr.net, nof->netid.net, 8);
+	strncpy(sr.name, nof->netid.name, 8);
+	sr.type 	= nof->type;
+	sr.lu_seg	= nof->lu_seg;
+	sr.bind_seg	= nof->bind_seg;
+	sr.max_lus	= nof->max_lus;
+	sr.node_status	= nof->status;
+	memcpy(&sr.nodeid, &nof->nodeid, sizeof(struct sna_nodeid));
+
+	if(copy_to_user(buf, &sr, sizeof(struct snareq)))
+                return (-EFAULT);
+        buf += sizeof(struct snareq);
+        len -= sizeof(struct snareq);
+        done += sizeof(struct snareq);
+
+        return (done);
+}
+	
+int sna_nof_query_node(char *arg)
+{
+	struct sna_nof_pinfo *nof;
+	struct snaconf sc;
+	char *pos;
+        int len, total;
+
+	sna_debug(10, "sna_nof_query_node\n");
+	if(copy_from_user(&sc, arg, sizeof(sc)))
+                return (-EFAULT);
+
+	pos = sc.snac_buf;
+        len = sc.snac_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(nof = nof_node_list; nof != NULL; nof = nof->next)
+	{
+		int done;
+
+                if(pos == NULL)
+                        done = sna_nof_ginfo(nof, NULL, 0);
+                else
+                        done = sna_nof_ginfo(nof, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+	}
+
+	sc.snac_len = total;
+	if(copy_to_user(arg, &sc, sizeof(sc)))
+                return (-EFAULT);
+
+	return (0);
+}
+
+int sna_nof_ioctl(int cmd, void *arg)
+{
+	sna_debug(5, "sna_nof_ioctl\n");
+        switch(cmd)
+        {
+		case (SIOCGLS):
+			sna_cs_query_ls(arg);
+			break;
+
+		case (SIOCGPORT):
+			sna_cs_query_port(arg);
+			break;
+
+		case (SIOCGDLC):
+			sna_cs_query_dlc(arg);
+			break;
+
+                case (SIOCGNODE):
+			sna_nof_query_node(arg);
+			break;
+
+		case (SIOCGMODE):
+			sna_rm_query_mode(arg);
+			break;
+
+		case (SIOCGLU):
+			sna_rm_query_lu(arg);
+			break;
+
+		case (SIOCGPLU):
+			sna_rm_query_plu(arg);
+			break;
+
+		case (SIOCGCOS):
+			sna_cosm_query_cos(arg);
+			break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (0);
+} 
diff -ruN linux-2.4.13/net/sna/sna_pc.c linux/net/sna/sna_pc.c
--- linux-2.4.13/net/sna/sna_pc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_pc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,587 @@
+/* sna_pc.c: Linux Systems Network Architecture implementation
+ * - Path Control (Route message units between HS and DLC). 
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+static struct sna_pc_pinfo *pc_clients = NULL;
+
+struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id)
+{
+	struct sna_pc_pinfo *pc;
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+		if(!memcmp(&pc->pc_id, pc_id, 8))
+			return (pc);
+
+	return (NULL);
+}
+
+struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n)
+{
+	struct sna_pc_pinfo *pc;
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+		if(!strcmp(pc->fqcp.net, n->net)
+			&& !strcmp(pc->fqcp.name, n->name))
+			return (pc);
+
+	return (NULL);
+}
+
+/* Destroy a single PC instance. */
+int sna_pc_destroy(unsigned char *pc_id)
+{
+	struct sna_pc_pinfo *pc, **clients;
+
+	clients = &pc_clients;
+	while((pc = *clients) != NULL)
+	{
+		if(!memcmp(&pc->pc_id, pc_id, 8))
+		{
+			*clients = pc->next;
+			kfree(pc);
+			return (0);
+		}
+		clients = &pc->next;
+	}
+
+	return (-ENOENT);
+}
+
+/* Create a single PC instance. Return the PC ID. */
+int sna_pc_init(struct sna_pc_create_parms *npc)
+{
+	struct sna_pc_pinfo *pc;
+
+        sna_debug(5, "sna_pc_init %s\n", sna_pr_netid(&npc->fqcp));
+        pc = (struct sna_pc_pinfo *)kmalloc(sizeof(struct sna_pc_pinfo),
+		GFP_ATOMIC);
+	if(!pc)
+		return (-ENOMEM);
+	pc->type		= npc->type;
+	pc->dlc			= npc->dlc;
+	pc->ls			= npc->ls;
+	pc->port		= npc->port;
+
+	pc->max_tx_btu		= npc->max_tx_btu;
+	pc->max_rx_btu		= npc->max_rx_btu;
+	pc->bind_seg		= npc->bind_seg;
+	pc->limited_tg		= npc->limited_tg;
+	pc->tg_number		= npc->tg_number;
+
+	pc->odai		= npc->odai;
+	memcpy(&pc->fqcp, &npc->fqcp, sizeof(struct sna_netid));
+	pc->local_seg		= npc->local_seg;
+	pc->godai		= npc->godai;
+	pc->next		= pc_clients;
+	pc_clients		= pc;
+
+	sna_ss_generate_pcid(pc->fqcp.net, pc->fqcp.name);
+	sna_ss_update_pcid(pc->pc_id);
+
+        return (0);
+}
+
+int sna_pc_mu_error_checker(struct sk_buff *skb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_pc_mu_error_checker (skb %d)\n", skb->len);
+
+	/* Need to check that FID type is valid and
+	 * correct TH, RH, and RU lengths.
+	 */
+
+	return (err);
+}
+
+struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb)
+{
+	struct snathdr *th = skb->nh.fidh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "sna_pc_xtract_lfsid %02X\n", th->fid.f0.ft);
+	l = (struct sna_lfsid *)kmalloc(sizeof(struct sna_lfsid), GFP_ATOMIC);
+	switch(th->fid.f0.ft)	/* type field is in the same location for all */
+	{
+		case (SNA_TH_FID0):
+		case (SNA_TH_FID1):
+			break;
+
+		case (SNA_TH_FID2):
+			l->odai 	= th->fid.f2.odai;
+			l->sid.hl.sidh 	= th->fid.f2.oaf;
+			l->sid.hl.sidl 	= th->fid.f2.daf;
+			break;
+
+		case (SNA_TH_FID3):
+			break;
+
+		case (SNA_TH_FID4):
+			break;
+
+		case (SNA_TH_FID5):
+			break;
+
+		case (SNA_TH_FIDF):
+			break;
+
+		default:
+			return (NULL);
+	}
+
+	return (l);
+}
+
+int sna_pc_mu_rcv_router(struct sk_buff *skb)
+{
+	struct snarhdr *rh = skb->h.rh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "sna_pc_mu_rcv_router\n");
+	l = sna_pc_xtract_lfsid(skb);
+	switch(rh->ru)
+	{
+		case (SNA_RH_RU_FMD):
+			sna_tc_rcv(skb, l);
+			break;
+
+		case (SNA_RH_RU_SC):
+			sna_asm_rcv(skb, l);
+			break;
+
+		case (SNA_RH_RU_DFC):
+		case (SNA_RH_RU_NC):
+			/* haven't seen these two bad boys used lately, as I
+			 * forget where they should go we will let them die.
+			 */
+		default:
+			sna_debug(5, "Unknown RU catagory %02X\n", rh->ru);
+			kfree_skb(skb);
+			break;
+	}
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_pc_pinfo *pc;
+	off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%-17s%-10s\n",
+                "NetID.Node", "path_control_id", "tg_number");
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+	{
+                len += sprintf(buffer + len, "%-18s%"
+			"02X%02X%02X%02X%02X%02X%02X%02X %10d\n", 
+			sna_pr_netid(&pc->fqcp), 
+			pc->pc_id[0], pc->pc_id[1], pc->pc_id[2],
+			pc->pc_id[3], pc->pc_id[4], pc->pc_id[5], pc->pc_id[6],
+			pc->pc_id[7], pc->tg_number);
+
+		/* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+#ifdef NOT
+/* Internode. */
+static int sna_pc_alert_handler(struct sna_mu *mu, __u32 sense)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_alert_signal: received alert signal.\n");
+
+	msg->mu = mu;
+	msg->sense = sense;
+//	sna_ms(msg);
+
+	return (0);
+}
+
+/* Internode. */
+static int sna_pc_flush_handler(void)
+{
+	if(sna_pc_debug > 5)
+		printk("sna_pc_flush_handler: activated\n");
+
+	return (0);
+}
+
+static int sna_pc_hs_adder(struct sna_pc_hs_table *newhs)
+{
+	struct sna_pc_hs_table *next, *prev;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_hs_adder: adding hs.\n");
+
+	next = sna_hs_table;
+	prev = next->prev;
+	newhs->next = next;
+	newhs->prev = prev;
+	next->prev = newhs;
+	prev->next = newhs;
+
+	return (0);
+}
+
+static struct sna_pc_hs_table *sna_pc_hs_finder(__u8 lfsid)
+{
+	struct sna_pc_hs_table *i;
+
+	for(i = sna_hs_table; i->next != NULL; i = i->next)
+        {
+                if(i->lfsid == lfsid)
+                        return (i);
+        }
+
+	return (NULL);
+}
+
+static int sna_pc_hs_deleter(__u8 lfsid)
+{
+	struct sna_pc_hs_table *prev, *next, *result;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_hs_deleter: deleting hs.\n");
+
+	prev = sna_pc_hs_finder(lfsid);
+	if(prev == NULL)
+		return (-1);
+
+        next = prev->next;
+        result = NULL;
+        if(next != prev)
+	{
+                result = next;
+                next = next->next;
+                next->prev = prev;
+                prev->next = next;
+                result->next = NULL;
+                result->prev = NULL;
+        }
+	kfree(result);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_local_bind_rq_send: active\n");
+
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+	msg->cmd = SNA_BIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+        if(sna_pc_debug > 5)
+                printk("sna_pc_local_bind_rsp_send: active\n");
+
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+        msg->cmd = SNA_BIND_RSP_RCV;
+//        sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_flush_ls(void)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_flush_ls: active\n");
+
+	msg->cmd = SNA_LS_FLUSHED;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_unbind_rq_send: active\n");
+
+	msg->mu = mu;
+	msg->cmd = SNA_UNBIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_unbind_rsp_send: active\n");
+
+	msg->mu = mu;
+        msg->cmd = SNA_UNBIND_RSP_RCV;
+    //    sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_send_free_lfsid(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_free_lfsid: active\n");
+
+	msg->mu = mu;
+	msg->cmd = SNA_FREE_LFSID;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_enqueuer(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+
+	switch(mu->tx_priority)
+	{
+		case (SNA_TP_NETWORK):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_network);
+			break;
+
+		case (SNA_TP_HIGH):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_high);
+			break;
+
+		case (SNA_TP_MEDIUM):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_medium);
+			break;
+
+		case (SNA_TP_LOW):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_low);
+			break;
+	}
+
+	mark_bh(PC_UPM_BM);
+	return (0);
+}
+
+static int sna_pc_fsm_send_mu(void)
+{
+	return (0);
+}
+
+static __u16 sna_pc_get_mu_pcid(__u8 lfsid)
+{
+	struct sna_pc_hs_table *hs_table_entry;
+
+	hs_table_entry = sna_pc_hs_finder(lfsid);
+
+	return (hs_table_entry->pc_id);
+}
+
+static int sna_pc_remote_send_mu_processing(struct sna_mu *mu)
+{
+	if(mu->dcf > 600) // sna_pc_max_btu_size)
+		sna_pc_segment_generator(mu);
+	else
+		sna_pc_enqueuer(mu);
+
+	return (0);
+}
+
+static int sna_pc_segment_generator(struct sna_mu *mu)
+{
+	struct sna_mu *newmu = NULL, *cmu = NULL;
+	int over_size, len = 0;
+	int sna_pc_max_btu_size = 600;
+
+//	sna_copy_mu(cmu, mu);
+
+//	sna_cut_mu_tail(mu, over_size);
+	sna_pc_enqueuer(mu);
+
+	for(over_size = cmu->dcf - sna_pc_max_btu_size;
+		over_size >= sna_pc_max_btu_size;
+		len = over_size - sna_pc_max_btu_size, over_size -= len)
+	{
+//		newmu = sna_bm_get_buff(len);
+		newmu->pc_id		= cmu->pc_id;
+		newmu->hs_id		= cmu->hs_id;
+		newmu->lfsid		= cmu->lfsid;
+		newmu->tx_priority	= cmu->tx_priority;
+		newmu->dcf		= len;
+		newmu->biu->rh 		= cmu->biu->rh;
+		newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+		newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_MID_MIU;
+//		newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+		newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+		newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+		newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+		newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+		sna_pc_enqueuer(newmu);
+	}
+
+//	newmu = sna_bm_get_buff(len);
+        newmu->pc_id    	= cmu->pc_id;
+        newmu->hs_id    	= cmu->hs_id;
+        newmu->lfsid    	= cmu->lfsid;
+	newmu->tx_priority      = cmu->tx_priority;
+        newmu->dcf      	= len;
+        newmu->biu->rh  	= cmu->biu->rh;
+        newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+	newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_EBIU;
+//	newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+	newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+        newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+        newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+        newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+	sna_pc_enqueuer(newmu);
+
+	return (0);
+}
+
+static int sna_pc_send_mu_to_dlc(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+	msg->cmd = SNA_PC_TO_DLC;
+//	sna_dlc(msg);
+
+	return (0);
+}
+
+/* Process the four different tx priority queues in a fair way. */
+static void sna_pc_upm_queue_aging_manager(void)
+{
+	unsigned long start_time = jiffies;
+	struct sna_msg_queue *msg;
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_high))
+	{
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_high);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+	}
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_network))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_network);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_medium))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_medium);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_low))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+		msg = sna_dequeue_msg(&sna_trpr_qs_low);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+        }
+	return;
+
+sna_pc_upm_queue_age_break:
+	mark_bh(PC_UPM_BM);
+	return;
+}
+#endif
diff -ruN linux-2.4.13/net/sna/sna_ps_conv.c linux/net/sna/sna_ps_conv.c
--- linux-2.4.13/net/sna/sna_ps_conv.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_conv.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,2424 @@
+/* sna_ps_conv.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Conversations (PS.CONV)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static int sna_ps_fmh5_options(struct sk_buff *skb, int tp_len, char *tp, 
+	int luw_len, int nqlu_len, char *nqlu, char *luw_i,
+	char *luw_s, int cc_len, char *cc)
+{
+	struct fmhdr *fm = skb->f.fm;
+	__u8 *ptr = &fm->fm.f5.raw;
+	int len = 0;
+
+	sna_debug(5, "sna_ps_fmh5_options\n");
+
+	/* Transaction program name field */
+	if(tp_len >= 1 && tp_len <= 64)	
+	{
+		memcpy(ptr, &tp_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, tp, tp_len);
+		len += tp_len;
+	}
+	else
+		return (-1);
+
+	/* Logical-Unit-of-Work Identifier field */
+	if((luw_len <= 26 && luw_len >= 10)
+		&& (nqlu_len >= 1 && nqlu_len <= 17))
+	{
+		memcpy(ptr + len, &luw_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, &nqlu_len, sizeof(__u8));
+		len += 1;
+
+		memcpy(ptr + len, nqlu, nqlu_len);
+		len += nqlu_len;
+
+        	memcpy(ptr + len, luw_i, luw_len - 1);
+		len += luw_len - 1;
+        	memcpy(ptr + len, luw_s, 1);
+		len += 1;
+	}
+	else
+	{
+		if(luw_len != 0 || nqlu_len != 0)
+			return (-1);
+	}
+
+	/* Conversation correlator field */
+	if(cc_len >= 1 && cc_len <= 8)
+	{
+		memcpy(ptr + len, &cc_len, 1);
+		len += 1;
+		memcpy(ptr + len, cc, cc_len);
+		len += cc_len;
+	}
+	else
+	{
+		if(cc_len != 0)
+			return (-1);
+	}
+
+	return (len);
+}
+
+static int sna_ps_build_fmh5(struct sna_tcb *tcb, struct sna_rcb *rcb,
+	struct sk_buff *skb)
+{
+	struct fmhdr *fm = skb->f.fm;
+	char cc[9];
+	int len = 0;
+	unsigned char luw_s;
+
+	sna_debug(5, "sna_ps_build_fmh5\n");
+	fm->type	= FMH_5;
+	fm->fm.f5.cmd	= 0x02FF;
+	fm->fm.f5.vid	= 0;
+	fm->fm.f5.pvid	= 0;
+	fm->fm.f5.spwdi	= 0;
+	fm->fm.f5.pipi	= 0;
+	fm->fm.f5.xaid	= 0;
+	fm->fm.f5.fxct	= 3;
+
+	fm->fm.f5.resrc_type	= 0xD1;
+	fm->fm.f5.sync_level	= 0x01;
+
+	sprintf(cc, "%04X", tcb->tcb_id);
+	luw_s = 9;
+	len = sna_ps_fmh5_options(skb, tcb->tp_name_length, 
+		tcb->tp_name, 10, tcb->partner_lu_name_length, 
+		tcb->partner_lu_name, cc, &luw_s, 8, cc);
+	fm->len = sizeof(struct sna_fmh5) + len;
+	printk("fmh5 len is %d %d\n", fm->len, (sizeof(struct sna_fmh5) + len));
+
+	return (0);
+}
+
+static int sna_ps_rcb_allocated(struct sna_tcb *tcb, struct sna_rcb *rcb)
+{
+	struct sk_buff *skb;
+	int size;
+
+	sna_debug(5, "sna_ps_rcb_allocated\n");
+
+	size = 250;	/* Enough for a FM5 */
+	skb = alloc_skb(size, GFP_ATOMIC);
+	skb_reserve(skb, sizeof(struct snarhdr));
+	skb_reserve(skb, sizeof(struct sna_fid2));
+	skb->f.raw = skb_put(skb,50);
+
+	sna_ps_build_fmh5(tcb, rcb, skb);
+	rcb->l.ps_to_hs.fmh = 1;
+
+	printk("after build_fmh5\n");
+	printk("%d %d\n", rcb->oaf, rcb->daf);
+
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        switch(rcb_allocated->rcode)
+        {
+                case (OK):
+                        allocate_verb->rcode = OK;
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        allocate_verb->resource = rcb->rcb_id;
+                        sna_set_init_rcb(rcb);
+
+                        switch(allocate_verb->rcntrl)
+                        {
+                                case (WHEN_SESSION_ALLOCATED):
+                                        rcb->session_req = ANY;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONWINNER_ALLOCATED):
+                                        rcb->session_req = CONWINNER;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONV_GROUP_ALLOCATED):
+                                        rcb->session_req = SPECIFIC;
+                                        rcb->conv_group_id = allocate_verb->conversaion_group_id;
+                                        break;
+
+                                case (IMMEDIATE):
+                                        /* Do nothing */
+                                        break;
+                        }
+
+                        if(allocate_verb->rcntrl == IMMEDIATE)
+                        {
+                                sna_create_and_init_limited_mu(rcb, mu);
+                                mu->ps_to_hs.allocate = YES;
+                        }
+                        else
+                                sna_obtain_session_proc(rcb, allocate_verb);
+
+                        if(allocate_verb->rcode == OK)
+                                sna_build_fmh5(mu);
+                        else
+                                fsm_conversation(r, allocation_error_rc, rcb);
+                        break;
+
+                case (UNSUCCESSFUL):
+                        allocate_verb->rcode = UNSUCCESSFUL;
+                        break;
+
+                case (SYNC_LEVEL_NOT_SUPPORTED):
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        init_allocated_rcb();
+                        fsm_conversation(r, allocation_error_rc, rcb);
+                        allocate_verb->rcode = ALLOCATION_ERROR;
+                        allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED_BY_LU;                        break;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_allocate(struct sna_tcb *tcb)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_ps_allocate %d %d\n", tcb->oaf, tcb->daf);
+	rcb_id = sna_rm_allocate_rcb(tcb);
+	rcb = sna_rm_find_rcb_by_id(rcb_id);
+	if(rcb == NULL)
+		return (-1);
+
+	sna_debug(5, "now in ps alloc %d %d\n", rcb->oaf, rcb->daf);
+	sna_ps_rcb_allocated(tcb, rcb);
+
+	return (0);
+}
+
+static int sna_ps_send_data_buffer_management(struct sk_buff *skb, 
+	struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "sna_ps_send_data_buffer_management\n");
+	rcb = sna_rm_find_rcb_by_id(tcb->rcb_id);
+	if(rcb == NULL)
+	{
+		sna_debug(5, "no rcb located\n");
+		return (-1);
+	}
+	memset(&rcb->l.ps_to_hs, 0, sizeof(struct sna_ps_to_hs));
+
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        mu = get_buf_send_pool();
+        if(mu == NULL)
+                sna_create_and_init_limited_mu(rcb, mu);
+        else
+        {
+                if(mu is full and more data to send)
+                        send_to_hs(mu);
+                sna_create_and_init_limited_mu(rcb, mu);
+        }
+
+        while(data != NULL)
+        {
+                mu = data_up_to_size_of_mu;
+                if(mu is full and more data to send)
+                {
+                        send_to_hs(mu);
+                        if(more data to send)
+                                sna_create_and_init_limited_mu(rcb, mu);
+                }
+                else
+                        save_mu_to_send_later(mu);
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_send_data(struct sna_tcb *tcb)
+{
+        struct sk_buff *skb;
+
+	sna_debug(5, "sna_ps_send_data %d\n", tcb->tcb_id);
+	skb = skb_dequeue(&tcb->transmit_queue);
+        if(skb == NULL)
+	{
+		printk("No more data on tcb transmit queue\n");
+		return (-1);
+	}
+
+	sna_ps_send_data_buffer_management(skb, tcb);
+
+#ifdef NOT
+	struct sna_rcb *rcb;
+
+        rcb = search_rcb(send_data_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                send_data_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                switch(fstate = sm_error_or_failure())
+                {
+                        case (CONV_FAILURE_PROTOCOL_ERROR):
+                        case (CONV_FAILURE_SON):
+                                if(state == CONV_FAILURE_SON)
+                                        send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                                break;
+
+                        case (RCVD_ERROR):
+                                if(mu == NULL)
+                                        sna_create_and_init_limited_mu(rcb, mu);                                mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+                                send_to_hs(mu);
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+                                state = fsm_error_or_failure();
+                                if(state == CONV_FAILURE_SON
+                                        || state == CONV_FAILURE_PROTOCOL_ERROR)                                {
+                                        if(state == CONV_FAILURE_SON)
+                                                send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                        else
+                                                send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                        fsm_conversation(r, resource_failure_rc, rcb);
+                                }
+                                else
+                                        sna_dequeue_fmh7_proc(send_data_verb, rcb);
+                                break;
+
+                        case (NO_REQUESTS):
+                                send_data_verb->rcode = OK;
+                                if(send_data_verb->max_length > 0)
+                                {
+                                        err = process_LL();
+                                        if(err != 0x0001)
+                                                send_data_verb->rcode = PROGRAM_PARAM_CHECK;
+                                        else
+                                                sna_send_data_buffer_management(send_data_verb->data, rcb);
+                                }
+                                break;
+
+                        default:
+                                /* Error */
+                }
+
+                send_data_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+                rcb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_rcv_wait(struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_rcv_wait\n");
+
+	/* handle signals */
+        if(signal_pending(current))
+        	return (-ERESTARTSYS);
+
+	if(skb_peek(&tcb->receive_queue) != NULL)
+	{
+		printk("Queue already has data on it, retuning now!\n");
+		return (0);
+	}
+
+	interruptible_sleep_on(&tcb->sleep);
+
+	return (0);
+}
+
+static int sna_ps_rcv_immediate(struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_rcv_immediate %d\n", tcb->tcb_id);
+
+#ifdef NOT
+        struct sna_rcb *rcb;
+
+        rcb = search_rcb(receive_immediate_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                receive_immediate_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                state = fsm_error_or_failure();
+                if(state == RCVD_ERROR)
+                {
+                        if(find_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                        if(state == CONV_FAILURE_SON
+                                || state == CONV_FAILURE_PROTOCOL_ERROR)
+                        {
+                                if(state == CONV_FAILURE_SON)
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                        }
+                        else
+                                sna_dequeue_fmh7_proc(receive_immediate_verb, rcb);
+                }
+                else
+                {
+                        fsm_conversation(s, receive_immediate, rcb);
+                        rcb->post_conditions.max_length = receive_immediate_verb->max_length;
+                        rcb->post_conditions.fill = receive_immediate_verb->fill;
+                        receive_immediate_verb->data = NULL;
+                        sna_perform_receive_proc(rcv, receive_immediate_verb);
+                        fsm_post(receive_immediate);
+                }
+
+                receive_immediate_verb->max_length = length_data_returned;
+                receive_immediate_verb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+	return (0);
+}
+
+int sna_ps_conv(int verb, struct sna_tcb *tcb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_ps_conv\n");
+        switch(verb)
+        {
+                case (ALLOCATE):
+                        err = sna_ps_allocate(tcb);
+                        break;
+
+#ifdef NOT
+		case (CONFIRM):
+                        sna_confirm_proc(confirm_verb);
+                        break;
+
+                case (TEST):
+                        sna_test_proc(test_verb);
+                        break;
+
+                case (CONFIRMED):
+                        sna_confirmed_proc(confirmed_verb);
+                        break;
+
+                case (DEALLOCATE):
+                        sna_deallocate_proc(deallocate_verb);
+                        break;
+
+                case (FLUSH):
+                        sna_flush_proc(flush_verb);
+                        break;
+
+                case (GET_ATTRIBUTES):
+                        sna_get_attributes_proc(get_attributes_verb);
+                        break;
+
+                case (POST_ON_RECEIPT):
+                        sna_post_on_receipt_proc(post_on_receipt_verb);
+                        break;
+
+                case (SEND_ERROR):
+                        sna_send_error_proc(send_error_verb);
+                        break;
+
+		case (PREPARE_TO_RECEIVE):
+                        sna_prepare_to_receive_proc(prepare_to_receive_verb);
+                        break;
+
+                case (REQUEST_TO_SEND):
+                        sna_request_to_send_proc(request_to_send);
+                        break;
+#endif
+		case (RECEIVE_AND_WAIT):
+			err = sna_ps_rcv_wait(tcb);
+			break;
+
+		case (RECEIVE_IMMEDIATE):
+			err = sna_ps_rcv_immediate(tcb);
+                        break;
+
+                case (SEND_DATA):
+                        err = sna_ps_send_data(tcb);
+                        break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (err);
+}
+
+#ifdef NOT
+
+static int sna_confirm_proc(struct sna_confirm_verb *confirm_verb)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirm_verb->resource);
+	if(rcb->sync_level == NONE || send data != logical bounds)
+	{
+		if(rcb->sync_level == NONE)
+			confirm_verb->rcode = PROGRAM_PARAM_CHECK;
+		else
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		if(fsm_conversation(s, confirm, rcb) cause state check)
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+		else
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			switch(fsm_error_or_failure())
+			{
+				case (CONV_FAILURE_PROTOCOL_ERROR):
+					confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (CONV_FAILURE_SON):
+					confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (RCVD_ERROR):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+					state = fsm_error_or_failure();
+					if(state == CONV_FAILURE_SON
+						|| state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						if(state == CONV_FAILURE_SON)
+							confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+						else
+							confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+					}
+					else
+						sna_dequeue_fmh7_proc(confirm_verb, rcb);
+					break;
+
+				case (NO_REQUESTS):
+					sna_complete_confirm_proc(confirm_verb, rcb);
+			}
+
+		confirm_verb->request_to_send_received = rcb->rq_to_send_rcvd;
+		rcb->request_to_send_received = NO;
+	}
+
+	return (0);
+}
+
+static int sna_comfirmed_proc(struct sna_confirmed_verb *confirmed_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirmed->resource);
+	if(fsm_conversation(s, confirmed, rcb) > cause state_condition)
+	{
+		confirmed_verb->rcode = PROGRAM_STATE_CHECK;
+	{
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(fsm_error_or_failure())
+		{
+			case (NO_REQUESTS):
+				sna_send_confirmed_proc(rcb);
+				break;
+
+			case (RCVD_ERROR):
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				break;
+
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				/* Do nothing */
+				break;
+		}
+
+		fsm_conversation(s, confirmed, rcb);
+		confirmed_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_proc(struct sna_deallocate_verb *deallocate_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(deallocate_verb->resource);
+	switch(deallocate_verb->type)
+	{
+		case (FLUSH):
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == NONE)
+			{
+				if(fsm_conversatio(s, deallocate_flush, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					deallocate_flush_proc(deallocate_verb, rcb);
+			}
+			break;
+
+		case (CONFIRM):
+			if(fsm_conversation(s, deallocate_confirm, rcb) > state_check)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				if(rcb->sync_level == CONFIRM
+					|| rcb->sync_level == SYNCPT)
+				{
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				}
+				else
+					deallocate_verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			break;
+
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == CONFIRM)
+			{
+				if(fsm_conversation(s, deallocate_confirm_rc, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				break;
+			}
+
+			if(rcb->sync_level == SYNCPT)
+			{
+				if(fsm_conversation(s, deallocate_defer, rcb) > state_condiation)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(tp == logical_bounds())
+					{
+						fsm_conversation(s, deallocate_defer, rcb);
+						deallocate_verb->rcode = OK;
+					}
+					else
+						deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+
+				break;
+			}
+
+		case (ABEND_PROG):
+		case (ABEND_SVC):
+		case (ABEND_TIMER):
+			if(fsm_conversation(s, deallocate_abend, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+				sna_deallocate_abend_proc(deallocate_verbm rcb);
+			break;
+
+		case (LOCAL):
+			if(fsm_conversation(s, deallocate_local, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				deallocate_verb->rcode = OK;
+				fsm_conversation(s, deallocate_local, rcb);
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_flush_proc(struct sna_flush_verb *flush_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	rcb = search_rcb(flush_verb->resource);
+	if(fsm_conversation(s, flush, rcb) > state_condition)
+		flush_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			switch(fsm_conversation())
+			{
+				case (SEND_STATE):
+					if(mu != NULL)
+						send_to_hs(mu);
+					break;
+
+				case (PREP_TO_RCV_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+					break;
+
+				case (DEALL_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					send_to_hs(mu);
+					break;
+
+			}
+
+			if(fsm_conversation() == DEALL_DEFER)
+				sna_end_conversation_proc(rcb);
+			fsm_conversation(s, flush, rcb);
+		}
+
+		flush_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_get_attributes_proc(struct sna_get_attributes_verb *get_attributes_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_partner_lu *plu;
+
+	rcb = search_rcb(get_attributes_verb->resources);
+	get_attributes_verb->conversation_group_id = rcb->conversation_group_id;
+	get_attributes_verb->partner_fq_lu_name = plu->fq_lu_name;
+	get_attributes_verb->partner_lu_name = rcb->lu_name;
+	get_attributes_verb->mode_name = rcb->mode_name;
+	get_attributes_verb->sync_level = rcb->sync_level;
+	get_attributes_verb->rcode = OK;
+
+	fsm_conversation(s, get_attributes, rcb);
+
+	return (0);
+}
+
+static int sna_post_on_receipt_proc(struct sna_post_on_receipt_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(post_on_receipt_verb->resource);
+	if(fsm_conversation(s, post_on_receipt, rcb) > state_condition)
+	{
+		post_on_receipt_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		fsm_conversation(s, post_on_receipt, rcb);
+		fsm_post(post_on_receipt);
+		rcb->post_conditions.fill = post_on_receipt_verb->fill;
+		rcb->post_conditions.max_length = post_receipt_verb->max_length;
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		post_on_receipt_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_prepare_to_receive_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(prepare_to_receive_verb->resource);
+	if(tp->data_sent != logical_bounday)
+		prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		switch(prepare_to_receive_verb->type)
+		{
+			case (FLUSH):
+			case (SYNC_LEVEL):
+				if(prepare_to_receive_verb->sync_level == NONE)
+				{
+					if(fsm_conversation(s, prepare_to_receive_flush, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_flush_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+			case (CONFIRM):
+				if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+				{
+					prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(sync_level == CONFIRM
+						|| sync_level == SYNCPT)
+					{
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					}
+					else
+						prepare_to_receive_verb->rcode = PROGRAM_PARAM_CHECK;
+				}
+				break;
+
+			case (SYNC_LEVEL):
+				if(sync_level == CONFIRM)
+				{
+					if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+				if(sync_level == SYNCPT)
+				{
+					if(fsm_conversation(s, prepare_to_receive_defer, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+					{
+						fsm_conversation(s, prepare_to_receve_defer, rcb);
+						rcb->locks = prepare_to_receive_verb->locks;
+						prepare_to_receive_verb->rcode = OK;
+					}
+
+					break;
+				}
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_receive_and_wait_proc(struct sna_receive_and_wait_verb *receive_and_wait_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	if(fsm_conversation(s, receive_and_wait, rcb) > state_condition)
+		receive_and_wait_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		if(fsm_error_or_failure() == RCVD_ERROR)
+		{
+			if(fsm_conversation() == SEND_STATE)
+			{
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+			}
+
+			if(check_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+			{
+				sna_receive_rm_or_hs_to_ps_buffer_list(suspend_list);
+			}
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(receive_and_wait_verb, rcb);
+		}
+		else
+		{
+			fsm_conversation(s, receive_and_wait, rcb);
+			recevie_and_wait_verb->data = NULL;
+			sna_receive_and_test_posting(rcb, receive_and_wait_verb);
+		}
+
+		receive_and_wait_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_request_to_send_proc(struct sna_request_to_send_verb *request_to_send_verb)
+{
+	struct sna_rcb *rcb
+
+	rcb = search_rcb(request_to_send_verb->resource);
+	if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+		request_to_send_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == NO_REQUESTS || state == RCVD_ERROR)
+		{
+			if(rcb->ec_type != DEALLOCATE_FLUSH)
+			{
+				sna_send_request_to_send_proc(rcb);
+				sna_wait_for_rsp_to_rq_to_send_proc(rcb);
+			}
+		}
+		request_to_send_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_send_err_proc(struct sna_send_error_verb *send_error_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(send_error_verb->resource);
+	if(fsm_conversation(s, send_error, rcb) > state_condition)
+		send_error_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(state = fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				fsm_conversation(s, send_error, rcb);
+				if(state == CONV_FAILURE_SON)
+					send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (NO_REQUESTS):
+			case (RCVD_ERROR):
+				switch(fsm_conversation())
+				{
+					case (SEND_STATE):
+						sna_send_error_in_send_state(send_error_verb, rcb);
+						break;
+
+					case (RCVD_CONFIRM):
+					case (RCVD_CONFIRM_SEND):
+					case (RCVD_CONFIRM_DEALL):
+						sna_send_error_to_hs_proc(rcb);
+						fsm_conversation(s, send_error, rcb);
+						sna_send_error_done_proc(send_error_verb, rcb);
+						break;
+
+					case (RCV_STATE):
+						sna_send_error_in_receive_state(send_error_verb, rcb);
+						break;
+
+					default:
+						/* Error */
+				}
+			}
+		}
+
+		send_error_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_test_proc(struct sna_test_verb *test_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(test_verb->resource);
+	test_verb->rcode = OK;
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(test_verb->param)
+	{
+		case (POSTED):
+			if(fsm_conversation(s, test_posted, rcb) > state_condition)
+			{
+				test_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FAILURE_SON):
+						test_verb->rcode = RESOURCE_FAILURE_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (CONV_FAILURE_PROTOCOL_ERROR):
+						test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (RCVD_ERROR):
+						if(fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+						{
+							sna_receive_rm_or_hs_to_ps_records(suspend_list);
+						}
+						state = fsm_error_or_failure();
+						if(state == CONV_FAILURE_SON
+							|| state == CONV_FAILURE_PROTOCOL_ERROR)
+						{
+							if(state == CONV_FAILURE_SON)
+								test_verb->rcode = RESOURCE_FAILURE_RETRY;
+							else
+								test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+							fsm_conversation(r, resource_failure_rc, rcb);
+						}
+						else
+							sna_dequeue_fmh7_proc(test_verb, rcb);
+						break;
+
+					case (NO_REQUESTS):
+						sna_test_for_post_statisfied(rcb);
+						switch(fsm_port)
+						{
+							case (PEND_POST):
+								test_verb->rcode = UNSUCCESSFUL;
+								break;
+
+							case (POSTED):
+								if(fmh7 next to process)
+									sna_dequeue_fmh7_proc(test_verb, rcb);
+								else
+									test_verb->subcode = NOT_DATA || DATA;
+						}
+
+						if(fsm_conversation() != END_CONV)
+							fsm_conversation(s, test, rcb);
+						fsm_post(test);
+						break;
+
+					case (REQUEST_TO_SEND_RECEIVED):
+						if(fsm_conversation(s, test_rq_to_send_rcvd, rcb) > state_condition)
+							test_verb->rcode = PROGRAM_STATE_CHECK;
+						else
+						{
+							if(rcb->rq_to_send_rcvd == YES)
+								rcb->rq_to_send_rcvd = NO;
+							else
+								test_verb->rcode = UNSUCCESSFUL;
+							fsm_conversation(s, test_rq_to_send_rcvd, rcv);
+						}
+						break;
+
+					default:
+						/* error */
+				}
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+
+/************************************************************************
+* Low level procedures							*
+************************************************************************/
+
+static int sna_complete_confirm_proc(struct sna_confirm *confirm, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_MU_BUFF);
+	if(mu == NULL)
+		sna_create_and_init_limited_mu(rcb, mu);
+
+	switch(fsm_conversation())
+	{
+		case (SEND_STATE):
+			mu->ps_to_hs.type = CONFIRM;
+			send_to_hs(mu);
+			break;
+
+		case (PREP_TO_RCV_DEFER):
+			if(rcb->locks == SHORT?)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT;
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+
+			send_to_hs(mu);
+			break;
+
+		case (DEALL_DEFER):
+			mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+			send_to_hs(mu);
+			break;
+
+	}
+
+	fsm_conversation(s, confirm, rcb);
+	sna_wait_for_confirmed_proc(confirm, rcb);
+
+	return (0);
+{
+
+static int sna_complete_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(deallocate->type)
+	{
+		case (ABEND_PROG):
+			sense = 0x08640000;
+			break;
+
+		case (ABEND_SVC):
+			sense = 0x08640001;
+			break;
+
+		case (ABEND_TIMER):
+			sense = 0x08640002;
+			break;
+	}
+
+	mu = bm(GET_SEND_BUF);
+	if(mu != NULL)
+		send_to_hs(mu);
+
+	sna_create_and_init_limited_mu(rcb, mu);
+	if(log_data != NULL)
+	{
+		mu->log_data = log_data;
+		mu->sense = sense;
+
+		err_log_gds = create();
+		sna_send_data_buffer_management(err_log_gds, rcb);
+		Log_err(err_log_gds);
+	}
+	else
+		store_mu(no_log_data);
+
+	mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_conversation_failure_proc(struct sna_conversation_failure *conv_failure)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(conv_failure->resource);
+	if(rcb != NULL)
+	{
+		if(conv_failure->reason == PROTOCOL_VIOLATION)
+			fsm_error_or_failure(conv_fail_protocol);
+		else
+			fsm_error_or_failure(conv_fail_son);
+
+		if(fsm_post == PEND_POSTED)
+			fsm_port(post);
+	}
+
+	return (0);
+}
+
+static int sna_create_and_init_limited_mu(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->limit_buf_pool_id, wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, rcb->send_ru_size, wait);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= send_data_record;
+	mu->ps_to_hs.allocate 		= NO;
+	mu->ps_to_hs.fmh 		= NO;
+	mu->ps_to_hs.type 		= FLUSH;
+	mu->dcf 			= (data->size + rh->size);
+
+	return (0);
+}
+
+static int sna_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	sna_receive_rm_or_hs_to_ps_records(susped_list);
+
+	state = fsm_error_or_failure();
+	if(state == NO_REQUEST || state == RCVD_ERROR)
+	{
+		switch(fsm_conversation())
+		{
+			case (RCV_STATE):
+				if(DEALLOCATE_FLUSH != received)
+				{
+					sna_send_eror_to_hs_proc(rcb);
+					sna_wait_for_send_error_done_proc(deallocate, rcb);
+				}
+				break;
+
+			case (RCVD_CONFIRM):
+			case (RCVD_CONFIRM_SEND):
+			case (RCVD_CONFIRM_DEALL):
+				sna_send_error_to_hs_proc(rcb);
+				sna_wait_for_send_error_done_proc(deallocate, rcb);
+				break;
+
+			case (SEND_STATE):
+			case (PREP_TO_RCV_DEFER):
+			case (DEALL_DEFER):
+				sna_complete_deallocate_abend_proc(deallocate,rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	deallocate->rcode = OK;
+	sna_fsm_conversation(s, dellocate, rcb);
+	sna_end_conversation_proc(rcb);
+
+	return (0);
+}
+
+static int sna_deallocate_confirm_proc(struct sna_deallocate *deallocate)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	if(tp->data != at_logical_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		fsm_conversation(s, deallocate_confim, rcb);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (CONV_FAILURE_SON)
+				deallocate->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (RCVD_ERROR):
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+
+				if(fmh7 !in rcb->hs_to_ps_buffer_list)
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				else
+					sna_receive_rm_or_hs_to_ps_records(suspend_list); /* Empty */
+
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON
+					{
+						deallocate->rcode = RESOURCE_FAILURE_RETRY;
+					}
+
+					if(state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+					}
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_deqeue_fmh7_proc(deallocate, rcb);
+
+			case (NO_REQUESTS):
+				if(mu == NULL)
+					mu = sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+				sna_wait_for_confirmed_proc(deallocate, rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_flush_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(tp->data != logical_record_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspends_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+		}
+
+		deallocate->rcode = OK;
+		fsm_conversation(s, deallocate_flush, rcb);
+		sna_end_conversation_proc(rcb);
+	}
+
+	return (0);
+}
+
+static int sna_dequeue_fmh7_proc(*tp, struct sna_rcb *rcb)
+{
+
+	fsm_post(receive_immediate);
+	if(rcb->hs_to_ps_buffer_list == fmh-7)
+	{
+		remove_first_from_list(rcb->hs_to_ps_buffer_list);
+		sna_process_fmh7_proc(rcb, tp);
+	}
+	else
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+		tp->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_end_conversation_proc(struct sna_rcb *rcb, struct sna_rcb_deallocated *rcb_deallocated)
+{
+	struct sna_mu *mu;
+	struct sna_deallocate_rcb *deallocate_rcb;
+
+	for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		bm(FREE, mu);
+
+	if(rcb->send_buffer != NULL)
+		bm(FREE, rcb->send_buffer);
+
+	deallocate_rcb = (struct sna_deallocate_rcb *)kmalloc(sizeof(deallocate_rcb), GFP_ATOMIC);
+	rcb_deallocated = sna_wait_for_rm_reply(rcb);
+	destroy(rcb_deallocated);
+
+	return (0);
+}
+
+static int sna_get_dallocate_from_hs(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	chain_type = sna_get_end_chain_from_hs(rcb);
+	if(chain_type == DEALLOCATE_FLUSH || chain_type == DEALLOCATE_CONFIRM)
+		do_nothing(); ??
+
+	state = fsm_error_or_failure();
+	if(state == CONV_FAILURE_PROTOCOL_ERROR || state == CONV_FAILURE_SON)
+		do_nothing(); ??
+
+	/* Otherwise */
+	sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+	tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+	rcb->fsm_conversation(r, resource_failure_rc, rcb);
+
+	return (0);
+}
+
+static int sna_get_end_chain_from_hs(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(end_of_chain != recieved_for_this_conv)
+	{
+		for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		{
+			if(mu->hs_to_ps.type == END_OF_CHAIN)
+				type = mu;
+
+			bm(FREE, mu);
+		}
+	}
+
+	while(end_of_chain != recieved)
+	{
+		record = grab_record(rcb);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				destroy(record);
+				break;
+
+			case (MU):
+				if(mu->hs_to_ps.type == END_OF_CHAIN)
+					type = mu;
+				bm(FREE, mu);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	/* Update rcb to show receipt of eoc type */
+	rcb->end_of_chain = eoc;
+
+	return (0);
+}
+
+static int sna_obtain_session_proc(struct sna_rcb *rcb, sna_allocate_verb *allocate_verb, __u8 session_req, __u8 conv_group_id)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *session_allocated;
+
+	get_session = (struct sna_get_session *)kmalloc(sizeof(get_session), GFP_ATOMIC);
+	get_session->tcb_id 	= rcb->tcb_id;
+	get_session->rcb_id 	= rcb->rcb_id;
+	get_session->type	= session_req;
+	get_session->conv_group_id = conv_group_id;
+	send_to_rm(get_session);
+
+	session_allocated = sna_wait_for_rm_reply();
+	switch(session_allocated->rcode)
+	{
+		case (OK):
+			rcb->send_ru_size = session_allocated->send_ru_size;
+			rcb->limit_buf_pool_id = session_allocated->limit_buf_pool_id;
+			rcb->perm_buf_pool_id = session_allocated->perm_buf_pool_id;
+			sna_create_and_init_limited_mu(rcb, mu);
+			if(session_allocated->in_conversation == YES)
+				mu->ps_to_hs.allocate = NO;
+			else
+				mu->ps_to_hs.allocate = YES;
+			break;
+
+		default:
+			allocate_verb->rcode = ALLOCATION_ERROR;
+			switch(sesion_allocated->rcode);
+			{
+				case (UNSUCCESSFUL_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_RETRY;
+					break;
+
+				case (UNSUCCESSFUL_NO_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_NO_RETRY;
+					break;
+
+				case (SYNC_LEVEL_NOT_SUPPORTED):
+					allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED;
+					break;
+			}
+			break;
+	}
+
+	destroy(session_allocated);
+
+	return (0);
+}
+
+static int sna_perform_receive_ec_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	if(tp->data_sent != logical_record_boundary)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	if(rcb->sync_level == NONE
+		&& rcb->ec_type == CONFIRM
+		|| rcb->ec_type == PREPARE_TO_RCV_CONFIRM
+		|| rcb->ec_type == DEALLOCATE_CONFIRM)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	/* Otherwise */
+	switch(rcb->ec_type)
+	{
+		case (CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM;
+			fsm_conversation(r, confirm_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_SEND;
+			fsm_conversation(r, confirm_send_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_FLUSH):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = SEND;
+			fsm_conversation(r, send_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_DEALLOCATE;
+			fsm_conversation(r, confirm_deallocate_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_FLUSH):
+			receive_verb->rcode = DEALLOCATE_NORMAL;
+			fsm_conversation(r, deallocate_normal_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perform_receive_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(mu_ptr != NULL || rcb->ec_indicator != NOT_END_OF_DATA)
+	{
+		for(mu = mu_ptr; (mu != NULL && post_not_satisfied); mu = mu->next)
+		{
+			if(mu->type == FMH_7)
+			{
+				if(no_data_copied_to_pass_to_tp)
+				{
+					sna_process_fmh7_proc(rcb,receive_verb);
+					continue;
+				}
+			}
+			else
+			{
+				if(mu->end_of_data != TRUE)
+					sna_process_data_proc(rcb, receive_verb, DATA_NEEDED);
+				else	/* All data received */
+				{
+					if(mu->hs_to_ps.type == NOT_END_OF_DATA)
+					{
+						bm(FREE, mu);
+						continue;
+					}
+					else
+					{
+						ec_received_post_ok;
+						break;
+					}
+				}
+			}
+		}
+
+		if(no_data_returned && fmh7 != processed
+			&& rcb->ec_type != NOT_END_OF_DATA)
+		{
+			sna_preform_receive_ec_processing(rcb, receive_verb);
+			return_to_tp (rcb->ec_type);
+		}
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (CONV_FAILURE_SON):
+				receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			default:
+				if(receive_verb->type == RECEIVE_IMMEDIATE)
+					receive_verb->rcode = UNSUCCESSFUL;
+				else
+					receive_verb->rcode = OK;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_perform_more_rcv_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		default:
+			if(receive_verb->type == RECEIVE_IMMEDIATE)
+				receive_verb->rcode = UNSUCCESSFUL;
+			else
+				receive_verb->rcode = OK;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_confirm_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	fsm_conversation(s, prepare_to_receive_confirm, rcb);
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (RCVD_ERROR):
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FALIURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		case (NO_REQUESTS):
+			if(rcb->locks == SHORT)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+			sna_wait_for_confirmed_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_flush_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	state = fsm_error_or_failure();
+	if(state == RCVD_ERROR || state == NO_REQUESTS)
+	{
+		if(mu == NULL)
+			sna_create_and_init_limited_mu(rcb, mu);
+		mu->ps_to_hs.type = PREPARE_TO_RECEIVE_FLUSH;
+		send_to_hs(mu);
+	}
+
+	prepare_to_receive_verb->rcode = OK;
+	fsm_conversation(s, prepare_to_receive_flush, rcb);
+
+	return (0);
+}
+
+static int sna_process_data_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_receive_verb *receive_verb)
+{
+
+	return 0;
+}
+
+static int sna_process_fmh7_log_data_proc(struct sna_rcb *rcb, __u8 fmh_sense_data, struct sna_tp_verb *tp_verb)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	/* Get log data */
+	receive_and_wait = (struct sna_receive_and_wait *)kmalloc(sizeof(receive_and_wait), GFP_ATOMIC);
+	receive_and_wait->resource 	= rcb->rcb_id;
+	receive_and_wait->fill 		= LL;
+	receive_and_wait->max_length 	= 0x7FFF;
+	receive_and_wait->data 		= NULL;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	if(receive_and_wait->rcode == OK
+		&& receive_and_wait->what_received == DATA_COMPLETE)
+	{
+		if(gds_id == 0x12E1)
+			Log_err();
+		else
+		{
+			Log_err();
+			sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+			fsm_error_or_failure_signal(CONV_FAIL_PROTOCOL);
+		}
+	}
+	else
+	{
+		if(receive_and_wait->rcode == RESOURCE_FAILURE_RETRY)
+			Log_err(son);
+		else
+			Log_err(proto);
+	}
+
+	destroy(receive_and_wait);
+
+	/* Set the states of the FSMs */
+	if(fmh_sense_data == 0x08640000
+		|| fmh_sense_data == 0x08640001
+		|| fmh_sense_data == 0x08640002)
+	{
+		if(fsm_error_or_failure() == NO_REQUESTS)
+			sna_get_deallocate_from_hs(tp_verb, rcb);
+		sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+				break;
+
+			case (CONV_FAILURE_SON):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_SON);
+				break;
+
+			default:
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+		}
+	}
+
+	sna_set_rcb_rcv_defaults(rcb);
+
+	return (0);
+}
+
+static int sna_process_fmh7_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_tp_verb *tp_verb)
+{
+	struct sna_mu *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	/* Validate FMH-7 */
+	err = sna_check_fmh7(mu);
+	if(err)
+	{
+		sna_ps_protocol_error(rcb->hs_id, err);
+		tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+		rcb->post_condiations.max_length = 0;
+	}
+	else
+	{
+		sna_set_init_rcb_rcv(rcb);
+		if(mu->data_received == ALL)
+		{
+			/* Remember if fmh7 has sense and log data */
+			type = mu->ec_type;
+			bm(FREE, mu);
+		}
+		mu_ptr = rcb->hs_to_ps_buffer_list;
+
+		/* Get log data if present */
+		if(fmh7->log_data == TRUE)
+		{
+			sna_process_fmh7_log_data_proc(rcb, fmh7_sense_data, tp_verb);
+		}
+		else
+		{
+			if(fmh_sense_data == 0x08640000
+				|| fmh_sense_data == 0x08640001
+				|| fmh_sense_data == 0x08640002)
+			{
+				sna_get_deallocate_from_hs(tp_verb, rcb);
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FALIURE_PROTOCOL_ERROR):
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+						break;
+
+					case (CONV_FAILURE_SON):
+						sna_set_fmh7_rcb(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_SON);
+						break;
+
+					default:
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						break;
+				}
+			}
+		}
+	}
+	
+	return (0);
+}
+
+static int sna_receive_and_test_posting(struct sna_rcb *rcb, struct sna_receive_and_wait *receive_and_wait)
+{
+	/* Test post */
+	fsm_post(POST_ON_RECEIPT);
+	rcb->post_conditions.fill = receive_and_wait->fill;
+	rcb->post_conditions.max_length = receive_and_wait->max_length;
+	sna_test_for_post_satisfied(rcb);
+	sna_perform_receive_processing(rcb, receive_and_wait);
+
+	if(fsm_post() == PEND_POSTED)	/* Remove if, its not needed, IBM... */
+	{
+		while(fsm_port() == PEND_POST)
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			sna_test_for_post_satisfied(rcb);
+			sna_performa_receive_processing(rcb, receive_and_wait);
+		}
+	}
+
+	sna_receive_and_wait->max_length = tp->data_returned;
+	fsm_post(RECEIVE_IMMEDIATE);
+
+	return (0);
+}
+
+static int sna_receive_rm_or_hs_to_ps_records(struct sna_suspend_list *suspend_list)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	more_records = 1;
+	if(suspend_list == NULL)
+		suspend_flag = NO_SUSPEND;
+	else
+		suspend_flag = SUSPEND;
+
+	while(more_records)
+	{
+		/* Shrink */
+		if(suspend_flag == SUSPEND)
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+			{
+				mu = find_record_hs_to_ps_q();
+				if(mu == NULL)
+					mu = find_record_suspend();
+			}
+		}
+		else	/* NO_SUSPEND */
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+				mu = find_record_hs_to_ps_q();
+		}
+
+		if(mu != NULL)
+		{
+			if(mu->type == CONVERSATION_FAILURE)
+			{
+				dequeue_rm_to_ps_q(mu);
+				rcb = search_rcb(mu->rcb_id);
+				if(rcb != NULL)
+					sna_conversation_failure_proc(mu);
+				else
+					destroy(mu);
+			}
+			else
+			{
+				dequeue_hs_to_ps_q(mu);
+				switch(mu->type)
+				{
+					case (REQUEST_TO_SEND):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							rcb->rq_to_send_rcvd = YES;
+						destroy(mu);
+						break;
+
+					case (RECEIVE_ERROR):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							fsm_error_or_failure(RECEIVE_ERROR, rcb);
+						destroy(mu);
+						break;
+
+					case (RSP_TO_REQUEST_TO_SEND):
+					case (CONFIRMED):
+						destroy(mu);
+						break;
+
+					case (MU):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+						{
+							if(fsm_conversation() == RCB_STATE || fsm_error_or_failure() == RCVD_ERROR)
+							{
+								queue_hs_to_ps_buffer_list(rcb->hs_to_ps_buffer_list, mu);
+							}
+							else
+							{
+								bm(FREE, mu);
+								if(fsm_conversation() == END_CONV)
+								{
+									sna_ps_protocol_error(rcb->hs_id, 0x20040000);
+								}
+							}
+						}
+						else
+							bm(FREE, mu);
+						break;
+				}
+			}
+
+			if(suspend_flag == SUSPEND 
+				&& found_rcb_id_in_suspend == TRUE)
+			{
+				suspend_flag = NO_SUSPEND;
+			}
+		}
+		else
+			more_records = 0;
+	}
+
+	return (0);
+}
+
+static int sna_send_confirmed_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->perm_buf_pool_id, no_wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, size, no_wait);
+
+	mu->header_type = PS_TO_HS;
+	mu->ps_to_hs.bracket_id = rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant = CONFIRMED;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_err_done_proc(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(send_error_verb->type)
+	{
+		case (PROG):
+			state = fsm_conversation();
+			if(state == SEND_STATE)
+			{
+				if(data sent by tp is at logical bounds)
+					sense = 0x08890000;
+				else
+					sense = 0x08890001;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		case (SVC):
+			state = fsm_conversation();
+
+			if(state == SEND_STATE)
+			{
+				if(data is at logical bounds)
+					sense = 0x08890100;
+				else
+					sense = 0x08890101;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		default:
+			/* Error */
+	}
+
+	if(send_error_verb->log_data != NULL)
+	{
+		create_fmh7_with_log_data();
+		create_log_gds(log_data);
+		sna_send_data_buffer_management(log_gds, rcb);
+		Log_err(sys);
+	}
+	else
+		create_fmh7_with_log_data();
+
+	if(FLUSH == NOT_IMPLEMENTED || fmh7->flush_immediately == TRUE)
+		send_to_hs(mu);
+
+	send_error_verb->rcode = OK;
+
+	return (0);
+}
+
+static int sna_send_err_in_receive_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(rcb->ec_type == DEALLOCATE_FLUSH)
+	{
+		if(mu_ptr != NULL)
+			bm(FREE, mu_ptr);
+		send_error_verb->rcode = DEALLOCATE_NORMAL;
+		fsm_conversation(r, deallocate_normal_rc, rcb);
+	}
+	else
+	{
+		sna_send_error_to_hs_proc(rcb);
+		sna_wait_for_send_error_done_proc(send_error_verb, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_send_err_in_send_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(fsm_error_or_failure() == NO_REQUESTS)
+	{
+		if(send_mu_buffer_present)
+			send_to_hs(mu);
+		fsm_conversation(s, send_error, rcb);
+		sna_send_error_done_proc(send_error_verb, rcb);
+	}
+	else
+	{
+		mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+		send_to_hs(mu);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		state = fsm_error_or_failure();
+		if(state == CONV_FAILURE_SON 
+			|| state == CONV_FAILURE_PROTOCOL_ERROR)
+		{
+			if(state == CONV_FAILURE_SON)
+				send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+			else
+				send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+		}
+		else
+			sna_dequeue_fmh7_proc(send_error_verb, rcb);
+	}
+
+	set_rcb_send_fields_to_init(rcb);
+
+	return (0);
+}
+
+static int sna_send_err_to_hs_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= SEND_ERROR;	/* verb?? */
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_request_to_send_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant	= REQUEST_TO_SEND;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_set_fmh7_rc(struct sna_rcb *rcb, __u8 fmh7_sense, struct sna_tp_verb *tp_verb)
+{
+	switch(fmh7_sense)
+	{
+		case (ALLOCATION_ERROR):
+			get_deallocate(rcb->hs_to_ps_buffer_list);
+			if(fsm_conversation() == END_CONV)
+			{
+				tp_verb->rcode = corresponding_rcode(END_CONV);?
+				fsm_conversation(r, allocation_error, rcb);
+			}
+			break;
+
+		case (RESOURCE_FAILURE_NO_RETRY):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (PROG_ERROR_NO_TRUNC):
+		case (PROG_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = PROG_ERROR_PURGING;
+			else
+				tp_verb->rcode = PROG_ERROR_NO_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (PROG_ERROR_TRUNC):
+			tp_verb->rcode = PROG_ERROR_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_NO_TRUNC):
+		case (SVC_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = SVC_ERROR_PURGING;
+			else
+				tp_verb->rcode = SVC_ERROR_NO_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_TRUNC):
+			tp_verb->rcode = SVC_ERROR_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (DEALLOCATE_ABEND):
+			tp_verb->rcode = many_diff_choices();
+			fsm_conversation(r, deallocate_abend_rc, rcb);
+			break;
+
+		default:
+			ps_protocol_error(rcb->hs_id, fmh7_sense);
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_test_for_post_satisfied(struct sna_rcb *rcb)
+{
+
+	return 0;
+}
+
+static int sna_wait_for_confirmed_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	struct sna_confirmed *confirmed;
+
+	while((confirmed = recv_confirmed()) == NULL)
+	{
+		record = get_record(1st);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				if(fsm_error_or_failure() == CONV_FAILURE_SON)
+					tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				while(rcb->hs_to_ps_buffer_list == NULL
+					&& fsm_error_or_failure() == RCVD_ERROR)
+				{
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				}
+
+				state = fsm_error_or_failure();
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON)
+						tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+					else
+						tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_dequeue_fmh7_proc(confirm_verb, rcb);
+				destroy(record);
+				break;
+
+			case (CONFIRMED):
+				tp_verb->rcode = OK;
+				if(fsm_conversation() == PEND_DEALL)
+				{
+					fsm_conversation(r, DEALLOCATION_INDICATOR, rcb);
+					sna_end_conversation_proc(rcb);
+				}
+				destroy(record);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(r, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_rm_reply(struct sna_mu *mu)
+{
+	mu = NULL
+
+	while(mu == NULL)
+	{
+		sleep()
+		mu = get_record();
+
+		if(mu->type == CONVERSATION_FAILURE)
+			sna_conversation_failure_proc(mu);
+		else
+			return (0);
+	}	
+
+	return (0);
+}
+
+static int sna_wait_for_rsp_to_rq_to_send_proc(struct sna_rcb *rcb, struct sna_hs_to_ps_records *hs_to_ps_records)
+{
+	struct sna_mu *mu = NULL;
+
+	while(mu == NULL)
+	{
+		mu = get_record(1st);
+		switch(mu->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(mu);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(mu);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				destroy(mu);
+				break;
+
+			case (RSP_TO_REQUEST_TO_SEND):
+				destroy(mu);
+				break;
+
+			case (MU):
+				queue_mu(rcb->hs_to_ps_buffer_list, mu);
+				queue_tail(hs_to_ps_buffer_list, mu);
+				if(rcb->ec_type == DEALLOCATE_FLUSH)
+					break;
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, fmh7_sense);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_send_err_done_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+
+	sna_get_end_chain_from_hs(rcb);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_SON):
+			tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(s, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+
+		default:
+			switch(rcb->ec_type)
+			{
+				case (DEALLOCATE_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						tp_verb->rcode = DEALLOCATE_NORMAL;
+						fsm_conversation(r, deallocate_normal_rc, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						tp_verb->rcode = OK;
+						break;
+					}
+
+					break;
+
+				case (DEALLOCATE_CONFIRM):
+				case (CONFIRM):
+				case (PREPARE_TO_RCV_CONFIRM):
+				case (PREPARE_TO_RCV_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						purge_ec_type();
+						sna_send_error_done_proc(send_error, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						sna_complete_deallocate_abend_proc(deallocate, rcb);
+						break;
+					}
+
+					break;
+			}
+	}
+
+	fsm_error_or_failure(reset);
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_ps_copr.c linux/net/sna/sna_ps_copr.c
--- linux-2.4.13/net/sna/sna_ps_copr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_copr.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,482 @@
+/* sna_ps_copr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Control Operator (PS.CORP)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_copr(int verb, struct sna_tcb *tcb)
+{
+#ifdef NOT
+	switch(cnos_verb->type)
+	{
+		case (INITIALIZE_SESSION_LIMIT):
+			sna_init_session_limit_proc(cnos_verb);
+			break;
+
+		case (CHANGE_SESSION_LIMIT):
+			sna_change_sesion_limit_proc(cnos_verb);
+			break;
+
+		case (RESET_SESSION_LIMIT):
+			sna_reset_session_limit_proc(cnos_verb);
+			break;
+
+		case (PROCESS_SESSION_LIMIT):
+			sna_process_session_limit_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_CONVERSATION_GROUP):
+			sna_deact_conversation_group_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_deactivate_session_proc(cnos_verb);
+			break;
+
+		case (ACTIVATE_SESSION):
+			sna_activate_session_proc(cnos_verb);
+			break;
+
+		case (DEFINE_LOCAL_LU):
+		case (DEFINE_REMOTE_LU):
+		case (DEFINE_MODE):
+		case (DEFINE_TP):
+			sna_define_proc(cnos_verb);
+			break;
+
+		case (DELETE):
+			sna_delete_proc(cnos_verb);
+			break;
+
+		default:
+			/* Error */
+	}
+#endif
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_init_session_limit_proc(struct sna_init_session_limit_verb *verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu->lu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG))
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_reset_session_limit_proc(verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_CHECK;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+				if(verb->force == YES)
+				{
+					if(rcode == ALLOCATION_ERROR
+						|| rcode == LU_MODE_SESSION_LIMIT
+						|| rcode == RESOURCE_FAILURE_NO_RETRY
+						|| rcode == UNRECOGNIZED_MODE_NAME)
+					{
+						sna_change_action(verb);
+						rcode = OK_FORCED;
+					}
+				}
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_change_session_limit_proc(verb, rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp != AUTH_OK)
+		rcode = PROGRAM_PARAMETER_CHECK;
+	else
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == INTERLU_PARALLEL
+				&& lucb->mode_name != SNASVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+			{
+				if(type == INTRALU_PARALLEL
+					&& (lucb->mode_name != SNASVCMG
+					|| lucb->mode_name != CPSVCMG)
+				{
+					sna_local_session_limit_proc(verb);
+				}
+				else
+					rcode = PROGRAM_PARAM_CHECK;
+			}
+		}
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_proc(verb, rcode)
+{
+	err = check_verb(activate_session);
+	switch(err)
+	{
+		case (NO_AUTH):
+			rcode = PROGRAM_PARAMETER_CHECK;
+			break;
+
+		case (ERROR_FOUND):
+			rcode = err;
+			break;
+
+		case (OK):
+			activate = (struct sna_rm_activate_session *)kmalloc(sizeof(activate), GFP_ATOMIC);
+			activate->tcb_id = ps_process_data->tcb_id;
+			activate->lu_name = verb->lu_name;
+			activate->mode_name = verb->mode_name;
+			send_to_rm(activate);
+
+			activated = recv_from_rm();
+			rcode = activated->rcode;
+			if(single sess && conwinner)
+				sec_code = OK.AS_SPECIFIED;
+			else
+				sec_code = OK.AS_NEGOTIATED;
+		}
+	}
+
+	destroy(activated);
+
+	return (0);
+}
+
+static int deact_conversation_group_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		deact_group = (struct sna_deactivate_conv_group *)kmalloc(sizeof(deact_group), GFP_ATOMIC);
+		deact_group->conv_group_id = verb->conv_group_id;
+		deact_group->type = verb->type;
+		if(deact_group->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deact_group->sense = verb->sense
+			else
+				deact_group->sense = 0x08A00002;
+		}
+		else
+			deact_group->sense = 0x00000000;
+		send_to_rm(deact_group);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int deactivate_session_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		deactivate = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+		deactivate->tcb_id = ps_process_data->tcb_id;
+		deactivate->session_id = verb->session_id;
+		deactivate->type = verb->type;
+		if(deactivate->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deactivate->sense = verb->sense;
+			else
+				deactivate->sense = 0x08A00002;
+		}
+		else
+			deactivate->sense = 0x00000000;
+		send_to_rm(deactivate);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int sna_define_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		assign values to data_structs..?
+
+	return (0);
+}
+
+static int sna_display_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Display request data, just copy to user space for us */
+
+	return (0);
+}
+
+static int sna_delete_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Delete attribs in delete verb */
+
+	return (0);
+}
+
+static int sna_local_session_limit_proc(verb)
+{
+
+	switch(session_type)
+	{
+		case (SINGLE):
+			err = sna_local_verb_parameter_check(verb);
+			break;
+
+		case (PARALLEL):
+			if(mode_name == SNASVCMG || mode_name == CPSVCMG)
+				err = sna_svcmg_verb_param_check(verb);
+			break;
+
+		case (INTRA_PARALLEL):
+			if(mode_name != SNASVCMG || mode_name != CPSVCMG)
+				err = sna_intra_lu_local_verb_param_check(verb);
+			break;
+
+	}
+
+	if(err = OK)
+		sna_change_action(verb);
+
+	return (0);
+}
+
+static int sna_local_verb_param_check(verb, struct sna_parnter_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+
+	/* Swich is bad here */
+	switch(err)
+	{
+		case (OK):
+			rcode = OK.AS_SPECIFIED;
+			break;
+
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (MODE):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		if(mode->local_max_session_limit != NULL)
+		{
+			case (MAX_ALLOWED):
+				rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_intra_lu_local_verb_parm_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *plu;
+
+	err = check_verb(verb);
+
+	rcode = OK.AS_NEGOTIATED;
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_ZERO;
+			break;
+
+		case LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		case (MAX_ALLOWED):
+			rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_svcmg_verb_param_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+	}
+
+	return (0);
+}
+
+struct sna_change_action(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_ps_main.c linux/net/sna/sna_ps_main.c
--- linux-2.4.13/net/sna/sna_ps_main.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_main.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,555 @@
+/* sna_ps_main.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Services (PS)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_ps_process_fmh5\n");
+	sna_attach_execute_tp(tcb_id, skb);
+
+#ifdef NOT
+        struct sna_tcb *tcb;
+        struct sna_rcb *rcb;
+        __u8 code;
+
+        code = sense;
+
+        rcb = search_rcb(mu->rcb_id?);
+        sna_init_attached_rcb(rcb, mu_with_attach);
+
+        move_to_head(rcb->hs_to_ps_buffer_list, mu_with_attach);
+
+        if(code == OK)
+        {
+                sna_ps_attach_chk(rcb, code);
+                if(pip != NULL)
+                        sna_receive_pip_field_from_hs(rcb, pip, code);
+                sna_ps_pip_chk(pip, code);
+        }
+
+        if(code == OK)
+                sna_upm_execute(tcb->tp_name, rcb->rcb_id, pip);
+        else
+                sna_attach_error_proc(rcb, code);
+#endif
+
+        return (0);
+}
+
+#ifdef NOT
+
+static int sna_ps(unsigned char *record)
+{
+	struct sna_ps_process_data *ps_process_data;
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+
+	/* Establish the enviroment ?? move to init */
+	ps_create_parms = (struct sna_ps_create_params)record;
+	ps_process_data			= ps_create_params;
+
+	lucb = search_lucb(ps_create_params->lu_id);
+	ps_process_data->lucb_ptr	= lucb;
+
+	tcb = search_tcb(ps_create_params->tcb_id);
+	ps_process_data->tcb_ptr	= tcb;
+
+	/* PS_initilize ?? */
+	
+	switch(record_type)
+	{
+		case (MU):
+			sna_process_fmh5(mu);
+			break;
+
+		case (START_TP):
+			sna_process_start_tp(start_tp);
+			break;
+
+		default:
+			Log_err();
+	}
+
+	sna_deallocation_cleanup_proc();	/* Everytime ? */
+
+	return (0);
+}
+
+static int sna_process_start_tp(struct sna_start_tp *start_tp, unsigned char *tp_name)
+{
+	struct sna_tcb *tcb;
+	struct sna_pip *pip; ???
+
+	pip = start_tp->pip;
+	destroy(pip);
+	sna_upm_execute(tp_name, NULL, pip);
+
+	return (0);
+}
+
+static int sna_receive_pip_field_from_hs(struct sna_rcb *rcb, struct sna_pip *pip, __u8 code)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	receive_and_wait = (struct sna_receive_and_wait *)kmalloc(sizeof(receive_and_wait), GFP_ATOMIC);
+	receive_and_wait->post_conditions.fill		= LL;
+	receive_and_wait->post_conditions.max_length	= 0x7FFF;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	err = sna_chk_pip(receive_and_wait->pip);
+	if(!err)
+		return(receive_and_wait->pip);
+	else
+		code = 0x1008201D;
+
+	return (0);
+}
+
+static int sna_ps_attach_chk(struct sna_attach *attach, __u8 code, struct sna_pip *pip)
+{
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_mu *mu;
+
+	mu = sna_get_buf_from_list(rcb->hs_to_ps_buffer_list);
+	mu->tp_name = tcb->tp_name;
+
+	/* Check attach fields for the following */
+	if(lu_work_id fields are bad)
+		code = 0x10086011;
+
+	if(tp->conversation_type != BASIC || tp->conversation_type != MAPPED)
+		code = 0x10086034;
+
+	if(mu has been processed)
+	{
+		type_field = mu->end_of_chain_type;
+		bm(FREE, mu);
+	}
+
+	return (0);
+}
+
+static int sna_ps_pip_chk(struct sna_pip *pip, __u8 code)
+{
+	struct sna_tcb *tcb;
+	struct sna_tp *tp;
+
+	tp->tp_name = attach->tp_name;	/* Screwed Big time */
+
+	if(code != OK)
+		return (-??);
+
+	if(tp->pip_numbers != NULL)
+	{
+		if(tp->number_of_pip_subfields == 0
+			&& attach->pip != NULL)
+		{
+			code = 0x10086031;
+		}
+		else
+		{
+			if(tp->number_of_pip_subfields
+				!= attach->number_of_pip_subfields)
+			{
+				code = 0x10086032;
+			}
+			else
+			{
+				err = check_pip_format(pip);
+				if(err)
+					code = 0x1008201D;
+			}
+		}
+	}
+
+	if(tp->pip == NULL)
+	{
+		if(pip_data == BAD ;)
+			code = 0x1008201D;
+	}
+
+	return (0);
+}
+
+static int sna_attach_error_proc(struct sna_rcb *rcb, __u8 code/sense)
+{
+	struct sna_mu *mu;
+
+	switch(code)
+	{
+		case (0x1008200E):
+		case (0x10086000):
+		case (0x10086005):
+		case (0x10086009):
+		case (0x10086011):
+		case (0x10086040):
+		case (0x1008201D):
+			sna_ps_protocol_error(rcb->hs_id, code);
+			sna_end_conversation_proc(rcb);
+			break;
+
+		default:
+			sna_send_error_to_hs_proc(rcb);
+			sna_end_chain_from_hs(rcb);
+			if(fsm_error_or_failure() == CONV_FAILURE_SON
+				|| fsm_error_or_failure == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				Log_error();
+			}
+			else
+			{
+				switch(end-of-chain type)
+				{
+					case (DEALLOCATE_FLUSH):
+						Log_error();
+						break;
+
+					case (DEALLOCATE_CONFIRM):
+					case (CONFIRM):
+					case (PREPARE_TO_RCV_CONFIRM):
+					case (PREPARE_TO_RCV_FLUSH):
+						sna_upm_attach_log(code, log_data);
+						if(log_data != NULL)
+						{
+							Log_err();
+							attach_fmh-7();
+							sna_send_data_bm(log_data, rcb);
+						}
+					else
+						put_fmh7_into_send_mu();
+
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					break;
+				}
+
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+#endif
+
+int sna_ps_verb_router(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_verb_router(%d)\n", verb);
+	switch(verb)
+	{
+		case (ALLOCATE):
+			sna_ps_conv(verb, tcb);
+			break;
+		case (CONFIRM):
+		case (CONFIRMED):
+		case (DEALLOCATE):
+		case (FLUSH):
+		case (GET_ATTRIBUTES):
+		case (POST_ON_RECEIPT):
+		case (PREPARE_TO_RECEIVE):
+		case (RECEIVE_AND_WAIT):
+		case (RECEIVE_IMMEDIATE):
+		case (REQUEST_TO_SEND):
+		case (SEND_DATA):
+		case (SEND_ERROR):
+		case (TEST):
+			sna_ps_conv(verb, tcb);
+			break;
+
+#ifdef NOT
+		case (MC_ALLOCATE):
+			sna_ps_mc(verb);
+			break;
+
+		case (MC_CONFIRM):
+		case (MC_CONFIRMED):
+		case (MC_DEALLOCATE):
+		case (MC_FLUSH):
+		case (MC_GET_ATTRIBUTES):
+		case (MC_POST_ON_RECEIPT):
+		case (MC_PREPARE_TO_RECEIVE):
+		case (MC_RECEIVE_AND_WAIT):
+		case (MC_REQUEST_TO_SEND):
+		case (MC_SEND_DATA):
+		case (MC_SEND_ERROR):
+		case (MC_TEST):
+			if(verb->resource =?= tcb->resource_list)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				if(rcb->conversation_type == MAPPED)
+				{
+					tcb->cntrl_component = SERVICE_COMPONENT;
+					sna_ps_mc(verb);
+					tcb->cntrl_component = TP;
+				}
+				else
+					verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (INITIALIZE_SESSION_LIMIT):
+		case (CHANGE_SESSION_LIMIT):
+		case (RESET_SESSION_LIMIT):
+		case (SET_LUCB):
+		case (SET_PARTNER_LU):
+		case (SET_MODE):
+		case (SET_MODE_OPTIONS):
+		case (SET_TRANSACTION_PROGRAM):
+		case (SET_PRIVILAEGED_FUNCTION):
+		case (SET_RESOURCE_SUPPORTED):
+		case (SET_SYNC_LEVEL_SUPPORTED):
+		case (SET_MC_FUNCTION_SUPPORTED_TP):
+		case (GET_LUCB):
+		case (GET_PARTNER_LU):
+		case (GET_MODE):
+		case (GET_LU_OPTION):
+		case (GET_MODE_OPTION):
+		case (GET_TRANSACTION_PROGRAM):
+		case (GET_PRIVILEGED_FUNCTION):
+		case (GET_RESOURCE_SUPPORTED):
+		case (GET_SYNC_LEVEL_SUPPORTED):
+		case (GET_MC_FUNCTION_SUPPORTED_LU):
+		case (GET_MC_FUNCTION_SUPPORTED_TP):
+		case (LIST_PARTNER_LU):
+		case (LIST_MODE):
+		case (LIST_LU_OPTION):
+		case (LIST_MODE_OPTION):
+		case (LIST_TRANSACTION_PROGRAM):
+		case (LIST_PRIVILEGED_FUNCTION):
+		case (LIST_RESOURCE_SUPPORTED):
+		case (LIST_SYNC_LEVEL_SUPPORTED):
+		case (LIST_MC_FUNCTION_SUPPORTED_LU):
+		case (LIST_MC_FUNCTION_SUPPORTED_TP):
+		case (PROCESS_SESSION_LIMIT):
+		case (ACTIVATE_SESSION):
+		case (DEACTIVATE_CONVERSATION_GROUP):
+		case (DEACTIVATE_SESSION):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_copr(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (SYNCPT):
+		case (BACKOUT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_sync(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (GET_TP_PROPERTIES):
+			sna_get_tp_properties_proc(verb);
+			break;
+
+		case (GET_TYPE):
+			verb->rcode = OK;
+			if(verb->resource == conversation_this_tp)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				verb->type = rcb->conversation_type;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (WAIT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_wait_proc(verb);
+			tcb->cntrl_component = TP;
+			break;
+#endif
+		default:
+			return (-EINVAL);
+	}
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_deallocation_cleanup_proc(struct sna_rcb *rcb)
+{
+	struct sna_terminate_ps *terminate_ps;
+	struct sna_tcb *tcb;
+
+	for(tcb = tcb_list; tcb != NULL; tcb = tcb->next)
+	{
+		if(tcb->rcb_id == rcb->rb_id)
+			sna_upm_return_processing(rcb);
+	}
+
+	send_to_rm(terminate_ps);
+
+	return (0);
+}
+
+static int sna_get_tp_properties_proc(struct sna_get_tp_properties *get_tp_properties)
+{
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+
+	get_tp_properties->own_tp_name		= tcb->tp_name;
+	get_tp_properties->own_tp_instance	= tcb->tcb_id;
+	get_tp_properties->own_fq_lu_name	= lucb->fq_lu_name;
+	get_tp_properties->security_profile	= tcb->init_security.profile;
+	get_tp_properties->security_user_id	= tcb->init_security.user_id;
+	get_tp_properties->rcode		= OK;
+
+	return (0);
+}
+
+static int sna_wait_proc(struct sna_wait *wait, unsigned char *data)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	err = sna_check_resource_list();
+	if(err)
+	{
+		wait->rcode = PROGRAM_PARAM_CHECK;
+		return (-?);
+	}
+
+	if(no_activated_resource)
+	{
+		wait->rcode = POSTING_NOT_ACTIVE;
+		return (-?);
+	}
+
+	for(each_resource_posting_active)
+	{
+		sna_test_for_resource_posted(rcb, rc);
+		if(rc != UNSUCCESSFULL)
+		{
+			wait->rcode = rc;
+			return (-?);
+		}
+
+	/* Spin until resource becomes posted */
+	rc = UNSUCCESSFULL;
+	while(rc == UNSUCCESSFULL)
+	{
+		sna_receive_rm_or_hs_to_ps_records(temp_resource_list);
+		rcb = rcb_data_active();
+		sna_test_for_resource_posted(rcb, rc);
+	}
+
+	resource_posted = rcb->rcb_id;
+	wait->rcode = rc;
+
+	return (0);
+}
+
+static int sna_ps_protocol_err(__u8 hs_id, __u8 tcb_id, __u8 sense)
+{
+	struct sna_unbind_protocol_error *unbind_proto_err;
+
+	unbind_proto_err->hs_id 	= hs_id;
+	unbind_proto_err->tcb_id	= tcb_id;
+	unbind_proto_err->sense		= sense;
+
+	send_to_rm(unbind_proto_err);
+
+	return (0);
+}
+
+static int sna_init_attached_rcb(struct sna_rcb *rcb, attach)
+{
+	rcb->conversation_type 	= attach->conversation_type;
+	rcb->limit_buf_pool_id 	= attach->limit_buf_pool_id;
+	rcb->perm_buf_pool_id	= attach->perm_buf_pool_id;
+	rcb->send_ru_size	= attach->send_ru_size;
+	rcb->post_conditions.fill	= LL;
+	rcb->post_conditions.max_length	= 0;
+	rcb->locks		= SHORT;
+	rcb->rq_to_send_rcvd	= NO;
+
+	sna_empty_list(rcb->hs_to_ps_buffer_list);
+
+	fsm_conversation	= RCV;
+	fsm_error_or_failure	= NO_REQUESTS;
+	fsm_post		= RESET;
+
+	if(rcb->conversation_type == MAPPED_CONVERSATION)
+	{
+		sna_empty_list(rcb->mc_receive_buffer);
+		rcb->mc_rq_to_send_rcvd	= NO;
+		rcb->mapper_save_area	= /* I decide, Hah! */
+		rcb->mc_max_send_size	= /* I decide this too!! Wee */
+	}
+
+	return (0);
+}
+
+static int sna_test_for_resource_posted(struct sna_rcb *rcb)
+{
+	struct sna_test *test;
+	struct sna_mc_test *mc_test;
+
+	switch(rcb->conversation_type)
+	{
+		case (BASIC):
+			test = (struct sna_test *)kmalloc(sizeof(test), GFP_ATOMIC);
+			test->resource 	= rcb->rcb_id;
+			test->test	= POSTED;
+			err = sna_test_proc(test);
+			break;
+
+		case (MAPPED):
+			mc_test = (struct sna_test *)kmalloc(sizeof(mc_test), GFP_ATOMIC);
+			mc_test->resource	= rcb->rcb_id;
+			mc_test->test		= POSTED;
+			err = sna_mc_test_proc(mc_test);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (err);
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_ps_mc.c linux/net/sna/sna_ps_mc.c
--- linux-2.4.13/net/sna/sna_ps_mc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_mc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,48 @@
+/* sna_ps_mc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Mapped Conversations (PS.MC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_mc(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_mc\n");
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_ps_sync.c linux/net/sna/sna_ps_sync.c
--- linux-2.4.13/net/sna/sna_ps_sync.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_sync.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,32 @@
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_sync(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_sync\n");
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_rm.c linux/net/sna/sna_rm.c
--- linux-2.4.13/net/sna/sna_rm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_rm.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,3272 @@
+/* sna_rm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Resource Manager (RM)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static struct sna_mode_cb *mode_list 	= NULL;
+static struct sna_lu_cb *lu_list	= NULL;
+static struct sna_plu_cb *plu_list	= NULL;
+
+static __u32 sna_mode_system_id = 1;
+static __u32 sna_lu_system_id	= 1;
+static __u32 sna_plu_system_id	= 1;
+static __u32 sna_rcb_system_id	= 1;
+static __u32 sna_bracket_id	= 1;
+static __u32 sna_conversation_correlator = 1;
+static __u32 sys_correlator_cnt = 1;
+
+static struct sna_rcb *rcb_list	= NULL;
+
+struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id)
+{
+        struct sna_rcb *rcb;
+
+        for(rcb = rcb_list; rcb != NULL; rcb = rcb->next)
+                if(rcb->rcb_id == rcb_id)
+                        return (rcb);
+        return (NULL);
+}
+
+int sna_rm_send_attach_to_ps(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_rm_send_attach_to_ps\n");
+	sna_ps_process_fmh5(tcb_id, rcb_id, skb);
+
+	return (0);
+}
+
+int sna_rm_create_ps(__u32 *tcb_id, __u32 *rcb_id, struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct snathdr *th = (struct snathdr *)skb->data;
+
+	sna_debug(5, "sna_rm_create_ps DAF is %02X\n", th->fid.f2.daf);
+	*tcb_id = sna_cpic_create_tcb();
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if(!tcb)
+	{
+		sna_debug(5, "No TCB found\n");
+		return (-1);
+	}
+	*rcb_id = sna_rm_allocate_rcb(tcb);
+	*tcb_id = tcb->tcb_id;
+
+	return (0);
+}
+
+static int sna_rm_process_attach(struct sk_buff *skb)
+{
+	__u32 tcb_id = 0, rcb_id = 0;
+
+	sna_debug(5, "sna_rm_process_attach\n");
+	sna_rm_create_ps(&tcb_id, &rcb_id, skb);
+	sna_rm_send_attach_to_ps(tcb_id, rcb_id, skb);
+
+#ifdef NOT
+        struct sna_scb *scb;
+        __u8 tcb_id, rcb_id, err;
+
+        tcb_id = 0;
+        rcb_id = 0;
+
+        scb = sna_search_scb();
+
+        if(FSM_SCB_STATUS != PENDING_ATTACH)
+                sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 0x20030000);
+        else
+        {
+                err = sna_attach_chk(fmh5, mu->layer.hs_to_rm.hs_id);
+                switch (err)
+                {
+                        case (0xFFFFFFFF):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x080F6051);
+                                sna_free_buffer(mu);
+                                break;
+
+
+                        case (0x10086040):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086040);
+                                sna_free_buffer(mu);
+                                break;
+
+                        case (0x10086011):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086011);
+                                sna_free_buffer(mu);
+                                break;
+                }
+
+                if(fmh5->fmh5cmd == ATTACH)
+                {
+                        if(err == 0x00000000)
+                        {
+                                tp = sna_search_tp();   /* ??? */
+
+                                /* Spell insane for now */
+                                if(err == 0x00000000
+                                        || tp->instance_cnt
+                                        < tp->instance_limit)
+
+                                        err = sna_ps_creation_proc(mu, tcb_id,rcb_id, tp, create_rc);
+                                        if(err == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                if(tp->tp_cnt > 0
+                                                        && err == 0)
+                                                {
+                                                        sna_queue_attach_proc(mu);
+                                                }
+                                                else
+                                                {
+                                                        sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                        bm_free(FREE, mu);
+                                                }
+                                                if(tp->tp_cnt == 0)
+                                                        sna_purge_queued_requests(tp);
+                                        }
+
+                                        sna_queue_attach(mu);
+                                }
+                                else
+                                {
+                                        mu->tp = NULL;
+                                        sna_ps_creation_proc(mu, tcb_id, rcb_id, tp, create_rc);
+                                        if(create_rc == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                bm_free(FREE, mu);
+                                        }
+                                }
+                        }
+                }
+        }
+#endif
+
+        return (0);
+}
+
+int sna_rm_process_hs_to_rm(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_rm_process_hs_to_rm\n");
+
+	/* if FMH-5 */
+	sna_rm_process_attach(skb);
+
+	return (0);
+}
+
+int sna_rm_destroy(struct sna_delete_node *d)
+{
+	struct sna_mode_cb *mode, **mclients = &mode_list;
+	struct sna_lu_cb *lu, **lclients = &lu_list;
+	struct sna_plu_cb *plu, **pclients = &plu_list;
+
+	while((mode = *mclients) != NULL)
+	{
+		*mclients = mode->next;
+		kfree(mode);
+		sna_mod_dec_use_count();
+	}
+
+	while((lu = *lclients) != NULL)
+	{
+		*lclients = lu->next;
+		kfree(lu);
+		sna_mod_dec_use_count();
+	}
+
+	while((plu = *pclients) != NULL)
+	{
+		*pclients = plu->next;
+		kfree(plu);
+		sna_mod_dec_use_count();
+	}
+
+	return (0);
+}
+
+struct sna_mode_cb *sna_rm_find_mode(char *mode_name)
+{
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_find_mode\n");
+	for(mode = mode_list; mode != NULL; mode = mode->next)
+		if(!strcmp(mode->mode_name, mode_name))
+			return (mode);
+
+	return (NULL);
+}
+
+struct sna_lu_cb *sna_rm_find_local_lu(char *lu_name)
+{
+	struct sna_lu_cb *lu;
+
+	sna_debug(5, "sna_rm_find_local_lu\n");
+	for(lu = lu_list; lu != NULL; lu = lu->next)
+		if(!strcmp(lu->lu_name, lu_name))
+			return (lu);
+
+	return (NULL);
+}
+
+struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_rm_find_remote_lu\n");
+	for(plu = plu_list; plu != NULL; plu = plu->next)
+		if(!strcmp(plu->netid_plu.net, id->net)
+			&& !strcmp(plu->netid_plu.name, id->name))
+			return (plu);
+
+	return (NULL);
+}
+
+int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+        struct sna_lu_cb *lu, **clients;
+
+        clients = &lu_list;
+        while((lu = *clients) != NULL)
+        {
+                if(!strcmp(lu->lu_name, dlu->lu_name))
+                {
+                        *clients = lu->next;
+                        kfree(lu);
+                        sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &lu_list;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu)
+{
+        struct sna_plu_cb *plu, **clients;
+
+        clients = &plu_list;
+        while((plu = *clients) != NULL)
+        {
+                if(!strcmp(plu->netid_plu.net, dplu->netid_plu.net)
+			&& !strcmp(plu->netid_plu.name, dplu->netid_plu.name))
+                {
+                        *clients = plu->next;
+                        kfree(plu);
+                        sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &plu_list;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_rm_delete_mode(struct sna_delete_mode *dm)
+{
+	struct sna_mode_cb *mode, **clients;
+
+	clients = &mode_list;
+	while((mode = *clients) != NULL)
+	{
+		if(!strcmp(mode->mode_name, dm->mode_name))
+		{
+			*clients = mode->next;
+			kfree(mode);
+			sna_mod_dec_use_count();
+			return (0);
+		}
+		clients = &mode_list;			
+	}
+
+	return (-ENOENT);
+}
+
+int sna_rm_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	struct sna_lu_cb *lu;
+
+        lu = sna_rm_find_local_lu(dlu->lu_name);
+        if(lu != NULL)
+                return (-EEXIST);
+
+        lu = (struct sna_lu_cb *)kmalloc(sizeof(struct sna_lu_cb),
+                GFP_ATOMIC);
+
+	memcpy(&lu->netid, &dlu->netid, sizeof(struct sna_netid));
+	strncpy(lu->lu_name, dlu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lu->sync_point	= dlu->sync_point;
+	lu->lu_sess_limit=dlu->lu_sess_limit;
+        lu->flags      	= SNA_UP;
+        lu->proc_id    	= sna_lu_system_id++;
+        lu->next       	= lu_list;
+	lu->prev	= NULL;
+        lu_list        	= lu;
+        sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_rm_define_remote_lu -%s-\n",
+		sna_pr_netid(&lu->netid_plu));
+
+	plu = sna_rm_find_remote_lu(&lu->netid_plu);
+	if(plu != NULL)
+		return (-EEXIST);
+
+	plu = (struct sna_plu_cb *)kmalloc(sizeof(struct sna_plu_cb),
+		GFP_ATOMIC);
+
+	memcpy(&plu->netid, &lu->netid, sizeof(struct sna_netid));
+	memcpy(&plu->netid_plu, &lu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&plu->netid_fqcp, &lu->netid_fqcp, sizeof(struct sna_netid));
+	plu->parallel_ss= lu->parallel_ss;
+	plu->cnv_security=lu->cnv_security;
+	plu->flags	= SNA_UP;
+	plu->proc_id	= sna_plu_system_id++;
+	plu->next	= plu_list;
+	plu->prev	= NULL;
+	plu_list	= plu;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_rm_define_mode(struct sna_define_mode *dm)
+{
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_define_mode\n");
+
+	mode = sna_rm_find_mode(dm->mode_name);
+	if(mode != NULL)
+		return (-EEXIST);
+
+	mode = (struct sna_mode_cb *)kmalloc(sizeof(struct sna_mode_cb),
+		GFP_ATOMIC);
+
+	memcpy(&mode->netid, &dm->netid, sizeof(struct sna_netid));
+	memcpy(&mode->netid_plu, &dm->netid_plu, sizeof(struct sna_netid));
+	strncpy(mode->mode_name, dm->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mode->cos_name, dm->cos_name, SNA_RESOURCE_NAME_LEN);
+	mode->tx_pacing = dm->tx_pacing;
+	mode->rx_pacing = dm->rx_pacing;
+	mode->max_tx_ru = dm->max_tx_ru;
+	mode->max_rx_ru = dm->max_rx_ru;
+	mode->crypto	= dm->crypto;
+	mode->flags	= SNA_UP;
+	mode->proc_id	= sna_mode_system_id++;
+
+	mode->max_sessions	= SNA_MODE_MAX_SESSIONS;
+	mode->min_conwinners	= SNA_MODE_MIN_CONWINNERS;
+	mode->min_conlosers	= SNA_MODE_MIN_CONLOSERS;
+	mode->active.sessions	= 0;
+	mode->active.conwinners	= 0;
+	mode->active.conlosers	= 0;
+	mode->pending.sessions	= 0;
+	mode->pending.conwinners= 0;
+	mode->pending.conlosers	= 0;
+
+	mode->next	= mode_list;
+	mode->prev	= NULL;
+	mode_list	= mode;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_mode_ginfo(struct sna_mode_cb *mode, char *buf, int len)
+{
+        struct modereq mr;
+        int done = 0;
+
+	sna_debug(10, "sna_mode_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(mr);
+                return (done);
+        }
+        if(len < (int)sizeof(mr))
+                return done;
+        memset(&mr, 0, sizeof(struct modereq));
+
+        /* Move the data here */
+	memcpy(&mr.netid, &mode->netid, sizeof(struct sna_netid));
+	memcpy(&mr.plu_name, &mode->netid_plu, sizeof(struct sna_netid));
+	strncpy(mr.mode_name, mode->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mr.cos_name, mode->cos_name, SNA_RESOURCE_NAME_LEN);
+	mr.tx_pacing		= mode->tx_pacing;
+	mr.rx_pacing		= mode->rx_pacing;
+	mr.max_tx_ru		= mode->max_tx_ru;
+	mr.max_rx_ru		= mode->max_rx_ru;
+	mr.crypto		= mode->crypto;
+	mr.proc_id		= mode->proc_id;
+	mr.flags		= mode->flags;
+	mr.auto_activation	= mode->auto_activation;
+	mr.max_sessions		= mode->max_sessions;
+	mr.min_conlosers	= mode->min_conlosers;
+	mr.min_conwinners	= mode->min_conwinners;
+	mr.act_sessions		= mode->active.sessions;
+	mr.act_conwinners	= mode->active.conwinners;
+	mr.act_conlosers	= mode->active.conlosers;
+	mr.pend_sessions	= mode->pending.sessions;
+	mr.pend_conwinners	= mode->pending.conwinners;
+	mr.pend_conlosers	= mode->pending.conlosers;
+
+        if(copy_to_user(buf, &mr, sizeof(struct modereq)))
+                return (-EFAULT);
+        buf += sizeof(struct modereq);
+        len -= sizeof(struct modereq);
+        done += sizeof(struct modereq);
+
+        return (done);
+}
+
+int sna_lu_ginfo(struct sna_lu_cb *lu, char *buf, int len)
+{
+        struct lureq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_lu_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(lr);
+                return (done);
+        }
+        if(len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lureq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &lu->netid, sizeof(struct sna_netid));
+	strncpy(lr.name, lu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lr.sync_point		= lu->sync_point;
+	lr.lu_sess_limit	= lu->lu_sess_limit;
+	lr.proc_id		= lu->proc_id;
+	lr.flags		= lu->flags;
+
+        if(copy_to_user(buf, &lr, sizeof(struct lureq)))
+                return (-EFAULT);
+        buf += sizeof(struct lureq);
+        len -= sizeof(struct lureq);
+        done += sizeof(struct lureq);
+
+        return (done);
+}
+
+int sna_plu_ginfo(struct sna_plu_cb *plu, char *buf, int len)
+{
+        struct plureq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_plu_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(pr);
+                return (done);
+        }
+        if(len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct plureq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&pr.plu_name, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&pr.fqcp_name, &plu->netid_fqcp, sizeof(struct sna_netid));
+	pr.parallel_ss	= plu->parallel_ss;
+	pr.cnv_security	= plu->cnv_security;
+	pr.proc_id	= plu->proc_id;
+	pr.flags	= plu->flags;
+
+        if(copy_to_user(buf, &pr, sizeof(struct plureq)))
+                return (-EFAULT);
+        buf += sizeof(struct plureq);
+        len -= sizeof(struct plureq);
+        done += sizeof(struct plureq);
+
+        return (done);
+}
+
+int sna_rm_query_mode(char *arg)
+{
+	struct modeconf mc;
+	struct sna_mode_cb *mode;
+	char *pos;
+	int len, total;
+
+	sna_debug(5, "sna_rm_query_mode\n");
+	if(copy_from_user(&mc, arg, sizeof(mc)))
+                return (-EFAULT);
+
+        pos = mc.modec_buf;
+        len = mc.mode_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(mode = mode_list; mode != NULL; mode = mode->next)
+        {
+		int done;
+
+                if(pos == NULL)
+                	done = sna_mode_ginfo(mode, NULL, 0);
+                else
+                        done = sna_mode_ginfo(mode,pos+total,len-total);
+                if(done < 0)
+                	return (-EFAULT);
+                total += done;
+        }
+
+        mc.mode_len = total;
+        if(copy_to_user(arg, &mc, sizeof(mc)))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_rm_query_lu(char *arg)
+{
+	struct luconf lc;
+	struct sna_lu_cb *lu;
+	char *pos;
+        int len, total;
+
+	sna_debug(5, "sna_rm_query_lu\n");
+        if(copy_from_user(&lc, arg, sizeof(lc)))
+                return (-EFAULT);
+
+        pos = lc.luc_buf;
+        len = lc.lu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(lu = lu_list; lu != NULL; lu = lu->next)
+        {
+        	int done;
+
+                if(pos == NULL)
+                	done = sna_lu_ginfo(lu, NULL, 0);
+                else
+                        done = sna_lu_ginfo(lu,pos+total,len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        lc.lu_len = total;
+        if(copy_to_user(arg, &lc, sizeof(lc)))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_rm_query_plu(char *arg)
+{
+	struct pluconf pc;
+	struct sna_plu_cb *plu;
+	char *pos;
+        int len, total;
+
+	sna_debug(5, "sna_rm_query_plu\n");
+        if(copy_from_user(&pc, arg, sizeof(pc)))
+                return (-EFAULT);
+
+        pos = pc.pluc_buf;
+        len = pc.plu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(plu = plu_list; plu != NULL; plu = plu->next)
+        {
+	        int done;
+
+                if(pos == NULL)
+	                done = sna_plu_ginfo(plu, NULL, 0);
+                else
+                        done = sna_plu_ginfo(plu, pos+total, len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        pc.plu_len = total;
+        if(copy_to_user(arg, &pc, sizeof(pc)))
+                return (-EFAULT);
+        return (0);
+}
+
+static int sna_rm_session_activation_polarity(struct sna_netid *plu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_plu_cb *plu;
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_session_activation_polarity %s.%s\n",
+		plu_name->net, plu_name->name);
+
+	plu = sna_rm_find_remote_lu(plu_name);
+	if(!plu)
+		return (-ENOENT);
+	mode = sna_rm_find_mode(mode_name);
+	if(!mode)
+		return (-ENOENT);
+
+        if(mode->pending.sessions == mode->max_sessions)
+                return (SNA_SESSION_NONE);
+/*
+        if((mode->pending.sessions +  mode->active.sessions) > 0
+                && partner->parallel == SUPPORTED)
+                return (SNA_SESSION_NONE);
+*/
+        if((mode->max_sessions - mode->min_conlosers)
+                > (mode->active.conwinners + mode->pending.conwinners))
+                return (SNA_SESSION_FIRST_SPEAKER);
+        else
+                return (SNA_SESSION_BIDDER);
+
+	return (0);
+}
+
+static int sna_rm_send_activate_session(struct sna_netid *plu_name,
+        unsigned char *mode_name, int polarity)
+{
+	struct sna_sm_act_session_rq *as;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_send_activate_session\n");
+	mode = sna_rm_find_mode(mode_name);
+	if(!mode)
+		return (-ENOENT);
+
+	as = (struct sna_sm_act_session_rq *)kmalloc(sizeof(struct sna_sm_act_session_rq), GFP_ATOMIC);
+        as->correlator	= sys_correlator_cnt++;
+	as->polarity	= (__u8)polarity;
+	memcpy(&as->plu_netid, plu_name, sizeof(struct sna_netid));
+	memcpy(as->mode_name, mode_name, SNA_RESOURCE_NAME_LEN);
+        mode->pending.sessions++;
+        if(polarity == SNA_SESSION_FIRST_SPEAKER)
+                mode->pending.conwinners++;
+        else
+                mode->pending.conlosers++;
+	sna_sm_process_activation_session(as);
+
+        return (0);
+}
+
+int sna_rm_activate_session(struct sna_rm_act_session_rq *as)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_rm_activate_session\n");
+        switch(sna_rm_session_activation_polarity(&as->plu_netid,as->mode_name))
+        {
+                case (SNA_SESSION_FIRST_SPEAKER):
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_FIRST_SPEAKER);
+                        break;
+
+                case (SNA_SESSION_BIDDER):
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_BIDDER);
+                        break;
+
+		case (SNA_SESSION_NONE):
+		default:
+			err = -1;    /* LU_MODE_SESSION_LIMIT_EXCEEDED */
+			break;
+        }
+
+	kfree(as);
+        return (err);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_lu_cb *lu;
+	off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-6s%-18s%-9s%-11s%-14s%-5s\n",
+                "lu_id", "netid.node", "lu_name", "sync_point",
+		"lu_sess_limit", "flags");
+
+        for(lu = lu_list; lu != NULL; lu = lu->next)
+        {
+                len += sprintf(buffer + len, "%-6d%-18s%-9s%-11d%-14d%04X\n",
+                        lu->proc_id, sna_pr_netid(&lu->netid), 
+			lu->lu_name, lu->sync_point,
+			lu->lu_sess_limit, lu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_plu_cb *plu;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-7s%-18s%-18s%-18s%-12s%-12s%-5s\n",
+                "plu_id", "netid.node", "netid.plu", "netid.fqcp",
+		"parallel_ss", "cnv_security", "flags");
+
+        for(plu = plu_list; plu != NULL; plu = plu->next)
+        {
+                len += sprintf(buffer + len, "%-7d%-17s%-17s%-17s%-12d%-12d%04X\n",
+			plu->proc_id, sna_pr_netid(&plu->netid), 
+			sna_pr_netid(&plu->netid_plu), 
+			sna_pr_netid(&plu->netid_fqcp),
+			plu->parallel_ss, plu->cnv_security, plu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_mode_cb *mode;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-8s%-18s%-18s%-10s%-10s%-10s%-10s%-10s%-7s%-5s\n", 
+		"mode_id", "netid.node", 
+		"netid.plu", "mode_name", "tx_pacing", "rx_pacing",
+		"max_tx_ru", "max_rx_ru", "crypto", "flags");
+
+        for(mode = mode_list; mode != NULL; mode = mode->next)
+        {
+                len += sprintf(buffer + len, "%-8d%-17s%-17s%-8s%-10d%-10d%-10d%-10d%-7d%04X\n",
+			mode->proc_id, sna_pr_netid(&mode->netid), 
+			sna_pr_netid(&mode->netid_plu), mode->mode_name, 
+			mode->tx_pacing,
+			mode->rx_pacing, mode->max_tx_ru, mode->max_rx_ru,
+			mode->crypto, mode->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+__u8 sna_rm_create_rcb(struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "sna_rm_create_rcb\n");
+        rcb = (struct sna_rcb *)kmalloc(sizeof(struct sna_rcb), GFP_ATOMIC);
+	rcb->tcb_id	= tcb->tcb_id;
+	rcb->rcb_id	= sna_rcb_system_id++;
+	tcb->rcb_id     = rcb->rcb_id;
+	rcb->hs_id	= 0;
+	rcb->bracket_id	= sna_bracket_id++;
+	rcb->session_id	= 0;
+	rcb->conversation_correlator = sna_conversation_correlator++;
+
+#ifdef NOT
+	/* This is really in the wrong place but works for now. */
+        sna_asm_assign_lfsid(rcb);
+	rcb->oaf	= tcb->oaf;
+	rcb->daf	= tcb->daf;
+#endif
+
+#ifdef NOT
+        rcb->sync       = alloc_rcb->sync;
+        rcb->security_select = alloc_rcb->security_select;
+        sna_fsm_rsb_status(S, ALLOCATE_RCB, UNDEFINED);
+#endif
+
+	memcpy(rcb->lu_name, tcb->partner_lu_name, tcb->partner_lu_name_length);
+	rcb->lu_name_length = tcb->partner_lu_name_length;
+
+	memcpy(rcb->mode_name, tcb->mode_name, tcb->mode_name_length);
+	rcb->mode_name_length = tcb->mode_name_length;
+
+	memcpy(rcb->tp_name, tcb->tp_name, tcb->tp_name_length);
+	rcb->tp_name_length = tcb->tp_name_length;
+
+	rcb->state	= FSM_RCB_STATUS_FSP;
+	rcb->next	= rcb_list;
+	rcb_list	= rcb;
+
+	return (rcb->rcb_id);
+}
+
+__u8 sna_rm_allocate_rcb(struct sna_tcb *tcb)
+{
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_rm_allocate_rcb\n");
+	rcb_id = sna_rm_create_rcb(tcb);
+
+        return (rcb_id);
+}
+
+#ifdef CONFIG_RM
+
+#include <net/sna/sna_th.h>
+#include <net/sna/sna_rh.h>
+#include <net/sna/sna_ru.h>
+#include <net/sna/sna_asm.h>
+#include <net/sna/sna_mu.h>
+#include <net/sna/sna_ipc.h>
+#include <net/sna/sna_sm.h>
+#include <net/sna/sna_dfc.h>
+#include <net/sna/sna_tc.h>
+#include <net/sna/sna_hs.h>
+
+static __u8 sys_rcb_id_cnt;
+static __u8 sys_tcb_id_cnt;
+static __u8 sys_scb_id_cnt;
+static __u8 sys_bracket_id_cnt;
+static __u8 sys_correlator_cnt;
+
+static struct sna_lucb *sna_lucb_list = NULL;	/* LU CB list */
+struct sna_scb *sna_scb_list = NULL;
+struct sna_rcb *sna_rcb_list = NULL;
+struct sna_tcb *sna_tcb_list = NULL;
+
+static int sna_process_initiator_to_rm(struct sna_mu *mu);
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name);
+static int sna_activate_session_rsp_proc(struct sna_mu *mu);
+static int sna_allocate_rcb_proc(struct sna_mu *mu);
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5);
+static int sna_attach_length_chk();
+static int sna_security_chk();
+static int sna_bid_proc(struct sna_mu *mu);
+static int sna_bid_rsp_proc(struct sna_mu *mu);
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id);
+static int sna_bis_race_loser(__u8 hs_id);
+static int sna_change_sessions_proc(struct sna_mu *mu);
+static int sna_check_for_bis_reply(__u8 hs_id);
+static int sna_complete_luw_id();
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id);
+static int sna_create_rcb(struct sna_allocate_rcb *alloc_rcb,
+        struct sna_rcb_allocated *rcb_allocd);
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+        struct sna_session_info *session_info);
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp,
+        struct sna_tp *tp);
+static int sna_deactivate_free_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_deactivate_pending_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_dequeue_waiting_request(__u8 hs_id);
+static int sna_enqueue_free_scb(__u8 hs_id);
+static int sna_first_speaker_proc(struct sna_get_session *get_session,
+        __u8 hs_id);
+static int sna_free_session_proc(struct sna_mu *mu);
+static int sna_get_session_proc(struct sna_get_session *get_session);
+static int sna_ps_abend_proc(struct sna_mu *mu);
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id,
+        struct sna_tp *target_tp);
+static int sna_ps_termination_proc(struct sna_mu *mu);
+static int sna_purge_queued_requests(struct sna_tp *tp);
+static int sna_queue_attach_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate);
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop);
+static int sna_rtr_rq_proc(struct sna_mu *mu);
+static int sna_rtr_rsp_proc(struct sna_mu *mu);
+static int sna_security_proc(struct sna_mu *mu);
+static int sna_send_bis(__u8 hs_id);
+static int sna_send_bis_reply(__u8 hs_id);
+static int sna_send_bis_rq(__u8 hs_id);
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type,
+	__u32 sense);
+static int sna_send_rtr_proc(struct sna_mu *mu);
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id);
+static int sna_session_activated_proc(struct sna_mu *mu);
+static int sna_session_activation_polarity(unsigned char *lu_name, unsigned char *mode_name);
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated);
+static int sna_session_deactivation_polarity(unsigned char *lu_name, 
+	unsigned char *mode_name);
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id);
+static int sna_should_send_bis(__u8 hs_id);
+static int sna_start_tp_proc(struct sna_start_tp *start_tp);
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp);
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_info *info);
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, 
+	struct sna_rcb_allocated *rcb_allocd);
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, int err);
+static int sna_fsm_scb_status(int signal);
+static int sna_fsm_bis(int signal);
+static int sna_fsm_rcb_status(int signal);
+
+static int sna_process_hs_to_rm(struct sna_mu *mu)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(some_type_of_id);
+	if(scb == NULL)
+	{
+		kfree(mu);
+		return (-1);
+	}
+
+	if(fsm_bis == CLOSED)
+	{
+		switch(mu->record_type)
+		{
+			case (SNA_REC_BID):
+				sna_bid_proc(mu);
+				break;
+
+			case (SNA_REC_BID_RSP):
+				sna_bid_rsp_proc(mu);
+				break;
+
+			case (MU):
+				if(MU == FMH5)
+					sna_attach_proc(mu);
+				if(MU == FMH12)
+					sna_security_proc(mu);
+					break;
+
+			case (SNA_REC_FREE_SESSION):
+				sna_free_session_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RQ):
+				sna_rtr_rq_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RSP):
+				sna_rtr_rsp_proc(mu);
+				break;
+
+			case (SNA_REC_BIS_RQ):
+				sna_fsm_bis(r, bis_reply, bis_reply->hs_id);
+				kfree(IPS);
+				break;
+
+			default:
+				kfree(mu);
+		}
+	}
+	else
+	{
+		if(MU)
+			bm_free(FREE, mu);
+		else
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_ps_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ALLOCATE_RCB):
+			sna_allocate_rcb_proc(mu);
+			break;
+
+		case (SNA_REC_GET_SESSION):
+			sna_get_session_proc(mu);
+			break;
+
+		case (SNA_REC_DEALLOCATE_RCB):
+			rcb = sna_search_rcb(deallocate_rcb->rcb_id);
+			if(scb == NULL)
+			{
+				bracket_freed = (struct sna_bracket_freed *)kmalloc(sizeof(struct sna_bracket_freed), GFP_ATOMIC);
+				bracket_freed->bracket_id = rcb->bracket_id;
+				sna_hs(bracket_freed);
+			}
+			discard(rcb);
+			rcb_deallocated = (struct sna_rcb_deallocated *)kmalloc(sizeof(struct sna_rcb_deallocated), GFP_ATOMIC);
+			sna_ps(rcb_deallocated);
+			break;
+
+		case (SNA_REC_TERMINATE_PS):
+			sna_ps_termination_proc(mu);
+			break;
+
+		case (SNA_REC_CHANGE_SESSIONS):
+			sna_change_sessions_proc(mu);
+			break;
+
+		case (SNA_REC_RM_ACTIVATE_SESSION):
+			sna_rm_activate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_SESSION):
+			sna_rm_deactivate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_CONV_GROUP):
+			sna_rm_deactivate_conv_group_proc(mu);
+			break;
+
+		case (SNA_REC_UNBIND_PROTOCOL_ERROR):
+			sna_send_deactivate_session(active, unbind_protocol_error->hs_id, abnormal, unbind_protocol_error->sense);
+			break;
+
+		case (SNA_REC_ABEND_NOTIFICATION):
+			sna_ps_abend_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_sm_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ACTIVATE_SESSION_RSP):
+			sna_activate_session_rsp_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_ACTIVATED):
+			sna_session_activated_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_DEACTIVATED):
+			sna_session_deactivated_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* We will cast data to appropiate struct type below */
+static int sna_process_initiator_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_START_TP):
+			sna_start_tp_proc(mu);
+			break;
+
+		case (SNA_REC_SEND_RTR):
+			sna_send_rtr_proc(mu);
+			break;
+
+		case (SNA_REC_RM_TIMER_POP):
+			sna_rm_timer_deactivate_sess_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* The only etrance point for RM, we cast data into appropiate record later */
+static int sna_rm_create(int caller, struct sna_mu *mu)
+{
+	struct sna_previous_time *ptime;
+
+	ptime = sna_time();
+
+	switch(caller)
+	{
+		case (SNA_SM):
+			sna_process_sm_to_rm(mu);
+			break;
+
+		case (SNA_HS):
+			sna_process_hs_to_rm(mu);
+			break;
+
+		case (SNA_INIT):
+			sna_process_initiator_to_rm(mu);
+			break;
+
+		case (SNA_PS):
+			sna_process_ps_to_rm(mu);
+			break;
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
+
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	__u8 polarity;
+
+	lucb = sna_search_lucb(lu_name);		/* ??? */
+	mode = sna_search_mode(lucb, mode_name);	/* ??? */
+
+	while((polarity = sna_session_activation_polarity(lu_name, mode_name)) 
+		!= NULL)
+	{
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+		else	/* Bidder */
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_BIDDER);
+
+	}
+
+	while((mode->active.conwinners + mode->pending.conwinners)
+		< min(mode->auto_act_limit, mode->min_conwinners))
+	{
+		polarity = sna_session_activation_polarity(lu_name, mode_name);
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_act_sess_rsp *rsp =(struct sna_act_sess_rsp *)mu->record_ptr;
+
+	if(pending_act->correlator == act_sess_rsp->sorrelator)
+	{
+		mode = pending_act->mode;
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->pending->conwinners--;
+		else
+			mode->pending->conlosers--;
+
+		mode->pending->sessions--;
+		if(act_sess_rsp->type == POS)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->active->conwinners++;
+			else
+				mode->active->conlosers++;
+			mode->active->sessions++;
+
+			sna_successful_session_activation(pending_act->lu_name, 
+				pending_act->mode_name,act_sess_rsp->sess_info);
+		}
+		else
+		{
+			sna_unsuccessful_session_activation(pending_act->lu_name,
+				pending_act->mode_name, act_sess_rsp->err_type);
+			remove_and_toss_pending_activation;
+		}
+	}
+
+	return (0);
+}
+
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5)
+{
+	__u8 err;
+
+	if(fmh5->fmh5cmd != ATTACH)
+		return (0x1008600B);
+
+	err = sna_attach_length_chk(fmh5);
+	if(err)
+		return (err);
+
+	if(fmh5->luw_id)	/* ??? */
+	{
+		/* This is wrong/bad */
+		if(fmh5->luw_net == NULL && fmh5->lu_net != NULL)
+			return (0x10086011);
+	}
+	else
+	{
+		if(fmh5->sync_leve == SYNCPT)
+			return (0x10086011);
+	}
+
+	if(TP_is_a_local_TP)
+	{
+		switch(fmh5->sync)
+		{
+			case (NONE):
+			case (CONFIRM):
+				break;
+			case (CONFIRM | SYNCPT | BACKOUT):
+				if(RemoteLU != supportabove)
+					return (0x10086040);
+			default:
+				return (0x10086040);
+		}
+
+		if(fmh5->sync != supported_by_TP)
+			return (0x10086041);
+		if(TP_temp_disabled)
+			return (0x084B6031);
+		if(TP_perm_disabled)
+			return (0x084C0000);
+
+		err = sna_attach_security_chk(fmh5);
+		if(err)
+			return (err);
+	}
+	else
+		return (0x1008600B);
+
+	return (0x00000000);
+}
+
+/* Need better Docs to do this one */
+static int sna_attach_length_chk()
+{
+
+	return 0;
+}
+
+static int sna_security_chk()
+{
+
+	return 0;
+}
+
+static int sna_bid_proc(struct sna_mu *mu)
+{
+	struct sna_bid *bid = (struct sna_bid *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_bid_rsp *bid_rsp;
+
+	scb = sna_search_scb(bid->hs_id);	/* ??? */
+	if(FSM_BIS == BIS_RCVD || FSM_BIS == CLOSED)
+		send_deactivate_session(active, bid->hs_id, abnormal, 0x20080000);
+	else
+	{
+		mode = sna_search_mode(bid);
+		if(mode->parallel == SNA_RM_FALSE
+			&& mode->session_limit == 0
+			&& mode->drain_partner == SNA_RM_FALSE
+			&& FSM_BIS == BIS_SENT)
+		{
+			bid_rsp->rti	= NEG;
+			bid_rsp->sense	= 0x088B0000;
+			sna_hs(bid_rsp);
+		}
+		else
+		{
+			if(FSM_SCB_STATUS == FREE)
+			{
+				FSM_SCB_STATUS(R, bid, UNDEFINED);
+				if(session_is_in_free_sessino_pool)
+					scb = pull_scb_pool();
+				bid_rsp->rti	= POS;
+				bid_rsp->sense	= 0;
+				sna_hs(bid_rsp);
+				if(scb->timer_unique_id != NULL)
+				{
+					stop_timer();
+					scb->timer_unique_id = NULL;
+				}
+			}
+			else
+			{
+				if(first_speaker)
+				{
+					bid_rsp->rti 	= NEG;
+					bid_rsp->sense 	= 0x08130000;
+					sna_hs(bid_rsp);
+					if(sense_code == 0x08140000)
+					{
+						Remember_LU_stuff;
+					}
+				}
+				else
+					send_deactivate_session(active, 
+						bid->hs_id,abnormal,0x20030000);
+			}
+		}
+	}
+
+	bm_free(FREE, bid);
+
+	return (0);
+}
+
+static int sna_bid_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_bid_rsp *rsp = (struct sna_bid_rsp *)mu->record_ptr;
+	struct sna_session_allocated *sallocated;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	if(rsp->rti == NEG && rsp->sense == 0x88B0000)
+	{
+		if(parallel != supported)
+		{
+			mode->conwinners 	= 0;
+			mode->conlosers 	= 0;
+			mode->sessions 		= 0;
+			send_deactivate_session(active, rsp->hs_id, cleanup, 0);
+		}
+		else
+			send_deactivate_session(active, rsp->hs_id, abnormal, 0x20100000);
+	}
+	else
+	{
+		rcb = sna_search_rcb(PENDING_SCB, rsp->hs_id);
+		if(rsp->rti == POS)
+		{
+			sna_set_rcb_and_scb_fields(rcb->rcb_id, rsp->hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, rsp->hs_id, reply);
+			scb = sna_search_scb(hs);
+
+			sallocated->rcode 		= OK;
+			sallocated->send_ru_size 	= scb->send_ru_size;
+			sallocated->limit_buf_pool_id 	=scb->limit_buf_pool_id;
+			sallocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+			sallocated->in_conver		= SNA_RM_TRUE;
+
+			sna_ps(sallocated);
+		}
+		else
+		{
+			rcb->hs_id = NULL;
+			sna_fsm_rcb_status(R, NEG_BID_RSP, UNDEFINED);
+			if(rsp->sense == 0x08140000)
+				remember_LU_owes_rtr;
+			
+			get_session = rcb->get_session;
+			sna_get_session_proc(get_session);
+		}
+	}
+
+	return (0);
+}
+
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id)
+{
+	struct sna_rcb *rcb;
+	struct sna_bid_without_attach *bid_wo_attach;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	rcb->hs_id = hs_id;
+
+	sna_fsm_rcb_status = FSM_RCB_STATUS_BIDDER;
+	rcb->session_parms_ptr = get_session;
+
+	sna_hs(bid_wo_attach);
+
+	return (0);
+}
+
+static int sna_bis_race_loser(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->pending.conwinners--;
+	else
+		mode->pending.conlosers--;
+
+	sna_hs(bis_reply);
+	close = sna_session_deactivation_polarity(mode->lu_name,
+		mode->mode_name);
+
+	if(close == EITHER)
+	{
+		sna_send_bis_rq(hs_id);
+		remove_from_free_sess_pool;
+	}
+
+	return (0);
+}
+
+static int sna_change_sessions_proc(struct sna_mu *mu)
+{
+	struct sna_change_sessions *chg_sess = (struct sna_change_sessions *)mu->record_ptr;
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *sess_allocd;
+
+	if(chg_sess->rsp == SNA_RM_TRUE)
+	{
+		mode = sna_search_mode(chg_sess->lu_name, chg_sess->mode_name);
+		conwinners = mode->active.conwinners + mode->pending.conwinners;
+		conlosers = mode->active.conlosers + mode->pending.conlosers;
+		old_slimit = mode->max_sessions - chg_sess->delta;
+		plateau = min(mode->active.sessions + mode->pending.sessions, old_slimit);
+		conwinner_incr = max(0, mode->min_conwinners - conwinners);
+		session_decr = max(0, plateau - mode->max_sessions);
+		conloser_incr = max(0, mode->min_conlosers - conlosers);
+		need_to_activate = conwinner_incr + conloser_incr;
+		room_for_activation = max(0, mode->max_sessions - plateau);
+		decrement_for_polarity = max(0, need_to_activate - room_for_activation);
+		mode->termination_cnt = mode->termination_cnt + session_decr + decrement_for_polarity;
+
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_pending_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_free_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+	}
+
+	if((mode->sessions == 0 && mode->drain_self == SNA_RM_FALSE)
+		|| (mode->active.sessions - (mode->pending.conwinners + mode->pending.conlosers) == 0))
+	{
+		struct sna_get_session *get_session;
+
+		while((get_session = sna_get_waiting_sessions(chg_sess->lu_name, chg_sess->mode_name)) != NULL)
+		{
+			struct sna_session_allocated *sallocated;
+			sallocated->rcode = UNSUCCESSFUL_NO_RETRY;
+			sna_ps(sallocated);
+			bm_free(FREE, get_session);
+		}
+	}
+
+	sna_activate_needed_sessions(chg_sess->lu_name, chg_sess->mode_name);
+
+	return (0);
+}
+
+static int sna_check_for_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if(mode->drain_self == SNA_RM_FALSE 
+		|| (sna_get_waiting_gsess(mode->lu_name,mode->mode_name)==NULL))
+	{
+		if(sess_free_brackets(hs_id))
+		{
+			sna_send_bis_reply(hs_id);
+			remove_from_free_sess_pool;
+		}
+	}
+
+	return (0);
+}
+
+/* Need to create an IBM S/370 time structure to complete function */
+static int sna_complete_luw_id()
+{
+
+	return 0;
+}
+
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	rcb = sna_search_rcb(rcb_id);
+
+	rcb->session_id = scb->session_id;
+	scb->bracket_id = rcb->bracket_id;
+
+	hs_ps_connected->bracket_id 	= rcb->bracket_id;
+	hs_ps_connected->ps_id 		= rcb->tcb_id;
+
+	sna_hs(hs_ps_connected);
+
+	return (0);
+}
+
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+				struct sna_session_info *session_info)
+{
+	struct sna_scb *scb;
+
+	scb = (struct sna_scb *)kmalloc(sizeof(scb), GFP_ATOMIC);
+	scb->hs_id 		= session_info->hs_id;
+	scb->lu_name 		= lu_name;
+	scb->mode_name		= mode_name;
+	scb->rcb_id		= 0;
+	scb->session_id		= session_info->session_id;
+	scb->send_ru_size 	= session_info->send_ru_size;
+	scb->limit_buf_pool_id	= session_info->limit_buf_pool_id;
+	scb->perm_buf_pool_id 	= session_info->perm_buf_pool_id;
+	scb->bracket_id		= 0;
+	scb->random		= session_info->random;
+	scb->limit_resource 	= session_info->limit_resource;
+	scb->timer_unique_id 	= 0;
+	scb->conversation.gid	= conv_gid++;
+
+	if(session_info->bracket_type == SNA_SESSION_FIRST_SPEAKER)
+	{
+		sna_fsm_bis(FSM_BIS_FSP);
+		sna_fsm_scb_status(FSM_SCB_STATUS_FSP);
+		scb->first_speaker = SNA_RM_TRUE;
+	}
+
+	if(session_info->bracket_type == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_bis(FSM_BIS_BIDDER);
+		sna_fsm_scb_status(FSM_SCB_STATUS_BIDDER);
+		scb->first_speaker = SNA_RM_FALSE;
+	}
+
+	return (0);
+}
+
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp, 
+	struct sna_tp *tp)
+{
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+	int err;
+
+	tcb = (struct sna_tcb *)kmalloc(sizeof(tcb), GFP_ATOMIC);
+	tcb->tcb_id		= tcb_id++;
+	tcb->tp_name		= start_tp->tp_name;
+	tcb->own_lu_id		= lucb->lu_id;
+	tcb->luw_id.fq_lu_name 	= start_tp->fq_lu_name;
+	sna_complete_luw_id(tcb);
+	tcb->ctrl_cmpnt	= tp;
+
+	/* Shrink these once I know which way is up */
+	if(start_tp->security.user_id != NULL)
+		tcb->security.user_id = start_tp->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+	if(start_tp->security.profile != NULL)
+		tcb->security.profile = start_tp->security.profile;
+	else
+		rcb->security.profile = NULL;
+
+	ps_create_parms = (struct sna_ps_create_parms *)kmalloc(sizeof(ps_create_parms), GFP_ATOMIC);
+
+	/* INITILIZE PS_CREATE_PARMS !!! */
+	err = sna_ps_creation_proc(ps_create_parms);
+	if(err)
+	{
+		bm_free(FREE, tcb);
+		start_tp->tcb_id = NULL;
+	}
+
+	tp->tp_cnt++;
+	start_tp->tcb_id = tcb->tcb_id;
+
+	return (0);
+}
+
+static int sna_deactivate_free_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_scb *scb;
+
+	/* XXXX */
+	while(free_session)
+	{
+		polarity = sna_session_deactivation_polarity(lu_name,mode_name);
+		scb = sna_search_scb(lu_name, mode_name);
+		remove_from_free_session_pool;
+		sna_send_bis(scb->hs_id);
+	}
+
+	return (0);
+}
+
+/* Saving it for a little later, when fsp functions firm up */
+static int sna_deactivate_pending_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(mode_name);
+
+	return (0);
+}
+
+static int sna_dequeue_waiting_request(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if((get_session = sna_get_waiting_gsess(hs_id)) != NULL)
+	{
+		/* Remove from waiting queue */
+
+		sna_get_session_proc(get_session);
+	}
+
+	return (0);
+}
+
+static int sna_enqueue_free_scb(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(hs_id);
+	if(nobody_is_using_this_scb)
+	{
+		if(timer_is_to_be_set)
+			start_timer(scb->timer);
+		scb->timer_unique_id = timer_id++;
+	}
+	put_scb_in_free_pool(scb);	/* ??? */
+
+	return (0);
+}
+
+static int sna_first_speaker_proc(struct sna_get_session *get_session, 
+	__u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *session_allocd;
+
+	sna_set_rcb_and_scb_fields(get_session->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get_session->rcb_id, hs_id);
+
+	session_allocd = (struct sna_session_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+	session_allocd->rcode = OK;
+
+	scb = sna_search_scb(hs_id);
+	session_allocd->send_ru_size		= scb->send_ru_size;
+	session_allocd->limit_buf_pool_id	= scb->limit_buf_pool_id;
+	session_allocd->perm_buf_pool_id	= scb->perm_buf_pool_id;
+	session_allocd->in_conver 		= SNA_RM_FALSE;
+
+	sna_ps(session_allocd);
+
+	return (0);
+}
+
+static int sna_free_session_proc(struct sna_mu *mu)
+{
+	struct sna_free_session *free = (struct sna_free_session *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_rtr_rq *rtr_rq;
+	struct sna_bracket_freed *bracket_freed;
+	struct sna_get_session *get_session;
+	int send_now;
+
+	scb = sna_search_scb(free->hs_id);
+	rcb = sna_search_rcb(scb->rcb_id);
+
+	if(rcb == NULL)
+	{
+		bracket_freed = (struct sna_bracket_freed *)kmalloc(sizeof(bracket_freed), GFP_ATOMIC);
+		bracket_freed->bracket_id = scb->bracket_id;
+		sna_hs(bracket_freed);
+	}
+
+	scb->rcb_id = NULL;
+	if(sna_fsm_scb_status() == PENDING_FMH12)
+	{
+		sna_send_deactivate_session(active, scb->hs_id, abnormal, 0x080F6051);
+		return (-1);
+	}
+	else
+		sna_fsm_scb_status(R, FREE_SESSION, UNDEFINED);
+
+	if(sna_fsm_rcb_status() == PENDING_SCB && rcb->hs_id == scb->hs_id)
+		return (0);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE)
+		{
+			if(no_get_session_rqs_waiting)
+			{
+				if(rtr_is_to_be_sent_now)
+				{
+					sna_hs(rtr_rq);
+					scb->rtr_owed = SNA_RM_FALSE;
+				}
+				else
+					sna_enqueue_free_scb(scb->hs_id);
+				return (0);
+			}
+			else
+				return (0);
+		}
+	}
+
+	send_now = sna_should_send_bis(scb->hs_id);
+	if(send_now)
+		sna_send_bis(scb->hs_id);
+	if(sna_fsm_bis() == BIS_SENT || sna_fsm_bis() == CLOSED)
+		return (0);
+	else
+	{
+		sna_enqueue_free_scb(scb->hs_id);
+		if(get_sessions_waiting)
+			sna_dequeue_waiting_request(scb->hs_id);
+	}
+
+	bm_free(FREE, free_session);
+
+	return (0);
+}
+
+static int sna_get_session_proc(struct sna_get_session *get_session)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_partner_lu *partner_lu;
+	struct sna_session_allocated *session_allocd;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	partner_lu = search_plu(rcb->lu_name);
+	mode = search_mode(rcb->lu_name, rcb->mode_name);
+
+	if(mode == NULL)	/* ??? */
+	{
+		session_allocd = (struct sna_session_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+		session_allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+		sna_ps(session_allocd);
+		bm_free(FREE, get_session);
+	}
+	else
+	{
+		if(sync_level_not_supported)
+		{
+			session_allocd = (struct sna_sessino_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+			session_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+			sna_ps(session_allocd); /* ??? */
+			bm_free(get_session);
+		}
+
+		if(free_session_exists)
+		{
+			scb = sna_search_scb(free_session);
+			if(scb->first_speaker == SNA_RM_TRUE)
+			{
+				sna_first_speaker_proc(get_session, scb->hs_id);
+				bm_free(FREE, get_session);
+			}
+			else
+				sna_bidder_proc(get_session, scb->hs_id);
+			Remove_session_from_free_sess_pool;
+
+			if(scb->timer_unique_id != NULL)
+			{
+				remove_timer(scb->timer);
+				scb->timer_unique_id = NULL;
+			}
+		}
+		else
+		{
+			if(get_session_requests >= pending_active_sess_requests)
+			{
+				polarity = sna_session_activation_polarity(rcb->lu_name, rcb->mode_name);
+				switch(polarity)
+				{
+					case (SNA_SESSION_NONE):
+						if(partner_lu->parallel == SNA_RM_FALSE
+							&& active_session_for_another_mode == SNA_RM_TRUE)
+						{
+							if(session_is_free)
+							{
+								scb = sna_search_scb(free_session);
+								remove_from_free_session_pool;
+								sna_send_bis(scb->hs_id);
+								if(scb->timer_unique_id != NULL)
+								{
+									remove_timer(scb->timer);
+									scb->timer_unique_id = NULL;
+								}
+							}
+						}
+						break;
+
+					case (SNA_SESSION_FIRST_SPEAKER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_FIRST_SPEAKER);
+						break;
+
+					case (SNA_SESSION_BIDDER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_BIDDER);
+						break;
+				}
+			}
+
+			sna_queue_get_session(get_session);	/* ??? */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_ps_abend_proc(struct sna_mu *mu)
+{
+	struct sna_abend_notify *abend 
+		= (struct sna_abend_notify *)mu->record_ptr;
+	struct sna_tcb *tcb;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+	struct sna_start_tp *tp;
+	struct sna_mode *mode;
+	struct sna_deactivate_session *deactivate_session;
+
+	tcb = sna_search_tcb(abend);
+	sna_destroy_queued_get_sessions(abend);
+	if(tcb != NULL)
+	{
+		for(each_rcb_associated_w_abended_PS;;)
+		{
+			if(sna_fsm_rcb_status() == FREE)
+				mode = sna_search_mode(rcb->lu_name, rcb->mode_name);
+			if(sna_fsm_rcb_status() == IN_USE 
+				|| sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				scb = sna_search_scb(rcb->hs_id);
+				bm_free(FREE, rcb);
+				if(scb != NULL)
+				{
+					deactivate_session = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate_session), GFP_ATOMIC);
+					deactivate_session->status = ACTIVE;
+					deactivate_session->hs_id = scb->hs_id;
+					deactivate_session->type = ABNORMAL;
+					deactivate_session->sense = 0x08640000;
+					sna_sm(deactivate_session);	/* ?? */
+
+					session_deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(session_deactivated), GFP_ATOMIC);
+					session_deactivated->hs_id = scb->hs_id;
+					session_deactivated->reason = ABNORMAL;
+					session_deactivated->sense = 0x08640000;
+					sna_session_deactivated_proc(session_deactivated);
+				}
+			}
+		}
+
+		tp = sna_search_tp(tcb->tp_name);
+		if(tp != NULL)
+		{
+			tp->tp_cnt--;
+			if(init_req_queued_for_tp && tp->tp_cnt < tp->max_tp)
+			{
+				remove_init_req_from_queue;
+				if(init_req_is_an_mu(containing_attach)
+				{
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					mu->layer.hs_to_rm.hs_id = rcb->hs_id;
+					scb = sna_search_rcb(rcb->hs_id);
+					sna_fsm_scb_status(r, free_session, undefined);
+					sna_fsm_scb_status(r, bid, undefined);
+					scb->bracket_id = NULL;
+					scb->rcb_id = NULL;
+					destroy_rcb(rcb);
+					sna_attach_proc(mu);
+				}
+
+				if(queued_init_req == START_TP)
+					sna_start_tp_proc(start_tp);
+			}
+		}
+	}
+
+	destroy_tcb(tcb);
+
+	return (0);
+}
+
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id, 
+	struct sna_tp *target_tp)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_lucb *lucb;
+
+	tcb = (struct sna_tcb *)kmalloc(sizeof(tcb), GFP_ATOMIC);
+	tcb->tcb_id 	= sys_tcb_id_cnt++;
+	tcb->tp_name 	= mu->attach.tp_name;
+	tcb->ctrl_cmpnt = tp;
+	tcb->own_lu_id	= lucb->lu_id;
+
+	/* Colapse these later */
+	if(attach->security.user_id != NULL)
+		tcb->security.user_id = attach->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+
+	if(attach->security.profile != NULL) 
+		tcb->security.profile = attach->security.profile;
+	else
+		tcb->security.profile = NULL;
+
+	if(attach->luw_id != NULL)
+		tcb->luw_id = attach->luw_id;
+	else
+	{
+		tcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+		sna_complete_luw_id(tcb);
+	}
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	rcb = (struct sna_rcb *)kmalloc(sizeof(rcb), GFP_ATOMIC);
+	rcb->rcb_id 	= sys_rcb_id_cnt++;
+	rcb->tcb_id 	= tcb->tcb_id;
+	rcb->lu_name 	= scb->lu_name;
+	rcb->mode_name 	= scb->mode_name;
+	rcb->tp_name 	= attach->tp_name;
+	rcb->bracket_id = sys_bracket_id_cnt++;
+	rcb->sync_level = attach->sync;
+	rcb->hs_to_ps_buffer_list = NULL;
+
+	if(attach->conversation != NULL)
+		rcb->conversation = attach->conversation;
+	else
+		rcb->conversation = NULL;
+
+	if(first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+
+	sna_fsm_rcb_status(r, attach, hs);
+	rcb->hs_id = mu->layer.hs_to_rm.hs_id;
+
+	/* Initlize PS_CREATE_PARMS */
+
+	if(ps != NULL)
+	{
+		create_rc = SUCCESS;
+		if(tp != NULL)
+			tp->tp_cnt++;
+	}
+	else
+	{
+		create_rc = FAILURE;
+		bm_free(FREE, tcb);
+		bm_free(FREE, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_ps_termination_proc(struct sna_mu *mu)
+{
+	struct sna_terminate_ps *term_ps = (struct sna_terminate_ps *)mu->record_ptr;
+	struct sna_lucb *lucb;
+	struct sna_tp *tp;
+	struct sna_mu *mu;
+	struct sna_start_tp *start_tp;
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	tcb = sna_search_tcb(term_ps);
+	tp  = sna_search_tp(term_ps);
+	if(tp != sna_NULL)
+	{
+		if(queued_init_req(tp) == SNA_RM_TRUE 
+			&& tp->max_tp != tp->tp_cnt)
+		{
+			switch(first_queued_req_rec_type)
+			{
+				case (MU_ATTACH):
+					mu->layer.rm_to_ps.tcb_id = tcb->tcb_id;
+					tcb->ctrl_cmpnt = tp;
+					if(attach->security != NULL)
+						tcb->security = attach->security;
+					if(attach->luw_id != NULL)
+						tcb->luw_id = attach->luw_id;
+					else
+					{
+						rcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+						sna_complete_luw_id(tcb);
+					}
+
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					rcb->tcb_id = tcb->tcb_id;
+					hs_ps_connected = (struct hs_ps_connected *)kmalloc(sizeof(hs_ps_connected), GFP_ATOMIC);
+					hs_ps_connected->bracket_id = rcb->bracket_id;
+					hs_ps_connected->ps_id = rcb->tcb_id;
+
+					sna_hs(hs_pd_connected);
+					err = sna_ps(mu);
+					if(err < 0)
+						bm_free(FREE, mu);
+					break;
+
+				case (START_TP):
+					start_tp->tcb_id = tcb->tcb_id;
+					tcb->luw_id.fq_lu_name = start_tp->fq_lu_name;
+					sna_complete_luw_id(tcb);
+					tcb->ctrl_cmpnt = tp;
+					if(start_tp->security_select 
+						== SNA_SECURITY_PGM)
+					{
+						tcb->security = start_tp->security;
+					}
+					else
+						tcb->security = NULL;
+
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = OK;
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+						send_to_caller(start_tp_reply);
+					}
+					break;
+			}
+		}
+	}
+	else
+	{
+		tp->tp_cnt--;
+		destroy_tcb(tcb);
+		destroy_ps(terminate_ps);
+	}
+
+	bm_free(terminate_ps);
+
+	return (0);
+}
+
+static int sna_purge_queued_requests(struct sna_tp *tp)
+{
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_start_tp *start_tp;
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_deactivate_session *deactivate_session;
+	struct sna_session_deactivated *session_deactivated;
+
+	if(tp != NULL)
+	{
+		while((request_type = get_wait_reqs(tp)) != NULL)
+		{
+			switch(request_type)
+			{
+				case (MU_ATTACH):
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					scb = sna_search_scb(rcb->hs_id);
+
+					destroy_rcb(rcb);
+					bm_free(FREE, mu);
+					if(scb != NULL)
+					{
+						deactivate_session = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate_session), GFP_ATOMIC);
+						deactivate_session->status = ACTIVE;
+						deactivate_session->hs_id = scb->hs_id;
+						deactivate_session->type = ABNORMAL;
+						deactivate_session->sense = 0x08640000;
+
+						sna_sm(deactivate_session);
+						session_deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(session_deactivated), GFP_ATOMIC);
+						session_deactivated->hs_id = scb->hs_id;
+						session_deactivated->reason = ABNORMAL_RETRY;
+						session_deactivated->sense = 0x08640000;
+						sna_session_deactivated_proc(session_deactivated);
+					}
+					break;
+
+				case (START_TP):
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						start_tp_reply->tcb_id = NULL;
+						send_tp_init_proc(start_tp_reply);
+					}
+
+					destroy_start_tp(start_tp);
+					break;
+			}
+		}
+	}
+
+
+	return (0);
+}
+
+static int sna_queue_attach_proc(struct sna_mu *mu)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	rcb = (struct sna_rcb *)kmalloc(sizeof(rcb), GFP_ATOMIC);
+	rcb->rcb_id 		= sys_rcb_id_cnt++;
+	rcb->tcb_id 		= NULL;
+	rcb->tp_name 		= mu->fmh5->tp_name;
+	rcb->hs_id 		= mu->layer.hs_to_rm.hs_id;
+	rcb->bracket_id 	= sys_bracket_id_cnt++;
+	rcb->sync 		= mu_fmh5->sync;
+	rcb->hs_buffer_list 	= NULL;
+
+	if(mu->fsmh5.conversation != NULL)
+		rcb->conversation = mu->fmh5.conversation;
+	else
+		rcb->conversation = NULL;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	rcb->lu_name 		= scb->lu_name;
+	rcb->mode_name 		= scb->mode_name;
+
+	if(scb->first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+	sna_fsm_rcb_status(r, attach, hs);
+
+	scb->bracket_id 	= rcb->bracket_id;
+	scb->rcb_id		= rcb->rcb_id;
+	rcb->conversation.gid	= scb->conversation.gid;
+	rcb->session_id		= scb->session_id;
+	sna_fsm_scb_status(r,
+
+	mu->layer.rm_to_ps.rcb_id		=
+	mu->layer.rm_to_ps.send_ru_size
+	mu->layer.rm_to_ps.limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	mu->layer.rm_to_ps.perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	mu->layer.rm_to_ps.sense		= 0;
+
+	queue_attach_mu(mu);	/* What about rcb ?? */
+
+	return (0);
+}
+
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu)
+{
+	struct sna_rm_deactivate_conv_group *rm_dact_conv_group
+		= (struct sna_rm_deactivate_conv_group *)mu->record_ptr;
+	struct sna_rm_deactivate_session *rm_deactivate;
+	struct sna_scb *scb;
+
+	while((scb = sna_search_scb_gid(rm_dact_conv_group->gid)) != NULL)
+	{
+		rm_deactivate = (struct sna_rm_deactivate_session *)kmalloc(sizeof(rm_deactivate), GFP_ATOMIC);
+		rm_deactivate->tcb_id 		= NULL;
+		rm_deactivate->session_id 	= scb->hs_id;
+		rm_deactivate->type 		= rm_dact_conv_group->type;
+		rm_deactivate->sense		= rm_dact_conv_group->sense;
+
+		sna_rm_deactivate_session_proc(rm_deactivate);
+	}
+
+	destroy_rm_dact_conv_group(rm_dact_conv_group);
+
+	return (0);
+}
+
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rm_deactivate->session_id);
+	if(scb != NULL)
+	{
+		switch(rm_deactivate->type)
+		{
+			case (CLEANUP):
+				sna_send_deactivate_session(ACTIVE, rm_deactivate->session_id, CLEANUP, rm_deactivate);
+				kfree(rm_deactivate);
+				break;
+
+			case (NORMAL):
+				if(session_in_free_session_pool)
+				{
+					if(sna_fsm_bis() != BIS_SENT)
+						queue_deact(rm_deactivate);
+					else
+						kfree(rm_deactivate);
+				}
+				else
+				{
+					queue_deact(rm_deactivate);
+					sna_send_bis_rq(hs_id);
+					remove_from_free_pool(hs_id);
+				}
+				break;
+		}
+	}
+	else
+		kfree(rm_deactivate);
+
+	return (0);
+}
+
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop)
+{
+	struct sna_scb *scb;
+	struct sna_mode *mode;
+	struct sna_rm_deactivate_session *rm_deactivate;
+
+	mode = sna_search_mode(rm_timer_pop->lu_name, rm_timer_pop->mode_name);
+	scb = sna_search_scb(rm_timer_pop->unique_id);
+	if(scb != NULL)
+	{
+		if(scb_in_free_ses_pool && scb->first_speaker == SNA_RM_TRUE
+			&& mode->active.conwinners + mode->pending.conwinners 
+			> mode->auto_activate_limit)
+		{
+			rm_deactivate = (struct sna_rm_deactivate_session *)kmalloc(sizeof(rm_deactivate), GFP_ATOMIC);
+			rm_deactivate_session_proc(rm_deactivate);
+		}
+	}
+
+	kfree(rm_timer_pop);
+
+	return (0);
+}
+
+static int sna_rtr_rq_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rq *rtr_rq = (struct sna_rtr_rq *)mu->record_ptr;
+	struct sna_get_session *get_session;
+	struct sna_rtr_rsp *rtr_rsp;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rtr_rq);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if((get_session = get_waiting_get_session()) != NULL)
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			rtr_rsp = (struct sna_rtr_rsp *)kmalloc(sizeof(rtr_rsp), GFP_ATOMIC);
+			rtr_rsp->rti = POS;
+			rtr_rsp->sense = 0x00000000;
+			sna_hs(rtr_rsp);
+			remove_get_session_wait(get_session);
+			sna_get_session_proc(get_session);
+		}
+		else
+		{
+			rtr_rsp = (struct sna_rtr_rsp *)kmalloc(sizeof(rtr_rsp), GFP_ATOMIC);
+			rtr_rsp->rti = NEG;
+			rtr_rsp->sense = 0x8190000;
+			send_to_hs(rtr_rsp);
+			bis_send = sna_should_send_bis(rtr_rq->hs_id);
+			if(bis_send != NULL)
+				sna_send_bis(rtr_rq->hs_id);
+			else
+				sna_enqueue_free_scb(scb->hs_id);
+		}
+		scb->rtr_owed = SNA_RM_FALSE;
+	}
+	else
+		sna_send_deactivate_session(ACTIVE, rtr_rq->hs_id, ABNORMAL, 0x2003000);
+
+	return (0);
+}
+
+static int sna_rtr_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rsp *rtr_rsp = (struct sna_rtr_rsp *)mu->record_ptr;
+
+	if(rtr_rsp->rti == NEG && fsm_bis == RESET)
+	{
+		bis_send = sna_should_send_bis(rtr_rsp->hs_id);
+		if(bis_send != NULL)
+			sna_send_bis(rtr_rsp->hs_id);
+		else
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			sna_dequeue_waiting_req(rtr_rsp->hs_id);
+		}
+	}
+
+	kfree(rtr_rsp);
+
+	return (0);
+}
+
+static int sna_security_proc(struct sna_mu *mu)
+{
+	struct sna_lucb *lucb;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	remove_random_data();
+
+	if(sna_fsm_scb_status() != PENDING_FMH12
+		|| fmh12->length != 10
+		|| fmh12->security_reply != expected)
+	{
+		sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 
+			0x080F6051);
+	}
+	else
+		sna_fsm_scb_status(R, FMH_12, UNDEFINED);
+
+	bm_free(FREE_BUFFER, mu);
+
+	return (0);
+}
+
+static int sna_send_bis(__u8 hs_id)
+{
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			sna_send_bis_rq(hs_id);
+			break;
+
+		case (BIS_RCVD):
+			sna_send_bis_reply(hs_id);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	sna_fsm_bis(s, BIS_REPLY, hs_id);
+
+	bis_reply = (struct sna_bis_reply *)kmalloc(sizeof(bis_reply), GFP_ATOMIC);
+	send_to_hs(bis_reply);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == FREE_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlosers++;
+
+	return (0);
+}
+
+static int sna_send_bis_rq(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_rq *bis_rq;
+
+	bis_rq = (struct sna_bis_rq *)kmalloc(sizeof(bis_rq), GFP_ATOMIC);
+	sna_send_to_hs(bis_rq);
+
+	sna_fsm_bis(s, bis_rq, hs_id);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlossers++;
+
+	if(pending_cnos(hs_id))
+		discard_all_queued(rm_deactivate_session);
+	else
+		mode->termnination.sessions--;
+
+	return (0);
+}
+
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type, 
+	__u32 sense)
+{
+	struct sna_pending_activation *pending;
+	struct sna_deactivate_session *deactivate;
+	struct sna_session_deactivated *deactivated;
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	switch(status)
+	{
+		case (PENDING):
+			pending = sna_search_pending(correlator);
+			if(pending != NULL)
+			{
+				deactivate = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+				deactivate->status 	= PENDING;
+				deactivate->correlator 	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+				send_to_sm(deactivate);
+
+				mode = sna_search_mode();
+				mode->pending.sessions--;
+
+				kfree(pending_activation);
+
+				if((mode->active.sessions + mode->pending.sessions) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						session_allocated = (struct sna_session_allocated *)kmalloc(sizeof(session_allocated), GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+
+				if((mode->active.conwinners + mode->pending.conwinners) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						if(get_session->type != CONWINNER)
+						{
+							continue;
+						}
+
+						session_allocated = (struct sna_session_allocated *)kmalloc(sizeof(session_allocated), GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+			}
+			break;
+
+		case (ACTIVE):
+			scb = sna_search_scb(correlator);
+			if(scb != NULL)
+			{
+				deactivate = (struct sna_deactiavte_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+				deactivate->hs_id	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+
+				send_to_sm(deactivate_session);
+
+				deavtivated = (struct sna_session_deactivated *)kmalloc(sizeof(deactivated), GFP_ATOMIC);
+				if(type == NORMAL)
+					deactivated->reason = NORMAL;
+				else
+				{
+					deactivated->reason = ABNORMAL_NO_RETRY;
+					deactivated->sense = sense;
+				}
+				sna_session_deactivated_proc(deactivated);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_rtr_proc(struct sna_mu *mu)
+{
+	struct sna_send_rtr *send_rtr = (struct sna_send_rtr *)mu->record_type;
+	struct sna_scb *scb;
+	struct sna_rtr_rq *rtr_rq;
+
+	scb = sna_search_scb(send_rtr->hs_id);
+	if(scb != NULL)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE && scb_is_free)
+		{
+			rtr_rq = (struct sna_rtr_rq *)kmalloc(sizeof(rtr_rq), GFP_ATOMIC);
+			sna_send_to_hs(rtr_rq);
+
+			scb->rtr_owed = SNA_RM_FALSE;
+			remove_from_free_pool(scb);
+		}
+	}
+
+	kfree(send_rtr);
+
+	return (0);
+}
+
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *allocated;
+
+	if(session == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_rcb_status(s, get_session, UNDEFINED);
+	}
+
+	sna_set_rcb_and_scb_fields(get->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get->rcb_id, hs_id, NORMAL);
+
+	scb = sna_search_scb(hs_id);
+	allocated = (struct sna_session_allocated *)kmalloc(sizeof(allocated), GFP_ATOMIC);
+	allocated->rcode 		= OK;
+	allocated->send_ru_size 	= scb->send_ru_size;
+	allocated->limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	allocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	allocated->in_conver 		= SNA_RM_TRUE;
+
+	send_to_ps(allocated);
+
+	return (0);
+}
+
+static int sna_session_activated_proc(struct sna_mu *mu)
+{
+	struct sna_session_activated *activated
+		= (struct sna_session_activated *)mu->record_ptr;
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(activated->lu_name, activated->mode_name);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->active.conwinners++;
+	else
+		mode->active.conlosers++;
+
+	mode->active.sessions++;
+
+	sna_successful_session_activation(activated->lu_name, 
+		activated->mode_name, activated->session_info);
+
+	kfree(activated);
+
+	return (0);
+}
+
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *partner;
+	struct sna_conv_failure *conv_fail;
+
+	scb = sna_search_scb(deactivated->hs_id);
+	if(scb != NULL)
+	{
+		mode = sna_search_mode(deactivated->lu_name, deactivated->mode_name);
+		if(sna_fsm_scb_status() == IN_USE)
+		{
+			if((rcb = sna_search_rcb(scb->rcb_id)) != NULL)
+			{
+				if(rcb->tcb_id != NULL)
+				{
+					conv_fail = (struct sna_conv_fail *)kmalloc(sizeof(conv_fail), GFP_ATOMIC);
+					conv_fail->rcb_id = scb->rcb_id;
+					switch(deactivated->reason)
+					{
+						case (NORMAL):
+						case (ABNORMAL_RETRY):
+							conv_fail->reason = SON;
+							break;
+
+						case (ABNORMAL_NO_RETRY):
+							conv_fail->reason = PROTO_VIOLATION;
+							break;
+					}
+					send_to_ps(conv_fail);
+				}
+				else
+				{
+					mu = search_mu(rcb->tp_name, rcb->rcb_id);
+					kfree(rcb);
+					remove_queue(mu);
+					bm_free(FREE, mu);
+				}
+			}
+		}
+		else
+			remove_from_free_sess(session);
+
+		rcb = sna_search_rcb(deactivated->hs_id);
+		if(rcb != NULL)
+		{
+			if(sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				rcb->hs_id = NULL;
+				sna_fsm_rcb_status(r, NEG_BID_RSP, UNDEFINED);
+				get_session = (struct sna_get_session *)kmalloc(sizeof(get_session), GFP_ATOMIC);
+				sna_get_session_proc(get_session);
+			}
+		}
+
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->active.conwinners--;
+		else
+			mode->active.conlosers--;
+		mode->active.sessions--;
+
+		if(session->pending.deactivation == SNA_RM_TRUE)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->termination.conwinners--;
+			else
+				mode->termination.conlosers--;
+		}
+
+		if(deactivated->reason != ABNORMAL_NO_RETRY)
+			sna_activate_needed_sessions(scb->lu_name, scb->mode_name);
+
+		if((mode->active.sessions + mode->pending.sessions) == 0)
+		{
+			if(partner->parallel == SNA_RM_FALSE)
+			{
+				if(waiting_request)
+					sna_activate_needed_sessions(partner->local_lu_name, mode->name);
+			}
+
+			while((get_session = get_sessions()) != NULL)
+			{
+				allocated = (struct sna_sesssion_allocated *)kmalloc(sizeof(allocated), GFP_ATOMIC);
+				allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+				send_to_ps(allocated);
+				kfree(get_session);
+			}
+
+			while((rm_activate = get_rm_activate_pend()) != NULL)
+			{
+				rm_activated = (struct sna_rm_session_activated *)kmalloc(sizeof(rm_activated), GFP_ATOMIC);
+				rm_activated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+				send_to_ps(rm_activated);
+				kfree(rm_activate);
+			}
+		}
+
+		kfree(scb);
+	}
+
+	kfree(deactivated);
+
+	return (0);
+}
+
+static int sna_session_deactivation_polarity(unsigned char *lu_name, unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->term_count == 0)
+		return (DEACTIVATE);
+	conwinner_cnt = mode->active.conwinners + mode->pending.conwinners 
+		- mode->terminator.conwinners;
+	conloser_cnt = mode->active.conlosers + mode->pending.conlosers 
+		- mode->termination.conlosers;
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		mode->term_count = 0;
+		return (SNA_SESSION_NONE);
+	}
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_BIDDER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinner
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		return (SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_EITHER);
+	}
+	
+	return (0);
+}
+
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	scb->rcb_id = rcb_id;
+
+	rcb = sna_search_rcb(rcb_id);
+	rcb->hs_id = hs_id;
+
+	if(rcb->first_speaker)
+	{
+		sna_fsm_scb_status(s, get_session, undefined);
+		sna_fsm_rcb_status(s, get_session, undefined);
+	}
+	else
+	{
+		sna_fsm_scb_status(r, pos_bid_rsp, undefined);
+		sna_fsm_rcb_status(r, pos_bid_rsp, undefined);
+	}
+
+	return (0);
+}
+
+static int sna_should_send_bis(__u8 hs_id)
+{
+	struct sna_partner *plu;
+	struct sna_mode *mode;
+	int polarity;
+
+	mode = sna_search_mode(hs_id);
+	plu = mode->partner;
+
+	if(!waiting_req(mode) && plu->parallel == NOT_SUPPORTED)
+	{
+		if(waiting_req(plu))
+			return (SNA_RM_TRUE);
+	}
+
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			polarity = sna_session_deactivation_polarity(lu_name, mode_name);
+			if(polarity == SNA_SESSION_EITHER 
+				|| polarity_mode->polarity)
+			{
+				if(mode->drain_self == SNA_RM_FALSE 
+					|| !waiting_req())
+					return (SNA_RM_TRUE);
+				if(pending_rm_deactivate_session)
+					return (SNA_RM_FALSE);
+				return (SNA_RM_FALSE);
+			}
+			break;
+
+		case (BIS_RCVD):
+			if(mode->drain_self == SNA_RM_FALSE || !waiting_req())
+				return (SNA_RM_TRUE);
+			else
+				return (SNA_RM_FALSE);
+
+		case (BIS_SENT):
+			return (SNA_RM_FALSE);
+
+		default:
+			return (-ERROR);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_proc(struct sna_start_tp *start_tp)
+{
+	struct sna_tp *tp;
+	struct sna_lucb *lucb;
+	struct sna_start_tp_reply *start_tp_reply;
+	int response_code;
+
+	response_code = OK;
+	tp = sna_search_tp(start_tp->target_tp_name);
+	if(tp == NULL)
+		response_code = TPN_NOT_RECOGNIZED;
+	else
+	{
+		if(tp->status == DISABLED_TEMPORARY)
+			response_code = TRANS_PGM_NOT_AVAILABLE_RETRY;
+		if(tp->status == DISABLED_PERMANENT)
+			response_code = TRANS_PGM_NOT_AVAIL_NO_RETRY;
+		if(tp->verify_pip == SNA_RM_TRUE && response_code == OK)
+		{
+			if(start_tp->pip_subs != tp->pip_subs)
+			{
+				if(tp->pip_subs == 0)
+					response_code = PIP_NOT_ALLOWED;
+				else
+					response_code = PIP_NOT_SPECIFIED_CORRECTLY;
+			}
+		}
+
+		if(response_code == OK)
+		{
+			err = start_tp_security_valid(start_tp, tp);
+			if(err < 0)
+				response_code = SECURITY_NOT_VALID;
+		}
+
+		if(response_code == OK && start_tp->fqlu_name != NULL
+			&& start_tp->fqlu_name == Not_proper_format)
+		{
+			response_code = INVALID_FULLY_QUALIFIED_LU_NAME;
+		}
+	}
+
+	if(reponse_code == OK)
+	{
+		if(start_tp->fq_lu_name == NULL)
+			start_tp->fq_lu_name = lucb->fq_lu_name;
+
+		if(tp->tp_cnt < tp->max_tp)
+		{
+			sna_create_tcb_and_ps(start_tp, tp);
+			if(start_tp->tcb_id != NULL)
+			{
+				send_to_ps(start_tp);
+				if(start_tp->reply == SNA_RM_TRUE)
+				{
+					start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+					start_tp_reply->rcode = response_code;
+					if(response_code == OK)
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+					send_tp_caller(start_tp_reply);
+				}
+				kfree(start_tp);
+			}
+			else
+			{
+				if(tp->tp_cnt > 0)
+					queue(start_tp);
+				else
+				{
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						send_to_init(start_tp_reply);
+					}
+					kfree(start_tp);
+					sna_purge_queued_requests(tp);
+				}
+			}
+		}
+		else
+			queue(start_tp);
+	}
+	else
+	{
+		if(start_tp->reply == SNA_RM_TRUE)
+		{
+			start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+			start_tp_reply->rcode = response_code;
+			start_tp_reply->tcb_id = NULL;
+			send_to_init(start_tp_reply);
+		}
+		kfree(start_tp);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp)
+{
+	if(start_tp->security_select == NULL)
+	{
+		if(tp_requires_security)
+			return (SNA_RM_FALSE);
+		else
+			return (SNA_RM_TRUE);
+	}
+
+	if(start_tp->security.profile != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security.passwd != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security_select ==SNA_SECURITY_PGM)
+	{
+		if(start_tp->security.user_id != NULL
+			&& start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(start_tp->security.user_id == NULL
+			|| (start_tp->security.passwd == NULL
+			&& tp_requires_security))
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(!tp requires security
+			&& (start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL))
+		{
+			return (SNA_RM_TRUE);
+		}
+
+		if(start_tp->security is bad combination)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+	else
+	{
+		if(start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+
+	if(limit_access_to_tp)
+	{
+		if(sna_access_ok(start_tp->security.user_id, 
+			start_tp->security.profile)
+		{
+			return (SNA_RM_TRUE);
+		}
+		else
+		{
+			return (SNA_RM_FALSE);
+		}
+	}
+		
+	return (SNA_RM_TRUE);
+}
+
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_information *info)
+{
+	struct sna_scb *scb;
+	struct sna_get_session *session;
+	struct sna_session_allocated *allocd;
+	struct sna_rm_hs_connected *connected;
+	struct sna_rm_activate_sesion *activate;
+	struct sna_rm_session_activated *activated;
+
+	sna_create_scb(lu_name, mode_name, info);
+	connected = (struct sna_rm_hs_connected *)kmalloc(sizeof(struct sna_rm_hs_connected), GFP_ATOMIC);
+	sna_send_to_hs(connected);
+
+	if(info->first_speaker != SNA_RM_TRUE && plu->parallel != SNA_RM_TRUE)
+	{
+		while((session = get_wait_sessions(CONWINNER)) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+			allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			remove_from_list(allocd);
+		}
+	}
+
+	if(info->primary_hs == SNA_RM_TRUE)
+	{
+		sna_fsm_scb_status(r, activated, PRI);
+		while(activated)
+		{
+			if(session == waiting)
+			{
+				if(session->security.level != waiting_req->security.level)
+				{
+					session->security.level = NONE;
+				}
+
+				if(session->sync_level != waiting_req->sync_level)
+				{
+					allocd = (struct sna_session_allocted *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+					allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+					send_to_ps(allocd);
+					kfree(session);
+				}
+				else
+				{
+					if(scb->random != NULL)
+					{
+						sec2 = (struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_ATOMIC);
+						sec2->send_parm.allocate = NO;
+						sec2->send_parm.fmh = YES;
+						sec2->send_parm.type = FLUSH;
+						sna_send_to_hs(sec2);
+						sna_session_activated_alloc(session, scb->hs_id);
+						kfree(session);
+					}
+				}
+			}
+			else
+			{
+				sna_fsm_scb_status(s, YEILD_SESSION, undefined);
+				if(scb->random_data != NULL)
+				{
+					sec2 = (struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_ATOMIC);
+					sec2->send_parm.allocate = NO;
+					sec2->send_parm.fmh = YES;
+					sec2->send_parm.type = DEALLOCATE_FLUSH;
+					sna_send_to_hs(sec2);
+				}
+				else
+				{
+					yield = (struct sna_yield_session *)kmalloc(struct sna_yield_session), GFP_ATOMIC);
+					sna_send_to_hs(yield);
+				}
+			}
+		}
+	}
+	else
+	{
+		if(scb->random_data != NULL)
+			sna_fsm_scb_status(r, activated, secure);
+		else
+			sna_fsm_scb_status(r, activated, sec);
+	}
+
+	activate = sna_rm_activate_pending();
+	if(activate != NULL)
+	{
+		activated = (struct sna_rm_session_activated *)kmalloc(sizeof(struct sna_rm_session_activated), GFP_ATOMIC);
+		activated->rcode = OK;
+		kfree(activate);
+	}
+
+	return (0);
+}
+
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, struct sna_rcb_allocated *rcb_allocd)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	if((find_fsp(rcb_alloc->lu_name, rcb_alloc->mode_name)) != NULL)
+	{
+		create_scb(rcb_alloc, rcb_allocd);
+		if(rcb->security_select != plu->security_select)
+		{
+			rcb->security_select = NONE;
+		}
+		if(rcb_alloc->sync_level != plu->sync_level)
+		{
+			rcb_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+		}
+		else
+		{
+			sna_set_rcb_and_scb_field(rcb->rcb_id, hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, hs_id);
+			rcb_allocd->rcode = OK;
+			rcb_allocd->send_ru_size = scb->send_ru_size;
+			rcb_allocd->limit_buf_pool_id = scb->limit_buf_pool_id;
+			rcb_allocd->perm_buf_pool_id = scb->perm_buf_pool_id;
+			dequeue_fs_pool();
+		}
+	}
+	else
+		rcb_allocd->rcode = UNSUCCESSFUL;
+
+	return (0);
+}
+
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, unsigned char *mode_name, int err)
+{
+	struct sna_mode *mode;
+	struct sna_session_allocated *allocd;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->active.sessions == 0 && mode->pending.sessions == 0)
+	{
+		while((waiting = waiting_req(lu_name, mode_name)) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+
+			send_to_ps(allocd);
+			kfree(waiting);
+		}
+
+		sessions = get_wait_sessions();
+		if(plu->parallel != SNA_RM_TRUE && sessions != NULL)
+		{
+			sna_activate_needed_sessions(lu_name, mode_name);
+		}
+	}
+
+	while(pending_rm_activate_reqs > mode->pending.sessions)
+	{
+		activated = (struct sna_rm_session_activated *)kmalloc(sizeof(sna_rm_session_activated), GFP_ATOMIC);
+
+		if(err == CAN_RETRY)
+			activated->rcode = ACTIVATION_FAILURE_RETRY;
+		else
+			acitvated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+
+		send_to_ps(activated);
+		kfree(activate);
+	}
+
+	if((mode->active.conwinners + mode->pending.conwinners) == 0)
+	{
+		while((get_session = get_wait_sessions()) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			kfree(get_session);
+		}
+	}
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session. */
+static int sna_fsm_scb_status(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session with respect to BIS_RQ and
+ * BIS_REPLY.
+ */
+static int sna_fsm_bis(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a conversation resource associated with a bidder
+ * half-session.
+ */
+static int sna_fsm_rcb_status(int signal)
+{
+
+	return (0);
+}
+
+struct sna_rcb *sna_search_rcb(__u8 id)
+{
+	struct sna_rcb *result = NULL;
+
+	return (result);
+}
+
+struct sna_scb *sna_search_scb(__u8 id)
+{
+	struct sna_scb *result = NULL;
+
+	return (result);
+}
+
+struct sna_tcb *sna_search_tcb(__u8 id)
+{
+	struct sna_tcb *result = NULL;
+
+	return (result);
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_rss.c linux/net/sna/sna_rss.c
--- linux-2.4.13/net/sna/sna_rss.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_rss.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,119 @@
+/* sna_rss.c: Linux Systems Network Architecture implementation
+ * Route Selection Services.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Bugs:
+ * - We do no weight calculations or tree building.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_rss_request_route(struct sna_rss_route *r)
+{
+
+	return (0);
+}
+
+int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r)
+{
+	struct sna_rq_tg_vectors *tg;
+	int err;
+
+	sna_debug(5, "sna_rss_request_single_hop_route %s.%s\n",
+		r->dst_cp_name.net, r->dst_cp_name.name);
+
+	tg = (struct sna_rq_tg_vectors *)
+		kmalloc(sizeof(struct sna_rq_tg_vectors), GFP_ATOMIC);
+	memcpy(&tg->org_cp_name, &r->dst_cp_name, sizeof(struct sna_netid));
+	err = sna_tdm_request_tg_vectors(tg);
+	if(err < 0)
+		return (err);
+
+	memset(&r->rs, 0, sizeof(struct sna_cv_rs));
+	memcpy(&r->rs.tg_desc, &tg->tg_vectors->desc, 
+		sizeof(struct sna_tg_desc));
+
+	return (0);
+}
+
+int sna_rss_obtain_tg_vectors(void)
+{
+
+	return (0);
+}
+
+int sna_rss_select_tg_vector(void)
+{
+
+	return (0);
+}
+
+int sna_rss_build_rscv(void)
+{
+
+	return (0);
+}
+
+int sna_rss_obtain_trees(void)
+{
+
+	return (0);
+}
+
+int sna_rss_update_trees(void)
+{
+
+	return (0);
+}
+
+int sna_rss_update_resource_weights(void)
+{
+
+	return (0);
+}
+
+int sna_rss_create(struct sna_start_node *start)
+{
+
+	return (0);
+}
+
+int sna_rss_destroy(struct sna_delete_node *delete)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_sm.c linux/net/sna/sna_sm.c
--- linux-2.4.13/net/sna/sna_sm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_sm.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,1989 @@
+/* sna_sm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Session Manager (SM)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif  /* CONFIG_SNA_LLC */
+
+static bind_state bstate = BIND_RESET;
+
+static struct sna_lulu_cb *lulu_list = NULL;
+
+struct sna_lulu_cb *sna_sm_find_lulu_fqpcid(unsigned char *pcid)
+{
+	struct sna_lulu_cb *l;
+
+	sna_debug(5, "sna_sm_find_lulu_fqpcid\n");
+	for(l = lulu_list; l != NULL; l = l->next)
+		if(!strncmp(l->fqpcid, pcid, 8))
+			return (l);
+
+	return (NULL);
+}
+
+static int sna_sm_build_bind_user_data(__u8 *start)
+{
+	int len = 0;
+	unsigned char name[17];
+	unsigned char unknown[9]={0x00,0x50,0xAA,0x12,0x46,0x2D,0xCA,0x75,0xEA};
+        __u8 l, s;
+	__u16 i;
+
+	sna_debug(5, "sna_sm_build_bind_user_data\n");
+	i = 0;
+	memcpy(start + len, &i, sizeof(__u16));
+	len += 2;
+	l = 12;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 45;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 8;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x02;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "CPSVCMG", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 9;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x03;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	s = 0x01;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "1234567", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 13;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x04;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 19;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	memcpy(start + len, unknown, 9);
+	len += 9;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.IBM", 10);
+	memcpy(start + len, name, 10);
+	len += 10;
+
+	return (len);
+}
+
+static int sna_sm_build_bind_cv(__u8 type, __u8 *cv_start)
+{
+	int len = 0;
+	__u8 s, l;
+	unsigned char name[17], pcid[8];
+
+	sna_debug(5, "sna_sm_build_bind_cv\n");
+	switch(type)
+	{
+		case (CV_ROUTE_SEL):
+			s = CV_ROUTE_SEL;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 19;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 17;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x46;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 15;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x80;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x00;	/* TG Number */
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 10;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.IBM", 10);
+			memcpy(cv_start + len, name, 10);
+			len += 10;
+			s = 0x00;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			break;
+
+		case (CV_COS_TPF):
+			s = 0x2C;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 9;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x04;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 7;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "CPSVCMG", 7);
+			memcpy(cv_start + len, name, 7);
+			len += 7;
+			break;
+
+		case (CV_FQ_PCID):
+			s = 0x60;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 21;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+
+			/* Copy pcid from lulu_cb here now */
+
+			memcpy(cv_start + len, pcid, 8);
+			len += 8;
+			l = 12;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+			memcpy(cv_start + len, name, 12);
+			len += 12;
+			break;
+	}
+
+	return (len);
+}
+
+/* Build +RSP(BIND). */
+static int sna_sm_build_bind_rsp_pos(struct sk_buff *skb, int t)
+{
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct net_device *dev = skb->dev;
+	struct sna_rcb *rcb = NULL;
+	struct sk_buff *newskb;
+	struct sna_bind *bind;
+	int size, len = 0;
+
+	sna_debug(5, "sna_sm_build_bind_rsp\n");
+
+#ifdef CONFIG_SNA_LLC
+        /* Device + Datalink + XID */
+        size = dev->hard_header_len + LLC_TYPE2_SIZE + 250;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+
+        skb_reserve(newskb, 200);
+	skb_reserve(newskb, sizeof(struct snarhdr));
+	skb_reserve(newskb, sizeof(struct sna_fid2));
+
+        skb_reserve(newskb, LLC_TYPE2_SIZE);
+        skb_reserve(newskb, dev->hard_header_len);
+        newskb->dev = dev;
+
+	if(t == BIND_S_BIND || t == BIND_S_PR_BIND
+		|| t == BIND_S_PR_BIND_W_AF)
+	{
+		if(t == BIND_S_BIND_W_AF)
+			bind = (struct sna_bind *)skb_push(newskb,
+                                sizeof(struct sna_bind) + 61 + 45 + 21);
+		else
+			bind = (struct sna_bind *)skb_push(newskb, 
+				sizeof(struct sna_bind) + 61 + 45);
+
+		memset(bind, 0, sizeof(struct sna_bind));
+		bind->request_code	= BIND_RQ;
+		bind->fm_profile	= FMH_19;
+		bind->ts_profile	= TSH_7;
+		bind->pri_flags		= 0xB0;
+		bind->sec_flags		= 0xB0;
+		bind->cm1_flags		= 0x50;
+		bind->cm2_flags		= 0xB3;
+		if(t == BIND_S_PR_BIND)
+		{
+			bind->sec_tx_win_size	= 0;
+			bind->sec_rx_win_size	= 0x80;
+		}
+		else
+		{
+//			if(t == BIND_S_PR_BIND_W_AF)
+//			{
+//				bind->sec_tx_win_size   = 0x01;
+ //                       	bind->sec_rx_win_size   = 0x81;
+//			}
+//			else
+//			{
+				bind->sec_tx_win_size 	= 0x07;
+				bind->sec_rx_win_size	= 0x87;
+//			}
+		}
+
+		if(t == BIND_S_PR_BIND_W_AF)
+		{
+			bind->shs_max_ru_size   = 0x86;
+                        bind->phs_max_ru_size   = 0x86;
+		}
+		else
+		{
+			bind->shs_max_ru_size	= 0x87;
+			bind->phs_max_ru_size	= 0x87;
+		}
+
+		if(t == BIND_S_PR_BIND)
+                {
+			bind->pri_tx_win_size	= 0x80;
+			bind->pri_rx_win_size	= 0;
+		}
+		else
+		{
+//			if(t == BIND_S_PR_BIND_W_AF)
+//			{
+//				bind->pri_tx_win_size   = 0x81;
+  //                              bind->pri_rx_win_size   = 0x01;
+//			}
+//			else
+//			{
+				bind->pri_tx_win_size	= 0x87;
+				bind->pri_rx_win_size	= 0x07;
+//			}
+		}
+		bind->lu_type		= 0x6;
+		bind->lu6_level		= 0x02;
+		bind->ps1_flags		= 0x16;
+		bind->ps2_flags		= 0x23;
+	
+		len += sna_sm_build_bind_user_data(&bind->raw);
+
+		if(t == BIND_S_PR_BIND_W_AF)
+			len += sna_sm_build_bind_cv(CV_ROUTE_SEL, 
+				&bind->raw + len); /*
++20 */
+
+		len += sna_sm_build_bind_cv(CV_COS_TPF, &bind->raw + len); /* +11 */
+       	 	len += sna_sm_build_bind_cv(CV_FQ_PCID, &bind->raw + len); /* +21 */
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		if(t == BIND_S_PR_BIND)
+                {
+			newskb->h.raw[0] = 0xEB;
+                	newskb->h.raw[1] = 0x80;
+                	newskb->h.raw[2] = 0x00;
+		}
+
+		if(t == BIND_S_PR_BIND_W_AF)
+		{
+			newskb->h.raw[0] = 0xEB;
+			newskb->h.raw[1] = 0x80;
+			newskb->h.raw[2] = 0x00;
+			newskb->nh.raw[2] = 0x02;
+                	newskb->nh.raw[3] = 0x01;
+		}
+	}
+	else
+	{
+		skb_push(newskb, 3);
+		newskb->data[0] = 0;
+		newskb->data[1] = 0;
+		newskb->data[2] = 1;
+
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		newskb->h.raw[0] = 0x83;
+		newskb->h.raw[1] = 0x01;
+		newskb->h.raw[2] = 0x00;
+		newskb->nh.raw[0] = 0x2D;
+		newskb->nh.raw[1] = 0x00;
+                if(t == BIND_S_PR_FMD_W_AF)
+		{
+			newskb->nh.raw[2] = 0x00; // 0x02;
+                        newskb->nh.raw[3] = 0x01;
+		}
+		else
+		{
+			newskb->nh.raw[2] = 0x01;
+			newskb->nh.raw[3] = 0x00;
+		}
+		newskb->nh.raw[4] = 0x00;
+		newskb->nh.raw[5] = 0x00;
+	}
+
+	llc_data(0x04, 0x04, eth_hdr->h_source, newskb, dev);
+#endif	/* CONFIG_SNA_LLC */
+
+        return (0);
+}
+
+/* Check BIND for semantic and state errors, create a half-session process,
+ * reserve required buffers. If no errors occur, build and send a +RSP(BIND),
+ * update and save active session parameters, and initialize the half-session.
+ */
+static int sna_sm_process_bind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rq\n");
+	if(bstate == BIND_RESET)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_BIND);
+		bstate = BIND_S_BIND;
+		kfree_skb(skb);
+		return (0);
+	}
+
+	if(bstate == BIND_S_BIND)
+	{
+		/* Send +RSP BIND */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND);
+		bstate = BIND_S_PR_BIND;
+		kfree_skb(skb);
+		return (0);
+	}
+
+	if(bstate == BIND_S_PR_BIND)
+	{
+		/* Send +RSP FMD BIND */
+                sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD);
+		bstate = BIND_S_PR_FMD;
+		kfree_skb(skb);
+		return (0);
+	}	
+
+	if(bstate == BIND_S_PR_FMD)
+	{
+		/* Send BIND w/ real oaf/daf */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND_W_AF);
+		bstate = BIND_S_PR_BIND_W_AF;
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		kfree_skb(skb);
+		return (0);
+	}
+
+#ifdef NOT
+	if(bstate == BIND_S_PR_BIND_W_AF)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return (0);
+	}
+
+	if(bstate == BIND_S_PR_BIND_W_AF)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return (0);
+	}
+#endif
+	kfree_skb(skb);
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_mu *mu_new;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_check_semantic(mu);
+        if(err < 0)
+        {
+                local->sense = err; ??
+                return (-?);
+        }
+
+        err = sna_bind_rq_state_error(mu);
+        if(err < 0)
+        {
+                local->sense = err;
+                return (-?);
+        }
+
+        plu->active_session_params.parallel = bind_rq_rcv->parallel;
+        lulu_cb = (struct sna_lulu_cb *)kmalloc(sizeof(lulu_cb), GFP_ATOMIC);
+        sna_init_lulu_cb_bind(mu, lulu_cb);
+        lulu_cb->hs_id = unique_hs_id();
+        sna_build_bind_rsp_pos(mu, lulu_cb, mu_new);
+        err = sna_reserve_constant_buffers(lulu_cb);
+        if(!err)
+                err = sna_reserver_variable_buffers(lulu_cb, bind_rq_rcv);
+        if(!err)
+        {
+                lulu_cb->session_id = sna_get_session_id();
+                sna_build_and_send_init_hs(lulu_cb, bind_image);
+        }
+
+        if(!err)
+        {
+                send_to_asm(mu_new);
+                fsm_status(mu_new, lulu_cb);
+        }
+        else
+        {
+                if(mu->bind_ru.fqpcid != NULL)
+                        sna_build_and_send_unbind_rq(mu,CLEANUP,local->sense);
+                else
+                {
+                        if(buffer_err == 0)
+                                bm(FREE, mu_new);
+                        sna_build_and_send_bind_rsp_neg(mu);
+                }
+
+                if(lulu_cb != NULL)
+                        sna_cleanup_lu_lu_session(lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Check if the received RSP(BIND) correlator with the previously sent BIND. If
+ * it does, delete pending random data used in LU-LU verification for the
+ * session (if present) and after additional processing (in case of a positive
+ * response) call the FSM. If it does not correlate, the RSP(BIND) is
+ * considered to be a stray one and is ignored (no action taken).
+ */
+static int sna_sm_process_bind_rsp(struct sk_buff *skb, 
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rsp\n");
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_correlate_bind_rsp(mu);
+        if(err >= 0)
+        {
+                plu->active_session_params.parallel = bind_rsp_rcv->parallel;
+                sna_remove_random(this_session);
+
+                if(mu->bind_rsp.type = POS)
+                {
+                        err = sna_check_semantic(mu);
+                        if(err)
+                                local->sense = err;
+
+                        err = sna_bind_rsp_state_error(mu, lulu_cb);
+
+                        if(err >= 0)
+                        {
+                                sna_reserve_variable_buffers(lulu_cb, bind_rsp_rcv);
+                                sna_build_and_send_init_hs(lulu_cb, bind_image);                        }
+                }
+
+                fsm_status(mu, lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Process a received UNBIND. SM always receives the entire UNBIND MU, since
+ * the PIU is not longer than 99 bytes and thus no reassembly by the ASM in
+ * needed. If a received UNBIND correlates to one of the active or pending
+ * active sessions, the FSM is called to clean up the session.
+ */
+static int sna_sm_process_unbind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_unbind_rq\n");
+
+#ifdef NOT
+        struct sna_lu_lu_cb *lulu_cb;
+
+        correlate = sna_correlator_unbind_rq(mu);
+        sna_build_and_send_unbind_rsp(mu);
+
+        if(correlate)
+                fsm_status(mu, lulu_cb);
+#endif
+
+        return (0);
+}
+
+int sna_sm_xtract_bind_type(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_sm_xtract_bind_type\n");
+
+	return (0);
+}
+
+/* entry point for incomming binds. */
+int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_mu\n");
+	switch(sna_sm_xtract_bind_type(skb))
+	{
+                case (SNA_BIND_RQ):
+                        sna_sm_process_bind_rq(skb, l);
+                        break;
+
+                case (SNA_BIND_RSP):
+                        sna_sm_process_bind_rsp(skb, l);
+                        break;
+
+                case (SNA_UNBIND_RQ):
+                        sna_sm_process_unbind_rq(skb, l);
+                        break;
+
+		case (SNA_UNBIND_RSP):
+                default:
+			kfree_skb(skb);
+			return (-1);
+        }
+
+        return (0);
+}
+
+/* Build and send a BIND. */
+static int sna_sm_build_and_send_bind_rq(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_mu *mu;
+        struct sna_bind_ru *bind_ru;
+
+        mu = bm(GET_BUFFER, demand, size, no_wait);     /* ??? */
+
+        mu->header_type                 = BIND_RQ_SEND;
+        mu->bind_rq_send.lu_id          = lulu_cb->lu_id;
+        mu->bind_rq_send.sender.type    = SM;
+        mu->bind_rq_send.lfsid          = lulu_cd->lfsid;
+        mu->bind_rq_send.tx_priority    = NETWORK;
+        mu->bind_rq_send.pc_id          = lulu_cd->pc_id;
+        mu->bind_rq_send.hs_id          = lulu_cd->hs_id;
+        mu->th.snf                      = find_unique(snf);
+
+        /* Set rest to default values in SNA Formats */
+
+        /* Set Bind_RU to defaults */
+
+        /* Insert random data into lucd->pending.random_data_list */
+
+        mu->dcf = (RH->size + RU->size);
+
+        send_to_asm(mu);
+#endif
+        return (0);
+}
+
+/* Get the address (LFSID structure) for the session. Create a half-session
+ * process. Reserve buffers for the session.
+ */
+static int sna_sm_prepare_to_send_bind(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_assign_lfsid *assign_lfsid;
+        struct sna_assign_lfsid_rsp *assign_lfsid_rsp;
+        struct sna_local *local;
+
+        assign_lfsid = (struct sna_assign_lfsid *)kmalloc(sizeof(struct sna_assign_lfsid), GFP_ATOMIC);
+        assign_lfsid->pc_id = lulu_cb->pc_id;
+        assign_lfsid->sm_process_id = lulu_cb->lu_id;
+        send_to_asm(assign_lfsid);
+
+        assign_lfsid_rsp = recv_from_asm();
+        if(assign_lfsid_rsp->sense != 0x00000000)
+                local->sense = assign_lfsid_rsp->sense;
+        else
+        {
+                lulu_cb->lfsid = assign_lfsid_rsp->lfsid;
+                /* Create a HS for this one ;) */
+                sna_reserve_constant_buffers(lulu_cb);
+                destroy(assign_lfsid_rsp);
+	}
+#endif
+
+	return (0);
+}
+
+/* Process a receieved CINIT_SIGNAL record. First, this signal must be
+ * correlated with a previously sent INIT_SIGNAL record. The correlation is
+ * based on the value of FQPCID. If the correlation fails, the session has
+ * already been brought down by the RM and a SESSEND_SIGNAL record is built
+ * and sent to SS.
+ */
+int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal)
+{
+	sna_debug(5, "sna_sm_process_cinit_signal\n");
+
+#ifdef NOT
+        struct sna_init_signal *init_signal;
+        struct sna_partner_lu *plu;
+        struct sna_mode *mode;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_local *local;
+        struct sna_sessend_signal *sessend_signal;
+
+        err = sna_correlate_init(cinit_signal->fqpcid); ???
+        if(err < 0)
+        {
+                sessend_signal = (struct sna_sessend_signal *)kmalloc(sizeof(sessend_signal), GFP_ATOMIC);
+                sessend_signal->sense = 0x00000000;
+                sessend_signal->fqpcid = cinit_signal->fqpcid;
+                sessend_signal->pc_id = cinit_signal->pc_id;
+                send_to_ss(sessend_signal);
+        }
+        else
+        {
+                err = sna_lu_mode_session_limit_exceeded(plu->fq_lu_name, mode,
+lulu_cb->session_type, AT_LEAST_BIND_SENT);
+                if(err)
+                        ???
+
+                err = sna_check_buff_size();
+                err = sna_check_active_already();
+                if(err < 0)
+                        local->sense = 0x08050000;
+
+                if(errs >= 0)
+                {
+                        err = sna_prepare_to_send_bind(lulu_cb);
+                        if(!err)
+                                sna_build_and_send_bind_rq(lulu_cb);
+                }
+
+                fsm_status(cinit_signal, lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of an ACTIVATE_SESSION received from RM.
+ */
+static int sna_sm_init_lulu_cb_act_sess(struct sna_sm_act_session_rq *as,
+        struct sna_lulu_cb *lulu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_sm_init_lulu_cb_act_sess\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+	if(!plu)
+		return (-ENOENT);
+
+	memcpy(&lulu->plu_netid, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&lulu->netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&lulu->mode_name, &as->mode_name, SNA_RESOURCE_NAME_LEN);
+	lulu->polarity = as->polarity;
+
+        return (0);
+}
+
+/* Build and send an INIT_SIGNAL record to the control point. */
+static int sna_sm_build_and_send_init_sig(struct sna_lulu_cb *lulu)
+{
+        struct sna_init_signal *init;
+
+	sna_debug(5, "sna_sm_build_and_send_init_sig\n");
+        init = (struct sna_init_signal *)kmalloc(sizeof(struct sna_init_signal), GFP_ATOMIC);
+	init->sm_proc_id	= lulu->proc_id;
+	memcpy(&init->fqpcid, &lulu->fqpcid, 8);
+	memcpy(&init->slu_name, &lulu->plu_netid, sizeof(struct sna_netid));
+	memcpy(&init->plu_name, &lulu->netid, sizeof(struct sna_netid));
+	memcpy(&init->mode_name, &lulu->mode_name, SNA_RESOURCE_NAME_LEN);
+
+	sna_ss_process_init_signal(init);
+
+        return (0);
+}
+
+/* Determine whether or not session limits associated with a given (LU,
+ * mode name) pair are exceeded for the given state condition (FSM_STATUS for
+ * this session).
+ */
+static int sna_sm_lu_mode_session_limit_exceeded(struct sna_netid *plu_name,
+        struct sna_mode_cb *mode, int polarity, int state)
+{
+#ifdef NOT
+        if(state == SNA_SESSION_ACTIVE)
+        {
+                bidder.sessions = sna_active_bid_sessions(mode); ??
+                fsp.sessions    = sna_active_fsp_sessions(mode); ??
+        }
+        else
+        {
+                if(state == SNA_SESSION_AT_LEAST_BIND_SENT)
+                {
+                        bidder.sessions = sna_sent_bid_sessions(mode); ??
+                        fsp.sessions    = sna_sent_fsp_sessions(mode); ??
+                }
+                else
+                {
+                        bidder.sessions = sna_init_bid_sessions(mode);
+                        fsp.sessions    = sna_init_fsp_sessions(mode);
+                }
+        }
+
+        total_limit     = mode->session_limit;
+        fsp_limit       = mode->min_conwinners_limit;
+        bidder_limit    = mode->min_conlosers_limit;
+
+        if(fsp.sessions + bidder.sessions ? total_limit)
+                return (1);
+
+        if(fsp.sessions ? total_limit - bidder_limit
+                && session_type == FIRST_SPEAKER
+                && plu->parallel == TRUE)
+                return (1);
+
+        if(bidder.sessions ? total_limit - fsp_limit
+                && session_type == BIDDER)
+                return (1);
+#endif
+
+        return (0);
+}
+
+static int sna_sm_build_and_send_act_sess_rsp_neg(int correlator, int retry)
+{
+	return (0);
+}
+
+/* Get the fully-qualified procedure correlation identifier (FQPCID) from the
+ * session services (SS) component of the control point. Repeat requests if
+ * a duplicate FQPCID was received. An FQPCID is considered duplicate if its
+ * PCID matches that for another active or pending-active session at this LU.
+ */
+static int sna_sm_get_fqpcid(struct sna_lulu_cb *lulu)
+{
+	struct sna_assign_pcid *pcid;
+
+	sna_debug(5, "sna_sm_get_fqpcid\n");
+	pcid = (struct sna_assign_pcid *)kmalloc(sizeof(*pcid), GFP_ATOMIC);
+	pcid->sm_proc_id	= lulu->proc_id;
+        pcid->duplicate_pcid	= 0;
+	sna_ss_assign_pcid(pcid);
+
+	while(sna_sm_find_lulu_fqpcid(pcid->fqpcid) != NULL)
+	{
+		pcid->duplicate_pcid = 1;
+		sna_ss_assign_pcid(pcid);
+	}
+
+	memcpy(&lulu->fqpcid, &pcid->fqpcid, 8);
+	kfree(pcid);
+        return (0);
+}
+
+/* Process an ACTIVATE_SESSION record received from RM. That includes checking
+ * for a session limit to be exceeded (since RM does not know whether the
+ * session limit is exceeded when it sends ACTIVATE_SESSION to SM), creating
+ * and initializing of the LULU_CB control block, getting an FQPCID for the
+ * session from SS, and sending an INIT_SIGNAL record to SS.
+ */
+int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as)
+{
+        struct sna_plu_cb *plu;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_sm_process_activation_session\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+        if(!plu)
+        	return (-ENOENT);
+        mode = sna_rm_find_mode(as->mode_name);
+        if(!mode)
+                return (-ENOENT);
+
+        if(sna_sm_lu_mode_session_limit_exceeded(&as->plu_netid, mode, 
+		as->polarity, SNA_SESSION_AT_LEAST_INIT_SENT))
+                sna_sm_build_and_send_act_sess_rsp_neg(as->correlator, 
+			SNA_ACT_SESS_RETRY);
+        else
+        {
+		struct sna_lulu_cb *lulu;
+                lulu = (struct sna_lulu_cb *)kmalloc(sizeof(struct sna_lulu_cb),
+			GFP_ATOMIC);
+                sna_sm_get_fqpcid(lulu);
+                sna_sm_init_lulu_cb_act_sess(as, lulu);
+
+		sna_sm_build_and_send_init_sig(lulu);
+        }
+
+        return (0);
+}
+
+#ifdef CONFIG_SM
+/* LU session manager (SM) is responsible for creating the RM process and for
+ * activating and deactivating sessions between this LU and another LU. There
+ * is one SM process per LU in the node, and it is created and destroyed when
+ * the LU is created and destroyed. SM receives records from the resource
+ * manager (RM), the half-session (HS), the address space manager (ASM), and
+ * the session services (SS) processes. When the records are received, they
+ * are routed to the appropriate procedures when they are processed. SM uses
+ * process data (called LOCAL) that can be accessed by any procedure in the
+ * SM process.
+ */
+static int sna_sm_create(unsigned char *data)
+{
+	struct sna_local *local;
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_lulu_cb *lulu_cb;
+	struct sna_rm_create_parms *rm_create_parms;
+	struct sna_rm_created *rm_created;
+	struct sna_sm_create_parms *sm_create_parms;
+
+	/* Creation time logic... need to seperate */
+	sm_create_parms = (struct sna_sm_create_parms *)data;
+	rm_create_parms = (struct sna_rm_create_parms *)kmalloc(sizeof(rm_create_parms), GFP_ATOMIC);
+	rm_create_parms->lucb_list_ptr = sm_create_parms->lucb_list_ptr;
+	rm_create_parms->lu_id = sm_create_parms->lu_id;
+	err = sna_rm_init(rm_create_parms);
+	if(err >= 0)
+	{
+		rm_created = (struct sna_rm_created *)kmalloc(sizeof(rm_created), GFP_ATOMIC);
+		rm_created->lu_id = sm_create_parms->lu_id;
+		sent_to_nof(rm_created); /* OhOh troubles abrew */
+	}
+	else
+		sna_sm_abend();
+
+	err = bm(CREATE_BUF_POOL, permanent, MAX_RU, 5);
+	if(err < 0)
+		sna_sm_abend();
+
+	/* Runtime stuff... should be here */
+	while(SM_exists)	/* This will not loop, but be always called */
+	{
+		local->sense = 0x00000000;
+		switch(data_from)
+		{
+			case (RM):
+				sna_process_record_from_rm(rm_to_sm_record);
+				break;
+
+			case (HS):
+				sna_process_record_from_hs(hs_to_sm_record);
+				break;
+
+			case (ASM):
+				sna_process_record_from_asm(asm_to_sm_record);
+				break;
+
+			case (SS):
+				sna_process_record_from_ss(ss_to_sm_record);
+				break;
+
+			default:
+				printk("Hmm, Hmm, Cookies!\n");
+				toss_record();
+		}
+	}
+
+	return (0);
+}
+
+/* Route records received from RM to appropriate procedures. */
+static int sna_process_record_from_rm(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (ACTIVATE_SESSION):
+			sna_process_activate_session(activate_session);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_process_deactivation_session(deactivate_session);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Route records received from the half-session (HS) process to the
+ * appropriate procedures.
+ */
+static int sna_process_record_from_hs(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (INIT_HS_RSP):
+			sna_process_init_hs_rsp(init_hs_rsp);
+			break;
+
+		case (ABORT_HS):
+			sna_process_abort_hs(abort_hs);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Determine if there is a state error on receipt of a BIND. */
+static int sna_bind_rq_state_err(struct sna_mu *mu)
+{
+	struct sna_parnter_lu *plu;
+	struct sna_mode *mode;
+	struct sna_bind_ru *bind_ru;
+	struct sna_lucb *lucb;
+	struct sna_local *local;
+
+	plu = search_plu(mu->plu_name);
+	if(plu != NULL)
+	{
+		local->sense = (0x0835 | offset_to_plu_name);
+		return (TRUE);
+	}
+
+	if(plu->lu_name != lucb->lu_name)
+	{
+		local->sense = 0x083B0001;
+		return (TRUE);
+	}
+
+	if(lucb->security_select != plu->security_select)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	mode = search_mode(mu->mode_name);
+	if(mode == NULL)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(plu->parallel != TRUE && mode->min_conwinners == 1)
+		local->session_type = FIRST_SPEAKER;
+	else /* Use value in bind */
+	{
+		if(mu->first_speaker == TRUE)
+			local->session_type = FIRST_SPEAKER;
+		else
+			local->session_type = BIDDER;
+	}
+
+	limit = sna_bind_session_limit_exceeded(plu->fqlu_name, mode, local->session_type);
+	if(limit == EXCEEDED)
+		return (TRUE);
+
+	if(plu->parallel != TRUE && another_pending_req() == TRUE)
+	{
+		/* Bind winner is the one with the longer LU name ;) */
+	}
+
+	/*
+	 * Consistency checks on PS usage fields
+	 */
+
+	err = check_sync_levels(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_parallel_level(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_cnos();
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_conv_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	err = check_verif_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(mu->bind.conv_secure == FALSE && mu->bind.alverified == TRUE)
+	{
+		local->sense = 0x0835001A;
+		return (TRUE);
+	}
+
+	if(mu->bind.crypto == TRUE && mu->bind.cryptopts == NULL)
+	{
+		local->sense = 0x08480000;
+		return (TRUE);
+	}
+
+	/*
+	 * One whole If-Else pair here
+	 */
+
+	err = check_session_id();
+	if(err < 0)
+	{
+		local->sense = 0x08520001;
+		return (TRUE);
+	}
+
+	if(plu->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->seg_reassm != TRUE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002B;
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/* Perform state error checking on a received +RSP(BIND). */
+static int sna_bind_rsp_state_err(struct sna_mu *mu, struct sna_lu_lu_cb *lulucb)
+{
+	struct sna_local *local;
+	struct sna_partner_lu *plu;
+	struct sna_bind_ru *bind_ru;
+	struct sna_mode *mode;
+
+	/* Pacing and Max. RU size checks */
+	if(bind->pace != rsp->pace)
+	{
+		local->sense = 0x08350008 or 0x0835000C;
+		return (TRUE);
+	}
+
+	if(rsp->adaptive_pace != TRUE)
+	{
+		if(rsp->second.send_window != bind->second.send_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		/* 0 is infinately large */
+		if(rsp->second.recv_window > bind->second.recv_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		if(rsp->primary.send_window > bind->primary.send_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+
+		if(rsp->primary.recv_window != bind->primary.recv_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+	}
+
+	/* Determine if within bounds for send/recv wins */
+	err = check_ru_bounds();
+	if(err < 0)
+	{
+		if(secondary_out_bounds)
+			local->sense = 0x0835000A;
+		else
+			local->sense = 0x0835000B;
+
+		return (TRUE);
+	}
+
+	/* PS usage checks */
+	if(other_active_sessions(plu) && conv_security != plu->conv_security)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && alrdy_verified != plu->alrdy_verified)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && sync != plu->sync)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+	else
+	{
+		if(rsp->sync == (CONFIRM|SYNCPOINT|BACKOUT)
+			&& bind->sync == (CONFIRM))
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel != TRUE)
+	{
+		if(rsp->sess_reinit == NONOPCTRL
+			&& bind->sess_reinit == OPCTRL)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == SECONDARY
+			&& bind->sess_reinit == PRIMARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == PRIMARY
+			&& bind->sess_reinit == SECONDARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel_opts != bind->parallel_opts
+		&& rsp->chg_sess != bind->chg_sess)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+
+	/* Contention winner checks */
+	if(rsp->parallel == TRUE)
+	{
+		if(rsp->contention_winner != bind->contention_winner)
+		{
+			local->sense = 0x08035007;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(rsp->contention_winner == PRIMARY
+			&& bind->contention_winner == SECONDARY)
+		{
+			local->sense = 0x08350007;
+			return (TRUE);
+		}
+	}
+
+
+	if(rsp->contention_winner == PRIMARY)
+		local->session_type = FIRST_SPEAKER;
+	else
+		local->session_type = BIDDER;
+
+	limit = sna_mode_session_limit_exceeded(plu->fqlu_name, mode, local->session_type, active);
+	if(limit == EXCEEDED)
+	{
+		return(TRUE);
+	}
+
+	/* Crypto checks */
+	if(rsp->cryptopts != bind->cryptopts)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	/* User data subfield checks */
+	if(rsp->mode_name != bind->mode->name)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(lulu_cb->random != NULL)
+	{
+		if(rsp->security == NULL || is_incorrect)
+		{
+			local->sense = 0x080F6051;
+			return (TRUE);
+		}
+	}
+
+	/* User data subfield - session_id checks */
+	if(rsp->session_id != 0x02)
+	{
+		if(rsp->session_id != 0x00 || rsp->session_id != 0xF0
+			|| rsp->session_id != bind->session_id)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(plu->fq_pcid != TRUE)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->session_id != NULL)
+	{
+		if(rsp->sessiond_id == 0x02)
+			lulu_cb->session_id = fq_pcid->pcid;
+		else
+			lulu_cb->session_id = rsp->session_id;
+
+		if(sna_id_unique(SESSION, lulu_cb->session_id) < 0)
+		{
+			local->sense = 0x8520001;
+			return (TRUE);
+		}
+	}
+
+	/* URC Checks */
+	if(rsp->urc != bind->urc)
+		return (TRUE);
+
+	return (FALSE);
+}
+
+/* Betermine whether or not session limits are exceeded for a received BIND. */
+static int sna_bind_session_limit_exceeded(unsigned char *plu_fqlu_name, 
+	struct sna_mode *mode, int type)
+{
+	struct sna_local *local;
+
+	if(mode->cnos_negotiation_in_progress == TRUE
+		&& prop_slimit > curr_slimit)
+	{
+		if(mode->active.sessions ? proposed.slimit)
+		{
+			local->sense = 0x08050000;
+			return (TRUE);
+		}
+		else
+		{
+			if((mode->active.sessions + mode->pending.sessions)
+				? proposed.slimit)
+			{
+				local->sense = 0x08050000;
+				return (TRUE);
+			}
+		}
+	}
+	else
+	{
+		limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, ACTIVE);
+		if(limit == EXCEEDED)
+		{
+			local->rcode = TRUE;
+		}
+		else
+		{
+			limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, AT_LEAST_BIND_SENT);
+			if(limit == EXCEEDED)
+				local->check_winner_flag = TRUE;
+		}
+	}
+
+	/* Check for BIND race conditions */
+	if(local->check_winner_flag == TRUE)
+	{
+		/* Fake for now */
+		if(session->lu_name > plu_fq_lu_name)
+			local->rcode = TRUE;
+		else
+		{
+			local->sense = 0x00000000;
+			local->rcode = FALSE;
+		}
+	}
+
+	return (local->rcode);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (negative) to RM. */
+static int sna_build_and_send_act_sess_rsp_neg(__u8 correlator, int err)
+{
+	struct sna_activate_session_rsp *act_rsp;
+
+	act_rsp = (struct sna_activate_session_rsp *)kmalloc(sizeof(act_rsp), GFP_ATOMIC);
+	act_rsp->correlator = correlator;
+	act_rsp->type = NEG;
+	act_rsp->err_type = err;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (positive) to RM. This completes
+ * (from the SM's standpoint) the session initiation activity triggered by
+ * the ACTIVATE_SESSION record received by SM from RM.
+ */
+static int sna_build_and_send_act_sess_rsp_pos(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_actiavte_session_rsp *act_rsp;
+
+	act_rsp = (struct sna_activate_session_rsp *)kmalloc(sizeof(struct sna_activate_session_rsp), GFP_ATOMIC);
+	act_rsp->correlator = lulu_cb->correlator;
+	act_rsp->type = POS;
+
+	act_rsp->session_information.hs_id = lulu_cb->hs_id;
+	act_rsp->session_information.hs_type = PRI;
+	act_rsp->session_information.bracket_type = lulu_cb->session_type;
+
+	act_rsp->session_information.send_ru_size = neg_max_send_ru_size;
+	act_rsp->session_information.perm_buf_pool_id = perm_buf_pool_id;
+	act_rsp->session_information.limit_buf_pool_id = limit_buf_pool_id;
+
+	act_rsp->session_informtaion.session_id = lulu_cb->session_id;
+
+	act_rsp->session_information.random_data = lulu_cb->random_data;
+	act_rsp->session_information.limit_resource = lulu_cb->limit_resource;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send a -RSP(BIND). */
+static int sna_build_and_send_bind_rsp_neg(unsigned char *buf)
+{
+	struct sna_mu *mu;
+
+	mu->header_type = BIND_RSP_SEND;
+	mu->bind_rsp_send.sender.id = lu_id;
+	mu->bind_rsp_send.sener.type = SM;
+	mu->bind_rsp_send.lfsid = bind->lfsid;
+	mu->bind_rsp_send.pc_id = bind->pc_id;
+	mu->bind_rsp_send.tx_priority = LOW;
+	mu->bind_rsp_send.free_lfsid = YES;
+	mu->bind_rsp_send.hs_id = NULL;
+
+	/* Set TH and RH fields to default 3.5.9 SNA formats */
+
+	/* Set RU */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a FREE_LFSID record to the control point. This is
+ * necessary when SM asked ASM to give SM an LFSID for a session, and SM
+ * received ASSIGN_LFSID_RSP, but could not send a BIND (because, for
+ * example, SM cannot get a buffer for it). In this case, SM explicity asks
+ * ASM to free the LFSID by sending the FREE_LFSID record to it. If SM sends
+ * a BIND successfully, it later sends an UNBIND or a RSP(UNBIND) to ASM
+ * and sets the FREE_LFSID variable to YES in them.
+ */
+static int sna_build_and_send_free_lfsid(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_free_lfsid *free_lfsid;
+
+	free_lfsid = (struct sna_free_lfsid *)kmalloc(sizeof (sna_free_lfsid), GFP_ATOMIC);
+	free_lfsid->pc_id = lulu_cb->pc_id;
+	free_lfsid->lfsid = lulu_cb->lfsid;
+
+	send_to_asm(free_lfsid);
+
+	return (0);
+}
+
+/* Build an INIT_HS (Initialize Half-Session) record and send it to the
+ * half-session designated by the passed LULU_CB.
+ */
+static int sna_build_and_send_init_hs(struct sna_lulu_cb *lulu_cb, 
+	unsigned char *bind_image)
+{
+	struct sna_local *local;
+	struct sna_init_hs *init_hs;
+
+	init_hs = (struct sna_init_hs *)kmalloc(sizeof(struct sna_init_hs), GFP_ATOMIC);
+	init_hs->pc_id	= lulu_cb->pc_id;
+	init_hs->lfsid			= lulu_cb->lfsid;
+	init_hs->hs_type		= lulu_cb->hs_type;
+	init_hs->dynamic_pool_id	= lulu_cb->dynamic_pool_id;
+	init_hs->dem_lim_pool_id	= lulu_cb->dem_lim_pool_id;
+	init_hs->tx_priority		= lulu_cb->tx_priority;
+	init_hs->short_bind_image	= bind_image;
+
+	if(lulu_cb->adaptive_pace == TRUE)
+	{
+		init_hs->short_bind_image.sec_send_window_size 	= 1;
+		init_hs->short_bind_image.pri_send_window_size 	= 1;
+		init_hs->short_bind_image.sec_rcv_window_size	= 1;
+		init_hs->short_bind_image.pri_rcv_window_size	= 1;
+	}
+
+	err = send_to_hs(init_hs);
+	if(err == ABEND)
+	{
+		destroy(init_hs);
+		local->sense = 0x0812000D;
+	}
+
+	return (0);
+}
+
+/* Build and send a PC_HS_DISCONNECT record to ASM. This is done only after
+ * a PLU receives a -RSP(BIND). If, instead, SM receives an UNBIND, it sends
+ * a RSP(UNBIND), asking ASM to free LFSID, thus disconnecting PC and HS.
+ */
+static int sna_build_and_send_pc_hs_disconnect(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->cmd 	= SNA_PC_HS_DISCONNECT;
+	msg->pc_id	= lulu_cb->pc_id;
+	msg->lfsid	= lulu_cb->lfsid;
+
+	sna_asm(msg);
+
+	return (0);
+}
+
+/* Build and send SESSION_ACTIVATED to RM to indicate that a new session
+ * has become active and to give RM the information about this session.
+ */
+static int sna_build_and_send_sess_activated(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_session_activated *activated;
+
+	activated = (struct sna_session_activated *)kmalloc(sizeof(struct sna_session_activated), GFP_ATOMIC);
+
+	activated->session_information.hs_id = lulu_cb->hs_id;
+	activated->session_information.hs_type = SEC;
+	activated->session_information.bracket_type = lulu_cb->session_type;
+
+	activated->session_information.send_ru_size = neg_max_send_ru_size;
+	activated->session_information.perm_buf_pool_id = lulu_cb->perm_pool_id;
+	actiavted->session_information.limit_buf_pool_id = lulu_cb->dem_lim_pool_id;
+	activated->session_information.session_id = lulu_cb->session_id;
+
+	/* Send to RM for FMH-12 info */
+
+	activated->session_information.random_data = lulu_cb->random;
+	activated->lu_name = lulu_cb->local_partner_lu_name;
+	activated->mode_name = lulu_cb->mode_name;
+	activated->session_information.limit_resource = lulu_cb->limit_resource;
+
+	err = send_to_rm(activated);
+	if(err < 0)
+		destroy(activated);
+
+	return (0);
+}
+
+/* Build and send SESSION_DEACTIVATED to RM to indicate that an active session
+ * has been deactivated.
+ */
+static int sna_build_and_send_sess_deactivated(__u8 hs_id, __u8 reason, 
+	__u8 sense)
+{
+	struct sna_session_deactivated *deactivated;
+
+	deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(struct sna_session_deactivated), GFP_ATOMIC);
+	deactivated->hs_id 	= hs_id;
+	deactivated->reason 	= reason;
+	if(reason != NORMAL)
+		deactivated->sense = sense;
+
+	err = send_to_rm(deactivated);
+	if(err < 0)
+		destroy(deactivated);
+
+	return (0);
+}
+
+/* Build and send a SESSEND_SIGNAL record to the control point. This record
+ * can be sent by both PLU and SLU when the session is brought down. The PLU
+ * sends it, however, only if it has previously received a CINIT_SIGNAL
+ * record. The SLU sends it only if it has already sent a SESSST_SIGNAL
+ * record to SS.
+ */
+static int sna_build_and_send_sessend_sig(struct sna_lulu_cb *lulu_cb, 
+	__u8 sense)
+{
+	struct sna_sessend_signal *sessend_signal;
+
+	sessend_signal = (struct sna_sessend_signal *)kmalloc(sizeof(struct sna_sessend_signal), GFP_ATOMIC);
+
+	sessend_signal->sense = sense;
+	sessend_signal->fqpcid = lulu_cb->fqpcid;
+	sessend_signal->pc_id = lulu_cb->pc_id;
+
+	send_to_ss(sessend_signal);
+
+	return (0);
+}
+
+/* Build and send a SESSST_SIGNAL record to the control point. This record is
+ * sent by the SLU when it receives the INIT_HS_RSP record from the half-session
+ * process. The PLU does not need to send it, since its local SS sends a
+ * CINIT_SIGNAL to SM and assumes that the session will be activated.
+ */
+static int sna_build_and_send_sessst_sig(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_sessst_signal *sessst_signal;
+
+	sessst_signal = (struct sna_sessst_signal *)kmalloc(sizeof(struct sna_sessst_signal), GFP_ATOMIC);
+
+	sessst_signal->pc_id = lulu_cd->pc_id;
+
+	send_to_ss(sessst_signal);
+
+	return (0);
+}
+
+/* Build and send an UNBIND. */
+static int sna_build_and_send_unbind_rq(unsigned char *buf, __u8 cleanup, 
+	__u8 sense)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	mu->header_type = UNBIND_RQ_SEND;
+	mu->unbind_rq_send.sender.id = local->lu_id;
+	mu->unbind_rq_send.sender.type = SM;
+	mu->unbind_rq_send.lfsid = lulu_cb->lfsid;
+	mu->unbind_rq_send.pc_id = lulu_cd->pc_id;
+	mu->unbind_rq_send.tx_priority = lulu_cd->tx_priority;
+	mu->unbind_rq_send.free_lfsid = YES;
+	mu->unbind_rq_send.hs_id = lulu_cd->hs_id;
+
+	/* Set TH and RH fields to default */
+
+	/* Set RU of unbind mu to defaults, using sense and type passed */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a RSP(UNBIND). */
+static int sna_build_and_send_unbind_rsp(struct sna_mu *mu)
+{
+	struct sna_lu_lu_cb *lulu_cb
+	struct sna_mu *mu_new;
+	int unbind_type;
+
+	if(determine_how_unbind_was_recieved() == EXR || length_err)
+		unbind_type = NEG;
+	else
+		unbind_type = POS;
+
+	mu_new = bm(GET_BUFFER, demand, size, no_wait);
+	if(mu != NULL)
+	{
+		mu_new->header_type = UNBIND_RSP_SEND;
+		mu_new->unbind_rsp_send.lu_id = lulu_cb->lu_id;
+		mu_new->unbind_rsp_send.sender.type = SM;
+
+		if(unbind correlated to a specific session)
+		{
+			mu_new->unbind_rsp_send.hs_id = lulu_cb->hs_id;
+			mu_new->unbind_rsp_send.tx_priority = lulu_cb->tx_priority;
+		}
+		else
+		{
+			mu_new->unbind_rsp_send.hs_id = NULL;
+			mu_new->unbind_rsp_send.tx_priority = LOW;
+		}
+
+		mu_new->unbind_rsp_send.free_lfsid = YES;
+		mu_new->pc_id = mu->pc_id;
+		mu_new->lfsid = mu->lfsid;
+		mu_new->th.snf = mu->th.snf;
+
+		/* Set TH and RH to defaults */
+
+		if(type == POS)
+			mu_new->ru.type = POS;
+		else
+			mu_new->ru.type = NEG;
+
+		mu->dcf = (RH->size + RU->size);
+
+		send_to_asm(mu);
+	}
+	else
+		/* IBM.. Duh do nothing */
+
+	return (0);
+}
+
+/* Clean up LU-LU session. */
+static int sna_cleanup_lu_lu_session(struct sna_lu_lu_cb *lulu_cb)
+{
+	if(sesst_signal was sent || cinit_signal was recieved)
+		sna_build_and_send_sessend_sig(lulu_cb);
+
+	sna_unreserve_buffers(lulu_cb);
+	hs = sna_hs_unlink(lulu_cb->hs_id);
+	sna_hs_destroy(hs);
+
+	random = sna_random_unlink(lulu_cb->random);
+	sna_random_destroy(random);
+
+	lulu_cb = sna_lulu_cb_unlink(lulu_cb);
+	sna_lulu_cb_destroy(lulu_cb);
+
+	return (0);
+}
+
+/* Check if the received RSP(BIND) correlates with a previously sent BIND. */
+static int sna_correlate_bind_rsp(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Check if the received RSP(UNBIND) correlates with a know session. */
+static int sna_correlate_unbind_rq(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of receiving a BIND.
+ */
+static int init_lulu_cd_bind(struct sna_mu *mu, struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_partner_lu *plu;
+	struct sna_local *local;
+
+	plu = search_plu(mu->bind_ru.plu_name);
+	lulu_cb->local_partner_lu_name = plu->local_lu_name;
+	lulu_cb->fq_partner_lu_name = local->user_data.pluname.name;
+	lulu_cb->mode_name = mu->bind_ru.mode_name;
+	lulu_cb->hs_type = SEC;
+
+	if(plu->parallel != TRUE && mode->min_conwinners_limit == 1)
+		lulu_cb->session_type = FIRST_SPEAKER;
+	else
+	{
+		if(bind->secondary == CONWINNER)
+			lulu_cb->session_type = FIRST_SPEAKER;
+		else
+			lulu_cb->session_type = BIDDER;
+	}
+
+	lulu_cb->pc_id = mu->bind_ru.pc_id;
+	lulu_cb->pc_characteristics = mu->bind_ru.pc_characteristics;
+	lulu_cb->lfsid = mu->bind_ru.lfsid;
+
+	if(mu->bind_ru.cos != NULL)
+		lulu_cb->tx_priority = mu->bind_ru.cos.tx_priority;
+
+	if(mu->bind_ru.fqpcid != NULL)
+		lulu_cb->fqpcid = mu->bind_ru.fqpcid;
+	else
+		lulu_cb->fqpcid = sna_get_fqpcid(lulu_cb);
+
+	return (0);
+}
+
+/* Process an abend notification record from a child process (RM or HS). */
+static int sna_process_abend_notification(struct sna_abend_notification *abend)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	switch(abend->abend_process)
+	{
+		case (RM_PROCESS_VARIABLE):
+			for(lu = local->lulu_cb_list; lu != NULL; lu = lu->next)
+			{
+				fsm_status(abend, lulu_cb);
+			}
+			break;
+
+		case (HS_PROCESS_VARIABLE):
+			lu = search_lulu_cb(abend->hs_id);
+			if(lu != NULL)
+				fsm_status(abend, lulu_cb);
+			break;
+
+		default:
+			printk("Idiot\n");
+	}
+
+	return (0);
+}
+
+/* Process an ABORT_HS record received from LU-LU half-session. */
+static int sna_process_abort_hs(struct sna_abort_hs *abort_hs)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(local->hs_id);
+	if(lulu_cb != NULL)
+		fsm_status(abort_hs, lulu_cb);
+
+	return (0);
+}
+
+/* Process a DEACTIVATION_SESSION record received from RM. */
+static int sna_process_deactivation_session(struct sna_deactivate_session *deactivate)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	if(deactivate->status == PENDING)
+		lulu_cb = search_lulu_cb(deactivate->correlator);
+	else
+		lulu_cb = search_lulu_cb(deactivate->hs_id);
+
+	if(lulu_cb)
+		fsm_status(deactivate, lulu_cb);
+
+	return (0);
+}
+
+/* Process an INIT_HS_RSP record received from a half-session. */
+static int sna_process_init_hs_rsp(struct sna_init_hs_rsp *init_hs_rsp)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(init_hs_rsp->hs_id);
+	if(lulu_cb)
+		fsm_status(init_hs_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received INIT_SIGNAL_NEG_RSP record from the SS component of
+ * the control point.
+ */
+static int sna_process_init_signal_neg_rsp(struct sna_init_signal_neg_rsp *init_signal_neg_rsp)
+{
+	struct sna_init_signal *init_signal;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	init_signal = search_init_signal(init_signal_neg_rsp);
+	lulu_cb = search_lulu_cb(init_signal_neg_rsp->fqpcid);
+
+	if(init_signal && lulu_cb)
+		fsm_status(init_signal_neg_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received LFSID_IN_USE record. This record is sent to SM by ASM
+ * so that ASM will know whether a given (LFSID, PC_ID) pair is
+ * currently in use. ASM must know before it sends a BIND to an appropriate
+ * LU. If the pair is in use, ASM will hold the BIND in order to avoid
+ * certain race conditions.
+ */
+static int sna_process_lfsid_in_use(struct sna_lfsid_in_use *lfsid_in_use)
+{
+	struct sna_lfsid_in_use_rsp *lfsid_in_use_rsp;
+
+	/* find activate or pending session ?? */
+	
+
+	lfsid_in_use_rsp = (struct sna_lfsid_in_use_rsp *)kmalloc(sizeof(lfsid_in_use_rsp), GFP_ATOMIC);
+
+	lfsid_in_use_rsp->pc_id = lfsid_in_use->pc_id;
+	lfsid_in_use_rsp->lfsid = lfsid_in_use->lfsid;
+
+	if(sna_find_session(PEND_ACTIVE, lfsid, pc_id))
+		lfsid_in_use_rsp->answer = YES;
+	else
+		lfsid_in_use_rsp->answer = NO;
+
+	send_to_asm(lfsid_in_use_rsp);
+
+	return (0);
+}
+
+/* Process a SESSION_ROUTE_INOP record received from ASM. */
+static int sna_process_session_route_inop(struct sna_session_route_inop *inop)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	for(lulu_cb = lulu_cb_list; lulu_cb != NULL; lulu_cb = lulu_cb->next)
+	{
+		if(inop->pc_id != lulu_cb->pc_id)
+			continue;
+
+		fsm_status(inop, lulu_cb);
+	}
+
+	return (0);
+}
+
+/* Increment the size of the permanent buffer pool. Get a demand buffer for
+ * an UNBIND.
+ */
+static int sna_reserve_constant_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_local *local;
+
+	err = bm(ADJUST_BUF_POOL, lulu_cb->perm_buf_pool_id, 1);
+
+	if(more_buffs_avail())
+	{
+		lulu_cb->perm_pool_adjusted_up = YES;
+		bm(GET_BUFFER, demand, size, no_wait);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Reserve a dynamic buffer pool, and a limited buffer pool. */
+static int sna_reserve_variable_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+
+	if(bind_rsp_rcv->adaptive_pace == SUPPORTED)
+	{
+		err = bm(CREATE_BUF_POOL, vary_dynamic, lulu_cb->hs_id, capacity, size, num_bufs);
+		if(err > 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size, num_bufs);
+	}
+	else
+	{
+		err = bm(CREATE_BUF_POOL, fixed_dynamic, lulu_cb->hs_id, capacity, size);
+		if(err < 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Unreserve (ie. release previously reserved buffers) appropriate buffers
+ * for the session.
+ */
+static int sna_unreserve_buffers(struct sna_lu_lu_cb *lulu_cb, 
+	__u8 perm_buf_pool_id)
+{
+	int size;
+
+	size = size_of_perm_buf - activted_pool_size;
+
+	if(size)
+		bm(ADJUST_BUF_POOL, perm_buf_pool_id, size);
+
+	if(demand_buf_reserverd_unbind)
+		bm(FREE, unbind);
+
+	return (0);
+}
+
+static int sna_fsm_status()
+{
+
+	/* Finite State Machines are Pass 3 so hold on here */
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.13/net/sna/sna_ss.c linux/net/sna/sna_ss.c
--- linux-2.4.13/net/sna/sna_ss.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ss.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,528 @@
+/* sna_ss.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_ss_pinfo *ss_clients = NULL;
+
+int sna_ss_insert(struct sna_ss_pinfo *ss)
+{
+        sna_debug(10, "sna_ss_insert\n");
+        ss->next = ss_clients;
+        ss_clients = ss;
+
+        return (0);
+}
+
+struct sna_ss_pinfo *sna_ss_find(char *name)
+{
+        struct sna_ss_pinfo *f;
+
+        sna_debug(5, "sna_ss_find\n");
+        for(f = ss_clients; f != NULL; f = f->next)
+                if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                        break;
+	return (f);
+}
+
+int sna_ss_shutdown(void)
+{
+        struct sna_ss_pinfo *d;
+        struct sna_ss_pinfo **clients = &ss_clients;
+        unsigned long flags;
+
+        sna_debug(5, "sna_ss_shutdown\n");
+        save_flags(flags);
+        cli();
+
+        while((d = *clients) != NULL)
+        {
+                *clients = d->next;
+                kfree(d);
+        }
+
+        restore_flags(flags);
+
+        return (0);
+}
+
+int sna_ss_create(struct sna_start_node *start)
+{
+	struct sna_ss_pinfo *ss;
+
+	sna_debug(5, "sna_ss_create %s\n", start->netid.name);
+	ss = sna_ss_find(start->netid.name);
+	if(ss)
+		return (-EEXIST);
+	ss=(struct sna_ss_pinfo*)kmalloc(sizeof(struct sna_ss_pinfo),
+		GFP_ATOMIC);
+	memcpy(&ss->netid, &start->netid, sizeof(struct sna_netid));
+	ss->next = NULL;
+	ss->prev = NULL;
+
+        sna_ss_insert(ss);
+	return (0);
+}
+
+int sna_ss_destroy(struct sna_delete_node *delete)
+{
+        struct sna_ss_pinfo *ss, **clients = &ss_clients;
+
+        sna_debug(5, "sna_ss_destroy\n");
+        while((ss = *clients) != NULL)
+        {
+                if(!strncmp(ss->netid.name, delete->netid.name, 8))
+                {
+                        *clients = ss->next;
+                        kfree(ss);
+                        return (0);
+                }
+                clients = &ss->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_ss_act_cp_cp_session(void)
+{
+
+	return (0);
+}
+
+int sna_ss_deact_cp_cp_session(void)
+{
+
+	return (0);
+}
+
+int sna_ss_act_control_sessions(void)
+{
+
+	return (0);
+}
+
+int sna_ss_deact_control_sessions(void)
+{
+
+	return (0);
+}
+
+int sna_ss_update_node_authorization(void)
+{
+
+	return (0);
+}
+
+int sna_ss_update_search_control_vectors(void)
+{
+
+	return (0);
+}
+
+int sna_ss_process_sesst_signal(void)
+{
+
+	return (0);
+}
+
+int sna_ss_process_sessend_signal(void)
+{
+
+	return (0);
+}
+
+int sna_ss_isr_init(void)
+{
+
+	return (0);
+}
+
+int sna_ss_isr_sessend(void)
+{
+
+	return (0);
+}
+
+static __u32 sna_pc_system_id  = 1;
+static unsigned long hash1, hash2;
+
+/*
+  Returns a string of 0 and 1 characters, representing the provided 64bit
+  number in binary.
+*/
+void
+rl_binary(unsigned char * number, unsigned char * result)
+{
+  int curbyte;
+  int resultidx;
+  unsigned char curbit;
+
+  resultidx = 63;
+  result[64] = '\0';
+
+  for(curbyte=0; curbyte < 8; curbyte++)
+    {
+      for(curbit = 0; curbit < 8; curbit++)
+        {
+          result[resultidx] = (number[curbyte] & (1<<curbit)) ? '1' : '0';
+          resultidx--;
+        }
+    }
+}
+
+
+/*
+  Subtracts two 64bit numbers.  The top value must be >= the bottom.
+ */
+void
+rl_sub(unsigned char * top, unsigned char * bottom)
+{
+  unsigned int curbyte;
+  int borrowed;
+  int curtop;
+
+  if(top[7] < bottom[7])
+    {
+      return;
+    }
+
+  borrowed = 0;
+
+  for(curbyte = 0; curbyte < 8; curbyte++)
+    {
+      curtop = top[curbyte];
+
+      if(borrowed)
+        {
+          if(curtop == 0)
+            {
+              curtop = 0xFF;
+              borrowed = 1;
+            } else {
+              curtop = curtop--;
+              borrowed = 0;
+            }
+        }
+
+      if(curtop < bottom[curbyte])
+        {
+          curtop = curtop + 0x100;
+          borrowed = 1;
+        }
+      curtop = curtop - bottom[curbyte];
+      top[curbyte] = curtop;
+    }
+}
+
+/*
+  Shifts the 64bit number one byte to the left.  Zero is inserted in the lsb.
+*/
+int rl_left(unsigned char * number)
+{
+        int carry;
+        unsigned char mask;
+        int curbyte;
+
+        if(number[7] & 0x80)
+                carry = 1;
+        else
+                carry = 0;
+
+        for(curbyte = 7; curbyte >= 0; curbyte--)
+        {
+                if(curbyte > 0)
+                {
+                        mask = (number[curbyte-1] & 0x80) ? 0x01 : 0x00;
+                        number[curbyte] = (number[curbyte] << 1) | mask;
+                }
+                else
+                        number[curbyte] <<= 1;
+        }
+
+        return(carry);
+}
+
+/*
+  Shifts the 64bit number one bit to the right.  Zero is inserted as the msb
+ */
+void
+rl_right(unsigned char * number)
+{
+  unsigned char mask;
+  int curbyte;
+
+  for(curbyte = 0; curbyte < 8; curbyte++)
+    {
+      if(curbyte < 7)
+        {
+          mask = (number[curbyte+1] & 0x01) ? 0x80 : 0x00;
+          number[curbyte] = (number[curbyte] >> 1) | mask;
+        } else {
+          number[curbyte] >>= 1;
+        }
+    }
+}
+
+/*
+  Shifts the divisor to the left as necessary to align the most signifcant
+  bit with the msb of the dividend.
+ */
+void
+rl_align(unsigned char * dividend, unsigned char * divisor)
+{
+  int maxbyte;
+  int maxbit;
+
+  for(maxbyte = 7; maxbyte >= 0; maxbyte--)
+    {
+      if(dividend[maxbyte] > 0)
+        break;
+    }
+
+  for(maxbit = 8; maxbit >= 0; maxbit--)
+    {
+      if( dividend[maxbyte] & (1 << maxbit) )
+        {
+          break;
+        }
+    }
+  while( !(divisor[maxbyte] & (1 << maxbit)))
+  {
+    rl_left(divisor);
+  }
+}
+
+/*
+  Returns true if the dividend is greater than or equal to the divisor.
+ */
+int
+rl_lt(unsigned char * dividend, unsigned char * divisor)
+{
+  int maxbyte;
+  int curbyte;
+
+  for(maxbyte = 7; maxbyte > 0; maxbyte--)
+    {
+      if( (dividend[maxbyte] != 0) || (divisor[maxbyte] != 0) )
+        {
+          break;
+        }
+    }
+
+  for(curbyte = maxbyte; curbyte > 0; curbyte--)
+    {
+      if(dividend[curbyte] == divisor[curbyte])
+        {
+          continue;
+        } else {
+          return(dividend[curbyte] >= divisor[curbyte]);
+        }
+    }
+  return(0);
+}
+
+/*
+  Divides two 64 bit numbers.  The numbers need to be passed as 8 element
+  arrays of unsigned char.  The quotient is returned in quotient, and the
+  remainder is returned in dividend.  The divisor is shifted during the
+  division, so don't count on it having the same value after invocation.
+ */
+void rl_div(unsigned char * dividend, unsigned char * divisor,
+       unsigned char * quotient)
+{
+  unsigned char tempdiv[8];
+  int curbyte;
+
+  memset(quotient, 0, 8);
+
+  for(curbyte=0; curbyte < 8; curbyte++)
+    {
+      tempdiv[curbyte] = divisor[curbyte];
+    }
+
+  rl_align(dividend, divisor);
+
+  do {
+
+    if( rl_lt(dividend, divisor) )
+      {
+        rl_sub(dividend, divisor);
+        rl_left(quotient);
+        quotient[0] = quotient[0] | 0x01;
+      } else {
+        rl_left(quotient);
+      }
+    rl_right(divisor);
+
+  } while(rl_lt(dividend, tempdiv));
+}
+
+/* Generates a FQPCID in the and returns it in the correct order. */
+int sna_ss_generate_pcid(char *net, char *name)
+{
+        unsigned char prime1[8] = {0xC7,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00};
+        unsigned char prime2[8] = {0x1F,0x88,0x53,0x7E,0x00,0x00,0x00,0x00};
+        unsigned char pname[8], pnet[8], fname[8], fnet[8];
+        unsigned char quotient[8], dividend[8], dividend2[8];
+        unsigned long scratch1;
+        struct timeval time;
+        int i;
+
+        /* Dividend */
+        atoe_strncpy(pname, name, strlen(name));
+        for(i = strlen(name); i < 8; i++)
+                pname[i] = 0x40;
+        for(i = 0; i < 8; i++)          /* reverse order */
+                fname[i] = pname[7-i];
+        atoe_strncpy(pnet, net, strlen(net));
+        for(i = strlen(net); i < 8; i++)
+                pnet[i] = 0x40;
+        etor_strncpy(pnet, pnet, 8);
+        for(i = 0; i < 8; i++)          /* reverse order */
+                fnet[i] = pnet[7-i];
+        for(i = 0; i < 8; i++)
+                dividend[i] = fname[i] ^ fnet[i];
+        memcpy(dividend2, dividend, 8);
+
+        /* Hash 1 */
+        rl_div(dividend2, prime1, quotient);
+        memcpy(&hash1, dividend2, sizeof(unsigned long));
+        scratch1 = (hash1 ^ (unsigned short)hash1) << 2;
+        set_bit(16, &scratch1);
+        set_bit(17, &scratch1);
+        set_bit(30, &scratch1);
+        set_bit(31, &scratch1);
+        hash1 = (scratch1 | (unsigned short)hash1);
+        hash1 += htonl(sna_pc_system_id++);
+
+        sna_debug(5, "HASH1 - %04lX\n", hash1);
+
+        /* Hash 2 */
+        memcpy(dividend2, dividend, 8);
+        rl_div(dividend2, prime2, quotient);
+        memcpy(&hash2, dividend2, sizeof(unsigned long));
+
+        do_gettimeofday(&time);
+        hash2 += time.tv_sec;
+
+        sna_debug(5, "HASH2 - %04lX\n", hash2);
+
+        return (0);
+}
+
+int sna_ss_update_pcid(unsigned char *r)
+{
+        unsigned char result[8], scratch2[8];
+        unsigned long nhash1, nhash2;
+
+        hash2++;
+
+        /* Generate final pcid */
+        memcpy(scratch2, &hash1, 4);
+        memcpy(scratch2 + 4, &hash2, 4);
+        nhash1 = ntohl(hash1);
+        nhash2 = ntohl(hash2);
+        memcpy(result, &nhash1, 4);
+        memcpy(result + 4, &nhash2, 4);
+        strncpy(r, result, 8);
+
+        return (0);
+}
+
+int sna_ss_assign_pcid(struct sna_assign_pcid *pcid)
+{
+//	struct sna_lulu_cb *lulu;
+
+	sna_debug(5, "sna_ss_assign_pcid\n");
+/*
+	lulu = sna_sm_find_lulu(pcid->sm_proc_id);
+	if(!lulu)
+		return (-ENOENT);
+
+	sna_ss_generate_pcid(lulu->netid.net, lulu->netid.name);
+	sna_ss_update_pcid(pcid->fqpcid);
+*/
+	pcid->duplicate_pcid = 0;	/* reset */
+        return (0);
+}
+
+int sna_ss_process_init_signal(struct sna_init_signal *init)
+{
+	struct sna_cos_tpf_vector *cos;
+	struct sna_rq_single_hop_route *rt;
+	struct sna_activate_route *as;
+	struct sna_cinit_signal *cinit;
+	struct sna_netid *netid;	
+	int err = 0;
+
+	sna_debug(5, "sna_ss_process_init_signal %s %s\n",
+		sna_pr_netid(&init->plu_name), sna_pr_netid(&init->slu_name));
+
+	cos = (struct sna_cos_tpf_vector *)kmalloc(sizeof(*cos), GFP_ATOMIC);
+	memcpy(&cos->mode_name, &init->mode_name, SNA_RESOURCE_NAME_LEN);
+	err = sna_cosm_cos_tpf_vector(cos);
+	if(err < 0)
+		return (err);
+
+	rt = (struct sna_rq_single_hop_route *)kmalloc(sizeof(*rt), GFP_ATOMIC);
+	memcpy(&rt->dst_cp_name, &init->plu_name, sizeof(struct sna_netid));
+	err = sna_rss_request_single_hop_route(rt);
+	if(err < 0)
+		return (err);
+
+	as = (struct sna_activate_route *)kmalloc(sizeof(*as), GFP_ATOMIC);
+	as->tg_id = rt->rs.tg_desc.id.tg_number;
+	memcpy(&as->pc_id, &init->fqpcid, 8);
+	netid = sna_char_to_netid(rt->rs.tg_desc.id.pcp_name);
+//	memcpy(&as->cp_name, netid, sizeof(struct sna_netid));
+	memcpy(&as->cp_name, &init->slu_name, sizeof(struct sna_netid));
+	err = sna_cs_activate_route(as);		/* XID */
+	if(err < 0)
+		return (err);
+
+	cinit = (struct sna_cinit_signal *)kmalloc
+		(sizeof(struct sna_cinit_signal), GFP_ATOMIC);
+	err = sna_sm_process_cinit_signal(cinit);	/* BIND */
+	if(err < 0)
+		return (err);
+
+	kfree(cos);
+        kfree(rt);
+        kfree(as);
+	kfree(cinit);
+
+        return (err);
+}
diff -ruN linux-2.4.13/net/sna/sna_tc.c linux/net/sna/sna_tc.c
--- linux-2.4.13/net/sna/sna_tc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_tc.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,913 @@
+/* sna_tc.c: Linux Systems Network Architecture implementation
+ * - SNA Transmission Control (TC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if_ether.h>
+#include <linux/sna.h>
+
+int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	sna_debug(5, "sna_tc_rcv\n");
+	sna_dfc_rcv(skb);
+
+	return (0);
+}
+
+int sna_tc_send_mu(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_tc_send_mu\n");
+
+	kfree_skb(skb);
+
+#ifdef NOT
+	int i;
+
+	if(sna_debug_level > 5)
+	{
+		printk("sna_tc_send_mu\n");
+		hexdump(skb->data, skb->len);
+		printk("Sizeof TH %d, RH %d, FMH %d\n", 
+			sizeof(struct sna_fid2), sizeof(struct snarhdr), 
+			sizeof(struct sna_fmh5)); 
+	}
+
+	skb = skb_unshare(skb, GFP_ATOMIC);
+	if(!skb)
+		return (-1);
+
+	for(i = 0; i < 1000; i++)
+		schedule();
+	sna_tc_rcv(skb);
+#endif
+
+	return (0);
+}
+
+int sna_tc_init(void)
+{
+	return (0);
+}
+
+#if defined(CONFIG_SNA_HS) || defined(CONFIG_SNA_HS_MODULE)
+
+extern __u16 sys_snf_ids;
+
+/* Initialize the Transmission Control layer. */
+int sna_tc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+
+	if(init_hs->type == SNA_HS_PRI)
+		tcb->max_rcv_ru_size 
+			= init_hs->bind.sec_hs_max_ru_size_sent;
+	else
+		tcb->max_rcv_ru_size
+			= init_hs->bind.pri_hs_max_ru_size_sent;
+	tcb->sqn_rcv_cnt = 0;
+
+	tcb->ccb.caller			= SNA_HS;
+	tcb->ccb.lfsid			= init_hs->lfsid;
+	tcb->ccb.pc_id			= init_hs->pc_id;
+	tcb->ccb.perm_buf_pool_id	= init_hs->perm_buf_pool_id;
+	tcb->ccb.dynamic_buf_pool_id	= init_hs->dynamic_buf_pool_id;
+	tcb->ccb.limit_buf_pool_id	= init_hs->limit_buf_pool_id;
+	tcb->ccb.tx_priority 		= init_hs->tx_priority;
+	tcb->ccb.num_bufs_per_ru	= 1;
+	tcb->ccb.send_pacing.rlwi	= SNA_CCB_NO_RLW;
+	tcb->ccb.send_pacing.rpc	= 0;
+	tcb->ccb.receive_pacing.rpc	= 0;
+
+	if(init_hs->type == SNA_HS_PRI)
+	{
+		tcb->ccb.send_pacing.nws	= init_hs->bind.pri_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.pri_rws;
+	}
+	else
+	{
+		tcb->ccb.send_pacing.nws 	= init_hs->bind.sec_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.sec_rws;
+	}
+
+	if(init_hs->bind.adapt_pace == SNA_RU_BIND_ADAPT_NO_SUPP)
+		tcb->ccb.send_pacing.type = SNA_PACING_TYPE_ADAPTIVE;
+	else
+	{
+		tcb->ccb.receive_pacing.type = SNA_PACING_TYPE_FIXED;
+		if(tcb->ccb.send_pacing.nws > 0)
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_FIXED;
+		else
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_NONE;
+	}
+
+	tcb->ccb.send_pacing.first_ws = tcb->ccb.send_pacing.nws;
+	tcb->ccb.receive_pacing.unsolicited_ipm_outstanding	= 0;
+	tcb->ccb.receive_pacing.adjust_ipm_ack_outstanding	= 0;
+	tcb->ccb.receive_pacing.unsolicited_nws 		= 0;
+	tcb->ccb.reserve_flag 					= 0;
+
+	if(init_hs->bind.whole_biu)
+		tcb->segmenting_supported = 0;
+	else
+		tcb->segmenting_supported = 1;
+
+	tcb->crypto = 0;
+	if(init_hs->bind.crypto.sess_level_crypto == SNA_RU_CRYPTO_MANDATORY)
+	{
+		tcb->crypto = 1;
+		sna_tc_exchange_crv(init_hs);
+	}
+
+	return (0);
+}
+
+/* Handle the exchange of the Cryptograhpy Verification (CRV) request. */
+static int sna_tc_exchange_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->pc_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+	struct sna_mu *mu = NULL;
+	int err;
+
+	if(init_hs->type == SNA_HS_PRI)
+	{
+		mu = sna_tc_build_crv(init_hs);
+		local->tcb.ccb.caller = SNA_HS;
+		sna_send_mu(mu, &tcb->ccb);
+
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+
+		err = sna_tc_crv_format_chk(mu);
+		if(err == 0)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		sna_free_buffer(mu);
+	}
+	else
+	{
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+		err = sna_tc_crv_format_chk(mu);
+		if(err == 0)
+		{
+			/* Check the crypto test values. */
+			if(err)
+			{
+				local->sense = 0x08350001;
+				sna_free_buffer(mu);
+			}
+			else
+			{
+				local->sense = 0;
+				mu->biu->rh.rh.rsp_h.rri = SNA_RH_RRI_RSP;
+				mu->biu->rh.rh.rsp_h.rti = SNA_RH_RTI_POS;
+				local->tcb.ccb.caller = SNA_HS;
+				sna_send_mu(mu, &tcb->ccb);
+			}
+		}
+	}
+
+	return (0);
+}
+
+/* Build and MU (containing the CRV request) by appropriately initializing
+ * the TH, RH, and RU fields.
+ */
+static struct sna_mu *sna_tc_build_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_mu *mu = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu = sna_get_buffer(SNA_BM_TYPE_DEMAND, init_hs->dynamic_buf_pool_id, 
+		0, SNA_BM_NO_WAIT);
+
+	mu->biu->th.fid.fid0.efi 		= SNA_TH_EFI_EXP;
+	mu->biu->th.fid.fid0.snf.number 	= *(__u16 *)jiffies;
+	mu->biu->th.fid.fid0.mpf		= SNA_TH_MPF_WHOLE_BIU;
+
+	req_h->rri	= SNA_RH_RRI_REQ;
+	req_h->ru	= SNA_RH_RU_SC;
+	req_h->fi	= SNA_RH_FI_FMH;
+	req_h->sdi	= SNA_RH_SDI_NO_SD;
+	req_h->bci	= SNA_RH_BCI_BC;
+	req_h->eci	= SNA_RH_ECI_EC;
+	SNA_DFC_SET_RQD1(req_h);
+	req_h->rlwi	= SNA_RH_RLWI_NO_RLW;
+	req_h->qri	= SNA_RH_QRI_NO_QR;
+	req_h->pi	= SNA_RH_PI_NO_PAC;
+	req_h->bbi	= SNA_RH_BBI_NO_BB;
+	req_h->cdi	= SNA_RH_CDI_NO_CD;
+	req_h->csi	= SNA_RH_CSI_CODE0;
+	req_h->edi	= SNA_RH_EDI_NO_ED;
+	req_h->pdi	= SNA_RH_PDI_NO_PD;
+	req_h->cebi	= SNA_RH_CEBI_NO_CEB;
+
+	/* More crypto stuff.. */
+
+	return (mu);
+}
+
+/* Check the RH bits of the CRV request or RSP(CRV) received from path_control
+ * (from the partner half_session).
+ */
+static int sna_tc_crv_format_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int length;
+
+	/* Calculate the length of the RU data. */
+	length = 0;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(local->half_session == SNA_HS_PRI)
+			local->sense = 0x20090000;
+		if(req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if((req_h->sdi == SNA_RH_SDI_NO_SD && length < 1)
+			|| (req_h->sdi == SNA_RH_SDI_SD && length < 5))
+			local->sense = 0x10020000;
+		if((req_h->sdi == SNA_RH_SDI_NO_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if(req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+
+		if(req_h->sdi == SNA_RH_SDI_SD)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		if(req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if(req_h->eci == SNA_RH_ECI_NO_EC)
+			local->sense = 0x400B0000;
+		if(SNA_DFC_RQD1(req_h))
+			local->sense = 0x40140000;
+		if(th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if(req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if(req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+		if(req_h->bbi == SNA_RH_BBI_BB)
+			local->sense = 0x400C0000;
+		if(req_h->ebi == SNA_RH_EBI_EB)
+			local->sense = 0x400C0000;
+		if(req_h->cdi == SNA_RH_CDI_CD)
+			local->sense = 0x400D0000;
+		if(req_h->csi == SNA_RH_CSI_CODE1)
+			local->sense = 0x40100000;
+		if(req_h->edi == SNA_RH_EDI_ED)
+			local->sense = 0x40160000;
+		if(req_h->pdi == SNA_RH_PDI_PD)
+			local->sense = 0x40170000;
+		if(req_h->cebi == SNA_RH_CEBI_CEB)
+			local->sense = 0x400C0000;
+	}
+	else	/* CRV Response */
+	{
+		if(local->half_session == SNA_HS_SEC)
+			local->sense = 0x20090000;
+		if(req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if((rsp_h->rti && length < 1) 
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && length < 5))
+			local->sense = 0x10020000;
+		if((req_h->sdi != SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if(req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+		if(req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if(req_h->eci == SNA_RH_ECI_NO_EC)
+			local->sense = 0x400B0000;
+		if(th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if(req_h->dr1i != SNA_RH_DR1I_DR1 
+			|| req_h->dr2i == SNA_RH_DR2I_DR2)
+			local->sense = 0x40140000;
+		if((rsp_h->rti == SNA_RH_RTI_POS && req_h->sdi == SNA_RH_SDI_SD)
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && req_h->sdi== SNA_RH_SDI_NO_SD))
+			local->sense = 0x40130000;
+		if(req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if(req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+	}
+	
+	return (0);
+}
+
+/* Send the input MU to path control. */
+int sna_send_mu(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *rh = &mu->biu->rh.rh.req_h;
+	int err = 0;
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		sna_send_to_pc(mu, cb);
+	if(th->mpf == SNA_TH_MPF_EBIU || rh->rri == SNA_RH_RRI_REQ)
+	{
+		if(local->tcb.ccb.caller == SNA_HS)
+		{
+			if(rh->ru == SNA_RH_RU_FMD)
+			{
+				/* sna_pad_mu(mu); */
+				rh->pdi = SNA_RH_PDI_PD;
+			}
+			else
+				rh->pdi = SNA_RH_PDI_NO_PD;
+
+			err = sna_des_encipher(mu);
+			if(err)
+				local->sense = 0x8480000;
+			else
+				local->sense = 0x0000000;
+		}
+
+		if(err)
+			sna_free_buffer(mu);
+		else
+		{
+			rh->edi = SNA_RH_EDI_ED;
+			if(cb->send_pacing.type != SNA_PACING_TYPE_NONE)
+			{
+				if(sna_hs_pacing_queue_empty 
+					|| (th->mpf == SNA_TH_MPF_BBIU
+					&& cb->send_pacing.rpc 
+					+ cb->send_pacing.nws == 0))
+				{
+					sna_hs_pacing_queue_tail(mu);
+				}
+			}
+			else
+				sna_send_to_pc(mu, cb);
+		}
+	}
+
+	if(rh->rri == SNA_RH_RRI_RSP)
+	{
+		if(cb->send_pacing.type == SNA_PACING_TYPE_NONE
+			|| sna_hs_pacing_queue_empty(mu) 
+			|| rh->qri == SNA_RH_QRI_NO_QR)
+		{
+			sna_send_to_pc(mu, cb);
+		}
+		else
+			sna_hs_pacing_queue_tail(mu);
+	}
+
+	return (0);
+}
+
+/* Update the send pacing counts in the common control block and set the
+ * pacing bits (rh->pi and rh->rlwi of the MU being sent) to the
+ * appropriate values.
+ */
+static int sna_send_pacing(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+
+	if(cb->send_pacing.rpc > 0)
+		cb->send_pacing.rpc--;
+	else
+	{
+		cb->send_pacing.rpc		= cb->send_pacing.nws - 1;
+		cb->send_pacing.nws 		= 0;
+		mu->biu->rh.rh.req_h.pi		= SNA_RH_PI_PAC;
+		mu->biu->rh.rh.req_h.rlwi 	= cb->send_pacing.rlwi;
+		cb->send_pacing.rlwi		= SNA_CCB_NO_RLW;
+	}
+
+	return (0);
+}
+
+/* Send an MU to path control. */
+static int sna_send_to_pc(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_ipm_extension *ipm_ext = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_msg_queue *msg = NULL;
+	int err;
+
+	mu->header_type = SNA_MU_HS_TO_PC;
+	mu->layer.hs_to_pc.lfsid = cb->lfsid;
+	mu->layer.hs_to_pc.tx_priority = cb->tx_priority;
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		if((req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC) 
+			|| req_h->dr1i == SNA_RH_DR1I_NO_DR1
+			|| (req_h->dr2i == SNA_RH_DR2I_NO_DR2 
+			&& cb->send_pacing.type == SNA_PACING_TYPE_ADAPTIVE))
+		{
+			if(ipm_ext->type != SNA_IPM_TYPE_RESET_ACK)
+				mu->layer.hs_to_pc.tx_priority 
+					= SNA_TP_NETWORK;
+		}
+		else
+		{
+			if(th->efi != SNA_TH_EFI_EXP && cb->send_pacing.type 
+				!= SNA_PACING_TYPE_NONE)
+				sna_send_pacing(mu);
+		}
+
+		msg->mu = mu;
+		err = sna_pc(msg);
+		if(err)
+			sna_free_buffer(mu);
+	}
+
+	return (0);
+}
+
+/* Receive an MU sent from path control. */
+int sna_tc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_mu *wmu;
+
+	sna_tc_segment_rcv_chk(mu);
+	if(local->sense != 0x00000000)
+		return (-1);
+
+	if(th->efi == SNA_TH_EFI_NORM && th->mpf == SNA_TH_MPF_BBIU)
+		sna_rcv_pacing(mu, &local->tcb.ccb);
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		wmu = sna_segment_reassembly(mu);
+		if(local->sense == 0x00000000)
+		{
+			if(wmu)
+			{
+				sna_tc_biu_rcv_chk(mu);
+				if(local->sense == 0x00000000)
+				{
+					if(th->efi == SNA_TH_EFI_NORM)
+					{
+						if(req_h->edi == SNA_RH_EDI_ED
+							&& mu->biu->ru.ru.raw != NULL
+							&& req_h->ru == SNA_RH_RU_FMD)
+						{
+							sna_tc_decipher_ru(mu);
+
+							if(local->sense == 0x00000000)
+							{
+								/* Must wrap to 0 after 65535 */
+								local->sqn_rcv_cnt++;
+							}
+
+							sna_dfc_rcv(mu);
+						}
+						else
+						{
+							if(req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC)
+							{
+								sna_rcv_pacing_rsp(mu, &local->tcb.ccb);
+								if(mu != NULL)
+									sna_dfc_rcv(mu);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return (0);
+}
+
+/* Perform receive checks on all segments received from PC. */
+static int sna_tc_segment_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(local->segmenting_supported && th->mpf == SNA_TH_MPF_NO_BIU)
+	{
+		local->sense = 0x80070001;
+	}
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(SNA_DFC_RQD(req_h)
+		|| (th->mpf == SNA_TH_MPF_BBIU && local->segmenting_supported))
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(th->mpf == SNA_TH_MPF_EBIU && !local->segmenting_supported)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if((th->mpf == SNA_TH_MPF_EBIU && th->mpf == SNA_TH_MPF_BBIU) 
+		!= th->mpf == SNA_TH_MPF_EBIU)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(mu->dcf < 10)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(th->mpf == SNA_TH_MPF_BBIU && local->sense == 0x00000000)
+		sna_mu_pacing_chk(mu);
+
+	return (0);
+}
+
+/* This procedure performs receive checks on BIUs. */
+static int sna_tc_biu_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u8 ru_len;
+
+	if(req_h->ru != SNA_RH_RU_FMD || req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x10070000;
+	else
+	{
+		ru_len = 0;
+		if(req_h->sdi == SNA_RH_SDI_SD)
+			ru_len += 4;
+		if(req_h->ru == SNA_RH_RU_DFC)
+			ru_len += 1;
+		if(mu->dcf < ru_len + 3)
+			local->sense = 0x1002000;
+		else
+		{
+			if(req_h->sdi == SNA_RH_SDI_SD)
+			{
+					local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+			}
+			else
+			{
+				if(th->efi == SNA_TH_EFI_NORM)
+				{
+					if(th->snf.number != local->sqn_rcv_cnt + 1)
+						local->sense = 0x2001000;
+					if(local->crypto)
+					{
+						if(req_h->ru == SNA_RH_RU_FMD)
+						{
+							if(mu->biu->ru.ru.raw != NULL
+								&& local->sense == 0x00000000)
+							{
+								if(req_h->edi != SNA_RH_EDI_ED)
+									local->sense = 0x08090000;
+								else
+								{
+									if(!(mu->dcf % 8))
+										local->sense = 0x10010000;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return (0);
+}
+
+static int sna_mu_pacing_chk(struct sna_mu *mu)
+{
+	struct sna_ipm_extension *ipm_extension = NULL;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		if(local->tcb.ccb.receive_pacing.rpc == 0)
+		{
+			if(local->tcb.ccb.receive_pacing.nws == 0)
+				local->sense = 0x20110000;
+			else
+			{
+				if(mu->biu->rh.rh.rsp_h.pi != SNA_RH_PI_PAC)
+					local->sense = 0x20110000;
+			}
+		}
+		else
+		{
+			if(mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC)
+				local->sense = 0x20110002;
+		}
+
+		return (0);
+	}
+
+	if(local->tcb.ccb.send_pacing.type == SNA_PACING_TYPE_ADAPTIVE 
+		&& mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC)
+	{
+		if(SNA_IPM_FORMAT_0)
+		{
+			if(mu->dcf < sizeof(struct sna_rh)
+				+ sizeof(struct sna_ipm_extension))
+			{
+				local->sense = 0x10020000;
+			}
+			else
+			{
+				if(ipm_extension->format_indicator
+					!= SNA_IPM_FORMAT_0)
+				{
+					local->sense = 0x10010003;
+				}
+			}
+		}
+		else
+		{
+			switch(ipm_extension->type)
+			{
+				case (SNA_IPM_TYPE_SOLICITED):
+					if(ipm_extension->nws == 0
+					|| mu->biu->ru.ru.ipm.rwi == SNA_IPM_RWI_RESET_WINDOW)
+					{
+						local->sense = 0x10010003;
+					}
+					else
+					{
+						if(local->tcb.ccb.send_pacing.nws > 0)
+						{
+							local->sense = 0x20110001;
+						}
+					}
+					break;
+
+				case (SNA_IPM_TYPE_UNSOLICITED):
+					if(ipm_extension->rwi != SNA_IPM_RWI_RESET_WINDOW)
+						local->sense = 0x10010003;
+					break;
+
+				case (SNA_IPM_TYPE_RESET_ACK):
+					if(local->tcb.ccb.receive_pacing.unsolicited_ipm_outstanding)
+						local->sense = 0x20110001;
+					break;
+
+				default:
+					local->sense = 0x10010003;
+					break;
+			}
+		}
+	}
+
+	local->sense = 0x20110003;
+
+	return (0);
+}
+
+/* This procedure updates the receive pacing counts in the local->common_cb
+ * and determines the type of buffer reserve action to request of the BM.
+ * This procedure is never called when the reidual pacing count and the
+ * next-window size are both 0.
+ */
+static int sna_rcv_pacing(struct sna_mu *mu, 
+	struct sna_common_cb *common_cb)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(req_h->pi != SNA_RH_PI_PAC)
+	{
+		common_cb->receive_pacing.rpc++;
+		common_cb->reserve_flag = SNA_CCB_NO;
+	}
+	else
+	{
+		common_cb->receive_pacing.rpc = common_cb->receive_pacing.nws-1;
+		common_cb->receive_pacing.nws = 0;
+		if(req_h->rlwi == SNA_RH_RLWI_RLW)
+			common_cb->reserve_flag = SNA_CCB_MORE;
+		else
+			common_cb->reserve_flag = SNA_CCB_ALL;
+	}
+
+	return (0);
+}
+
+/* This procedure copies normal-flow request MUs from link buffer to a
+ * dynamic buffer. This procedure is called to reassemble segments into a
+ * whole BIU.
+ */
+static struct sna_mu *sna_segment_reassembly(struct sna_mu *mu)
+{
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_mu *wmu = NULL;
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		if(sizeof(mu->biu->ru) > 0)
+			local->sense = 0x10020000;
+		else
+		{
+			wmu = sna_get_buffer(SNA_BM_TYPE_DEMAND, 
+				local->tcb.ccb.limit_buf_pool_id, 0,
+				SNA_BM_NO_WAIT);
+		}
+
+		sna_free_buffer(mu);
+	}
+	else
+	{
+		/* Theres more. */
+		sna_free_buffer(mu);
+	}
+
+	if(th->mpf == SNA_TH_MPF_EBIU)
+	{
+		th->mpf = SNA_TH_MPF_EBIU;
+	}
+
+	if(local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding)
+	{
+		sna_adjust_buf_pool(local->perm_buf_pool_id, SNA_BM_TYPE_PERM,
+			0);
+		local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding = 0;
+	}
+
+	return (wmu);
+}
+
+/* This procedure updates pacing counts in the local->common_cb, sends
+ * reset acknowledgments to unsolicited IPMs and sends MUs to path_control
+ * if possible.
+ */
+static int sna_rcv_pacing_rsp(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ipm_extension *ipm_ex = NULL;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	switch(rsp_h->pi)
+	{
+		case (SNA_PACING_TYPE_ADAPTIVE):
+			if(ipm_ex->type == SNA_IPM_TYPE_RESET_ACK)
+			{
+				cb->receive_pacing.rpc = 0;
+				cb->receive_pacing.nws 
+					= cb->receive_pacing.unsolicited_nws;
+				cb->receive_pacing.unsolicited_ipm_outstanding = 0;
+				sna_free_buffer(mu);
+
+				if(1)
+					sna_adjust_buf_pool(local->tcb.ccb.dynamic_buf_pool_id, SNA_BM_TYPE_DEMAND, 0);
+				else
+					cb->receive_pacing.adjust_ipm_ack_outstanding = 1;
+			}
+
+			if(ipm_ex->type == SNA_IPM_TYPE_SOLICITED)
+			{
+				if(sna_hs_pacing_queue_empty(mu))
+				{
+					if(cb->send_pacing.rpc == 0)
+						cb->send_pacing.rlwi
+							= SNA_CCB_RLW;
+					sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id, SNA_BM_TYPE_LIMIT, 0);
+					cb->send_pacing.nws = ipm_ex->nws;
+					sna_free_buffer(mu);
+				}
+			}
+
+			if(ipm_ex->type == SNA_IPM_TYPE_UNSOLICITED)
+			{
+				mu = sna_get_buffer(SNA_BM_TYPE_DEMAND,
+					local->tcb.ccb.limit_buf_pool_id,
+					0, SNA_BM_NO_WAIT);
+				cb->send_pacing.nws = mu->biu->ru.ru.ipm.nws;
+				cb->send_pacing.rpc = 0;
+				ipm_ex->type 	= SNA_IPM_TYPE_RESET_ACK;
+				ipm_ex->rwi 	= SNA_IPM_RWI_NO_RESET_WINDOW;
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case (SNA_PACING_TYPE_NONE):
+			while(sna_hs_pacing_queue_empty(mu))
+			{
+				sna_hs_pacing_dequeue(mu);
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case (SNA_PACING_TYPE_FIXED):
+			cb->send_pacing.nws = cb->send_pacing.first_ws;
+			if(rsp_h->dr1i == SNA_RH_DR1I_NO_DR1 
+				|| rsp_h->dr2i == SNA_RH_DR2I_NO_DR2)
+			{
+				sna_free_buffer(mu);
+			}
+			sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id,
+				SNA_BM_TYPE_LIMIT, 0);
+			break;
+	}
+
+	return (0);
+}
+
+/* This procedure receives buffers_reserved signals from the
+ * BM, updates the appropriate pacing counts in the local->common_cb
+ * and builds and sends the appropriate pacing response.
+ */
+int sna_buffers_reserved(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_ipm_extension *ipm_ex = NULL;
+
+	if(1)	/* reserved_buf_reduce. */
+	{
+		cb->receive_pacing.unsolicited_ipm_outstanding = 1;
+		cb->receive_pacing.unsolicited_nws = 0;
+		mu->dcf = sizeof(struct sna_req_h) + sizeof(struct sna_ru_ipm);
+		ipm_ex->type = SNA_IPM_TYPE_UNSOLICITED;
+		ipm_ex->rwi = SNA_IPM_RWI_RESET_WINDOW;
+		ipm_ex->format_indicator = SNA_IPM_FORMAT_0;
+		ipm_ex->nws = cb->receive_pacing.nws;
+	}
+	else
+		mu->dcf = th->dcf;
+
+	th->mpf		= SNA_TH_MPF_WHOLE_BIU;
+	th->efi 	= SNA_TH_EFI_EXP;
+	th->snf.number 	= 0;
+
+	sna_send_to_pc(mu, cb);
+
+	return (0);
+}
+
+/* Decipher an enciphered message. */
+static int sna_tc_decipher_ru(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	int err;
+	__u8 len, pad_cnt = 0;
+
+	err = sna_des_decipher(mu);
+	if(err)
+		local->sense = 0x08480000;
+	else
+	{
+		if(req_h->pdi == SNA_RH_PDI_PD)
+		{
+			len = mu->dcf - sizeof(mu->biu->ru);
+			pad_cnt = mu->biu->ru.ru.raw[len];
+			if(pad_cnt < 1 || pad_cnt > 7)
+				local->sense = 0x10010000;
+			else
+			{
+				mu->dcf -= pad_cnt;
+				req_h->pdi = SNA_RH_PDI_NO_PD;
+			}
+		}
+	}
+
+	return (0);
+}
+
+#endif /* CONFIG_SNA_LU62_HS || CONFIG_SNA_LU62_HS_MODULE */
diff -ruN linux-2.4.13/net/sna/sna_tdm.c linux/net/sna/sna_tdm.c
--- linux-2.4.13/net/sna/sna_tdm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_tdm.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,429 @@
+/* sna_tdm.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Bugs:
+ * - process TDUs
+ * - Garbage collection
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+#include <linux/ctype.h>
+
+static struct sna_tdm_node_cb *node_list = NULL;
+static struct sna_tdm_an_cb *ancb_list 	 = NULL;
+
+unsigned char sna_system_tg_num_id	 = 1;
+
+int sysctrl_co_max_retries		 = CO_MAX_RETRIES;
+
+struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid)
+{
+	struct sna_tdm_node_cb *n;
+
+	sna_debug(5, "sna_tdm_find_node_entry %s\n", sna_pr_netid(netid));
+	for(n = node_list; n != NULL; n = n->next)
+		if(!strncmp(n->netid.net, netid->net, SNA_RESOURCE_NAME_LEN)
+			&& !strncmp(n->netid.name, netid->name, SNA_RESOURCE_NAME_LEN))
+			return (n);
+
+	return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac)
+{
+	struct sna_tdm_node_cb *n;
+
+        sna_debug(5, "sna_tdm_find_tg_by_mac (%s)\n", sna_pr_ether(mac));
+        for(n = node_list; n != NULL; n = n->next)
+        {
+                struct sna_tg_cb *t;
+
+                for(t = n->tg_list; t != NULL; t = t->next)
+                        if(!memcmp(t->tg_vector.desc.dlc.mac,mac,MAX_ADDR_LEN))
+                                return (t);
+        }
+
+        return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num)
+{
+	struct sna_tdm_node_cb *n;
+
+	sna_debug(5, "sna_tdm_find_tg_by_id\n");
+	for(n = node_list; n != NULL; n = n->next)
+	{
+		struct sna_tg_cb *t;
+
+        	for(t = n->tg_list; t != NULL; t = t->next)
+		{
+			printk("%d %d\n", t->tg_vector.desc.id.tg_number, tg_num);
+                	if(t->tg_vector.desc.id.tg_number == tg_num)
+                        	return (t);
+		}
+	}
+
+	return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n, 
+	unsigned char tg_num)
+{
+	struct sna_tg_cb *t;
+
+	sna_debug(5, "sna_tdm_find_tg %d\n", tg_num);
+	for(t = n->tg_list; t != NULL; t = t->next)
+	        if(t->tg_vector.desc.id.tg_number == tg_num)
+	                return (t);
+
+	return (NULL);
+}
+
+int sna_tdm_cp_status(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_init_tg_update(struct sna_tg_update *tg)
+{
+	sna_debug(5, "sna_tdm_init_tg_update\n");
+	tg->node_type			= 0;
+	tg->routing			= 0;
+	tg->tg_desc.type		= 0;
+	tg->tg_desc.id.type		= 0;
+	tg->tg_desc.id.tg_number	= 0;
+	tg->tg_desc.id.pcp_len		= 0;
+	tg->tg_desc.id.pcp_name		= NULL;
+	tg->tg_desc.id.pcp_name_id_cn	= 0;
+	tg->tg_desc.id.more_cfg_info	= 0;
+	tg->tg_desc.id.hpr_support	= 0;
+	tg->tg_desc.id.tg_type		= 0;
+	tg->tg_desc.id.intersubnet_tg	= 0;
+	tg->tg_desc.id.rtp_support	= 0;
+	tg->tg_desc.id.subarea_number	= 0;
+	tg->tg_desc.dlc.type		= 0;
+	tg->tg_desc.dlc.lsap		= 0;
+	memset(tg->tg_desc.dlc.mac, 0, MAX_ADDR_LEN);
+	tg->tg_chars.type		= 0;
+	tg->tg_chars.rsn		= 0;
+	tg->tg_chars.status		= 0;
+	tg->tg_chars.garbage		= 0;
+	tg->tg_chars.quiescing		= 0;
+	tg->tg_chars.cpcp_session	= 0;
+	tg->tg_chars.effective_capacity	= 0;
+	tg->tg_chars.cost_per_connect	= 0;
+	tg->tg_chars.cost_per_byte	= 0;
+	tg->tg_chars.security		= 0;
+	tg->tg_chars.propagation_delay	= 0;
+	tg->tg_chars.user1		= 0;
+	tg->tg_chars.user2		= 0;
+	tg->tg_chars.user3		= 0;
+
+	return (0);
+}
+
+int sna_tdm_tg_update(struct sna_tg_update *utg)
+{
+	struct sna_tdm_node_cb *cb;
+	struct sna_tg_cb *tg;
+	struct sna_netid *pcp_name;
+
+	sna_debug(5, "sna_tdm_tg_update %s\n", utg->tg_desc.id.pcp_name);
+	pcp_name = sna_char_to_netid(utg->tg_desc.id.pcp_name);
+//	sna_debug(5, "(%s) (%s)\n", pcp_name->net, pcp_name->name);
+
+	cb = sna_tdm_find_node_entry(pcp_name);
+	if(!cb)
+		return (-ENOENT);
+	tg = sna_tdm_find_tg(cb, utg->tg_desc.id.tg_number);
+	if(!tg)
+	{
+		tg = (struct sna_tg_cb *)kmalloc(sizeof(struct sna_tg_cb),
+			GFP_ATOMIC);
+		init_timer(&tg->co_retry);
+		init_waitqueue_head(&tg->sleep);
+        	tg->co_retry.function   = sna_cs_connect_out;
+        	tg->co_retry.data       = (unsigned long)tg;
+        	tg->co_interval         = CO_TIMEOUT;
+        	tg->co_retries          = 0;
+        	tg->co_max_retries      = sysctrl_co_max_retries;
+		tg->cos_list		= NULL;
+		tg->next		= cb->tg_list;
+		cb->tg_list		= tg;
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+		tg->tg_vector.desc.id.tg_number = sna_system_tg_num_id++;
+
+		/* init xid information for this transmission group */
+		tg->xid_info = (struct sna_xid_info *)kmalloc(sizeof(struct sna_xid_info), GFP_ATOMIC);
+		init_timer(&tg->xid_info->xid_timer);
+		tg->xid_info->xid_timer.function = sna_cs_connect_out;
+		tg->xid_info->xid_timer.data = (unsigned long)tg;
+		tg->xid_info->xid_retry_interval = 3 * HZ;	/* 3 secs */
+		tg->xid_info->xid_retry_limit = 10;
+		tg->xid_info->xid_retries = 0;
+		tg->xid_info->last_tx_xid = NULL;
+		tg->xid_info->last_rx_xid = NULL;
+		tg->xid_info->xid_status        = XID_RESET;
+	}
+	else
+	{
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+	}
+
+	do_gettimeofday(&tg->updated);
+	tg->dev				= utg->dev;
+	tg->lsap			= utg->lsap;
+	tg->partner_node_type    	= utg->node_type;
+        tg->intermediate_routing 	= utg->routing;
+	tg->tg_vector.desc.id.pcp_name 	= utg->tg_desc.id.pcp_name;
+        utg->tg_desc.id.pcp_name 	= NULL;
+	memcpy(&tg->tg_vector.chars,&utg->tg_chars,sizeof(struct sna_tg_chars));
+
+	sna_debug(5, "It is %s %d %d\n", tg->tg_vector.desc.id.pcp_name,
+		strlen(tg->tg_vector.desc.id.pcp_name), 
+		tg->tg_vector.desc.id.pcp_len);
+
+//	sna_rss_resource_updates();
+	kfree(utg);
+
+	return (tg->tg_vector.desc.id.tg_number);	/* TG Number */
+}
+
+int sna_tdm_define_node_chars(struct sna_define_node_chars *n)
+{
+	struct sna_tdm_node_cb *cb;
+
+	sna_debug(5, "sna_tdm_define_node_chars\n");
+	cb = sna_tdm_find_node_entry(&n->cp_name);
+	if(!cb)
+	{
+		cb = (struct sna_tdm_node_cb *)kmalloc(sizeof(struct sna_tdm_node_cb), GFP_ATOMIC);
+		memcpy(&cb->netid, &n->cp_name, sizeof(struct sna_netid));
+		memset(&cb->node_vector, 0, sizeof(struct sna_node_vector));
+		cb->tg_list	= NULL;
+		cb->cos_list	= NULL;
+		cb->next	= node_list;
+		node_list	= cb;
+	}
+	do_gettimeofday(&cb->updated);
+	memcpy(&cb->node_vector.desc.cp_name, &n->cp_name,
+		sizeof(struct sna_netid));
+	cb->node_vector.chars.info.route_resistance 	= n->route_resistance;
+	cb->node_vector.chars.info.quiescing		= n->quiescing;
+//	sna_rss_resource_updates();
+
+	return (0);
+}
+
+int sna_tdm_node_congenstion(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_query_cpname(void)
+{
+
+	return (0);
+}
+
+/* Returned last FRSN recieved for cp_name specified */
+unsigned long sna_tdm_request_last_frsn(struct sna_netid *cp_name)
+{
+	struct sna_tdm_node_cb *cb;
+
+	cb = sna_tdm_find_node_entry(cp_name);
+	if(!cb)
+		return (-ENOENT);
+	return (cb->frsn);
+}
+
+/* This only returns the first TG found and does not check for any
+ * options.
+ */
+int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v)
+{
+	struct sna_tdm_node_cb *cb;
+
+	sna_debug(5, "sna_tdm_request_tg_vectors %s.%s\n",
+		v->org_cp_name.net, v->org_cp_name.name);
+
+	cb = sna_tdm_find_node_entry(&v->org_cp_name);
+	if(!cb)
+		return (-ENOENT);
+
+	v->tg_vectors = (struct sna_tg_vector *)
+		kmalloc(sizeof(struct sna_tg_vector), GFP_ATOMIC);
+	memcpy(v->tg_vectors, &cb->tg_list->tg_vector, 
+		sizeof(struct sna_tg_vector));
+	v->tg_vectors->desc.id.pcp_name = (unsigned char *)
+		kmalloc(v->tg_vectors->desc.id.pcp_len + 1, GFP_ATOMIC);
+	strcpy(v->tg_vectors->desc.id.pcp_name, 
+		cb->tg_list->tg_vector.desc.id.pcp_name);
+
+	return (0);
+}
+
+int sna_tdm_garbage_collection(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_tdu_chk_errors(void)
+{
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s\n", "NetID.Node");
+        for(c = node_list; c != NULL; c = c->next)
+        {
+                len += sprintf(buffer + len, "%-18s\n",sna_pr_netid(&c->netid));
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%5s%4s%7s%8s%10s%5s%5s%4s%4s%9s%18s%6s%6s%6s\n",
+                "NetID.Node", "type", "tgn", "status", "garbage",
+		"quiescing", "cpcp", "ecap", "cpc",
+		"cpb", "security", "propagation_delay",
+		"user1", "user2", "user3");
+
+        for(c = node_list; c != NULL; c = c->next)
+        {
+		struct sna_tg_cb *t;
+
+		for(t = c->tg_list; t != NULL; t = t->next)
+		{
+                	len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&c->netid));
+			len += sprintf(buffer + len, "%5d%4d%7d%8d%10d%5d"
+				"%5d%4d%4d%9d%18d%6d%6d%6d\n",
+				t->tg_vector.desc.id.type,
+				t->tg_vector.desc.id.tg_number,
+				t->tg_vector.chars.status,
+				t->tg_vector.chars.garbage,
+				t->tg_vector.chars.quiescing,
+				t->tg_vector.chars.cpcp_session,
+				t->tg_vector.chars.effective_capacity,
+				t->tg_vector.chars.cost_per_connect,
+				t->tg_vector.chars.cost_per_byte,
+				t->tg_vector.chars.security,
+				t->tg_vector.chars.propagation_delay,
+				t->tg_vector.chars.user1,
+				t->tg_vector.chars.user2,
+				t->tg_vector.chars.user3);
+
+			pos = begin + len;
+                	if(pos < offset)
+                	{
+                        	len = 0; 
+				begin = pos;
+                	}
+                	if(pos > offset + length) 
+                        	break;
+		}
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+
+int sna_tdm_create(struct sna_start_node *start)
+{
+
+	return (0);
+}
+
+int sna_tdm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_tdm_node_cb *cb;
+	struct sna_tg_cb *t;
+
+	for(cb = node_list; cb != NULL; cb = cb->next)
+	{
+		for(t = cb->tg_list; t != NULL; t = t->next)
+			kfree(t);
+		kfree(cb);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sna_trs.c linux/net/sna/sna_trs.c
--- linux-2.4.13/net/sna/sna_trs.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_trs.c	Sat Nov  3 13:18:54 2001
@@ -0,0 +1,57 @@
+/* sna_trs.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_trs_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_trs_create\n");
+	sna_cosm_create(start);
+	sna_rss_create(start);
+	sna_tdm_create(start);
+
+	return (0);
+}
+
+int sna_trs_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "sna_trs_destroy\n");
+	sna_tdm_destroy(delete);
+	sna_rss_destroy(delete);
+	sna_cosm_destroy(delete);
+
+	return (0);
+}
diff -ruN linux-2.4.13/net/sna/sysctl_net_sna.c linux/net/sna/sysctl_net_sna.c
--- linux-2.4.13/net/sna/sysctl_net_sna.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sysctl_net_sna.c	Wed Nov  7 10:58:24 2001
@@ -0,0 +1,108 @@
+/* sysctl_net_sna.c: Linux Systems Network Architecture implementation
+ * - SysCtrl user interface to Linux-SNA
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+extern __u32   	sysctl_max_link_stations_cnt;
+extern __u32   	sysctl_max_lu_cnt;
+extern __u32   	sysctl_max_mode_cnt;
+extern __u32   	sysctl_max_inbound_activations;
+extern __u32   	sysctl_max_outbound_activations;
+extern __u32   	sysctl_max_retry_limit;
+extern __u32   	sysctl_max_btu_size;
+extern __u32   	sysctl_max_tx_ru_size;
+extern __u32   	sysctl_max_rx_ru_size;
+extern __u32   	sysctl_max_auto_activation_limit;
+extern __u32   	sysctl_bind_pacing_cnt;
+extern __u8    	sna_debug_level;
+
+/* XID sysctls */
+extern __u32	sysctl_xid_idle_limit;
+extern __u32	sysctl_xid_retry_interval;
+extern __u32	sysctl_xid_retry_limit;
+
+extern int	sysctrl_co_max_retries;
+
+#ifdef CONFIG_SYSCTL
+ctl_table sna_table[] = {
+	{NET_SNA_MAX_LINK_STATIONS, "max_link_station_count",
+        &sysctl_max_link_stations_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_LU, "max_lu_count",
+        &sysctl_max_lu_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_MODE, "max_mode_count", &sysctl_max_mode_cnt,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_XID_RETRY, "xid_retry_limit", &sysctl_xid_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_IDLE_LIMIT, "xid_idle_limit", &sysctl_xid_idle_limit,
+	sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_RETRY_INTERVAL, "xid_retry_interval", 
+	&sysctl_xid_retry_interval, sizeof(__u32), 0644, NULL, 
+	&proc_dointvec_jiffies},
+        {NET_SNA_MIA, "max_inbound_activations",
+        &sysctl_max_inbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MOA, "max_outbound_activations",
+        &sysctl_max_outbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RETRY, "max_retry_limit", &sysctl_max_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_BTU, "max_btu_size", &sysctl_max_btu_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_TX_RU, "max_tx_ru_size", &sysctl_max_tx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RX_RU, "max_rx_ru_size", &sysctl_max_rx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_MAX_AUTO_ACT, "max_auto_activation_limit",
+        &sysctl_max_auto_activation_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_DEBUG, "debug_level", &sna_debug_level,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_CO_MAX_RETRIES, "max_connect_out_retries",
+	&sysctrl_co_max_retries, 
+	sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+	{0}
+};
+
+static ctl_table sna_dir_table[] = {
+        {NET_SNA, "sna", NULL, 0, 0555, sna_table},
+        {0}
+};
+
+static ctl_table sna_root_table[] = {
+        {CTL_NET, "net", NULL, 0, 0555, sna_dir_table},
+        {0}
+};
+
+static struct ctl_table_header *sna_table_header;
+
+void sna_register_sysctl(void)
+{
+	sna_table_header = register_sysctl_table(sna_root_table, 1);
+
+	return;
+}
+
+void sna_unregister_sysctl(void)
+{
+	unregister_sysctl_table(sna_table_header);
+
+	return;
+}
+#endif
