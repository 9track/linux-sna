diff -ruN linux-2.4.4/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.4/Documentation/Configure.help	Fri Apr 20 16:23:12 2001
+++ linux/Documentation/Configure.help	Mon May 14 19:40:23 2001
@@ -4291,6 +4291,23 @@
   The module will be called af_spx.o. If you want to compile it as a
   module, say M here and read Documentation/modules.txt.
 
+SNA Networking
+CONFIG_SNA
+  Systems Network Architecture (SNA) is a data communication protocol
+  established by IBM to specify common conventions for communication among
+  the wide array of IBM hardware and software data communications products.
+
+  Linux-SNA is the Linux supported version of the IBM SNA protocol
+  specifications. To learn more about Linux-SNA point your web browser
+  to http://www.linux-sna.org
+
+  Many of the Linux-SNA protocol options can be compiled as (M)odules
+  or staticly in the kernel. Please follow the proper Linux-SNA FAQs
+  and HOWTOs in order to select the appropriate options for your SNA
+  enviroment.
+
+  If you don't know what you are doing, say  N.
+
 DECnet networking (EXPERIMENTAL)
 CONFIG_DECNET
   The DECnet networking protocol was used in many products made by
diff -ruN linux-2.4.4/Documentation/networking/llc.txt linux/Documentation/networking/llc.txt
--- linux-2.4.4/Documentation/networking/llc.txt	Wed Dec 31 16:00:00 1969
+++ linux/Documentation/networking/llc.txt	Mon May 14 19:40:46 2001
@@ -0,0 +1,80 @@
+llc.txt: Documentation for the Linux IEEE 802.2 and Linux LLC UI layers.
+         Written by: Jay Schulist <jschlst@turbolinux.com>
+
+LLC User Interface Notes:
+
+LLC Class 1 socket types:
+	- SOCK_DGRAM
+LLC Class 2 socket types:
+	- SOCK_STREAM
+
+Besides normal data transfer, the user can send a test request 
+from either socket type. just set the sllc_test to 1 in the sockaddr_llc
+structure.
+
+struct sockaddr_llc {
+	sa_family_t	sllc_family;
+
+	unsigned char 	sllc_dmac[14];
+	unsigned char   sllc_dsap;
+	unsigned char	sllc_smac[14];
+	unsigned char	sllc_ssap;
+	unsigned char	sllc_test;
+};
+
+
+IEEE 802.2 Layer Notes:
+Initialization/LLC load:
+1). LLC scans for LLC interfaces in the IFF_UP state. For each interface
+    found a independent Station Component (SC) is created. *
+2). We register a device notifier to alert us of devices going up and/or
+    down. We then either add or delete a SC for the appropriate device. *
+
+* Required for protocol compliance.
+
+Operation:
+
+LLC commands are executed by the llc_queue_cmd() call unless otherwise
+noted. The following commands are available depending on the llc class type.
+([] = only available by this command)
+
+Class One:
+- LLC_STATE_SAP_ACTIVATION_REQUEST	[register_8022_client()]
+- LLC_STATE_SAP_DEACTIVATION_REQUEST	[unregister_8022_client()]
+
+- LLC_STATE_XID_REQUEST
+
+- LLC_STATE_TEST_REQUEST		[dl->datalink_header()]
+					[dev_queue_xmit() or llc_queue_xmit()]
+- LLC_STATE_UNITDATA_REQUEST		[dl->datalink_header()]
+					[dev_queue_xmit() or llc_queue_xmit()]
+
+Class Two:
+- LLC_STATE_CONNECT_REQUEST		[llc_connect()]
+- LLC_STATE_CONNECT_RESPONSE		[llc_connect()]
+- LLC_STATE_DISCONNECT_REQUEST		[llc_disconnect()]
+- LLC_STATE_DISCONNECT_RESPONSE		[llc_disconnect()]
+- LLC_STATE_RESET_REQUEST		[llc_reset()]
+- LLC_STATE_RESET_RESPONSE		[llc_reset()]
+
+- LLC_STATE_DATA_REQUEST		[dl->datalink_header()]
+					[llc_queue_xmit()]
+
+Check linux/net/llc/af_llc.c for a great reference on how to connect your
+networking layer into the llc layer, it is great fun and worth a try.
+
+
+- Transmit and Receive Processor paths
+
+Receive:
+- llc_rcv
+  - llc_find_client
+  - llc_decode_pdu
+  - llc_demux_pdu
+    - llc_process_pdu_type2
+
+Transmit
+- llc_datalink_header
+  - llc_demux_cmd
+    - llc_process_cmd_type2
+      - llc_build_pdu
diff -ruN linux-2.4.4/Documentation/networking/sna/node-start.txt linux/Documentation/networking/sna/node-start.txt
--- linux-2.4.4/Documentation/networking/sna/node-start.txt	Wed Dec 31 16:00:00 1969
+++ linux/Documentation/networking/sna/node-start.txt	Tue May  9 11:36:03 2000
@@ -0,0 +1,24 @@
+Linux-SNA DLC handling is as follows:
+
+Each system (node) has a pool of non-active DLCs (eth0, tr0, etc).
+
+Once a DLC has been defined 
+
+
+Available DLCs: tr0, sdlc0
+Active DLCs: eth0
+
+Upon start_node command:
+1. IFF_UP interfaces are defined and placed into the DLC_UP state.
+
+Upon port start:
+2. Listener is added for new interface when registered to be defined.
+
+DLC is only active and associated with a node when the start_dlc command
+is issued by the use.
+
+define_dlc + delete_dlc are system commands.
+
+/proc/net/sna/sna-cs-dlc
+
+
diff -ruN linux-2.4.4/MAINTAINERS linux/MAINTAINERS
--- linux-2.4.4/MAINTAINERS	Wed Apr 25 14:35:25 2001
+++ linux/MAINTAINERS	Mon May 14 19:42:29 2001
@@ -160,7 +160,7 @@
 
 APPLETALK NETWORK LAYER
 P:	Jay Schulist
-M:	jschlst@turbolinux.com
+M:	jschlst@samba.org
 L:	linux-atalk@netspace.org
 S:	Maintained
 
@@ -696,7 +696,7 @@
 
 IPX/SPX NETWORK LAYER
 P:	Jay Schulist
-M:	jschlst@turbolinux.com
+M:	jschlst@samba.org
 L:	linux-net@vger.kernel.org
 S:	Maintained
 
@@ -793,6 +793,13 @@
 L:	linuxppc-dev@lists.linuxppc.org
 S:	Maintained
 
+LLC NETWORK LAYER
+P:      Jay Schulist
+M:      jschlst@samba.org
+W:      http://www.linux-sna.org
+L:      linux-sna@tubrolinux.com
+S:      Maintained
+
 M68K
 P:	Jes Sorensen
 M:	jes@linuxcare.com
@@ -1222,13 +1229,13 @@
 
 SPX NETWORK LAYER
 P:	Jay Schulist
-M:	jschlst@turbolinux.com
+M:	jschlst@samba.org
 L:	linux-net@vger.kernel.org
 S:	Supported
 
 SNA NETWORK LAYER
 P:	Jay Schulist
-M:	jschlst@turbolinux.com
+M:	jschlst@samba.org
 L:	linux-sna@turbolinux.com
 W:	http://www.linux-sna.org
 S:	Supported
diff -ruN linux-2.4.4/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S
--- linux-2.4.4/arch/i386/kernel/entry.S	Wed Nov  8 17:09:50 2000
+++ linux/arch/i386/kernel/entry.S	Mon May 14 19:44:25 2001
@@ -645,6 +645,14 @@
 	.long SYMBOL_NAME(sys_madvise)
 	.long SYMBOL_NAME(sys_getdents64)	/* 220 */
 	.long SYMBOL_NAME(sys_fcntl64)
+	.long SYMBOL_NAME(sys_cpicall)
+        .long SYMBOL_NAME(sys_appcall)
+        .long SYMBOL_NAME(sys_tp_register)
+        .long SYMBOL_NAME(sys_tp_correlate)    /* 225 */
+        .long SYMBOL_NAME(sys_tp_unregister)
+        .long SYMBOL_NAME(sys_attach_open)
+        .long SYMBOL_NAME(sys_attach_listen)
+        .long SYMBOL_NAME(sys_attach_close)
 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for TUX */
 
 	/*
@@ -653,6 +661,6 @@
 	 * entries. Don't panic if you notice that this hasn't
 	 * been shrunk every time we add a new system call.
 	 */
-	.rept NR_syscalls-221
+	.rept NR_syscalls-230
 		.long SYMBOL_NAME(sys_ni_syscall)
 	.endr
diff -ruN linux-2.4.4/drivers/net/channel/Config.in linux/drivers/net/channel/Config.in
--- linux-2.4.4/drivers/net/channel/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/channel/Config.in	Tue May  9 11:36:03 2000
@@ -0,0 +1,13 @@
+#
+# ESCON / BUS/TAG channel adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'Channel driver support'
+
+bool 'Channel driver support' CONFIG_CHANNEL
+if [ "$CONFIG_CHANNEL" = "y" ]; then
+   tristate 'Bus-Tech adapter support' CONFIG_BUSTECH
+fi
+
+endmenu
diff -ruN linux-2.4.4/drivers/net/channel/Makefile linux/drivers/net/channel/Makefile
--- linux-2.4.4/drivers/net/channel/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/channel/Makefile	Tue May  9 11:36:03 2000
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/channel
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.4/drivers/net/twinax/Config.in linux/drivers/net/twinax/Config.in
--- linux-2.4.4/drivers/net/twinax/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/twinax/Config.in	Tue May  9 11:36:03 2000
@@ -0,0 +1,14 @@
+#
+# Twinax adapter drivers
+#
+
+mainmenu_option next_comment
+comment 'TwinAx driver support'
+
+bool 'TwinAx driver support' CONFIG_TWINAX
+if [ "$CONFIG_TWINAX" = "y" ]; then
+   tristate 'Affinity adapter support' CONFIG_AFFINITY
+   tristate 'Praim adapter support' CONFIG_PRAIM
+fi
+
+endmenu
diff -ruN linux-2.4.4/drivers/net/twinax/Makefile linux/drivers/net/twinax/Makefile
--- linux-2.4.4/drivers/net/twinax/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/drivers/net/twinax/Makefile	Tue May  9 11:36:03 2000
@@ -0,0 +1,26 @@
+#
+# Makefile for drivers/net/twinax
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now inherited from the
+# parent makefile.
+#
+
+#
+# Note : at this point, these files are compiled on all systems.
+# In the future, some of these should be built conditionally.
+#
+
+SUB_DIRS     := 
+MOD_SUB_DIRS := $(SUB_DIRS)
+ALL_SUB_DIRS := $(SUB_DIRS)
+
+
+L_TARGET :=
+L_OBJS   := 
+M_OBJS   :=
+
+include $(TOPDIR)/Rules.make
diff -ruN linux-2.4.4/include/asm-i386/unistd.h linux/include/asm-i386/unistd.h
--- linux-2.4.4/include/asm-i386/unistd.h	Fri Aug 11 14:39:23 2000
+++ linux/include/asm-i386/unistd.h	Mon May 14 19:46:38 2001
@@ -227,6 +227,14 @@
 #define __NR_madvise1		219	/* delete when C lib stub is removed */
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
+#define __NR_cpicall            222
+#define __NR_appcall            223
+#define __NR_tp_register        224
+#define __NR_tp_correlate       225
+#define __NR_tp_unregister      226
+#define __NR_attach_open        227
+#define __NR_attach_listen      228
+#define __NR_attach_close	229
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-i386/errno.h> */
 
diff -ruN linux-2.4.4/include/linux/appc.h linux/include/linux/appc.h
--- linux-2.4.4/include/linux/appc.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/appc.h	Mon May 14 19:47:14 2001
@@ -0,0 +1,571 @@
+/* appc.h: Advanced Program-to-Program Communications structures and defs.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _APPC_H
+#define _APPC_H
+
+/* Linux-SNA APPC Call OPCODES */
+#define AC_ALLOCATE				0x0001
+#define AC_MC_ALLOCATE				0x0010
+#define AC_DEALLOCATE				0x0020
+#define AC_MC_DEALLOCATE			0x0030
+#define AC_GET_ATTRIBUTES			0x0040
+#define AC_GET_TP_PROPERTIES			0x0050
+#define AC_RECEIVE_AND_WAIT			0x0060
+#define AC_MC_RECEIVE_AND_WAIT			0x0070
+#define AC_REQUEST_TO_SEND			0x0080
+#define AC_MC_REQUEST_TO_SEND			0x0090
+#define AC_SEND_DATA				0x00A0
+#define AC_MC_SEND_DATA				0x00B0
+#define AC_CONFIRM				0x00C0
+#define AC_MC_CONFIRM				0x00D0
+#define AC_CONFIRMED				0x00E0
+#define AC_MC_CONFIRMED				0x00F0
+#define AC_SEND_ERROR				0x0100
+#define AC_MC_SEND_ERROR			0x0110
+#define AC_CHANGE_SESSION_LIMIT			0x0120
+#define AC_INIT_SESSION_LIMIT			0x0130
+#define AC_PROCESS_SESSION_LIMIT		0x0140
+#define AC_RESET_SESSION_LIMIT			0x0150
+#define AC_MC_GET_ATTRIBUTES			0x0160
+#define AC_GET_TYPE				0x0170
+#define AC_SET_SYNCPT_OPTIONS			0x0180
+#define AC_FLUSH				0x0190
+#define AC_MC_FLUSH				0x01A0
+#define AC_POST_ON_RECEIPT			0x01B0
+#define AC_MC_POST_ON_RECEIPT			0x01C0
+#define AC_PREPARE_TO_RECEIVE			0x01D0
+#define AC_MC_PREPARE_TO_RECEIVE		0x01E0
+#define AC_RECEIVE_EXPEDITED_DATA		0x01F0
+#define AC_RECEIVE_IMMEDIATE			0x0200
+#define AC_MC_RECEIVE_IMMEDIATE			0x0210
+#define AC_SEND_EXPEDITED_DATA			0x0220
+#define AC_MC_SEND_EXPEDITED_DATA		0x0230
+#define AC_TEST					0x0240
+#define AC_MC_TEST				0x0250
+#define AC_WAIT					0x0260
+#define AC_WAIT_FOR_COMPLETION			0x0270
+#define AC_BACKOUT				0x0280
+#define AC_PREPARE_FOR_SYNCPT			0x0290
+#define AC_MC_PREPARE_FOR_SYNCPT		0x02A0
+#define AC_ACTIVATE_SESSION			0x02B0
+#define AC_DEACTIVATE_CONVERSATION_GROUP	0x02C0
+#define AC_DEACTIVATE_SESSION			0x02D0
+#define AC_DEFINE_LOCAL_LU			0x02E0
+#define AC_DEFINE_MODE				0x02F0
+#define AC_DEFINE_REMOTE_LU			0x0300
+#define AC_DEFINE_TP				0x0310
+#define AC_DELETE				0x0320
+#define AC_DISPLAY_LOCAL_LU			0x0330
+#define AC_DISPLAY_MODE				0x0340
+#define AC_DISPLAY_REMOTE_LU			0x0350
+#define AC_DISPLAY_TP				0x0360
+#define AC_PROCESS_SIGNOFF			0x0370
+#define AC_SIGNOFF				0x0380
+
+/* Linux-SNA APPC return codes */
+#define AC_OK					0x0000
+#define AC_PARAMETER_CHECK			0x0001
+#define AC_BAD_TP_ID				0x0010
+#define AC_BAD_CONV_ID				0x0020
+#define AC_BAD_LU_ALIAS				0x0030
+#define AC_INVALID_DATA_SEGMENT			0x0040
+#define AC_BAD_CONV_TYPE			0x0050
+#define AC_BAD_SYNC_LEVEL			0x0060
+#define AC_BAD_SECURITY				0x0070
+#define AC_BAD_RETURN_CONTROL			0x0080
+#define AC_PIP_LEN_INCORRECT			0x0090
+#define AC_NO_USE_OF_SNASVCMG			0x00A0
+#define AC_UNKNOWN_PARTNER_MODE			0x00B0
+#define AC_CONFIRM_ON_SYNC_LEVEL_NONE		0x00C0
+#define AC_DEALLOC_BAD_TYPE			0x00D0
+#define AC_DEALLOC_LOG_LL_WRONG			0x00E0
+#define AC_P_TO_R_INVALID_TYPE			0x00F0
+#define AC_RCV_AND_WAIT_BAD_FILL		0x0100
+#define AC_RCV_IMMD_BAD_FILL			0x0110
+#define AC_RCV_AND_POST_BAD_FILL		0x0120
+#define AC_INVALID_SEMAPHONE_HANDLE		0x0130
+#define AC_BAD_RETURN_STATUS_WITH_DATA		0x0140
+#define AC_BAD_LL				0x0150
+#define AC_SEND_INVALID_TYPE			0x0160
+#define AC_INVALID_SESSION_ID			0x0170
+#define AC_INVALID_POLARITY			0x0180
+#define AC_INVALID_TYPE				0x0190
+#define AC_INVALID_LU_ALIAS			0x01A0
+#define AC_INVALID_PLU_ALIAS			0x01B0
+#define AC_INVALID_MODE_NAME			0x01C0
+#define AC_INVALID_TRANSACT_ID			0x01D0
+#define AC_SEND_DATA_CONFIRM_SYNC_LEVEL_NONE	0x01E0
+#define AC_BAD_PARTNER_LU_ALIAS			0x01F0
+#define AC_SEND_ERROR_LOG_LL_WRONG		0x0200
+#define AC_SEND_ERROR_BAD_TYPE			0x0210
+#define AC_BAD_ERROR_DIRECTION			0x0220
+#define AC_TOO_MANY_TPS				0x0230
+#define AC_BAD_TYPE				0x0240
+#define AC_UNDEFINED_TP_NAME			0x0250
+#define AC_INVALID_SET_PROT			0x0260
+#define AC_INVALID_NEW_PROT			0x0270
+#define AC_INVALID_SET_UNPROT			0x0280
+#define AC_INVALID_NEW_UNPROT			0x0290
+#define AC_INVALID_SET_USER			0x02A0
+#define AC_INVALID_DATA_TYPE			0x02B0
+#define AC_BAD_LOCAL_LU_ALIAS			0x02C0
+#define AC_BAD_REMOTE_LU_ALIAS			0x02D0
+#define AC_POST_ON_RECEIPT_BAD_FILL		0x02E0
+#define AC_STATE_CHECK				0x02F0
+#define AC_CONFIRM_BAD_STATE			0x0300
+#define AC_CONFIRM_NO_LL_BDY			0x0310
+#define AC_CONFIRMED_BAD_STATE			0x0320
+#define AC_DEALLOC_FLUSH_BAD_STATE		0x0330
+#define AC_DEALLOC_CONFIRM_BAD_STATE		0x0340
+#define AC_DEALLOC_NOT_LL_BDY			0x0350
+#define AC_FLUSH_NOT_SEND_STATE			0x0360
+#define AC_P_TO_R_NOT_LL_BDY			0x0370
+#define AC_P_TO_R_NOT_SEND_STATE		0x0380
+#define AC_RCV_AND_WAIT_BAD_STATE		0x0390
+#define AC_RCV_AND_WAIT_NOT_LL_BDY		0x03A0
+#define AC_RCV_IMMD_BAD_STATE			0x03B0
+#define AC_RCV_AND_POST_BAD_STATE		0x03C0
+#define AC_RCV_AND_POST_NOT_LL_BDY		0x03D0
+#define AC_R_T_S_BAD_STATE			0x03E0
+#define AC_SEND_DATA_NOT_SEND_STATE		0x03F0
+#define AC_SEND_DATA_NOT_LL_BDY			0x0400
+#define AC_ATTACH_MANAGER_INACTIVE		0x0410
+#define AC_ALLOCATE_NOT_PENDING			0x0420
+#define AC_INVALID_PROCESS			0x0430
+#define AC_ALLOCATION_ERROR			0x0440
+#define AC_ALLOCATION_FAILURE_NO_RETRY		0x0450
+#define AC_ALLOCATION_FAILURE_RETRY		0x0460
+#define AC_SECURITY_NOT_VALID			0x0470
+#define AC_TRANS_PGM_NOT_AVAIL_RETRY		0x0480
+#define AC_TRANS_PGM_NOT_AVAIL_NO_RETRY		0x0490
+#define AC_TP_NAME_NOT_RECOGNIZED		0x04A0
+#define AC_PIP_NOT_ALLOWED			0x04B0
+#define AC_PIP_NOT_SPECIFIED_CORRECTLY		0x04C0
+#define AC_CONVERSATION_TYPE_MISMATCH		0x04D0
+#define AC_SYNC_LEVEL_NOT_SUPPORTED		0x04E0
+#define AC_DEALLOC_ABEND			0x04F0
+#define AC_DEALLOC_ABEND_PROG			0x0500
+#define AC_DEALLOC_ABEND_SCV			0x0510
+#define AC_DEALLOC_ABEND_TIMER			0x0520
+#define AC_DEALLOC_NORMAL			0x0530
+#define AC_PROG_ERROR_NO_TRUNC			0x0540
+#define AC_PROG_ERROR_PURGING			0x0550
+#define AC_CONV_FAILURE_RETRY			0x0560
+#define AC_CONV_FAILURE_NO_RETRY		0x0570
+#define AC_SCV_ERROR_TRUNC			0x0580
+#define AC_SCV_ERROR_PURGING			0x0590
+#define AC_UNSUCCESSFUL				0x05A0
+#define AC_CONVERSATION_TYPE_MIXED		0x05B0
+#define AC_CANCELLED				0x05C0
+#define AC_SECURITY_REQUESTED_NOT_SUPPORTED	0x05D0
+#define AC_TP_BUSY				0x05E0
+#define AC_BACKED_OUT				0x05F0
+#define AC_BO_NO_RESYNC				0x0600
+#define AC_BO_RESYNC				0x0610
+#define AC_ACTIVATION_FAIL_RETRY		0x0620
+#define AC_ACTIVATION_FAIL_NO_RETRY		0x0630
+#define AC_SESSION_LIMITS_CLOSED		0x0640
+#define AC_SESSION_LIMITS_EXCEEDED		0x0650
+#define AC_VERB_IN_PROGRESS			0x0660
+#define AC_SESSION_DEACTIVATED			0x0670
+#define AC_COMM_SUBSYSTEM_ABENDED		0x0680
+#define AC_COMM_SUBSYSTEM_NOT_LOADED		0x0690
+#define AC_CONV_BUSY				0x06A0
+#define AC_INVALID_VERB				0x06B0
+
+
+/* Linux-SNA APPC call data structures. */
+struct sna_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	conv_type;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char 	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_mc_allocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	rtn_ctl;
+	unsigned long	conv_group_id;
+	unsigned long	sense_data;
+	unsigned char	plu_alias[8];
+	unsigned char	mode_name[8];
+	unsigned char	tp_name[64];
+	unsigned char	security;
+	unsigned char	pwd[10];
+	unsigned char	user_id[10];
+	unsigned short	pip_dlen;
+	unsigned char	*pip_dptr;
+	unsigned char	fqplu_name[17];
+};
+
+struct sna_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_deallocate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	dealloc_type;
+};
+
+struct sna_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_tp_properties {
+
+};
+
+struct sna_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_and_wait {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_request_to_send {
+
+};
+
+struct sna_mc_request_to_send {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_mc_send_data {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	data_type;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+	unsigned char	type;
+};
+
+struct sna_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_mc_confirm {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+};
+
+struct sna_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_confirmed {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_send_error {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	rts_rcvd;
+	unsigned char	err_type;
+	unsigned char	err_dir;
+	unsigned short	log_dlen;
+	unsigned char	*log_dptr;
+};
+
+struct sna_mc_send_error {
+        unsigned char   tp_id[8];
+        unsigned long   conv_id;
+        unsigned char   rts_rcvd;
+        unsigned char   err_type;
+        unsigned char   err_dir;
+        unsigned short  log_dlen;
+        unsigned char   *log_dptr;
+};
+
+struct sna_change_session_limit {
+
+};
+
+struct sna_init_session_limit {
+
+};
+
+struct sna_process_session_limit {
+
+};
+
+struct sna_reset_session_limit {
+
+};
+
+struct sna_mc_get_attributes {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	sync_level;
+	unsigned char	mode_name[8];
+	unsigned char	net_name[8];
+	unsigned char	lu_name[8];
+	unsigned char	lu_alias[8];
+	unsigned char	plu_alias[8];
+	unsigned char	plu_un_name[8];
+	unsigned char	fqplu_name[17];
+	unsigned char	user_id[10];
+	unsigned long	conv_group_id;
+	unsigned char	conv_corr_len;
+	unsigned char	conv_corr[8];
+	unsigned char	luw_id[26];
+	unsigned char	sess_id[8];
+};
+
+struct sna_get_type {
+
+};
+
+struct sna_set_syncpt_options {
+
+};
+
+struct sna_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_mc_flush {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+};
+
+struct sna_post_on_receipt {
+
+};
+
+struct sna_mc_post_on_receipt {
+
+};
+
+struct sna_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_mc_prepare_to_receive {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned char	ptr_type;
+	unsigned char	locks;
+};
+
+struct sna_receive_expedited_data {
+
+};
+
+struct sna_mc_receive_expedited_data {
+
+};
+
+struct sna_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	fill;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_mc_receive_immediate {
+	unsigned char	tp_id[8];
+	unsigned long	conv_id;
+	unsigned short	what_rcvd;
+	unsigned char	rtn_status;
+	unsigned char	rts_rcvd;
+	unsigned short	max_len;
+	unsigned short	dlen;
+	unsigned char	*dptr;
+};
+
+struct sna_send_expedited_data {
+
+};
+
+struct sna_mc_send_expedited_data {
+
+};
+
+struct sna_test {
+
+};
+
+struct sna_mc_test {
+
+};
+
+struct sna_wait {
+
+};
+
+struct sna_wait_for_completion {
+
+};
+
+struct sna_backout {
+
+};
+
+struct sna_prepare_for_syncpt {
+
+};
+
+struct sna_mc_prepare_for_syncpt {
+
+};
+
+struct sna_syncpt {
+
+};
+
+struct sna_activate_session {
+
+};
+
+struct sna_deactivate_conversation_group {
+
+};
+
+struct sna_deactivate_session {
+
+};
+
+struct sna_define_local_lu {
+
+};
+
+struct sna_define_mode {
+
+};
+
+struct sna_define_remote_lu {
+
+};
+
+struct sna_define_tp {
+
+};
+
+struct sna_delete {
+
+};
+
+struct sna_display_local_lu {
+
+};
+
+struct sna_display_mode {
+
+};
+
+struct sna_display_remote_lu {
+
+};
+
+struct sna_display_tp {
+
+};
+
+struct sna_process_signoff {
+
+};
+
+struct sna_signoff {
+
+};
+
+extern void appc(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr);
+
+#ifdef __KERNEL__
+
+struct appc_ops {
+	int family;
+};
+
+#endif /* __KERNEL__ */
+#endif /* _APPC_H */
diff -ruN linux-2.4.4/include/linux/attach.h linux/include/linux/attach.h
--- linux-2.4.4/include/linux/attach.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/attach.h	Mon May 14 19:47:38 2001
@@ -0,0 +1,66 @@
+#ifndef _LINUX_ATTACH_H
+#define _LINUX_ATTACH_H
+
+struct tp_info {
+        char            tp_name[64];
+        unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+        unsigned long   flags;
+};
+
+struct tp_attach {
+	char		tp_name[64];
+	int		tp_len;
+	unsigned long	tcb_id;
+	char		netid[17];
+	char		luow_id[6];
+	char		raw_attach_hdr[100];
+};
+
+#ifdef __KERNEL__
+
+typedef enum {
+        AT_RESET = 1,
+        AT_INIT,
+        AT_WAITING,
+        AT_ATTACHED
+} attach_state;
+
+struct attach_tps {
+	struct attach_tps *next;
+	struct attach_tps *prev;
+
+	attach_state	state;
+	unsigned short	flags;
+	pid_t		pid;
+	unsigned long	id;
+
+	char		tp_name[64];
+	unsigned char   cnv_type;
+        unsigned char   sync_level;
+        unsigned long   limit;
+};
+
+struct attach {
+        unsigned short          flags;
+
+        struct attach_ops       *ops;		/* Calls backs for this ID */
+	struct attach_tps	*tps;		/* All TPs using the attach */
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+
+        wait_queue_head_t       wait;
+};
+
+struct attach_ops {
+        int family;
+        int (*tp_correlate)  (pid_t pid, unsigned long tcb_id, char *tp_name);
+        int (*attach_listen) (struct attach *at, void *buf, int len);
+};
+
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+#endif /* __KERNEL__ */
+#endif /* __LINUX_ATTACH_H */
diff -ruN linux-2.4.4/include/linux/cpic.h linux/include/linux/cpic.h
--- linux-2.4.4/include/linux/cpic.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/cpic.h	Mon May 14 19:47:55 2001
@@ -0,0 +1,855 @@
+/* cpic.h: CPI Communications Header.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef _CPIC_H
+#define _CPIC_H
+
+#define CM_INT32 signed long int
+#define CM_ENTRY extern void
+#define CM_PTR *
+
+typedef unsigned char CONVERSATION_ID [8];
+typedef unsigned char CONTEXT_ID [32];
+typedef unsigned char SECURITY_PASSWORD [10];
+typedef unsigned char SECURITY_USER_ID [10];
+
+typedef CM_INT32 CM_AE_QUAL_OR_AP_TITLE_FORMAT;
+typedef CM_INT32 CM_ALLOCATE_CONFIRM_TYPE;
+typedef CM_INT32 CM_BEGIN_TRANSACTION;
+typedef CM_INT32 CM_BUFFER_LENGTH;
+typedef CM_INT32 CM_CALL_ID;
+typedef CM_INT32 CM_COMPLETED_OP_COUNT;
+typedef CM_INT32 CM_CONFIRMATION_URGENCY;
+typedef CM_INT32 CM_CONTEXT_ID_LENGTH;
+typedef CM_INT32 CM_CONTROL_INFORMATION_RECEIVED;
+typedef CM_INT32 CM_CONVERSATION_QUEUE;
+typedef CM_INT32 CM_CONVERSATION_RETURN_CODE;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 CM_SECURITY_PASSWORD_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_SECURITY_LENGTH;
+typedef CM_INT32 CM_SECURITY_USER_ID_LENGTH;
+typedef CM_INT32 CM_CONVERSATION_STATE;
+typedef CM_INT32 CM_CONVERSATION_TYPE;
+typedef CM_INT32 CM_DATA_RECEIVED_TYPE;
+typedef CM_INT32 CM_DEALLOCATE_TYPE;
+typedef CM_INT32 CM_DIRECTORY_ENCODING;
+typedef CM_INT32 CM_DIRECTORY_SYNTAX;
+typedef CM_INT32 CM_ERROR_DIRECTION;
+typedef CM_INT32 CM_FILL;
+typedef CM_INT32 CM_MAXIMUM_BUFFER_SIZE;
+typedef CM_INT32 CM_OOID;
+typedef CM_INT32 CM_PARTNER_ID_SCOPE;
+typedef CM_INT32 CM_PARTNER_ID_TYPE;
+typedef CM_INT32 CM_PREPARE_DATA_PERMITTED_TYPE;
+typedef CM_INT32 CM_PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 CM_PROCESSING_MODE;
+typedef CM_INT32 CM_RECEIVE_TYPE;
+typedef CM_CONTROL_INFORMATION_RECEIVED CM_REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETURN_CODE;
+typedef CM_INT32 CM_RETURN_CONTROL;
+typedef CM_INT32 CM_SEND_RECEIVE_MODE;
+typedef CM_INT32 CM_SEND_TYPE;
+typedef CM_INT32 CM_STATUS_RECEIVED;
+typedef CM_INT32 CM_SYNC_LEVEL;
+typedef CM_INT32 CM_TIMEOUT;
+typedef CM_INT32 CM_TRANSACTION_CONTROL;
+typedef CM_INT32 CONVERSATION_TYPE;
+typedef CM_INT32 CONVERSATION_SECURITY_TYPE;
+typedef CM_INT32 DATA_RECEIVED;
+typedef CM_INT32 DEALLOCATE_TYPE;
+typedef CM_INT32 ERROR_DIRECTION;
+typedef CM_INT32 PREPARE_TO_RECEIVE_TYPE;
+typedef CM_INT32 PROCESSING_MODE;
+typedef CM_INT32 RECEIVE_TYPE;
+typedef CM_INT32 REQUEST_TO_SEND_RECEIVED;
+typedef CM_INT32 CM_RETCODE;
+typedef CM_INT32 RETURN_CONTROL;
+typedef CM_INT32 SEND_TYPE;
+typedef CM_INT32 STATUS_RECEIVED;
+typedef CM_INT32 SYNC_LEVEL;
+
+#define CM_DN	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 0
+#define CM_OID	(CM_AE_QUAL_OR_AP_TITLE_FORMAT) 1
+
+/* Allocate_confirm values. */
+#define CM_ALLOCATE_NO_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 0
+#define CM_ALLOCATE_CONFIRM	(CM_ALLOCATE_CONFIRM_TYPE) 1
+
+/* begin_transaction values. */
+#define CM_BEGIN_IMPLICIT	(CM_BEGIN_TRANSACTION) 0
+#define CM_BEGIN_EXPLICIT	(CM_BEGIN_TRANSACTION) 1
+
+/* call_ID values. */
+#define CM_CMACCI		(CM_CALL_ID) 1
+#define CM_CMACCP		(CM_CALL_ID) 2
+#define CM_CMALLC		(CM_CALL_ID) 3
+#define CM_CMCANC		(CM_CALL_ID) 4
+#define CM_CMCFM		(CM_CALL_ID) 5
+#define CM_CMCFMD		(CM_CALL_ID) 6
+#define CM_CMCNVI		(CM_CALL_ID) 7
+#define CM_CMCNVO		(CM_CALL_ID) 8
+#define CM_CMDEAL		(CM_CALL_ID) 9
+#define CM_CMDFDE		(CM_CALL_ID) 10
+#define CM_CMEACN		(CM_CALL_ID) 11
+#define CM_CMEAEQ		(CM_CALL_ID) 12
+#define CM_CMEAPT		(CM_CALL_ID) 13
+#define CM_CMECS		(CM_CALL_ID) 14
+#define CM_CMECT		(CM_CALL_ID) 15
+#define CM_CMECTX		(CM_CALL_ID) 16
+#define CM_CMEID		(CM_CALL_ID) 17
+#define CM_CMEMBS		(CM_CALL_ID) 18
+#define CM_CMEMN		(CM_CALL_ID) 19
+#define CM_CMEPID		(CM_CALL_ID) 20
+#define CM_CMEPLN		(CM_CALL_ID) 21
+#define CM_CMESI		(CM_CALL_ID) 22
+#define CM_CMESL		(CM_CALL_ID) 23
+#define CM_CMESRM		(CM_CALL_ID) 24
+#define CM_CMESUI		(CM_CALL_ID) 25
+#define CM_CMETC		(CM_CALL_ID) 26
+#define CM_CMETPN		(CM_CALL_ID) 27
+#define CM_CMFLUS		(CM_CALL_ID) 28
+#define CM_CMINCL		(CM_CALL_ID) 29
+#define CM_CMINIC		(CM_CALL_ID) 30
+#define CM_CMINIT		(CM_CALL_ID) 31
+#define CM_CMPREP		(CM_CALL_ID) 32
+#define CM_CMPTR		(CM_CALL_ID) 33
+#define CM_CMRCV		(CM_CALL_ID) 34
+#define CM_CMRCVX		(CM_CALL_ID) 35
+#define CM_CMRLTP		(CM_CALL_ID) 36
+#define CM_CMRTS		(CM_CALL_ID) 37
+#define CM_CMSAC		(CM_CALL_ID) 38
+#define CM_CMSACN		(CM_CALL_ID) 39
+#define CM_CMSAEQ		(CM_CALL_ID) 40
+#define CM_CMSAPT		(CM_CALL_ID) 41
+#define CM_CMSBT		(CM_CALL_ID) 42
+#define CM_CMSCSP		(CM_CALL_ID) 43
+#define CM_CMSCST		(CM_CALL_ID) 44
+#define CM_CMSCSU		(CM_CALL_ID) 45
+#define CM_CMSCT		(CM_CALL_ID) 46
+#define CM_CMSCU		(CM_CALL_ID) 47
+#define CM_CMSDT		(CM_CALL_ID) 48
+#define CM_CMSED		(CM_CALL_ID) 49
+#define CM_CMSEND		(CM_CALL_ID) 50
+#define CM_CMSERR		(CM_CALL_ID) 51
+#define CM_CMSF			(CM_CALL_ID) 52
+#define CM_CMSID		(CM_CALL_ID) 53
+#define CM_CMSLD		(CM_CALL_ID) 54
+#define CM_CMSLTP		(CM_CALL_ID) 55
+#define CM_CMSMN		(CM_CALL_ID) 56
+#define CM_CMSNDX		(CM_CALL_ID) 57
+#define CM_CMSPDP		(CM_CALL_ID) 58
+#define CM_CMSPID		(CM_CALL_ID) 59
+#define CM_CMSPLN		(CM_CALL_ID) 60
+#define CM_CMSPM		(CM_CALL_ID) 61
+#define CM_CMSPTR		(CM_CALL_ID) 62
+#define CM_CMSQCF		(CM_CALL_ID) 63
+#define CM_CMSQPM		(CM_CALL_ID) 64
+#define CM_CMSRC		(CM_CALL_ID) 65
+#define CM_CMSRT		(CM_CALL_ID) 66
+#define CM_CMSSL		(CM_CALL_ID) 67
+#define CM_CMSSRM		(CM_CALL_ID) 68
+#define CM_CMSST		(CM_CALL_ID) 69
+#define CM_CMSTC		(CM_CALL_ID) 70
+#define CM_CMSTPN		(CM_CALL_ID) 71
+#define CM_CMTRTS		(CM_CALL_ID) 72
+#define CM_CMWAIT		(CM_CALL_ID) 73
+#define CM_CMWCMP		(CM_CALL_ID) 74
+
+/* confirmation_urgency values. */
+#define CM_CONFIRMATION_NOT_URGENT	(CM_CONFIRMATION_URGENCY) 0
+#define CM_CONFIRMATION_URGENT		(CM_CONFIRMATION_URGENCY) 1
+
+/* control_information_received, request_to_send_received_values. */
+#define CM_NO_CONTROL_INFO_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_NOT_RECEIVED	(CM_CONTROL_INFORMATION_RECEIVED) 0
+#define CM_REQ_TO_SEND_RECEIVED		(CM_CONTROL_INFORMATION_RECEIVED) 1
+#define CM_ALLOCATE_CONFIRMED		(CM_CONTROL_INFORMATION_RECEIVED) 2
+#define CM_ALLOCATE_CONFIRMED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 3
+#define CM_ALLOCATE_REJECTED_WITH_DATA	(CM_CONTROL_INFORMATION_RECEIVED) 4
+#define CM_EXPEDITED_DATA_AVAILABLE	(CM_CONTROL_INFORMATION_RECEIVED) 5
+#define CM_RTS_RCVD_AND_EXP_DATA_AVAIL	(CM_CONTROL_INFORMATION_RECEIVED) 6
+
+/* conversation_queue values. */
+#define CM_INITIALIZATION_QUEUE		(CM_CONVERSATION_QUEUE) 0
+#define CM_SEND_QUEUE			(CM_CONVERSATION_QUEUE) 1
+#define CM_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 2
+#define CM_SEND_RECEIVE_QUEUE		(CM_CONVERSATION_QUEUE) 3
+#define CM_EXPEDITED_SEND_QUEUE		(CM_CONVERSATION_QUEUE) 4
+#define CM_EXPEDITED_RECEIVE_QUEUE	(CM_CONVERSATION_QUEUE) 5
+
+/* conversation_state values. */
+#define CM_INITIALIZE_STATE		(CM_CONVERSATION_STATE) 2
+#define CM_SEND_STATE			(CM_CONVERSATION_STATE) 3
+#define CM_RECEIVE_STATE		(CM_CONVERSATION_STATE) 4
+#define CM_SEND_PENDING_STATE		(CM_CONVERSATION_STATE) 5
+#define CM_CONFIRM_STATE		(CM_CONVERSATION_STATE) 6
+#define CM_CONFIRM_SEND_STATE		(CM_CONVERSATION_STATE) 7
+#define CM_CONFIRM_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 8
+#define CM_DEFER_RECEIVE_STATE		(CM_CONVERSATION_STATE) 9
+#define CM_DEFER_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 10
+#define CM_SYNC_POINT_STATE		(CM_CONVERSATION_STATE) 11
+#define CM_SYNC_POINT_SEND_STATE	(CM_CONVERSATION_STATE) 12
+#define CM_SYNC_POINT_DEALLOCATE_STATE	(CM_CONVERSATION_STATE) 13
+#define CM_INITIALIZE_INCOMING_STATE	(CM_CONVERSATION_STATE) 14
+#define CM_SEND_ONLY_STATE		(CM_CONVERSATION_STATE) 15
+#define CM_RECEIVE_ONLY_STATE		(CM_CONVERSATION_STATE) 16
+#define CM_SEND_RECEIVE_STATE		(CM_CONVERSATION_STATE) 17
+#define CM_PREPARED_STATE		(CM_CONVERSATION_STATE) 18
+
+/* conversation_type value. */
+#define CM_BASIC_CONVERSATION		(CM_CONVERSATION_TYPE) 0
+#define CM_MAPPED_CONVERSATION		(CM_CONVERSATION_TYPE) 1
+
+/* data_received values. */
+#define CM_NO_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 0
+#define CM_DATA_RECEIVED		(CM_DATA_RECEIVED_TYPE) 1
+#define CM_COMPLETE_DATA_RECEIVED	(CM_DATA_RECEIVED_TYPE) 2
+#define CM_INCOMPLETE_DATA_RECEVIED	(CM_DATA_RECEIVED_TYPE) 3
+
+/* deallocate_type values. */
+#define CM_DEALLOCATE_SYNC_LEVEL	(CM_DEALLOCATE_TYPE) 0
+#define CM_DEALLOCATE_FLUSH		(CM_DEALLOCATE_TYPE) 1
+#define CM_DEALLOCATE_CONFIRM		(CM_DEALLOCATE_TYPE) 2
+#define CM_DEALLOCATE_ABEND		(CM_DEALLOCATE_TYPE) 3
+
+/* directory_encoding values. */
+#define CM_DEFAULT_ENCODING		(CM_DIRECTORY_ENCODING) 0
+#define CM_UNICODE_ENCODING		(CM_DIRECTORY_ENCODING) 1
+
+/* directory_syntax values. */
+#define CM_DEFAULT_SYNTAX		(CM_DIRECTORY_SYNTAX) 0
+#define CM_DCE_SYNTAX			(CM_DIRECTORY_SYNTAX) 1
+#define CM_XDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 2
+#define CM_NDS_SYNTAX			(CM_DIRECTORY_SYNTAX) 3
+
+/* error_direction values. */
+#define CM_RECEIVE_ERROR		(CM_ERROR_DIRECTION) 0
+#define CM_SEND_ERROR			(CM_ERROR_DIRECTION) 1
+
+/* fill values. */
+#define CM_FILL_LL			(CM_FILL) 0
+#define CM_FILL_BUFFER			(CM_FILL) 1
+
+/* partner_ID_scope values. */
+#define CM_EXPLICIT			(CM_PARTNER_ID_SCOPE) 0
+#define CM_REFERENCE			(CM_PARTNER_ID_SCOPE) 1
+
+/* partner_ID_type values. */
+#define CM_DISTINGUISHED_NAME		(CM_PARTNER_ID_TYPE) 0
+#define CM_LOCAL_DISTINGUISHED_NAME	(CM_PARTNER_ID_TYPE) 1
+#define CM_PROGRAM_FUNCTION_ID		(CM_PARTNER_ID_TYPE) 2
+#define CM_OSI_TPSU_TITLE_OID		(CM_PARTNER_ID_TYPE) 3
+#define CM_PROGRAM_BINDING		(CM_PARTNER_ID_TYPE) 4
+
+/* prepare_data_permitted values. */
+#define CM_PREPARE_DATA_NOT_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 0
+#define CM_PREPARE_DATA_PERMITTED	(CM_PREPARE_DATA_PERMITTED_TYPE) 1
+
+/* prepare_to_receive_type values. */
+#define CM_PREP_TO_RECEIVE_SYNC_LEVEL	(CM_PREPARE_TO_RECEIVE_TYPE) 0
+#define CM_PREP_TO_RECEIVE_FLUSH	(CM_PREPARE_TO_RECEIVE_TYPE) 1
+#define CM_PREP_TO_RECEIVE_CONFIRM	(CM_PREPARE_TO_RECEIVE_TYPE) 2
+
+/* processing_mode values. */
+#define CM_BLOCKING			(CM_PROCESSING_MODE) 0
+#define CM_NON_BLOCKING			(CM_PROCESSING_MODE) 1
+
+/* receive_type values. */
+#define CM_RECEIVE_AND_WAIT		(CM_RECEIVE_TYPE) 0
+#define CM_RECEIVE_IMMEDIATE		(CM_RECEIVE_TYPE) 1
+
+/* return_code values. */
+#define CM_OK				(CM_RETURN_CODE) 0
+#define CM_ALLOCATE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 1
+#define CM_ALLOCATE_FAILURE_RETRY	(CM_RETURN_CODE) 2
+#define CM_CONVERSATION_TYPE_MISMATCH	(CM_RETURN_CODE) 3
+#define CM_PIP_NOT_SPECIFIED_CORRECTLY	(CM_RETURN_CODE) 5
+#define CM_SECURITY_NOT_VALID		(CM_RETURN_CODE) 6
+#define CM_SYNC_LVL_NOT_SUPPORTED_LU	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_SYS	(CM_RETURN_CODE) 7
+#define CM_SYNC_LVL_NOT_SUPPORTED_PGM	(CM_RETURN_CODE) 8
+#define CM_TPN_NOT_RECOGNIZED		(CM_RETURN_CODE) 9
+#define CM_TP_NOT_AVAILABLE_NO_RETRY	(CM_RETURN_CODE) 10
+#define CM_TP_NOT_AVAILABLE_RETRY	(CM_RETURN_CODE) 11
+#define CM_DEALLOCATED_ABEND		(CM_RETURN_CODE) 17
+#define CM_DEALLOCATED_NORMAL		(CM_RETURN_CODE) 18
+#define CM_PARAMETER_ERROR		(CM_RETURN_CODE) 19
+#define CM_PRODUCT_SPECIFIC_ERROR	(CM_RETURN_CODE) 20
+#define CM_PROGRAM_ERROR_NO_TRUNC	(CM_RETURN_CODE) 21
+#define CM_PROGRAM_ERROR_PURGING	(CM_RETURN_CODE) 22
+#define CM_PROGRAM_ERROR_TRUNC		(CM_RETURN_CODE) 23
+#define CM_PROGRAM_PARAMETER_CHECK	(CM_RETURN_CODE) 24
+#define CM_PROGRAM_STATE_CHECK		(CM_RETURN_CODE) 25
+#define CM_RESOURCE_FAILURE_NO_RETRY	(CM_RETURN_CODE) 26
+#define CM_RESOURCE_FAILURE_RETRY	(CM_RETURN_CODE) 27
+#define CM_UNSUCCESSFUL			(CM_RETURN_CODE) 28
+#define CM_DEALLOCATED_ABEND_SVC	(CM_RETURN_CODE) 30
+#define CM_DEALLOCATED_ABEND_TIMER	(CM_RETURN_CODE) 31
+#define CM_SVC_ERROR_NO_TRUNC		(CM_RETURN_CODE) 32
+#define CM_SVC_ERROR_PURGING		(CM_RETURN_CODE) 33
+#define CM_SVC_ERROR_TRUNC		(CM_RETURN_CODE) 34
+#define CM_OPERATION_INCOMPLETE		(CM_RETURN_CODE) 35
+#define CM_SYSTEM_EVENT			(CM_RETURN_CODE) 36
+#define CM_OPERATION_NOT_ACCEPTED	(CM_RETURN_CODE) 37
+#define CM_CONVERSATION_ENDING		(CM_RETURN_CODE) 38
+#define CM_SEND_RCV_MODE_NOT_SUPPORTED	(CM_RETURN_CODE) 39
+#define CM_BUFFER_TOO_SMALL		(CM_RETURN_CODE) 40
+#define CM_EXP_DATA_NOT_SUPPORTED	(CM_RETURN_CODE) 41
+#define CM_DEALLOC_CONFIRM_REJECT	(CM_RETURN_CODE) 42
+#define CM_ALLOCATION_ERROR		(CM_RETURN_CODE) 43
+#define CM_RETRY_LIMIT_EXCEEDED		(CM_RETURN_CODE) 44
+#define CM_NO_SECONDARY_INFORMATION	(CM_RETURN_CODE) 45
+#define CM_SECURITY_NOT_SUPPORTED	(CM_RETURN_CODE) 46
+#define CM_SECURITY_MUTUAL_FAILED	(CM_RETURN_CODE) 47
+#define CM_CALL_NOT_SUPPORTED		(CM_RETURN_CODE) 48
+#define CM_PARM_VALUE_NOT_SUPPORTED	(CM_RETURN_CODE) 49
+#define CM_TAKE_BACKOUT			(CM_RETURN_CODE) 100
+#define CM_DEALLOCATED_ABEND_BO		(CM_RETURN_CODE) 130
+#define CM_DEALLOCATED_ABEND_SVC_BO	(CM_RETURN_CODE) 131
+#define CM_DEALLOCATED_ABEND_TIMER_BO	(CM_RETURN_CODE) 132
+#define CM_RESOURCE_FAIL_NO_RETRY_BO	(CM_RETURN_CODE) 133
+#define CM_RESOURCE_FAILURE_RETRY_BO	(CM_RETURN_CODE) 134
+#define CM_DEALLOCATED_NORMAL_BO	(CM_RETURN_CODE) 135
+#define CM_CONV_DEALLOC_AFTER_SYNCPT	(CM_RETURN_CODE) 136
+#define CM_INCLUDE_PARTNER_REJECT_BO	(CM_RETURN_CODE) 137
+
+/* return_control values. */
+#define CM_WHEN_SESSION_ALLOCATED	(CM_RETURN_CONTROL) 0
+#define CM_IMMEDIATE			(CM_RETURN_CONTROL) 1
+
+/* send_receive_mode values. */
+#define CM_HALF_DUPLEX			(CM_SEND_RECEIVE_MODE) 0
+#define CM_FULL_DUPLEX			(CM_SEND_RECEIVE_MODE) 1
+
+/* send_type values. */
+#define CM_BUFFER_DATA			(CM_SEND_TYPE) 0
+#define CM_SEND_AND_FLUSH		(CM_SEND_TYPE) 1
+#define CM_SEND_AND_CONFIRM		(CM_SEND_TYPE) 2
+#define CM_SEND_AND_PREP_TO_RECEIVE	(CM_SEND_TYPE) 3
+#define CM_SEND_AND_DEALLOCATE		(CM_SEND_TYPE) 4
+
+/* status_received values. */
+#define CM_NO_STATUS_RECEIVED		(CM_STATUS_RECEIVED) 0
+#define CM_SEND_RECEIVED		(CM_STATUS_RECEIVED) 1
+#define CM_CONFIRM_RECEIVED		(CM_STATUS_RECEIVED) 2
+#define CM_CONFIRM_SEND_RECEIVED	(CM_STATUS_RECEIVED) 3
+#define CM_CONFIRM_DEALLOC_RECEIVED	(CM_STATUS_RECEIVED) 4
+#define CM_TAKE_COMMIT			(CM_STATUS_RECEIVED) 5
+#define CM_TAKE_COMMIT_SEND		(CM_STATUS_RECEIVED) 6
+#define CM_TAKE_COMMIT_DEALLOCATE	(CM_STATUS_RECEIVED) 7
+#define CM_TAKE_COMMIT_DATA_OK		(CM_STATUS_RECEIVED) 8
+#define CM_TAKE_COMMIT_SEND_DATA_OK	(CM_STATUS_RECEIVED) 9
+#define CM_TAKE_COMMIT_DEALLOC_DATA_OK	(CM_STATUS_RECEIVED) 10
+#define CM_PREPARE_OK			(CM_STATUS_RECEIVED) 11
+#define CM_JOIN_TRANSACTION		(CM_STATUS_RECEIVED) 12
+
+/* sync_level values. */
+#define CM_NONE				(CM_SYNC_LEVEL) 0
+#define CM_CONFIRM			(CM_SYNC_LEVEL) 1
+#define CM_SYNC_POINT			(CM_SYNC_LEVEL) 2
+#define CM_SYNC_POINT_NO_CONFIRM	(CM_SYNC_LEVEL) 3
+
+/* conversation_security_type values. */
+#define CM_SECURITY_NONE		(CM_CONVERSATION_SECURITY_TYPE) 0
+#define CM_SECURITY_SAME		(CM_CONVERSATION_SECURITY_TYPE) 1
+#define CM_SECURITY_PROGRAM		(CM_CONVERSATION_SECURITY_TYPE) 2
+#define CM_SECURITY_DISTRIBUTED		(CM_CONVERSATION_SECURITY_TYPE) 3
+#define CM_SECURITY_MUTUAL		(CM_CONVERSATION_SECURITY_TYPE) 4
+#define CM_SECURITY_PROGRAM_STRONG	(CM_CONVERSATION_SECURITY_TYPE) 5
+
+/* transaction_control values. */
+#define CM_CHAINED_TRANSACTIONS		(CM_TRANSACTION_CONTROL) 0
+#define CM_UNCHAINED_TRANSACTIONS	(CM_TRANSACTION_CONTROL) 1
+
+/* maximum sizes of strings and buffers. */
+#define CM_CID_SIZE	(8)	/* converstation ID. */
+#define CM_CTX_SIZE	(32)	/* context ID. */
+#define CM_LD_SIZE	(512)	/* log data. */
+#define CM_MN_SIZE	(8)	/* mode name. */
+#define CM_PLN_SIZE	(17)	/* partner LU name. */
+#define CM_PW_SIZE	(10)	/* password. */
+#define CM_SDN_SIZE	(8)	/* synbolic destination name. */
+#define CM_TPN_SIZE	(64)	/* TP name. */
+#define CM_UID_SIZE	(10)	/* userid ID. */
+
+CM_ENTRY cmacci(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmaccp(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmallc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcanc(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfm(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcfmd(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmcnvo(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdeal(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmdfde(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmecs(unsigned char CM_PTR,
+        CM_CONVERSATION_STATE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmect(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmectx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmeid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmembs(CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmemn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmepln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesi(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmesui(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmetpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmflus(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmincl(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminic(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cminit(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmprep(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmptr(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcv(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_DATA_RECEIVED_TYPE CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_STATUS_RECEIVED CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrcvx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmrts(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsaeq(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsac(unsigned char CM_PTR,
+        CM_ALLOCATE_CONFIRM_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsacn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsapt(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_AE_QUAL_OR_AP_TITLE_FORMAT CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsbt(unsigned char CM_PTR,
+        CM_BEGIN_TRANSACTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsp(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscst(unsigned char CM_PTR,
+        CM_CONVERSATION_SECURITY_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscsu(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsct(unsigned char CM_PTR,
+        CM_CONVERSATION_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmscu(unsigned char CM_PTR,
+        CM_CONFIRMATION_URGENCY CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsdt(unsigned char CM_PTR,
+        CM_DEALLOCATE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsed(unsigned char CM_PTR,
+        CM_ERROR_DIRECTION CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsend(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmserr(unsigned char CM_PTR,
+	CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsf(unsigned char CM_PTR,
+        CM_FILL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsid(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsld(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsltp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsmn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsndx(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspdp(unsigned char CM_PTR,
+        CM_PREPARE_DATA_PERMITTED_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspid(unsigned char CM_PTR,
+        CM_PARTNER_ID_TYPE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_PARTNER_ID_SCOPE CM_PTR,
+        CM_DIRECTORY_SYNTAX CM_PTR,
+        CM_DIRECTORY_ENCODING CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspln(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmspm(unsigned char CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsptr(unsigned char CM_PTR,
+        CM_PREPARE_TO_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqcf(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsqpm(unsigned char CM_PTR,
+        CM_CONVERSATION_QUEUE CM_PTR,
+        CM_PROCESSING_MODE CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrc(unsigned char CM_PTR,
+        CM_RETURN_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsrt(unsigned char CM_PTR,
+        CM_RECEIVE_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssl(unsigned char CM_PTR,
+        CM_SYNC_LEVEL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmssrm(unsigned char CM_PTR,
+        CM_SEND_RECEIVE_MODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmsst(unsigned char CM_PTR,
+        CM_SEND_TYPE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstc(unsigned char CM_PTR,
+        CM_TRANSACTION_CONTROL CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmstpn(unsigned char CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmtrts(unsigned char CM_PTR,
+        CM_CONTROL_INFORMATION_RECEIVED CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwait(unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+CM_ENTRY cmwcmp(unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_INT32 CM_PTR,
+        unsigned char CM_PTR,
+        CM_RETURN_CODE CM_PTR);
+
+/* Macros to use long descriptive names instead of crusty CPI-C names. */
+#define Accept_Conversation(v1,v2)			cmaccp(v1,v2)
+#define Accept_Incoming(v1,v2)				cmacci(v1,v2)
+#define Allocate(v1,v2)					cmallc(v1,v2)
+#define Cancel_Conversation(v1,v2)			cmcanc(v1,v2)
+#define Confirm(v1,v2,v3)				cmcfm(v1,v2,v3)
+#define Confirmed(v1,v2)				cmcfmd(v1,v2)
+#define Convert_Incoming(v1,v2,v3)			cmcnvi(v1,v2,v3)
+#define Convert_Outgoing(v1,v2,v3)			cmcnvo(v1,v2,v3)
+#define Deallocate(v1,v2)				cmdeal(v1,v2)
+#define Deferred_Deallocate(v1,v2)			cmdfde(v1,v2)
+#define Extract_AE_Qualifier(v1,v2,v3,v4,v5)		cmeaeq(v1,v2,v3,v4,v5)
+#define Extract_AP_Title(v1,v2,v3,v4,v5)		cmeapt(v1,v2,v3,v4,v5)
+#define Extract_Application_Context_Name(v1,v2,v3,v4)	cmeacn(v1,v2,v3,v4)
+#define Extract_Conversation_Context(v1,v2,v3,v4)	cmectx(v1,v2,v3,v4)
+#define Extract_Conversation_State(v1,v2,v3)		cmecs(v1,v2,v3)
+#define Extract_Conversation_Type(v1,v2,v3)		cmect(v1,v2,v3)
+#define Extract_Initialization_Data(v1,v2,v3,v4,v5)	cmeid(v1,v2,v3,v4,v5)
+#define Extract_Maximum_Buffer_Size(v1,v2)		cmembs(v1,v2)
+#define Extract_Mode_Name(v1,v2,v3,v4,v5)		cmemn(v1,v2,v3,v4,v5)
+#define Extract_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8,v9) \
+	cmepid(v1,v2,v3,v4,v5,v6,v7,v8,v9)
+#define Extract_Partner_LU_Name(v1,v2,v3,v4)		cmpln(v1,v2,v3,v4)
+#define Extract_Secondary_Information(v1,v2,v3,v4,v5,v6,v7) \
+	cmesi(v1,v2,v3,v4,v5,v6,v7)
+#define Extract_Security_User_ID(v1,v2,v3,v4)		cmesui(v1,v2,v3,v4)
+#define Extract_Send_Receive_Mode(v1,v2,v3)		cmesrm(v1,v2,v3)
+#define Extract_Sync_Level(v1,v2,v3)			cmesl(v1,v2,v3)
+#define Extract_Transaction_Control(v1,v2,v3)		cmetc(v1,v2,v3)
+#define Extract_TP_Name(v1,v2,v3,v4)			cmetpn(v1,v2,v3,v4)
+#define Flush(v1,v2)					cmflus(v1,v2)
+#define Include_Partner_In_Transaction(v1,v2)		cmincl(v1,v2)
+#define Initialize_Conversation(v1,v2,v3)		cminit(v1,v2,v3)
+#define Initialize_For_Incomint(v1,v2)			cminic(v1,v2)
+#define Prepare(v1,v2)					cmprep(v1,v2)
+#define Prepare_To_Receive(v1,v2)			cmptr(v1,v2)
+#define Receive(v1,v2,v3,v4,v5,v6,v7,v8)		\
+	cmrcv(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Receive_Expedited_Data(v1,v2,v3,v4,v5,v6,v7)	\
+	cmrcvx(v1,v2,v3,v4,v5,v6,v7)
+#define Release_Local_TP_Name(v1,v2,v3)			cmrltp(v1,v2,v3)
+#define Request_To_Send(v1,v2)				cmrts(v1,v2)
+#define Send_Data(v1,v2,v3,v4,v5)			cmsend(v1,v2,v3,v4,v5)
+#define Send_Error(v1,v2,v3)				cmserr(v1,v2,v3)
+#define Send_Expedited_Data(v1,v2,v3,v4,v5)		cmsndx(v1,v2,v3,v4,v5)
+#define Set_AE_Qualifier(v1,v2,v3,v4,v5)		cmsaeq(v1,v2,v3,v4,v5)
+#define Set_Allocate_Confirm(v1,v2,v3)			cmsac(v1,v2,v3)
+#define Set_AP_Title(v1,v2,v3,v4,v5)			cmsapt(v1,v2,v3,v4,v5)
+#define Set_Application_Context_Name(v1,v2,v3,v4)	cmsacn(v1,v2,v3,v4)
+#define Set_Begin_Transaction(v1,v2,v3)			cmsbt(v1,v2,v3)
+#define Set_Confirmation_Urgency(v1,v2,v3)		cmscu(v1,v2,v3)
+#define Set_Conversation_Security_Password(v1,v2,v3,v4)	cmscsp(v1,v2,v3,v4)
+#define Set_Conversation_Security_Type(v1,v2,v3)	cmscst(v1,v2,v3)
+#define Set_Conversation_Security_User_ID(v1,v2,v3,v4)	cmscsu(v1,v2,v3,v4)
+#define Set_Conversation_Type(v1,v2,v3)			cmsct(v1,v2,v3)
+#define Set_Deallocate_Type(v1,v2,v3)			cmsdt(v1,v2,v3)
+#define Set_Error_Direction(v1,v2,v3)			cmsed(v1,v2,v3)
+#define Set_Fill(v1,v2,v3)				cmsf(v1,v2,v3)
+#define Set_Initialization_Data(v1,v2,v3,v4)		cmsid(v1,v2,v3,v4)
+#define Set_Log_Data(v1,v2,v3,v4)			cmsld(v1,v2,v3,v4)
+#define Set_Mode_Name(v1,v2,v3,v4)			cmsmn(v1,v2,v3,v4)
+#define Set_Partner_ID_Name(v1,v2,v3,v4,v5,v6,v7,v8)	\
+	cmspid(v1,v2,v3,v4,v5,v6,v7,v8)
+#define Set_Partner_LU_Name(v1,v2,v3,v4)		cmspln(v1,v2,v3,v4)
+#define Set_Prepare_Data_Permitted(v1,v2,v3)		cmspdp(v1,v2,v3)
+#define Set_Prepare_To_Receive_Type(v1,v2,v3)		cmsptr(v1,v2,v3)
+#define Set_Processing_Mode(v1,v2,v3)			cmspm(v1,v2,v3)
+#define Set_Queue_Callback_Function(v1,v2,v3,v4,v5,v6)	\
+	cmsqcf(v1,v2,v3,v4,v5,v6)
+#define Set_Queue_Processing_Mode(v1,v2,v3,v4,v5,v6)	\
+	cmsqpm(v1,v2,v3,v4,v5,v6)
+#define Set_Receive_Type(v1,v2,v3)			cmsrt(v1,v2,v3)
+#define Set_Return_Control(v1,v2,v3)			cmsrc(v1,v2,v3)
+#define Set_Send_Type(v1,v2,v3)				cmsst(v1,v2,v3)
+#define Set_Sync_Level(v1,v2,v3)			cmssl(v1,v2,v3)
+#define Set_TP_Name(v1,v2,v3,v4)			cmstpn(v1,v2,v3,v4)
+#define Set_Transaction_Control(v1,v2,v3)		cmstc(v1,v2,v3)
+#define Specify_Local_TP_Name(v1,v2,v3)			cmsltp(v1,v2,v3)
+#define Test_Request_To_Send_Received(v1,v2,v3)		cmtrts(v1,v2,v3)
+#define Wait_For_Completion(v1,v2,v3,v4,v5,v6,v7)	\
+	cmwcmp(v1,v2,v3,v4,v5,v6,v7)
+#define Wait_For_Conversation(v1,v2,v3)			cmwait(v1,v2,v3)
+
+#define CPIC_DEFINE_SIDE                0x101D
+#define CPIC_DELETE_SIDE                0x1035
+
+struct cpic_define_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+
+        unsigned char           sym_dest_name[9];
+        unsigned char           mode_name[9];
+        unsigned char           tp_name[64];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[10];
+        unsigned char           password[10];
+};
+
+struct cpic_delete_side_info {
+        unsigned char           netid[18];
+        unsigned char           netid_plu[18];
+        unsigned char           sym_dest_name[9];
+};
+
+struct cpicsreq {
+	struct cpicsreq		*next;
+	struct cpicsreq		*prev;
+
+	char			netid[18];
+	char			netid_plu[18];
+        char            	sym_dest_name[9];
+        char            	mode_name[9];
+        char            	tp_name[65];
+        unsigned char   	service_tp;
+        unsigned char   	security_level;
+        char            	username[11];
+        char            	password[11];
+        unsigned short  	flags;
+        unsigned long   	proc_id;
+};
+
+struct cpicsconf {
+        int     cpics_len;
+        char    cpics_net[9];
+        char    cpics_name[9];
+        char    cpics_plunet[9];
+        char    cpics_pluname[9];
+        char    cpics_sym_dest_name[9];
+
+        union {
+                char            *cpicsc_buf;
+                struct cpicsreq   *cpicsc_req;
+        } cpicsc_cpicscu;
+};
+
+struct sna_qcpics {
+        struct sna_qcpics *next;
+        struct cpicsreq   data;
+};
+
+#define cpicsc_buf cpicsc_cpicscu.cpicsc_buf         /* buffer address       */
+#define cpicsc_req cpicsc_cpicscu.cpicsc_req         /* array of structures  */
+
+/* Input/Output CPI-C call structure. */
+typedef struct {
+        unsigned long   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8, *a9;
+} cpic_args;
+
+#define cargo1(a, v1)                   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1;
+
+#define cargo2(a, v1, v2)               \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2;
+
+#define cargo3(a, v1, v2, v3)           \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3;
+
+#define cargo4(a, v1, v2, v3, v4)       \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4;
+
+#define cargo5(a, v1, v2, v3, v4, v5)   \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5;
+
+#define cargo6(a, v1, v2, v3, v4, v5, v6) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6;
+
+#define cargo7(a, v1, v2, v3, v4, v5, v6, v7) \
+        a = (cpic_args *)malloc(sizeof(cpic_args)); \
+        a->a1 = (unsigned long *)v1; \
+        a->a2 = (unsigned long *)v2; \
+        a->a3 = (unsigned long *)v3; \
+        a->a4 = (unsigned long *)v4; \
+        a->a5 = (unsigned long *)v5; \
+        a->a6 = (unsigned long *)v6; \
+        a->a7 = (unsigned long *)v7;
+
+#endif	/* _CPIC_H */
diff -ruN linux-2.4.4/include/linux/fs.h linux/include/linux/fs.h
--- linux-2.4.4/include/linux/fs.h	Fri Apr 27 15:48:28 2001
+++ linux/include/linux/fs.h	Mon May 14 20:47:15 2001
@@ -27,6 +27,9 @@
 
 struct poll_table_struct;
 
+#include <linux/cpic.h>
+#include <net/cpic.h>
+#include <linux/attach.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -430,6 +433,8 @@
 
 	unsigned int		i_flags;
 	unsigned char		i_sock;
+	unsigned char           i_cpic;
+        unsigned char           i_attach;
 
 	atomic_t		i_writecount;
 	unsigned int		i_attr_flags;
@@ -461,6 +466,8 @@
 		struct proc_inode_info		proc_i;
 		struct socket			socket_i;
 		struct usbdev_inode_info        usbdev_i;
+		struct cpic			cpic_i;
+		struct attach			attach_i;
 		void				*generic_ip;
 	} u;
 };
diff -ruN linux-2.4.4/include/linux/if_arp.h linux/include/linux/if_arp.h
--- linux-2.4.4/include/linux/if_arp.h	Fri Apr 27 15:48:52 2001
+++ linux/include/linux/if_arp.h	Mon May 14 20:47:16 2001
@@ -49,9 +49,11 @@
 #define ARPHRD_ROSE	270
 #define ARPHRD_X25	271		/* CCITT X.25			*/
 #define ARPHRD_HWX25	272		/* Boards with X.25 in firmware	*/
+#define ARPHRD_CHANNEL 	273             /* ESCONBus-Tag Channel         */
 #define ARPHRD_PPP	512
 #define ARPHRD_CISCO	513		/* Cisco HDLC	 		*/
 #define ARPHRD_HDLC	ARPHRD_CISCO
+#define ARPHRD_SDLC    	514             /* SDLC                         */
 #define ARPHRD_LAPB	516		/* LAPB				*/
 #define ARPHRD_DDCMP    517		/* Digital's DDCMP protocol     */
 #define ARPHRD_RAWHDLC	518		/* Raw HDLC			*/
diff -ruN linux-2.4.4/include/linux/if_ether.h linux/include/linux/if_ether.h
--- linux-2.4.4/include/linux/if_ether.h	Thu Apr 19 08:38:50 2001
+++ linux/include/linux/if_ether.h	Mon May 14 19:49:43 2001
@@ -55,6 +55,7 @@
 #define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
 #define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
 #define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_SNA      	0x80D5          /* SNA                          */
 #define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
 #define ETH_P_IPX	0x8137		/* IPX over DIX			*/
 #define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
diff -ruN linux-2.4.4/include/linux/llc.h linux/include/linux/llc.h
--- linux-2.4.4/include/linux/llc.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/llc.h	Mon May 14 19:50:14 2001
@@ -0,0 +1,109 @@
+/*
+ * IEEE 802.2 for Linux, data structures and indicators.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __LINUX_LLC_H
+#define __LINUX_LLC_H
+
+#ifdef __KERNEL__
+
+struct llc_msg_head
+{
+	struct llc_msg *next;
+	struct llc_msg *prev;
+	unsigned long qlen;
+};
+
+struct llc_msg
+{
+	struct llc_msg *next;
+	struct llc_msg *prev;
+
+	struct llc_msg_head *list;
+	struct llc_pinfo *llc;
+
+	unsigned char cmd;
+	unsigned char rsp;
+
+	struct sk_buff *skb;
+};
+#endif
+
+struct sockaddr_llc {
+        sa_family_t     sllc_family;
+        unsigned char   sllc_dmac[14];
+        unsigned char   sllc_dsap;
+        unsigned char   sllc_smac[14];
+        unsigned char   sllc_ssap;
+	unsigned char	sllc_test;
+};
+
+#define LLC_IOCTL_RETRY			0x01	/* Max retrans attempts. */
+#define LLC_IOCTL_SIZE			0x02	/* Max PDU size. */
+#define LLC_IOCTL_WINDOW		0x03	/* Max PDU window size. */
+#define LLC_IOCTL_ACK_TIMER_EXPIRE	0x04
+#define LLC_IOCTL_P_TIMER_EXPIRE	0x05
+#define LLC_IOCTL_REJ_TIMER_EXPIRE	0x06
+#define LLC_IOCTL_BUSY_TIMER_EXPIRE	0x07
+#define LLC_IOCTL_SSAP			0x08
+#define LLC_IOCTL_CLASS			0x09
+
+#define LLC_MAX_RETRY			100
+#define	LLC_MAX_SIZE			sizeof(int)
+#define LLC_MAX_WINDOW			50
+#define LLC_MAX_ACK_TIMER_EXPIRE	60 * HZ
+#define LLC_MAX_P_TIMER_EXPIRE		60 * HZ
+#define LLC_MAX_REJ_TIMER_EXPIRE	60 * HZ
+#define LLC_MAX_BUSY_TIMER_EXPIRE	60 * HZ
+
+struct llc_data
+{
+	unsigned char	ssap;
+};
+
+/* LLC socket operations. */
+#define LLC_REG_SAP_CLIENT	0xAA		/* Reg. LLC UI client w/ LLC */
+#define LLC_SET_SAP_CLASS	0xBB		/* Set class (LLC1 or LLC2) */
+#define LLC_QUE_MSG		0xCC		/* UI SAP Event Indication. */
+
+/* LLC types. */
+#define LLC_SAP_CLASS_1		0x01
+#define LLC_SAP_CLASS_2         0x02
+
+/* Linux LLC header sizes. */
+#define LLC_TYPE1_SIZE          3       /* 3 bytes. */
+#define LLC_TYPE2_SIZE          4       /* 4 bytes. */
+
+/* LLC SAP types. */
+#define LLC_SAP_NULL	0x00		/* NULL SAP. 			*/
+#define LLC_SAP_LLC	0x02		/* LLC Sublayer Managment. 	*/
+#define LLC_SAP_SNA	0x04		/* SNA Path Control. 		*/
+#define LLC_SAP_PNM	0x0E		/* Proway Network Managment.	*/	
+#define LLC_SAP_IP	0x06		/* TCP/IP. 			*/
+#define LLC_SAP_BSPAN	0x42		/* Bridge Spanning Tree Proto	*/
+#define LLC_SAP_MMS	0x4E		/* Manufacturing Message Srv.	*/
+#define LLC_SAP_8208	0x7E		/* ISO 8208			*/
+#define LLC_SAP_3COM	0x80		/* 3COM. 			*/
+#define LLC_SAP_PRO	0x8E		/* Proway Active Station List	*/
+#define LLC_SAP_SNAP	0xAA		/* SNAP. 			*/
+#define LLC_SAP_BANYAN	0xBC		/* Banyan. 			*/
+#define LLC_SAP_IPX	0xE0		/* IPX/SPX. 			*/
+#define LLC_SAP_NETBIOS	0xF0		/* NetBIOS. 			*/
+#define LLC_SAP_LANMGR	0xF4		/* LanManager. 			*/
+#define LLC_SAP_IMPL	0xF8		/* IMPL				*/
+#define LLC_SAP_DISC	0xFC		/* Discovery			*/
+#define LLC_SAP_OSI	0xFE		/* OSI Network Layers. 		*/
+#define LLC_SAP_LAR	0xDC		/* LAN Address Resolution 	*/
+#define LLC_SAP_RM	0xD4		/* Resource Management 		*/
+#define LLC_SAP_GLOBAL	0xFF		/* Global SAP. 			*/
+
+#endif /* __LINUX_LLC_H */
diff -ruN linux-2.4.4/include/linux/netdevice.h linux/include/linux/netdevice.h
--- linux-2.4.4/include/linux/netdevice.h	Fri Apr 27 15:48:51 2001
+++ linux/include/linux/netdevice.h	Mon May 14 20:47:16 2001
@@ -442,6 +442,7 @@
 extern int		dev_open(struct net_device *dev);
 extern int		dev_close(struct net_device *dev);
 extern int		dev_queue_xmit(struct sk_buff *skb);
+extern struct net_device *dev_getbyhwaddr(unsigned short type, char *ha);
 extern int		register_netdevice(struct net_device *dev);
 extern int		unregister_netdevice(struct net_device *dev);
 extern int 		register_netdevice_notifier(struct notifier_block *nb);
diff -ruN linux-2.4.4/include/linux/skbuff.h linux/include/linux/skbuff.h
--- linux-2.4.4/include/linux/skbuff.h	Fri Apr 27 15:48:50 2001
+++ linux/include/linux/skbuff.h	Mon May 14 20:47:16 2001
@@ -134,9 +134,26 @@
 	struct timeval	stamp;			/* Time we arrived				*/
 	struct net_device	*dev;		/* Device we arrived on/are leaving by		*/
 
+	struct net_device	*rx_dev;
+
+	/* Function management header */
+        union
+        {
+                struct fmhdr    *fm;
+                unsigned char   *raw;
+        } f;
+
+        /* Session layer header */
+        union
+        {
+                struct snaruhdr *ru;
+                unsigned char   *raw;
+        } s;
+
 	/* Transport layer header */
 	union
 	{
+		struct snarhdr  *rh;
 		struct tcphdr	*th;
 		struct udphdr	*uh;
 		struct icmphdr	*icmph;
@@ -149,14 +166,23 @@
 	/* Network layer header */
 	union
 	{
+		struct snathdr  *fidh;
 		struct iphdr	*iph;
 		struct ipv6hdr	*ipv6h;
+		struct larhdr   *larh;
 		struct arphdr	*arph;
 		struct ipxhdr	*ipxh;
 		unsigned char	*raw;
 	} nh;
   
 	/* Link layer header */
+        union
+       	{
+        	struct llchdr   *llc;
+               	unsigned char   *raw;
+       	} link;
+
+       	/* Mac/Hardware header */
 	union 
 	{	
 	  	struct ethhdr	*ethernet;
@@ -172,6 +198,10 @@
 	 * first. This is owned by whoever has the skb queued ATM.
 	 */ 
 	char		cb[48];	 
+
+	/* LLC layer. */
+       	unsigned int    llc_cmd;
+       	struct packet_type *pt;
 
 	unsigned int 	len;			/* Length of actual data			*/
  	unsigned int 	data_len;
diff -ruN linux-2.4.4/include/linux/sna.h linux/include/linux/sna.h
--- linux-2.4.4/include/linux/sna.h	Wed Dec 31 16:00:00 1969
+++ linux/include/linux/sna.h	Mon May 14 21:05:34 2001
@@ -0,0 +1,1184 @@
+/* sna.h: Linux-SNA Network Operator Facility Headers.
+ *
+ * Author:
+ * Jay Schulist		<jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#define SNA_NETWORK_NAME_LEN    9
+#define SNA_RESOURCE_NAME_LEN   9
+#define SNA_FQCP_NAME_LEN	18
+#define SNA_PORT_ADDR_LEN       12
+
+struct sna_netid {
+        unsigned char net[SNA_NETWORK_NAME_LEN];
+        unsigned char name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_nodeid {
+	unsigned long	block_id:12,
+			pu_id:20;
+};
+
+#define SNA_DOWN        0x1
+#define SNA_UP          0x2             /* Registed w/ the system */
+#define SNA_RUNNING     0x4             /* In a Running state */
+#define SNA_STOPPED     0x8             /* In a Stopped state */
+
+#define SNA_PORT_ROLE_PRI       0x1
+#define SNA_PORT_ROLE_SEC       0x2
+#define SNA_PORT_ROLE_NEG       0x4
+
+#ifdef __KERNEL__
+
+extern char sna_version[];
+extern char sna_maintainer[];
+extern __u32 sna_debug_level;
+
+extern void sna_mod_inc_use_count(void);
+extern void sna_mod_dec_use_count(void);
+
+extern int hexdump(unsigned char *pkt_data, int pkt_len);
+extern int sna_utok(void *uaddr, int ulen, void *kaddr);
+extern int sna_ktou(void *kaddr, int klen, void *uaddr);
+
+#define sna_debug(level, format, arg...) \
+        if(sna_debug_level > level)  \
+                printk(__FILE__ ": " format, ## arg)
+
+/* Linux-SNA Layer Identifiers */
+#define SNA_SM          0x01    /* Session Manager */
+#define SNA_HS          0x02    /* Half Session Router */
+#define SNA_INIT        0x03    /* SNA Initiator */
+#define SNA_PS          0x04    /* Presentation Services */
+#define SNA_RM          0x05    /* Resource Manager */
+#define SNA_ASM         0x06    /* Address Space Manager */
+#define SNA_SS          0x07    /* Session Services */
+
+/* Linux-SNA MU header types */
+#define SNA_MU_BIND_RQ_SEND             0x01
+#define SNA_MU_BIND_RSP_SEND            0x02
+#define SNA_MU_UNBIND_RQ_SEND           0x03
+#define SNA_MU_UNBIND_RQ_RCV            0x04
+#define SNA_MU_UNBIND_RSP_SEND          0x05
+#define SNA_MU_BIND_RQ_RCV              0x06
+#define SNA_MU_BIND_RSP_RCV             0x07
+#define SNA_MU_HS_TO_RM                 0x08
+#define SNA_MU_RM_TO_PS                 0x09
+#define SNA_MU_HS_TO_PS                 0x0A
+#define SNA_MU_PS_TO_HS                 0x0B
+#define SNA_MU_HS_TO_PC                 0x0C
+
+/* Linux-SNA Deactivate session identifiers */
+#define SNA_DEACT_PENDING               0x01
+#define SNA_DEACT_ACTIVE                0x02
+
+/* Linux-SNA Session Identifiers */
+#define SNA_SESSION_NONE                0x00    /* No Session Speaker */
+#define SNA_SESSION_FIRST_SPEAKER       0x01    /* First Speaker Session */
+#define SNA_SESSION_BIDDER              0x02    /* Bidder Session */
+#define SNA_SESSION_EITHER              0x03    /* First or Bidder Session */
+
+/* Linux-SNA Sync level indicators */
+#define SNA_SYNC_NONE                   0x01
+#define SNA_SYNC_CONFIRM                0x02
+#define SNA_SYNC_SYNCPT                 0x03
+#define SNA_SYNC_BACKOUT                0x04
+
+/* Linux-SNA HS type indicators */
+#define SNA_HS_PRI                      0x01
+#define SNA_HS_SEC                      0x02
+
+/* Linux-SNA Security indicators */
+#define SNA_SECURITY_NONE               0x01
+#define SNA_SECURITY_SAME               0x02
+#define SNA_SECURITY_PGM                0x03
+
+/* Linux-SNA sna_send_deactivate_pending() indicators */
+#define SNA_PENDING                     0x01
+#define SNA_ACTIVE                      0x02
+#define SNA_ABNORMAL                    0x03
+#define SNA_ABNORMAL_RETRY              0x04
+#define SNA_ABNORMAL_NO_RETRY           0x05
+#define SNA_CLEANUP                     0x06
+#define SNA_NORMAL                      0x07
+
+/* Linux-SNA Structure Identifiers */
+#define SNA_REC_BID                     0x001
+#define SNA_REC_BID_RSP                 0x002
+#define SNA_REC_MU                      0x003
+#define SNA_REC_MU_FMH5                 0x004
+#define SNA_REC_MU_FMH12                0x005
+#define SNA_REC_FREE_SESSION            0x006
+#define SNA_REC_RTR_RQ                  0x007
+#define SNA_REC_RTR_RSP                 0x008
+#define SNA_REC_BIS_REPLY               0x009
+#define SNA_REC_ALLOCATE_RCB            0x00A
+#define SNA_REC_GET_SESSION             0x00B
+#define SNA_REC_DEALLOCATE_RCB          0x00C
+#define SNA_REC_TERMINATE_PS            0x00D
+#define SNA_REC_CHANGE_SESSIONS         0x00E
+#define SNA_REC_RM_ACTIVATE_SESSION     0x00F
+#define SNA_REC_RM_DEACTIVATE_SESSION   0x010
+#define SNA_REC_DEACTIVATE_CONV_GROUP   0x011
+#define SNA_REC_UNBIND_PROTOCOL_ERROR   0x012
+#define SNA_REC_ABEND_NOTIFICATION      0x013
+#define SNA_REC_ACTIVATE_SESSION_RSP    0x014
+#define SNA_REC_SESSION_ACTIVATED       0x015
+#define SNA_REC_SESSION_DEACTIVATED     0x016
+#define SNA_REC_BIS_RQ                  0x017
+#define SNA_REC_ACTIVATE_SESSION        0x018
+#define SNA_REC_DEACTIVATE_SESSION      0x019
+#define SNA_REC_INIT_HS_RSP             0x01B
+#define SNA_REC_ABORT_HS                0x01C
+#define SNA_REC_INIT_SIGNAL_NEG_RSP     0x01D
+#define SNA_REC_CINIT_SIGNAL            0x01E
+#define SNA_REC_SESSION_ROUTE_INOP      0x01F
+#define SNA_REC_LFSID_IN_USE            0x020
+#define SNA_REC_BRACKET_FREED           0x021
+#define SNA_REC_BID_WITHOUT_ATTACH      0x022
+#define SNA_REC_HS_PS_CONNECTED         0x023
+#define SNA_REC_RM_HS_CONNECTED         0x024
+#define SNA_REC_SECURITY_REPLY_2        0x025
+#define SNA_REC_YIELD_SESSION           0x026
+#define SNA_REC_INIT_HS                 0x027
+#define SNA_REC_RCB_ALLOCATED           0x028
+#define SNA_REC_SESSION_ALLOCATED       0x029
+#define SNA_REC_RM_SESSION_ALLOCATED    0x02A
+#define SNA_REC_CONV_FAIL               0x02B
+#define SNA_REC_RM_SESSION_ACTIVATED    0x02C
+#define SNA_REC_START_TP                0x02D
+#define SNA_REC_FREE_LFSID              0x02E
+#define SNA_REC_PC_HS_DISCONNECT        0x02F
+#define SNA_REC_ASSIGN_LFSID            0x030
+#define SNA_REC_LFSID_IN_USE_RSP        0x031
+#define SNA_REC_INIT_SIGNAL             0x032
+#define SNA_REC_SESSEND_SIGNAL          0x033
+#define SNA_REC_SESSST_SIGNAL           0x034
+#define SNA_REC_ASSIGN_PCID             0x035
+#define SNA_REC_RCB_DEALLOCATED         0x036
+#define SNA_REC_SEND_RTR                0x037
+#define SNA_REC_RM_TIMER_POP            0x038
+
+#endif /* __KERNEL__ */
+
+#define SIOCGNODE	0x1000
+#define SIOCGDLC	0x1001
+#define SIOCGPORT	0x1002
+#define SIOCGLS		0x1003
+#define SIOCGMODE	0x1004
+#define SIOCGLU		0x1005
+#define SIOCGPLU	0x1006
+#define SIOCGCPICS	0x1007
+#define SIOCGPS		0x1008
+#define SIOCGCOS	0x1009
+
+struct cosreq {
+	struct cosreq		*next;
+	struct cosreq		*prev;
+
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+};
+
+struct cosconf {
+        int     cos_len;
+        char    cos_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *cosc_buf;
+                struct cosreq   *cosc_req;
+        } cosc_coscu;
+};
+
+struct sna_qcos {
+        struct sna_qcos *next;
+        struct cosreq   data;
+};
+
+#define cosc_buf cosc_coscu.cosc_buf              /* buffer address       */
+#define cosc_req cosc_coscu.cosc_req              /* array of structures  */
+
+struct plureq {
+	struct plureq		*next;
+	struct plureq		*prev;
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	struct sna_netid	fqcp_name;
+	unsigned char		parallel_ss;
+        unsigned char   	cnv_security;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct pluconf {
+	int	plu_len;
+	char	plu_net[SNA_NETWORK_NAME_LEN];
+	char	plu_name[SNA_RESOURCE_NAME_LEN];
+	char	plu_plunet[SNA_NETWORK_NAME_LEN];
+	char	plu_pluname[SNA_RESOURCE_NAME_LEN];
+	char	plu_fqcpnet[SNA_NETWORK_NAME_LEN];
+	char	plu_fqcpname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char            *pluc_buf;
+                struct plureq	*pluc_req;
+        } pluc_plucu;
+};
+
+struct sna_qplu {
+        struct sna_qplu *next;
+        struct plureq   data;
+};
+
+#define pluc_buf pluc_plucu.pluc_buf              /* buffer address       */
+#define pluc_req pluc_plucu.pluc_req              /* array of structures  */
+
+struct lureq {
+	struct lureq		*next;
+	struct lureq		*prev;
+
+	struct sna_netid	netid;
+	char			name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		sync_point;
+	unsigned long		lu_sess_limit;
+	unsigned long   	proc_id;
+        unsigned short  	flags;
+};
+
+struct luconf {
+	int             lu_len;
+        char            lu_net[SNA_NETWORK_NAME_LEN];
+        char            lu_name[SNA_RESOURCE_NAME_LEN];
+	char		lu_luname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *luc_buf;
+                struct lureq      *luc_req;
+        } luc_lucu;
+};
+
+struct sna_qlu {
+        struct sna_qlu *next;
+        struct lureq   data;
+};
+
+#define luc_buf luc_lucu.luc_buf              /* buffer address       */
+#define luc_req luc_lucu.luc_req              /* array of structures  */
+
+/* mode information request record. */
+struct modereq {
+	struct modereq		*next;
+	struct modereq		*prev;
+
+	char			mode_name[SNA_RESOURCE_NAME_LEN];
+	char			cos_name[SNA_RESOURCE_NAME_LEN];
+
+	struct sna_netid	netid;
+	struct sna_netid	plu_name;
+	unsigned long		tx_pacing;
+        unsigned long   	rx_pacing;
+        unsigned long   	max_tx_ru;
+        unsigned long   	max_rx_ru;
+        unsigned long   	crypto;
+        unsigned long   	proc_id;
+        unsigned short  	flags;
+
+	unsigned short  	auto_activation;
+        unsigned long   	max_sessions;
+        unsigned long   	min_conlosers;
+        unsigned long   	min_conwinners;
+
+        unsigned long   	act_sessions;
+        unsigned long   	act_conwinners;
+        unsigned long   	act_conlosers;
+
+        unsigned long   	pend_sessions;
+        unsigned long   	pend_conwinners;
+        unsigned long   	pend_conlosers;
+};
+
+struct modeconf {
+	int             mode_len;
+        char            mode_net[SNA_NETWORK_NAME_LEN];
+        char            mode_name[SNA_RESOURCE_NAME_LEN];
+	char		mode_modename[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *modec_buf;
+                struct modereq      *modec_req;
+        } modec_modecu;
+};
+
+struct sna_qmode {
+        struct sna_qmode *next;
+        struct modereq   data;
+};
+
+#define modec_buf modec_modecu.modec_buf              /* buffer address       */
+#define modec_req modec_modecu.modec_req              /* array of structures  */
+
+struct lsreq {
+	struct lsreq		*next;
+	struct lsreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+        char            	lsname[SNA_RESOURCE_NAME_LEN];
+	char			dname[SNA_FQCP_NAME_LEN];
+	char			daddr[12];
+	unsigned char		sport;
+	unsigned long		proc_id;
+	unsigned short		flags;
+	unsigned long		auto_act;
+	unsigned long		auto_deact;
+	unsigned long		byteswap;
+};
+
+struct lsconf {
+        int             ls_len;
+        char            ls_net[SNA_NETWORK_NAME_LEN];
+        char            ls_name[SNA_RESOURCE_NAME_LEN];
+        char            ls_devname[SNA_RESOURCE_NAME_LEN];
+        char            ls_portname[SNA_RESOURCE_NAME_LEN];
+	char		ls_lsname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *lsc_buf;
+                struct lsreq      *lsc_req;
+        } lsc_lscu;
+};
+
+struct sna_qls {
+        struct sna_qls *next;
+        struct lsreq   data;
+};
+
+#define lsc_buf lsc_lscu.lsc_buf              /* buffer address       */
+#define lsc_req lsc_lscu.lsc_req              /* array of structures  */
+
+struct portreq {
+	struct portreq		*next;
+	struct portreq		*prev;
+
+	struct sna_netid	netid;
+        char            	devname[SNA_RESOURCE_NAME_LEN];
+        char            	portname[SNA_RESOURCE_NAME_LEN];
+
+	char			saddr[12];
+	unsigned long		ls_qlen;
+	unsigned long		proc_id;
+	unsigned long		role;
+	unsigned long		btu;
+	unsigned long		mia;
+	unsigned long		moa;
+
+	unsigned short		flags;
+
+	struct lsreq		*ls;
+};
+
+struct portconf {
+        int             port_len;
+        char            port_net[SNA_NETWORK_NAME_LEN];
+        char            port_name[SNA_RESOURCE_NAME_LEN];
+        char            port_devname[SNA_RESOURCE_NAME_LEN];
+	char		port_portname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char              *portc_buf;
+                struct portreq    *portc_req;
+        } portc_portcu;
+};
+
+struct sna_qport {
+        struct sna_qport *next;
+        struct portreq   data;
+};
+
+#define portc_buf portc_portcu.portc_buf              /* buffer address       */
+#define portc_req portc_portcu.portc_req              /* array of structures  */
+
+struct dlcreq {
+	struct dlcreq		*next;
+	struct dlcreq		*prev;
+
+	struct sna_netid	netid;
+	char			devname[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		port_qlen;
+	unsigned long		proc_id;
+	unsigned short		flags;	
+
+	struct portreq		*port;
+};
+
+struct dlconf {
+        int             dlc_len;
+        char            dlc_net[SNA_NETWORK_NAME_LEN];
+        char            dlc_name[SNA_RESOURCE_NAME_LEN];
+	char		dlc_devname[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *dlc_buf;
+                struct dlcreq    *dlc_req;
+        } dlc_dlcu;
+};
+
+struct sna_qdlc {
+        struct sna_qdlc *next;
+        struct dlcreq   data;
+};
+
+#define dlc_buf dlc_dlcu.dlc_buf              /* buffer address       */
+#define dlc_req dlc_dlcu.dlc_req              /* array of structures  */
+
+struct snareq {
+	char		net[SNA_NETWORK_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short   bind_seg;      /* Is Bind segmenting supported. */
+        unsigned long    max_lus;	/* Max LU sessions */
+	unsigned short	node_status;
+};
+
+struct snaconf {
+        int             snac_len;
+	char		snac_net[SNA_NETWORK_NAME_LEN];
+	char		snac_name[SNA_RESOURCE_NAME_LEN];
+
+        union {
+                char             *snac_buf;
+                struct snareq    *snac_req;
+        } snac_snacu;
+};
+
+struct sna_qsna {
+        struct sna_qsna *next;
+        struct snareq   data;
+};
+
+#define snac_buf snac_snacu.snac_buf              /* buffer address       */
+#define snac_req snac_snacu.snac_req              /* array of structures  */
+
+struct larreq {
+        unsigned char netid[SNA_RESOURCE_NAME_LEN];
+        unsigned char name[SNA_RESOURCE_NAME_LEN];
+        unsigned char group[SNA_RESOURCE_NAME_LEN];
+        unsigned char mac[ETH_ALEN];
+        unsigned char lsap;
+        unsigned long rtcap;
+};
+
+struct larconf {
+        int             larc_len;
+        char            larc_net[SNA_RESOURCE_NAME_LEN];
+        unsigned char   larc_group[SNA_RESOURCE_NAME_LEN];
+        unsigned long   larc_rtcap;
+
+        union
+        {
+                char            *larc_buf;
+                struct larreq   *larc_req;
+        } larc_larcu;
+};
+
+#define larc_buf larc_larcu.larc_buf               /* buffer address       */
+#define larc_req larc_larcu.larc_req               /* array of structures  */
+
+#define SIOCGLAR                0x0001
+
+#define SNA_LAR_FIND            0x0001
+#define SNA_LAR_FIND_MEMBER     0x0002
+#define SNA_LAR_SEARCH          0x0003
+#define SNA_LAR_ERASE           0x0004
+#define SNA_LAR_RECORD          0x0005
+
+#define SNA_RTCAP_APPN_NN       0x80
+#define SNA_RTCAP_SUBAREA       0x40
+#define SNA_RTCAP_NAME          0xAA
+
+struct sna_all_info {
+	struct sna_all_info *next;		/* Next node */
+
+	/* Std. Node info. */
+	char		net[SNA_RESOURCE_NAME_LEN];
+	char		name[SNA_RESOURCE_NAME_LEN];
+	struct sna_nodeid	nodeid;
+	unsigned short  type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;      	/* Is Bind segmenting supported. */
+        unsigned long   max_lus;       	/* Max LU sessions */
+	unsigned short	node_status;	
+
+	struct modereq		*mode;
+	struct plureq		*plu;
+	struct lureq		*lu;
+	struct dlcreq		*dl;
+	struct cpicsreq		*cpics;
+	struct cosreq		*cos;
+};
+
+#define SNA_NODE_NAME_LEN	8
+
+struct sna_nof_pinfo {
+	struct sna_nof_pinfo *next;
+	struct sna_nof_pinfo *prev;
+
+	struct sna_netid 	netid;
+	struct sna_nodeid	nodeid;
+	unsigned short	status;
+	unsigned char	type;           /* Node type. */
+        unsigned short  lu_seg;         /* Is LU segmenting supported. */
+        unsigned short  bind_seg;       /* Is Bind segmenting supported. */
+        unsigned long   max_lus;        /* Max number of LU sessions,
+                                         * 0 = Unlimited.
+                                         */
+
+	/* Data below not currently used. */
+        unsigned long   netid_registered;
+        unsigned long   ls_supp_type;
+        unsigned long   resource_registration;
+        unsigned long   segment_generation_lvl;
+        unsigned long   mode_to_cos_mapping;
+        unsigned long   ms_node_type;
+        unsigned long   mj_vector_file;
+        unsigned long   ms_log_file;
+        unsigned long   peer_resource_registration;
+        unsigned long   network_node_type;
+        unsigned long   directory_type_supp;
+        unsigned long   rs_tree_update_type;
+        unsigned long   tdm_node_name;
+        unsigned long   cosdm_node_name;
+        unsigned long   max_rs_cache_trees;
+        unsigned long   max_oos_tdm_updates;
+        unsigned long   resource_service_search;
+        unsigned long   general_odai_usage_supp;
+};
+
+#define SNA_NOF_NODE_SHUTDOWN_RQ		0xFFFF
+
+#define SNA_CP_CREATE_PARMS_RQ			0x0100
+struct sna_cp_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_cp;
+	unsigned long	*netid;
+	unsigned long	bind_reassembly;
+	unsigned long	adaptive_bind_pacing;
+	unsigned long	sense;
+};
+
+#define SNA_TRS_CREATE_PARMS_RQ			0x0102
+struct sna_trs_create_parms {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	node_type;
+	unsigned long	*cp_name;
+	unsigned long	netid;
+	unsigned long	rs_tree_caching;
+	unsigned long	incr_rs_tree_updates;
+	unsigned long	max_rs_trees;
+	unsigned long	max_tdm_nodes;
+	unsigned long	max_oos_tdus;
+	unsigned long	cosdm_file_name;
+	unsigned long	tdm_file_name;
+	unsigned long	gateway;
+	unsigned long	central_directory_server;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NAME		0x9998
+struct sna_query_connection_name {
+	char 		connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned 	long sense;
+};
+
+#define SNA_ACTIVATE_CONTROL_SESSIONS	0x1000
+struct sna_activate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*remote_cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_CHANGE_SESSION_LIMIT		0x1002
+struct sna_change_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	new_limit_conwinner;
+	unsigned long	new_limit_conloser;
+	unsigned long	deactivating_lu;
+	unsigned long   sense;
+};
+
+#define SNA_DEACTIVATE_CONTROL_SESSIONS	0x1004
+struct sna_deactivate_control_sessions {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cp_name;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_ADJACENT_NODE		0x1006
+struct sna_define_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long	cp_capabilities;
+	unsigned long	node_type;
+	unsigned long	auth_lvl_adj_node;
+	unsigned long	*netid_lu_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_CLASS_OF_SERVICE		0x1008
+struct sna_define_cos {
+	unsigned char   name[SNA_RESOURCE_NAME_LEN];
+        unsigned short  weight;
+        unsigned short  tx_priority;
+	unsigned char   default_cos_invalid;
+        unsigned char   default_cos_null;
+
+	/* Tg Characteristics */
+	unsigned short	tg_rsn;
+	unsigned short  min_cost_per_connect;
+        unsigned short  max_cost_per_connect;
+        unsigned short  min_cost_per_byte;
+        unsigned short  max_cost_per_byte;
+        unsigned short  min_security;
+        unsigned short  max_security;
+        unsigned short  min_propagation_delay;
+        unsigned short  max_propagation_delay;
+        unsigned short  min_effective_capacity;
+        unsigned short  max_effective_capacity;
+        unsigned short  min_user1;
+        unsigned short  max_user1;
+        unsigned short  min_user2;
+        unsigned short  max_user2;
+        unsigned short  min_user3;
+        unsigned short  max_user3;
+
+	/* Node Characteristics */
+	unsigned short  node_rsn;
+        unsigned short  min_route_resistance;
+	unsigned short	max_route_resistance;
+        unsigned short  min_node_congested;
+	unsigned short	max_node_congested;
+};
+
+#define SNA_DEFINE_CONNECTION_NETWORK	0x100A
+struct sna_define_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid;
+	unsigned long	tg_characteristics;
+	unsigned long	port_list;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_DIRECTORY_ENTRY		0x100C
+struct sna_define_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource;
+	unsigned long	entry_class;
+	unsigned long	directory_entry_scope;
+	unsigned long	registration_requirements;
+	unsigned long   sense;
+};
+
+#define SNA_LS_MODE_ABM				0x1
+#define SNA_LS_MODE_NRM				0x2
+
+#define SNA_DEFINE_ISR_TUNING		0x1010
+struct sna_define_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*secondary_lu_name;
+	unsigned long	*mode_name;
+	unsigned long	slu_mode_entry;
+	unsigned long	pri_rws;
+	unsigned long	sec_rws;
+	unsigned long	max_pri_rws;
+	unsigned long	max_sec_rws;
+	unsigned long	nonreserved_perm_buf_pool_size;
+	unsigned long	max_pri_ru_size;
+	unsigned long	max_sec_ru_size;
+	unsigned long	adaptive_session_lvl_pacing;
+	unsigned long   sense;
+};
+
+#define SNA_DEFINE_LINK_STATION		0x1012
+struct sna_define_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+        char    saddr[SNA_PORT_ADDR_LEN];       /* 0x04 */
+
+	struct sna_netid plu_name;
+	char	dname[7];			/* Dest. MAC addr */
+	char	daddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+
+	int byteswap;
+	int retry_on_fail;
+        int retry_times;
+        int autoact;
+        int autodeact;
+        int tg_number;
+        int cost_per_byte;
+        int cost_per_connect_time;
+        int effective_capacity;
+        int propagation_delay;
+        int security;
+        int user1;
+        int user2;
+        int user3;
+};
+
+#define SNA_DEFINE_LOCAL_LU			0x1014
+struct sna_define_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char	sync_point;
+	unsigned long	lu_sess_limit;
+
+	/* Data below not used */
+	unsigned long	reg_requirments;
+	unsigned long	bind_range_process;
+	unsigned long	queueing_capability;
+	unsigned long	map_lu_names_list;
+};
+
+#define SNA_DEFINE_MODE			0x1016
+struct sna_define_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long		tx_pacing;
+	unsigned long		rx_pacing;
+	unsigned long		max_tx_ru;
+	unsigned long		max_rx_ru;
+	unsigned char		crypto;
+	unsigned long		min_conwinners;
+	unsigned long		min_conlosers;
+	unsigned long		max_sessions;
+	unsigned char		auto_activation;
+};
+
+#define SNA_DEFINE_NODE_CHARS		0x1018
+struct sna_define_node_chars {
+	struct sna_netid	cp_name;
+	unsigned char		route_resistance;
+	unsigned char		quiescing;
+};
+
+#define SNA_DEFINE_PARTNER_LU		0x101A
+struct sna_define_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+	struct sna_netid netid_fqcp;
+	unsigned char 	parallel_ss;
+	unsigned char 	cnv_security;
+
+	/* Data below not used. */
+	unsigned long	init_lu_type;
+	unsigned long	multi_sessions;
+	unsigned long	cnos_lvl_exchg;
+	unsigned long	password;
+	unsigned long	lu_access_security;
+};
+
+#define SNA_DEFINE_PORT			0x101C
+struct sna_define_port {
+	struct sna_netid netid;
+	char	name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x4 */
+	unsigned long	role;		/* PRI */
+	unsigned long	btu;		/* Max Rx/Tx BTU size. */
+	unsigned long	mia;		/* Max inbound activations */
+	unsigned long	moa;		/* Max outbound activations */
+	
+	unsigned long	link_station_txrx;
+	unsigned long	max_nonack_xid;
+};
+
+#define SNA_DEFINE_TP			0x101E
+struct sna_define_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	init_tp_status;
+	unsigned long	conv_types_allowed;
+	unsigned long	sync_lvl_supp;
+	unsigned long	pip_lvl;
+	unsigned long	num_pip_parms;
+	unsigned long	data_map_supp;
+	unsigned long	fm_hdr_supp;
+	unsigned long	max_concurrent_tp_instances;
+	unsigned long	*issue_verb_list;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ADJACENT_NODE		0x1020
+struct sna_delete_adjacent_node {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_cp;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_CLASS_OF_SERVICE		0x1022
+struct sna_delete_cos {
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_CONNECTION_NETWORK	0x1024
+struct sna_delete_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_net;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_DIRECTORY_ENTRY		0x1026
+struct sna_delete_directory_entry {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*resource_name;
+	unsigned long	resource_type;
+	unsigned long	*parent_resource_name;
+	unsigned long	parent_resource_type;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_ISR_TUNING		0x102A
+struct sna_delete_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	mode_name;
+	unsigned long   sense;
+};
+
+#define SNA_DELETE_LINK_STATION		0x102C
+struct sna_delete_link_station {
+	struct sna_netid netid;
+	char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN]; 
+	char	dname[17];
+	char	daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_DELETE_LOCAL_LU			0x102E
+struct sna_delete_local_lu {
+	struct sna_netid netid;
+	unsigned char 	lu_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_MODE			0x1030
+struct sna_delete_mode {
+	struct sna_netid	netid;
+	struct sna_netid	netid_plu;
+	unsigned char		mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+#define SNA_DELETE_PARTNER_LU		0x1032
+struct sna_delete_partner_lu {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+};
+
+#define SNA_DELETE_PORT			0x1034
+struct sna_delete_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_DELETE_TP			0x1036
+struct sna_delete_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long   sense;
+};
+
+#define SNA_INITIALIZE_SESSION_LIMIT		0x1038
+struct sna_initialize_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	max_session_limit;
+	unsigned long	max_session_limit_conwinner;
+	unsigned long	max_session_limit_conloser;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CLASS_OF_SERVICE		0x103A
+struct sna_query_class_of_service {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*cos_name;
+
+	unsigned long	tx_priority;
+	unsigned long	*mode_name_list;
+	unsigned long	*node_weights;
+	unsigned long	*tg_weights;
+	unsigned long	default_cos;
+	unsigned long	default_blank_cos;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_CONNECTION_NETWORK		0x103C
+struct sna_query_connection_network {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*netid_connection_network;
+
+	unsigned long	*network_control_block;
+	unsigned long	*tg_status_list;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_DLC			0x103E
+struct sna_query_dlc {
+	struct sna_netid netid;
+
+	char 		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+	unsigned long	fsm_dlc_state;
+
+	char		port_list[90];	/* Room for 10 ports to be listed. */
+};
+
+#define SNA_QUERY_ISR_TUNING			0x1040
+struct sna_query_isr_tuning {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*slu_name;
+	unsigned long	*mode_name;
+
+	unsigned long	*slu_mode_entry;
+	unsigned long   sense;
+};
+
+#define SNA_QUERY_LINK_STATION		0x1042
+struct sna_query_link_station {
+	struct sna_netid *netid;
+
+	char		ls_name[SNA_RESOURCE_NAME_LEN];
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned long	adj_node_type;
+	unsigned long	fsm_ls_state;
+
+	unsigned long	ls_entered_act_state;
+	unsigned long	node_act;
+	unsigned long	ls_activation;
+
+	char		dest_addr[6];
+
+	unsigned long	tx_win_size;
+	unsigned long	rx_win_size;
+
+	unsigned long	fsm_xid_state;
+	unsigned long	fsm_nonact_xid_state;
+	unsigned long	fsm_ls_role_state;
+};
+
+#define SNA_QUERY_PORT			0x1044
+struct sna_query_port {
+	struct sna_netid *netid;
+
+	char		port_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_system_id;
+	char		dlc_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	port_type;
+	unsigned long   max_rx_btu_size;
+        unsigned long   max_tx_btu_size;
+
+        unsigned long   max_adjacent_link_stations;
+        unsigned long   real_adjacent_link_stations;
+
+        unsigned long   max_inbound_activation;
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   max_outbound_activation;
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+	unsigned long   port_role;
+	unsigned long   link_station_txrx;
+	unsigned long   max_nonack_xid;
+	unsigned long	port_address;
+	unsigned long	fsm_port_state;
+};
+
+#define SNA_QUERY_STATISTICS			0x1046
+struct sna_query_stats {
+	struct sna_netid *netid;
+
+	unsigned long	*adj_link_station_name;
+	unsigned long	*sysid_dlc;
+	unsigned long	*sysid_port;
+	unsigned long	*sysid_adj_ls;
+	unsigned long	*stats;
+};
+
+#define SNA_RESET_SESSION_LIMIT		0x1048
+struct sna_reset_session_limit {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	struct sna_fq_netid 	*netid_plu;
+	unsigned long	*mode_name;
+	unsigned long	rsp_lu;
+	unsigned long	lu_session_availability;
+	unsigned long	plu_session_availability;
+	unsigned long	cnos_error_handling;
+	unsigned long   sense;
+};
+
+#define SNA_START_NODE			0x104A
+struct sna_start_node {
+	struct sna_netid 	netid;	/* Local NetID.Node. */
+	struct sna_nodeid	nodeid;	/* Local Block and PU ID. */
+	unsigned char	type;		/* Node type. */
+	unsigned short	lu_seg;		/* Is LU segmenting supported. */
+	unsigned short	bind_seg;	/* Is Bind segmenting supported. */
+	unsigned long	max_lus;	/* Max number of LU sessions,
+					 * 0 = Unlimited.
+					 */
+
+	/* Data below not used at the moment */
+	unsigned long	netid_registered;
+	unsigned long	ls_supp_type;
+	unsigned long	resource_registration;
+	unsigned long	segment_generation_lvl;
+	unsigned long	mode_to_cos_mapping;
+	unsigned long	ms_node_type;
+	unsigned long	*mj_vector_file;
+	unsigned long	*ms_log_file;
+	unsigned long	peer_resource_registration;
+	unsigned long	network_node_type;
+	unsigned long	directory_type_supp;
+	unsigned long	rs_tree_update_type;
+	unsigned long	*tdm_node_name;
+	unsigned long	*cosdm_node_name;
+	unsigned long	max_rs_cache_trees;
+	unsigned long	max_oos_tdm_updates;
+	unsigned long	*resource_service_search;
+	unsigned long	general_odai_usage_supp;
+};
+
+#define SNA_DELETE_NODE			0x104B
+struct sna_delete_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_START_DLC			0x104C
+struct sna_start_dlc {
+	char node_name[SNA_NODE_NAME_LEN];
+	unsigned long	*dlc_name;
+        unsigned long   dlc_type;
+        unsigned long   ls_mode;
+        unsigned long   remote_ipl;
+        unsigned long   data;
+	unsigned long   sense;
+};
+
+#define SNA_START_LINK_STATION		0x104E
+struct sna_start_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+};
+
+#define SNA_START_PORT			0x1050
+struct sna_start_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+};
+
+#define SNA_START_TP				0x1052
+struct sna_start_tp {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_fq_netid 	*netid_lu;
+	unsigned long	*tp_name;
+	unsigned long	*pip;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_DLC				0x1054
+struct sna_stop_dlc {
+	char connection_name[SNA_RESOURCE_NAME_LEN];
+	unsigned long	*dlc_name;
+	unsigned long	deact_type;
+	unsigned long   sense;
+};
+
+#define SNA_STOP_NODE				0x1055
+struct sna_stop_node {
+        struct sna_netid netid;
+	unsigned long deact_type;
+};
+
+#define SNA_STOP_LINK_STATION		0x1056
+struct sna_stop_link_station {
+	struct sna_netid netid;
+	struct sna_netid netid_plu;
+        char    name[SNA_RESOURCE_NAME_LEN];
+        char    saddr[SNA_PORT_ADDR_LEN];
+        char    dname[SNA_FQCP_NAME_LEN];
+        char    daddr[SNA_PORT_ADDR_LEN];
+
+	unsigned long	deact_type;
+};
+
+#define SNA_STOP_PORT			0x1058
+struct sna_stop_port {
+	struct sna_netid netid;
+        char    name[SNA_RESOURCE_NAME_LEN];	/* eth0 */
+	char	saddr[SNA_PORT_ADDR_LEN];	/* 0x04 */
+	unsigned long	deact_type;
+};
+
+/* SNA node types. */
+#define SNA_LEN_END_NODE	0x1
+#define SNA_APPN_END_NODE	0x2
+#define SNA_APPN_NET_NODE	0x4
+
+/* SNA Network qualified name is registered or not. */
+#define SNA_NOF_NO_NETID_REG		0x0
+#define SNA_NOF_NETID_REG		0x1
+
+/* SNA resource registration indicatiors. */
+#define SNA_NOF_RESOURCE_REG_NONE	0x0
+#define SNA_NOF_RESOURCE_REG_RESOURCES	0x1
+
+/* MS node type. */
+#define SNA_NOF_MS_ENTRY_POINT		0x0
+#define SNA_NOF_MS_FOCAL_POINT		0x1
+
+#ifdef __KERNEL__
+
+#include <net/sna_formats.h>
+#include <net/sna_cbs.h>
+#include <net/sna_externs.h>
+#include <net/sna_errors.h>
+
+#endif  /* __KERNEL__ */
diff -ruN linux-2.4.4/include/linux/socket.h linux/include/linux/socket.h
--- linux-2.4.4/include/linux/socket.h	Fri Apr 27 15:48:20 2001
+++ linux/include/linux/socket.h	Mon May 14 20:47:15 2001
@@ -156,6 +156,7 @@
 #define AF_IRDA		23	/* IRDA sockets			*/
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
+#define AF_LLC         	30      /* LLC Class One, Two and Three */
 #define AF_MAX		32	/* For now.. */
 
 /* Protocol families, same as address families. */
@@ -186,6 +187,7 @@
 #define PF_IRDA		AF_IRDA
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
+#define PF_LLC		AF_LLC
 #define PF_MAX		AF_MAX
 
 /* Maximum queue length specifiable by listen.  */
@@ -235,6 +237,11 @@
 #define SOL_ATM		264	/* ATM layer (cell level) */
 #define SOL_AAL		265	/* ATM Adaption Layer (packet level) */
 #define SOL_IRDA        266
+#define SOL_LLC         277     /* LLC User Interface SAPs */
+#define SOL_SNA_NOF     278     /* SNA Network Operator Facility */
+#define SOL_SNA_CPIC    279     /* CPI-C v2.1 */
+#define SOL_SNA_LAR     280     /* LAN Address Resolution */
+#define SOL_SNA_PS	281     /* Presentation Services */
 
 /* IPX options */
 #define IPX_TYPE	1
diff -ruN linux-2.4.4/include/linux/sysctl.h linux/include/linux/sysctl.h
--- linux-2.4.4/include/linux/sysctl.h	Fri Apr 27 15:48:20 2001
+++ linux/include/linux/sysctl.h	Mon May 14 20:48:25 2001
@@ -157,7 +157,33 @@
 	NET_TR=14,
 	NET_DECNET=15,
 	NET_ECONET=16,
-	NET_KHTTPD=17
+	NET_KHTTPD=17,
+        NET_LLC=18,
+        NET_SNA_BM=19,
+        NET_SNA_PC=20,
+        NET_SNA_NOF=21,
+        NET_SNA_COSM=22,
+        NET_SNA_CS=23,
+        NET_SNA_DLC=24,
+        NET_SNA_DS=25,
+        NET_SNA_ISR=26,
+        NET_SNA_TRS=27,
+        NET_SNA_CPIC=28,
+        NET_SNA_HPR=29,
+        NET_SNA_MPTN_APPLETALK=30,
+        NET_SNA_MPTN_IPXSPX=31,
+        NET_SNA_MPTN_IPV4=32,
+        NET_SNA_MPTN_IPV6=33,
+        NET_SNA_LU_RM=34,
+        NET_SNA_LU_SM=35,
+        NET_SNA_LU_HS=36,
+        NET_SNA_LU_PS=37,
+        NET_SNA_LU=38,
+        NET_SNA_MPTN=39,
+        NET_SNA=40,
+        NET_SNA_ASM=41,
+	NET_SNA_APPN=42,
+        NET_SNA_LAR=43
 };
 
 /* /proc/sys/kernel/random */
@@ -202,7 +228,47 @@
 
 /* /proc/sys/net/ethernet */
 
-/* /proc/sys/net/802 */
+/* /proc/sys/net/llc */
+enum {
+        NET_LLC_MAX_RETRY=1,
+        NET_LLC_MAX_SIZE=2,
+        NET_LLC_MAX_WINDOW=3,
+        NET_LLC_ACK_TIMER_EXPIRE=4,
+        NET_LLC_P_TIMER_EXPIRE=5,
+        NET_LLC_REJ_TIMER_EXPIRE=6,
+        NET_LLC_BUSY_TIMER_EXPIRE=7,
+        NET_LLC_DEBUG=8
+};
+
+/* /proc/sys/net/sna/lar */
+enum {
+        NET_SNA_LAR_FIND_TIMER_EXPIRE=1,
+        NET_SNA_LAR_FIND_COUNT=2,
+        NET_SNA_LAR_AD_TIMER_EXPIRE=3,
+        NET_SNA_LAR_AD_COUNT=4,
+        NET_SNA_LAR_SOLICIT_TIMER_EXPIRE=5,
+        NET_SNA_LAR_QUERY_TIMER_EXPIRE=6
+};
+
+/* /proc/sys/net/sna */
+enum {
+        NET_SNA_MAX_LINK_STATIONS=1,
+        NET_SNA_MAX_LU=2,
+        NET_SNA_MAX_MODE=3,
+        NET_SNA_XID_RETRY=4,
+        NET_SNA_MIA=5,
+        NET_SNA_MOA=6,
+        NET_SNA_MAX_RETRY=7,
+        NET_SNA_MAX_BTU=8,
+        NET_SNA_MAX_TX_RU=9,
+        NET_SNA_MAX_RX_RU=10,
+        NET_SNA_MAX_AUTO_ACT=11,
+        NET_SNA_DEBUG=12,
+        NET_SNA_XID_IDLE_LIMIT=13,
+        NET_SNA_XID_RETRY_INTERVAL=14,
+        NET_SNA_CO_MAX_RETRIES=15,
+	NET_SNA_MAX_LS_CNT=16
+};
 
 /* /proc/sys/net/unix */
 
diff -ruN linux-2.4.4/include/net/cpic.h linux/include/net/cpic.h
--- linux-2.4.4/include/net/cpic.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/cpic.h	Mon May 14 19:55:20 2001
@@ -0,0 +1,183 @@
+#ifndef _NET_CPIC_H
+#define _NET_CPIC_H
+
+#ifdef __KERNEL__
+
+typedef enum {
+	CM_RESET = 1,
+	CM_INIT,
+	CM_SEND,
+	CM_RCV,
+	CM_SEND_PEND,
+//	CM_CONFIRM,
+	CM_CONFIRM_SEND,
+	CM_CONFIRM_DEALLOC,
+	CM_INIT_INCOMING,
+	CM_SEND_RCV,
+	CM_SEND_ONLY,
+	CM_RCV_ONLY,
+	CM_DEFER_RCV,
+	CM_DEFER_DEALLOC,
+	CM_PREPARED,
+//	CM_SYNC_POINT,
+	CM_SYNC_POINT_SEND,
+	CM_SYNC_POINT_DEALLOC
+} cpic_state;
+
+#define NETWORK_NAME_LEN    9
+#define RESOURCE_NAME_LEN   9
+struct netid {
+        unsigned char net[NETWORK_NAME_LEN];
+        unsigned char name[RESOURCE_NAME_LEN];
+};
+
+struct cpic_side_info {
+        struct cpic_side_info   *next;
+        struct cpic_side_info   *prev;
+
+        unsigned long           proc_id;
+
+	struct netid		netid;
+	struct netid		netid_plu;
+
+        unsigned char           sym_dest_name[RESOURCE_NAME_LEN];
+        unsigned char           mode_name[RESOURCE_NAME_LEN];
+        unsigned char           tp_name[65];
+        unsigned char           service_tp;
+        unsigned short          security_level;
+        unsigned char           username[11];
+        unsigned char           password[11];
+};
+
+struct cpic {
+        cpic_state              state;
+        unsigned short          flags;
+
+        struct cpic_ops         *ops;
+        struct cpic_side_info   *side;
+        struct inode            *inode;
+        struct fasync_struct    *fasync_list;
+        struct file             *file;
+        pid_t                   pid;
+
+	union {
+        	struct sna_tcb         *sna;
+	} vi;
+
+        wait_queue_head_t       wait;
+};
+
+/* Should be:
+ *
+ *	struct cpic_ops {
+ *		int family;
+ *		*release
+ *		*create
+ *		*extract
+ *		*set
+ *		*rcv
+ *		*rcvx
+ *		*send
+ *		*sendx
+ *	};
+ */
+
+struct cpic_ops {
+        int     family;
+
+	struct sna_tcb *(*find_tcb_by_pid) (pid_t pid);
+        int     (*release)      (struct cpic *cpic);
+        int     (*create)       (struct cpic *cpic, int s);
+
+        __u32 (*cmsaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+/* 5 */ __u32 (*cmsac)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmsbt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsp)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*10*/  __u32 (*cmscst)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscsu)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsct)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmscu)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsdt)          (struct cpic *cpic, __u32 *a1);
+/*15*/  __u32 (*cmsed)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsend)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmserr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsf)           (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsid)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*20*/  __u32 (*cmsld)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsmn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmsndx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmspdp)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmspid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+/*25*/  __u32 (*cmspln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmspm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsptr)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsqcf)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+        __u32 (*cmsqpm)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+/*30*/  __u32 (*cmsrc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsrt)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmssrm)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsst)          (struct cpic *cpic, __u32 *a1);
+/*35*/  __u32 (*cmstc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmstpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeaeq)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmeapt)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3);
+        __u32 (*cmeacn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*40*/  __u32 (*cmecs)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmect)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmectx)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmeid)  (struct cpic *cpic, __u32 *a1, __u32 *a2, __u32 *a3);
+        __u32 (*cmemn)          (struct cpic *cpic, __u32 *a1, __u32 *a2);
+/*45*/  __u32 (*cmepid)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6, __u32 *a7);
+        __u32 (*cmepln)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmesi)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4);
+        __u32 (*cmesl)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmesrm)         (struct cpic *cpic, __u32 *a1);
+/*50*/  __u32 (*cmesui)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmetc)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmetpn)         (struct cpic *cpic, __u32 *a1, __u32 *a2);
+        __u32 (*cmallc)         (struct cpic *cpic);
+        __u32 (*cmcanc)         (struct cpic *cpic);
+/*55*/  __u32 (*cmcfmd)         (struct cpic *cpic);
+        __u32 (*cmcfm)          (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmdeal)         (struct cpic *cpic);
+        __u32 (*cmrcv)          (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5, __u32 *a6);
+        __u32 (*cmdfde)         (struct cpic *cpic);
+/*60*/  __u32 (*cmacci)         (struct cpic *cpic);
+        __u32 (*cmwait)         (struct cpic *cpic, __u32 *a1);
+        __u32 (*cmsltp)         (__u32 *a1, __u32 *a2);
+        __u32 (*cmflus)         (struct cpic *cpic);
+        __u32 (*cmincl)         (struct cpic *cpic);
+/*65*/  __u32 (*cmprep)         (struct cpic *cpic);
+        __u32 (*cmptr)          (struct cpic *cpic);
+        __u32 (*cmrcvx)         (struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5);
+        __u32 (*cmrts)          (struct cpic *cpic);
+        __u32 (*cmtrts)         (struct cpic *cpic, __u32 *a1);
+/*70*/  __u32 (*cminic)         (struct cpic *cpic);
+};
+
+extern int cpic_query_side_info(char *arg);
+extern int cpic_register_side_info(struct cpic_define_side_info *side);
+extern int cpic_unregister_side_info(struct cpic_delete_side_info *side);
+extern int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int cpic_register(struct cpic_ops *ops);
+extern int cpic_unregister(int family);
+
+#endif  /* __KERNEL__ */
+#endif /* _NET_CPIC_H */
diff -ruN linux-2.4.4/include/net/datalink.h linux/include/net/datalink.h
--- linux-2.4.4/include/net/datalink.h	Wed Aug 18 11:38:47 1999
+++ linux/include/net/datalink.h	Mon May 14 19:55:50 2001
@@ -2,15 +2,24 @@
 #define _NET_INET_DATALINK_H_
 
 struct datalink_proto {
-	unsigned short	type_len;
-	unsigned char	type[8];
-	const char	*string_name;
-	unsigned short	header_length;
-	int	(*rcvfunc)(struct sk_buff *, struct net_device *, 
-				struct packet_type *);
-	void	(*datalink_header)(struct datalink_proto *, struct sk_buff *,
-					unsigned char *);
-	struct datalink_proto	*next;
+        unsigned short  type_len;
+        unsigned char   type[8];
+        const char      *string_name;
+
+        union {
+                struct llc_pinfo *llc;
+        } ll_pinfo;
+
+        struct llc_sc_info *llc_sc;
+        struct sock *sock;
+
+        unsigned short  header_length;
+
+        int     (*rcvfunc)(struct sk_buff *, struct net_device *,
+                                struct packet_type *);
+        void    (*datalink_header)(struct datalink_proto *, struct sk_buff *,
+                                        unsigned char *);
+        struct datalink_proto   *next;
 };
 
 #endif
diff -ruN linux-2.4.4/include/net/llc.h linux/include/net/llc.h
--- linux-2.4.4/include/net/llc.h	Mon Dec 11 13:30:23 2000
+++ linux/include/net/llc.h	Mon May 14 21:22:19 2001
@@ -1,135 +1,1536 @@
+/*
+ * IEEE 802.2 for Linux, data structures and indicators.
+ */
+
+#ifndef __NET_LLC_H
+#define __NET_LLC_H
+
 #include <linux/skbuff.h>
+#include <linux/llc.h>
 
-#define LLC_MODULE
+#define LLC_SC_SAP		0x12	/* Linux Specific SC SAP. */
 
-typedef struct llc_struct llc;
-typedef struct llc_struct *llcptr;
+#define LLC_MSG_QUEUE_SIZE	20
 
-/*
- *	LLC private data area structure.
- */
+/* LLC timer indicators. */
+#define LLC_P_TIMER         	0
+#define LLC_REJ_TIMER       	1
+#define LLC_ACK_TIMER       	2
+#define LLC_BUSY_TIMER      	3
+#define LLC_TIMER_IDLE      	0
+#define LLC_TIMER_RUNNING   	1
+#define LLC_TIMER_EXPIRED   	2
+
+/* LLC operational modes. */
+#define LLC_MODE_ADM		1
+#define LLC_MODE_ABM 		2
+
+typedef struct
+{
+	unsigned pdu_type:1;	/* PDU type field. */
+	unsigned ns:7;		/* Send sequence #, network-order. */
+	unsigned pf:1;		/* Poll/Final command/response bit. */
+	unsigned nr:7;		/* Receive sequence #, network-order. */
+} llc_ictrl;
+
+typedef struct
+{
+	unsigned pdu_type:2;	/* PDU type field. */
+	unsigned cmd:2;		/* Supervisory command. */
+	unsigned __pad:4;	/* Zero'd out padding. */
+	unsigned pf:1;		/* Poll/Final command/response bit. */
+	unsigned nr:7;		/* Receive sequence #, network-order. */
+} llc_sctrl;
+
+typedef struct
+{
+	unsigned pdu_type:2;	/* PDU type field. */
+	unsigned mod1:2;	/* Modifer bits, field one. */
+	unsigned pf:1;		/* Poll/Final command/response bit. */
+	unsigned mod2:3;	/* Modifier bits, field two. */
+} llc_uctrl;
+
+typedef struct
+{
+	unsigned f1:1;
+	unsigned f2:1;
+	unsigned f3:6;
+} llc_bits;
+
+/* LLC data link header. */
+typedef struct
+{
+	__u8	dsap:8;	/* Destination Service Access Point. */
+	__u8	ssap:8;	/* Source Service Access Point. */
+
+	union {
+		llc_bits bits __attribute__ ((packed));
+		/* I PDU control bit fields. */
+		llc_ictrl ictrl __attribute__ ((packed));
+		/* S PDU control bit fields. */
+		llc_sctrl sctrl __attribute__ ((packed));
+		/* U PDU control bit fields. */
+		llc_uctrl uctrl __attribute__ ((packed));
+		__u8 ctrl __attribute__ ((packed));
+	} ctrl;
+} llchdr;
 
-struct llc_struct
-{ 
-	char eye[4];			/* To recognize llc area in dump */
-	int retry_count;		/* LLC link state variables */
-	unsigned char name[9];		/* name of this llc instance */
-	unsigned char s_flag;
-	unsigned char p_flag;
-	unsigned char f_flag;
-	unsigned char data_flag;
-	unsigned char cause_flag;
-	unsigned char vs;		/* Send state variable */
-	unsigned char vr;		/* Receive state variable */
-	unsigned char remote_busy;
-	unsigned char state;		/* Current state of type2 llc procedure */
-	int n1;				/* Maximum number of bytes in I pdu 7.8.2 */
-	int n2;				/* Naximum number of retransmissions 7.8.2 */
-	unsigned char k;		/* Transmit window size 7.8.4, tw in IBM doc*/ 
-	unsigned char rw;		/* Receive window size */
-	struct 
-	{     				
-		/*
-		 *	FRMR_RSP info field structure: 5.4.2.3.5 p55
-		 */
-
-		unsigned char cntl1;
-		unsigned char cntl2;
-		unsigned char vs;
-		unsigned char vr_cr;
-		unsigned char xxyz;
-	} frmr_info_fld;
-
-	/*
-	 *	Timers in 7.8.1 page 78 
-	 */
-
-#define P_TIMER         0
-#define REJ_TIMER       1
-#define ACK_TIMER       2 
-#define BUSY_TIMER      3
-	unsigned long timer_expire_time[4];	
-	unsigned char timer_state[4];	/* The state of each timer */
-#define TIMER_IDLE      0
-#define TIMER_RUNNING   1
-#define TIMER_EXPIRED   2
-	unsigned long timer_interval[4]; 
-	struct timer_list tl[4];
-
-	/* 
-	 *	Client entry point, called by the LLC.
-	 */
-	 
-	void	(*llc_event)(struct llc_struct *);
-	
-	/*
-	 *	Mux and Demux variables
-	 */
-	 
-	char * client_data;		/* Pointer to clients context */
-	unsigned char local_sap;
-	unsigned char remote_sap ;
-	char remote_mac[MAX_ADDR_LEN];  /* MAC address of remote session partner */ 
-	struct net_device *dev;		/* Device we are attached to */
-		     
-	unsigned char llc_mode;		/* See doc 7.1 on p70 */
-#define MODE_ADM 1
-#define MODE_ABM 2
-
-	int llc_callbacks;		/* Pending callbacks */
-#define LLC_CONN_INDICATION	1	/* We have to ensure the names don't */
-#define LLC_CONN_CONFIRM	2	/* mix up with the 802 state table */
-#define LLC_DATA_INDIC		4
-#define LLC_DISC_INDICATION	8
-#define LLC_RESET_INDIC_LOC	16
-#define LLC_RESET_INDIC_REM	32
-#define LLC_RST_CONFIRM		64
-#define LLC_FRMR_RECV		128
-#define LLC_FRMR_SENT		256
-#define LLC_REMOTE_BUSY		512
-#define LLC_REMOTE_NOTBUSY	1024
-#define LLC_TEST_INDICATION	2048
-#define LLC_XID_INDICATION	4096
-#define LLC_UI_DATA		8192
-
-	struct sk_buff *inc_skb;	/* Saved data buffer for indications */
-	
-	struct sk_buff_head rtq;	/* Retransmit queue */
-	struct sk_buff_head atq;	/* Await transit queue */
-      
-	unsigned char xid_count;
+typedef struct
+{
+	__u16	ctrl;
+	unsigned __pad1:1;
+	unsigned vs:7;
+	unsigned cr:1;
+	unsigned vr:7;
+	unsigned wxyz:4;
+	unsigned v:4;
+} llc_frmr;
 
-	struct llc_struct *nextllc;	/* ptr to next llc struct in proto chain */
+typedef struct
+{
+	__u8	format;		/* 10000001, IEEE Basic Format. */
+	unsigned class:5;	/* LLC Type/Class. */
+	unsigned __pad:4;
+	unsigned window:7;	/* Recieve window size (k). */
+} llc_xid;
+
+typedef struct
+{
+	unsigned vs:7;
+	unsigned vr:7;
+} llc_seq;
+
+/* LLC SC information */
+struct llc_sc_info
+{
+	struct llc_sc_info *next;
+	struct llc_sc_info *prev;
+
+	struct datalink_proto *llc_sap_list;
+	struct net_device *dev;
+
+	int state;
 };
 
-#define ADD_TO_RTQ(skb) skb_queue_tail(&lp->rtq,skb)
-#define ADD_TO_ATQ(skb) skb_queue_tail(&lp->atq,skb)
+/* LLC SAP information per socket. */
+struct llc_pinfo 
+{
+	int event;		/* Current event on the link. */
+	int state;		/* Current state of the link. LLC 1 */
+	int state2;		/* Current state of the link. LLC 2 */
+
+	int build;		/* Current PDU to be built. */
+	__u8 build_pf:1;	/* PF to use when Building PDU. */
+	int build_dsap;		/* DSAP to use when Building PDU. */
+
+	__u8 dmac[14];		/* XXX??? Destination Mac. may not stay */
+
+	__u8 dsap;
+	__u8 ssap;
+
+	int class;		/* LLC communication class. */
+
+	int s_flag;		/* Supervisory function bit. */
+	int p_flag;		/* Poll function bit. */
+	int f_flag;		/* Final function bit. */
+	int data_flag;		/* Number of toss'd PDUs due to a local busy. */
+	int remote_busy;	/* Indicates if the DSAP is busy. */
+
+	llc_seq seq;		/* Tx/Rx sequence numbers */
+
+#ifdef NOT
+	__u8 vs;		/* Send state variable. (Tx sequence #) */
+	__u8 vr;		/* Receive state variable. (Rx sequence #) */
+#endif
+
+	int retry_count;	/* Number of retransmits/retrys. */
+	int window_count;	/* Number of outstanding I PDUs. */
+	int xid_r_count;	/* Number of XID responses. */
+
+	int max_retry;		/* Maximm number of transmissions, N2. */
+	int max_size;		/* Maximum number of octets in an I PDU, N1. */
+	int max_window;		/* Maximum number of outstanding I PDUs, k. */
+
+	struct sk_buff_head rx_queue;
+
+	int tx_queue_depth;
+	struct sk_buff_head tx_queue;
+
+	int retransmitting;
+	int retx_queue_depth;
+	struct sk_buff_head retx_queue;
+
+	struct datalink_proto *dl;
+
+	int (*rcvfunc)(int rsp, struct sk_buff *);
+
+	int ack_expire;			/* Ack time-out value. */
+	struct timer_list ack_timer;	/* Acknowledgment timer. */
+	int p_expire;			/* P time-out value. */
+	struct timer_list p_timer;	/* P-bit timer. */
+	int rej_expire;			/* Reject time-out value. */
+	struct timer_list rej_timer;	/* Reject timer. */
+	int busy_expire;		/* Busy time-out value. */
+	struct timer_list busy_timer;	/* Busy timer. */
+};
+
+#define LLC_PDU_RSP		0x01
+#define LLC_P_FLAG		1
+#define LLC_F_FLAG		1
+#define LLC_X_FLAG		0
+
+#define LLC_XID_SIZE		3
+#define LLC_FRMR_SIZE		5
+
+/* LLC timer time-outs, these are linux specific (not to spec). */
+#define LLC_ACK_TIMER_EXPIRE	3 * HZ;
+#define LLC_P_TIMER_EXPIRE	3 * HZ;
+#define LLC_REJ_TIMER_EXPIRE	10 * HZ;
+#define LLC_BUSY_TIMER_EXPIRE	15 * HZ;
+
+/* LLC maximum counts, these are linux specific (not to spec). */
+#define LLC_RETRY		10
+#define LLC_SIZE		65535	/* Should hold us for a while ;) */
+#define LLC_WINDOW		15
+
+/* LLC PDU types. */
+#define LLC_I_CMD			0x00
+#define LLC_I_RSP			0x01
+#define LLC_RR_CMD			0x02
+#define LLC_RR_RSP			0x03
+#define LLC_ACK_CMD			LLC_RR_CMD
+#define LLC_ACK_RSP			LLC_RR_RSP
+#define LLC_RNR_CMD			0x04
+#define LLC_RNR_RSP			0x05
+#define LLC_REJ_CMD			0x06
+#define LLC_REJ_RSP			0x07
+#define LLC_FRMR_RSP			0x08
+#define LLC_UI_CMD			0x09
+#define LLC_TEST_CMD			0x0A
+#define LLC_TEST_RSP			0x0B
+#define LLC_DISC_CMD			0x0C
+#define LLC_UA_RSP			0x0D
+#define LLC_DM_RSP			0x0E
+#define LLC_XID_CMD			0x0F
+#define LLC_XID_RSP			0x10
+#define LLC_SABME_CMD			0x11
+
+/* LLC Control Byte Assignments. */
+#define LLC_CTRL_I_CMD			0x00
+#define LLC_CTRL_I_RSP			LLC_CTRL_I_CMD
+#define LLC_CTRL_RR_CMD			0x01
+#define LLC_CTRL_RR_RSP			LLC_CTRL_RR_CMD
+#define LLC_CTRL_RNR_CMD		0x05
+#define LLC_CTRL_RNR_RSP		LLC_CTRL_RNR_CMD
+#define LLC_CTRL_REJ_CMD		0x09
+#define LLC_CTRL_REJ_RSP		LLC_CTRL_REJ_CMD
+#define LLC_CTRL_DISC_CMD		0x43
+#define LLC_CTRL_SABME_CMD		0x7F
+#define LLC_CTRL_UA_RSP			0x63
+#define LLC_CTRL_DM_RSP			0x0F
+#define LLC_CTRL_FRMR_RSP		0x87
+#define LLC_CTRL_UI_CMD			0x03
+#define LLC_CTRL_XID_CMD		0xBF
+#define LLC_CTRL_XID_RSP		LLC_CTRL_XID_CMD
+#define LLC_CTRL_TEST_CMD		0xF3		/* Was 0xE3 */
+#define LLC_CTRL_TEST_RSP		LLC_CTRL_TEST_CMD
+
+/* LLC connection states, Type 1 and Type 2. */
+#define LLC_STATE_DISCONNECTED		0x00
+#define LLC_STATE_DISCONNECTING		0x01
+#define LLC_STATE_RESETTING		0x02
+#define LLC_STATE_FRMR_TX		0x03
+#define LLC_STATE_FRMR_RX		0x04
+#define LLC_STATE_CONNECTING		0x05
+#define LLC_STATE_CONNECTED		0x06
+#define LLC_STATE_CHKPOINT		0x07
+#define LLC_STATE_LOCAL_BUSY		0x08	/* User and Buffer. */
+#define LLC_STATE_REMOTE_BUSY		0x09
+#define LLC_STATE_REJECTION		0x0A
+#define LLC_STATE_CLEARING		0x0B
+#define LLC_STATE_DYNWINDOW		0x0C
+
+/* Message/Command action words. */
+#define ENABLE_W_DUP_ADDR_CHK	LLC_STATE_ENABLE_W_DUPLICATE_ADDRESS_CHK
+#define ENABLE			LLC_STATE_ENABLE_WOUT_DUPLICATE_ADDRESS_CHK
+
+#define LLC_R_XID_C_INDICATION			0x01
+#define LLC_R_XID_R_INDICATION			0x02
+#define LLC_R_TEST_C_INDICATION			0x03
+#define LLC_R_TEST_R_INDICATION			0x04
+
+
+
+#define LLC_STATE_SEND_XID_R_DATA		0x9F	/* Linux specific. */
+
+/* Linux LLC states for the Linux LLC state machine. 
+ * - IEEE 802.2-1989 state naratives are provided for the enjoyment
+ *   of the reader.
+ */
+
+/* Linux LLC Type 1 states. */
+#define LLC_STATE_DOWN			0x90	/* DOWN_STATE. The station
+						 * component is powered off,
+						 * not initialized, and/or
+						 * disabled from operating in
+						 * the local area network.
+						 */
+#define LLC_STATE_DUPLICATE_ADDRESS_CHK	0x91	/* DUPLICATE_ADDRESS_CHECK_STATE
+						 * The station component is in
+						 * the process of checking for
+						 * duplicate MAC addresses on
+						 * the LAN. The main purpose of
+						 * this state shall be to allow
+						 * the LLC station component to
+						 * verify that this station's
+						 * MAC address is unique on the
+						 * LAN. The station component
+						 * shall send XID command PDUs
+						 * with identical MAC DA and SA
+						 * addresses, and shall wait for
+						 * a possible XID Response PDU
+						 * indicating the existance of
+						 * other stations with identical
+						 * MAC link addresses.
+						 */
+#define LLC_STATE_UP			0x92	/* UP_STATE. The station 
+						 * component is enabled, powered
+						 * on, initialized, and 
+						 * operating in the local area
+						 * network. The LLC shall allow
+						 * SAPs to exchange LLC PDUs on
+						 * the medium.
+						 */
+#define LLC_STATE_ENABLE_W_DUPLICATE_ADDRESS_CHK 0x93
+						/* ENABLE_WITH_DUPLICATE_
+						 * ADDRESS_CHECK. Station
+						 * component user has 
+						 * initialized/enabled the
+						 * station equipment, and has
+						 * requested that the LLC check
+						 * for MAC service access point
+						 * address duplications before
+						 * participating in data link
+						 * communications.
+						 */
+#define LLC_STATE_ENABLE_WOUT_DUPLICATE_ADDRESS_CHK 0x94
+						/* ENABLE_WITHOUT_DUPLICATE_
+						 * ADDRESS_CHECK. Station
+						 * component user has
+						 * initialized/enabled the
+						 * station equipment, but
+						 * duplicate MAC service access
+						 * point address checking by the
+						 * LLC is not supported/desired.
+						 */
+#define LLC_STATE_ACK_TIMER_EXPIRED_AND_RETRY_COUNT_OK 0x95
+						/* ACK_TIMER_EXPIRED_AND_RETRY_
+						 * COUNT<MAXIMUM_RETRY.
+						 * Acknowledgment timer has
+						 * expired and retry count is
+						 * less than maximum retry 
+						 * limit.
+						 */
+#define LLC_STATE_ACK_TIMER_EXPIRED_AND_RETRY_COUNT_MAX 0x96
+						/* ACK_TIMER_EXPIRED_AND_RETRY_
+						 * COUNT=MAXIMUM_RETRY.
+						 * Acknowledgment timer has
+						 * expired and retry count is
+						 * equal to the maximum retry
+						 * limit.
+						 */
+#define LLC_STATE_RECEIVE_NULL_DSAP_XID_C 0x97	/* RECEIVE_NULL_DSAP_XID_C. An
+						 * XID command PDU with the
+						 * NULL DSAP address has been
+						 * received.
+						 */
+#define LLC_STATE_RECEIVE_NULL_DSAP_XID_R 0x98
+						/* RECEIVE_NULL_DSAP_XID_R_AND_
+						 * XID_R_COUNT=0. A single XID
+						 * response PDU with the null
+						 * DSAP address has been 
+						 * received.
+						 */
+#define LLC_STATE_RECEIVE_NULL_DSAP_XID_R_AND_XID_R_CNT_1 0x99
+						/* RECEIVE_NULL_DSAP_XID_R_AND_
+						 * XID_R_COUNT=1. A second XID
+						 * response PDU with the null
+						 * DSAP address have been
+						 * received.
+						 */
+#define LLC_STATE_RECEIVE_NULL_DSAP_TEST_C 0x9A	/* RECEIVE_NULL_DSAP_TEST_C. A
+						 * TEST command PDU with the
+						 * null DSAP address has been
+						 * received.
+						 */
+#define LLC_STATE_DISABLE_REQUEST	0x9B	/* DISABLE_REQUEST. Station user
+						 * has requested that the
+						 * equipment be disabled from
+						 * operating on the medium.
+						 */
+#define LLC_STATE_XID_R_COUNT_0		0x9F	/* XID_R_COUNT:=0. Initialize
+						 * the XID response PDU counter.
+						 */
+#define LLC_STATE_XID_R_COUNT_PLUS_1	0xA0	/* XID_R_COUNT:=XID_R_COUNT+1.
+						 * Increment the XID response
+						 * PDU counter.
+						 */
+#define LLC_STATE_SEND_NULL_DSAP_XID_C	0xA1	/* SEND_NULL_DSAP_XID_C. The LLC
+						 * shall send an XID command PDU
+						 * with null SSAP and null DSAP
+						 * addresses and with identical
+						 * MAC DA and SA addresses.
+						 */
+#define LLC_STATE_SEND_XID_R		0xA2	/* SEND_XID_R. The LLC shall 
+						 * send an XID response PDU,
+						 * using the SSAP address of the
+						 * XID command PDU as the DSAP
+						 * address of the response PDU,
+						 * and using a null SSAP 
+						 * address.
+						 */
+#define LLC_STATE_SEND_TEST_R		0xA3	/* SEND_TEST_R. The LLC shall
+						 * send a TEST response PDU,
+						 * using the SSAP address of the
+						 * TEST command PDU as the DSAP
+						 * address of the response PDU,
+						 * and using a null SSAP 
+						 * address.
+						 */
+#define LLC_STATE_RPT_STATION_UP	0xA4	/* REPORT_STATUS(STATION_UP).
+						 * LLC entity is now 
+						 * operational.
+						 */
+#define LLC_STATE_RPT_STATION_DOWN	0xA5	/* REPORT_STATUS(STATION_DOWN).
+						 * The LLC entity is now
+						 * non-operational.
+						 */
+#define LLC_STATE_RPT_DUPLOCATE_ADDRESS_FOUND 0xA6
+						/* REPORT_STATUS(DUPLICATE_
+						 * ADDRESS_FOUNT). LLC entity 
+						 * has detected another LLC
+						 * entity on the LAN with a MAC
+						 * service access point address
+						 * identical to its own.
+						 */
+#define LLC_STATE_INACTIVE		0xA7	/* INACTIVE_STATE. LLC SAP
+						 * component is not active,
+						 * functioning, or operational.
+						 * No PDUs are accepted and/or
+						 * sent.
+						 */
+#define LLC_STATE_ACTIVE		0xA8	/* ACTIVE_STATE. LLC SAP
+						 * component is active, 
+						 * functioning, and operational.
+						 * PDUs are received and sent.
+						 */
+#define LLC_STATE_SAP_ACTIVATION_REQUEST 0xA9	/* SAP_ACTIVATION_REQUEST. The
+						 * SAP user has requested that
+						 * the particular LLC SAP
+						 * component be activated and
+						 * begin logical data link
+						 * operation of the Type 1
+						 * services.
+						 */
+#define LLC_STATE_SAP_DEACTIVATION_REQUEST 0xAA	/* SAP_DEACTIVATION_REQUEST. The
+						 * SAP user has requested that
+						 * the particular LLC SAP
+						 * component be deactivated and
+						 * no longer allow to operate on
+						 * the logical data link.
+						 */
+#define LLC_STATE_XID_REQUEST		0xAB	/* XID_REQUEST. The SAP user has
+						 * requested that the LLC SAP
+						 * component send an XID
+						 * command PDU to one or more
+						 * remote SAPs.
+						 */
+#define LLC_STATE_TEST_REQUEST		0xAC	/* TEST_REQUEST. The SAP user 
+						 * has requested that the LLC
+						 * SAP component send a TEST
+						 * command PDU to one or more
+						 * remote SAPs.
+						 */
+#define LLC_STATE_RECEIVE_UI		0xAD	/* RECEIVE_UI. The local SAP
+						 * component has received a UI
+						 * PDU from a remote SAP.
+						 */
+#define LLC_STATE_UNITDATA_REQUEST	0xAE	/* UNITDATA_REQUEST. The SAP
+						 * user has requested that a
+						 * data unit be passed to a
+						 * remote LLC SAP, via a UI PDU.
+						 */
+#define LLC_STATE_RECEIVE_XID_C		0xAF	/* RECEIVE_XID_C. The local SAP
+						 * component has received an XID
+						 * command PDU from a remote 
+						 * SAP.
+						 */
+#define LLC_STATE_RECEIVE_XID_R		0xB0	/* RECEIVE_XID_R. The local SAP
+						 * component has received an XID
+						 * response PDU from a remote 
+						 * SAP.
+						 */
+#define LLC_STATE_RECEIVE_TEST_C	0xB1	/* RECEIVE_TEST_C. The local SAP
+						 * component has received a TEST
+						 * command PDU from the remote
+						 * SAP.
+						 */
+#define LLC_STATE_RECEIVE_TEST_R	0xB2	/* RECEIVE_TEST_R. The local SAP
+						 * component has received a TEST
+						 * response PDU from the remote
+						 * SAP.
+						 */
+#define LLC_STATE_UNITDATA_INDICATION	0xB3	/* UNITDATA_INDICATION. LLC SAP
+						 * component has received a UI
+						 * PDU from a remote SAP. The
+						 * service data unit is given to
+						 * the SAP user.
+						 */
+#define LLC_STATE_SEND_UI		0xB4	/* SEND_UI. A UI PDU is sent to
+						 * one or more remote SAPs in
+						 * response to a user request to
+						 * send a service data unit.
+						 */
+#define LLC_STATE_SEND_XID_C		0xB5	/* SEND_XID_C. LLC SAP component
+						 * shall send an XID command PDU
+						 * to remote SAPs in response to
+						 * a SAP user request to 
+						 * identify other SAPs.
+						 */
+#define LLC_STATE_SEND_TEST_C		0xB7	/* SEND_TEST_C. LLC SAP 
+						 * component shall send a TEST
+						 * command PDU in response to
+						 * a SAP user request to test
+						 * a remote SAP.
+						 */
+#define LLC_STATE_RPT_SAP_ACTIVE	0xB9	/* REPORT_STATUS(SAP_ACTIVE).
+						 * The SAP_ACTIVATION_REQUEST
+						 * has been successfully
+						 * processed and the component
+						 * is now operational.
+						 */
+#define LLC_STATE_RPT_SAP_INACTIVE	0xBA	/* REPORT_STATUS(SAP_INACTIVE).
+						 * The SAP_DEACTIVATION_REQUEST
+						 * has been successfully
+						 * processed and the component
+						 * is now deactivated.
+						 */
+#define LLC_STATE_XID_INDICATION	0xBB	/* XID_INDICATION. LLC SAP
+						 * component has received an XID
+						 * response PDU from a remote
+						 * SAP. An indication of this
+						 * event is passed to the SAP
+						 * user, and may also return the
+						 * XID information field.
+						 */
+#define LLC_STATE_TEST_INDICATION	0xBC	/* TEST_INDICATION. LLC SAP
+						 * component has received a
+						 * TEST response PDU from a
+						 * remote SAP. An indication of
+						 * this event is passed to the
+						 * SAP user, and may also return
+						 * the TEST information field.
+						 */
+
+/* Linux LLC Type 2 states. */
+#define LLC_STATE_ADM			0x00	/* ADM. The connection component
+						 * is in the asynchronous
+						 * disconnected mode. It can
+						 * accept an SABME PDU from a
+						 * remote LLC SSAP or, at the
+						 * request of the service access
+						 * point user, can initiate an
+						 * SABME PDU transmission to a
+						 * remote LLC DSAP, to establish
+						 * a data link connection. It
+						 * also responds to a DISC
+						 * command PDU and to any 
+						 * command PDU with the P bit
+						 * set to "1".
+						 */
+#define LLC_STATE_SETUP			0x01	/* SETUP. The connection 
+						 * component has transmitted an
+						 * SABME command PDU to a remote
+						 * LLC DSAP and is waiting for
+						 * a reply.
+						 */
+#define LLC_STATE_NORMAL		0x02	/* NORMAL. A data link 
+						 * connection exists between the
+						 * local LLC service access 
+						 * point and the remote LLC
+						 * service access point. Sending
+						 * and reception of information
+						 * and supervisory PDUs can be
+						 * performed.
+						 */
+#define LLC_STATE_BUSY			0x03	/* BUSY. A data link connection
+						 * exists between the local LLC
+						 * service access point and the
+						 * remote LLC service access
+						 * point. I PDUs may be sent.
+						 * Local conditions make it 
+						 * likely that the information
+						 * field of received I PDUs will
+						 * be ignored. Supervisory PDUs
+						 * may be both sent and received
+						 */
+#define LLC_STATE_REJECT		0x04	/* REJECT. A data link 
+						 * connection exists between the
+						 * local LLC service access 
+						 * point and the remote LLC
+						 * service point The remote
+						 * connection component has
+						 * requested that the remote
+						 * connection component resend
+						 * a specified I PDU that the
+						 * local connection component
+						 * has detected as being out
+						 * of sequence. Both I PDUs and
+						 * supervisory PDUs may be
+						 * sent and received.
+						 */
+#define LLC_STATE_AWAIT			0x05	/* AWAIT. A data link connection
+						 * exists between the local LLC
+						 * service access point and the
+						 * remote LLC service access
+						 * point. The local LLC is
+						 * performing a timer recovery
+						 * operation and has sent a
+						 * command PDU with the P bit
+						 * set to "1", and is awaiting
+						 * an acknowledgment from the
+						 * remote LLC. I PDUs may be
+						 * received but not sent.
+						 * Supervisory PDUs may be both
+						 * sent and received.
+						 */
+#define LLC_STATE_AWAIT_BUSY		0x06	/* AWAIT_BUSY. A data link
+						 * connection exists between the
+						 * local LLC service access
+						 * point and the remote LLC
+						 * service access point. The 
+						 * local LLC is performing a
+						 * timer recovery operation and
+						 * has sent a command PDU with 
+						 * the P bit set to "1", and is
+						 * awaiting an acknowledgment
+						 * from the remote LLC. I PDUs
+						 * may not be sent. Local
+						 * conditions make it likely
+						 * that the information field of
+						 * received I PDUs will be 
+						 * ignored. Supervisory PDUs may
+						 * be both sent and received.
+						 */
+#define LLC_STATE_AWAIT_REJECT		0x07	/* AWAIT_REJECT. A data link
+						 * connection exists between the
+						 * local LLC service access
+						 * point and the remote LLC
+						 * service access point. The
+						 * local connection component
+						 * has requested that the remote
+						 * connection component
+						 * re-transmit a specified I PDU
+						 * that the local connection
+						 * component has detected as
+						 * being out of sequence. Before
+						 * the local LLC entered this
+						 * state it was performing a
+						 * timer recovery operation and
+						 * had sent a command PDU with
+						 * the P bit set to "1", and is
+						 * still awaiting an 
+						 * acknowledgment from the 
+						 * remote LLC. I PDUs may be
+						 * received but not transmitted.
+						 * Supervisory PDUs may be both
+						 * transmitted and received.
+						 */
+#define LLC_STATE_D_CONN		0x08	/* D_CONN. At the request of the
+						 * service access point user, 
+						 * the local LLC has sent a DISC
+						 * command PDU to the remote LLC
+						 * DSAP and it waiting for a
+						 * reply.
+						 */
+#define LLC_STATE_RESET			0x09	/* RESET. As a result of a 
+						 * service access point user
+						 * request or the receipt of a
+						 * FRMR response PDU, the local
+						 * connection component has sent
+						 * an SABME command PDU to the
+						 * remote LLC DSAP to reset the
+						 * data link connection and is
+						 * waiting for a reply.
+						 */
+#define LLC_STATE_ERROR			0x0A	/* ERROR. The local connection
+						 * component has detected an
+						 * error in a received PDU and
+						 * has sent a FRMR response PDU.
+						 * It is waiting for a reply
+						 * from the remote connection
+						 * component.
+						 */
+#define LLC_STATE_CONN			0x0B	/* CONN. The local connection
+						 * component has received an
+						 * SABME PDU from a remote LLC
+						 * SSAP, and it is waiting for
+						 * the local user to accept or
+						 * refuse the connection.
+						 */
+#define LLC_STATE_RESET_CHECK		0x0C	/* RESET_CHECK. The local
+						 * connection component is 
+						 * waiting for the local user to
+						 * accept or refuse a remote
+						 * reset request.
+						 */
+#define LLC_STATE_RESET_WAIT		0x0D	/* RESET_WAIT. The local 
+						 * connection component is 
+						 * waiting for the local user to
+						 * indicate a RESET_REQUEST or a
+						 * DISCONNECT_REQUEST.
+						 */
+#define LLC_STATE_CONNECT_REQUEST	0x10	/* CONNECT_REQUEST. The user has
+						 * requested that a data link
+						 * connection be established 
+						 * with a remote LLC DSAP.
+						 */
+#define LLC_STATE_CONNECT_RESPONSE	0x11	/* CONNECT_RESPONSE. The user
+						 * has accepted the data link
+						 * connection.
+						 */
+#define LLC_STATE_DATA_REQUEST		0x12	/* DATA_REQUEST. The user has
+						 * requested that a data unit
+						 * be sent to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_DISCONNECT_REQUEST	0x13	/* DISCONNECT_REQUEST. The user
+						 * has requested that the data
+						 * link connection with the
+						 * remote LLC DSAP be 
+						 * terminated.
+						 */
+#define LLC_STATE_RESET_REQUEST		0x14	/* RESET_REQUEST. The user has
+						 * requested that the data link
+						 * connection with the remote
+						 * LLC DSAP be reset.
+						 */
+#define LLC_STATE_RESET_RESPONSE	0x15	/* RESET_RESPONSE. The user has
+						 * accepted the reset of the 
+						 * data link connection.
+						 */
+#define LLC_STATE_LOCAL_BUSY_DETECTED	0x16	/* LOCAL_BUSY_DETECTED. The
+						 * local station has entered a
+						 * busy condition and may not
+						 * be able to accept I PDUs from
+						 * the remote LLC SSAP.
+						 */
+#define LLC_STATE_LOCAL_BUSY_CLEARED	0x17	/* LOCAL_BUSY_CLEARED. The local
+						 * station busy condition has
+						 * ended and the station can
+						 * accept I PDUs from the remote
+						 * LLC SSAP.
+						 */
+#define LLC_STATE_RECEIVE_BAD_PDU	0x18	/* RECEIVE_BAD_PDU. The remote
+						 * SSAP has sent to the local
+						 * DSAP a command or response
+						 * PDU which is not implemented,
+						 * or has an information field
+						 * when not permitted, or is an
+						 * I PDU with an information
+						 * field length greater than can
+						 * be accommodated by the local
+						 * LLC.
+						 */
+#define LLC_STATE_RECEIVE_DISC_CMD	0x19	/* RECEIVE_DISC_CMD(P=X). The
+						 * remote SSAP has sent a DISC
+						 * command PDU with the P bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_DM_RSP	0x1A	/* RECEIVE_DM_RSP(F=X). The
+						 * remote SSAP has sent a DM
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_FRMR_RSP	0x1B	/* RECEIVE_FRMR_RSP(F=X). The
+						 * remote SSAP has sent a
+						 * FRMR response PDU with the F
+						 * bit set to "X" addressed to
+						 * the local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_I_CMD		0x1C	/* RECEIVE_I_CMD(P=X). The 
+						 * remote SSAP has sent a I
+						 * command PDU with the P bit 
+						 * set to "X" addressed to the
+						 * local DSAP. Both the N(R) and
+						 * N(S) fields are valid and the
+						 * N(S) value is the expected
+						 * sequence number.
+						 */
+#define LLC_STATE_RECEIVE_I_CMD_W_UNEXPECTED_SEQ 0x1D
+						/* RECEIVE_I_CMD(P=X)_WITH_
+						 * UNEXPECTED_N(S). The remote
+						 * SSAP has sent an I command
+						 * PDU with the P bit set to
+						 * "X" addressed to the local
+						 * DSAP. The N(S) field of the
+						 * command does not contain the
+						 * expected sequence number but
+						 * is within the windows size.
+						 * The N(R) field is valid.
+						 */
+#define LLC_STATE_RECEIVE_I_CMD_W_INVALID_SEQ 0x1E
+						/* RECEIVE_I_CMD(P=X)_WITH_
+						 * INVALID_N(S). The remote SSAP
+						 * has sent an I command PDU 
+						 * with the P bit set to "X"
+						 * addressed to the local DSAP.
+						 * The N(S) field of the command
+						 * is invalid. The N(R) field is
+						 * valid.
+						 */
+#define LLC_STATE_RECEIVE_I_RSP		0x1F	/* RECEIVE_I_RSP(F=X). The 
+						 * remote SSAP has sent a I
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP. Both the N(R) and
+						 * N(S) fields are valid and the
+						 * N(S) value is the expected
+						 * sequence number.
+						 */
+#define LLC_STATE_RECEIVE_I_RSP_W_UNEXPECTED_SEQ 0x20
+						/* RECEIVE_I_RSP(F=X)_WITH_
+						 * UNEXPECTED_N(S). The remote
+						 * SSAP has sent an I response
+						 * PDU with the F bit set to "X"
+						 * addressed to the local DSAP.
+						 * The N(S) field of the command
+						 * does not contain the expected
+						 * sequence number but is within
+						 * the window size.
+						 */
+#define LLC_STATE_RECEIVE_I_RSP_W_INVALID_SEQ 0x21
+						/* RECEIVE_I_RSP(F=X)_WITH_
+						 * INVALID_N(S). The remote SSAP
+						 * has sent an I response PDU
+						 * with the F bit set to "X"
+						 * addressed to the local DSAP.
+						 * The N(S) field of the 
+						 * response is invalid. The N(R)
+						 * field is valid.
+						 */
+#define LLC_STATE_RECEIVE_REJ_CMD	0x22	/* RECEIVE_REJ_CMD(P=X). The
+						 * remote SSAP has sent a REJ
+						 * command PDU with the P bit 
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_REJ_RSP	0x23	/* RECEIVE_REJ_RSP(F=X). The
+						 * remote SSAP has sent a REJ
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_RNR_CMD	0x24	/* RECEIVE_RNR_CMD(P=X). The
+						 * remote SSAP has sent a REJ
+						 * response PDU with the P bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_RNR_RSP	0x25	/* RECEIVE_RNR_RSP(F=X). The
+						 * remote SSAP has sent a RNR
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_RR_CMD	0x26	/* RECEIVE_RR_CMD(P=X). The
+						 * remote SSAP has sent a RNR
+						 * command PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_RR_RSP	0x27	/* RECEIVE_RR_RSP(F=X). The
+						 * remote SSAP has sent a RR
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_SABME_CMD	0x28	/* RECEIVE_SABME_CMD(P=X). The
+						 * remote SSAP has sent an SABME
+						 * command PDU with the P bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_UA_RSP	0x29	/* RECEIVE_UA_RSP(F=X). The
+						 * remote SSAP has sent a UA
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP.
+						 */
+#define LLC_STATE_RECEIVE_XXX_CMD	0x2A	/* RECEIVE_XXX_CMD(F=X). The
+						 * remote SSAP has sent a Type 2
+						 * command PDU with the P bit
+						 * set to "X" addressed to the
+						 * local DSAP. The command is
+						 * any command not specificly
+						 * listed for that state.
+						 */
+#define LLC_STATE_RECEIVE_XXX_RSP	0x2B	/* RECEIVE_XXX_RSP(F=X). The
+						 * remote SSAP has sent a Type 2
+						 * response PDU with the F bit
+						 * set to "X" addressed to the
+						 * local DSAP. The response is
+						 * any response not specifically
+						 * listed for that state.
+						 */
+#define LLC_STATE_RECEIVE_XXX_YYY	0x2C	/* RECEIVE_XXX_YYY. The remote
+						 * SSAP has sent a Type 2 PDU
+						 * addressed to the local DSAP.
+						 * The PDU is any command or
+						 * response not specificly 
+						 * listed for that state.
+						 */
+#define LLC_STATE_RECEIVE_ZZZ_CMD_W_INVALID_SEQ	0x2D
+						/* RECEIVE_ZZZ_CMD(P=X)_WITH_
+						 * INVALID_N(R). The remote
+						 * SSAP has sent an I, RR, RNR,
+						 * or REJ command PDU with the
+						 * P bit set to "X" addressed to
+						 * the local DSAP. The N(R) 
+						 * field of the command is 
+						 * invalid.
+						 */
+#define LLC_STATE_RECEIVE_ZZZ_RSP_W_INVALID_SEQ	0x2E
+						/* RECEIVE_ZZZ_RSP(F=X)_WITH_
+						 * INVALID_N(R). The remote SSAP
+						 * has sent an I, RR, RNR, or
+						 * REJ command PDU with the F 
+						 * bit set to "X" addressed to 
+						 * the local DSAP. The N(R) 
+						 * field of the response is
+						 * invalid.
+						 */
+#define LLC_STATE_P_TIMER_EXPIRED	0x2F	/* P_TIMER_EXPIRED. The P/F 
+						 * cycle timer has expired.
+						 */
+#define LLC_STATE_ACK_TIMER_EXPIRED	0x30	/* ACK_TIMER_EXPIRED. The
+						 * acknowledgment timer has
+						 * expired.
+						 */
+#define LLC_STATE_REJ_TIMER_EXPIRED	0x31	/* REJ_TIMER_EXPIRED. The "sent
+						 * REJ" timer has expired.
+						 */
+#define LLC_STATE_BUSY_TIMER_EXPIRED	0x32	/* BUSY_TIMER_EXPIRED. The
+						 * remote-busy timer has expired
+						 * In the state transition table
+						 * some of the above events are
+						 * qualified by the following
+						 * conditions. The event is
+						 * recognized only when the
+						 * condition is true.
+						 */
+#define LLC_STATE_P_FLAG_1		0x37	/* P_FLAG=1. P_FLAG has a value
+						 * of one when a command with 
+						 * the P bit set to "1" has been
+						 * sent and a response with the
+						 * F bit set to "1" is expected.
+						 */
+#define LLC_STATE_P_FLAG_F		0x38	/* P_FLAG=F. P_FLAG has a value
+						 * equal to the F bit in the
+						 * response PDU received.
+						 */
+#define LLC_STATE_REMOTE_BUSY_1		0x39	/* REMOTE_BUSY=1. When
+						 * REMOTE_BUSY has a value of
+						 * one, an RNR PDU has been
+						 * received from the remote
+						 * connection commponent to
+						 * indicate that I PDUs should
+						 * not be sent. DATA_REQUEST
+						 * events are not recognized
+						 * until this flag is reset to
+						 * zero.
+						 */
+#define LLC_STATE_RETRY_COUNT_OK	0x3B	/* RETRY_COUNT<N2. The number of
+						 * retries is less than the
+						 * maximum number of retries.
+						 */
+#define LLC_STATE_RETRY_COUNT_MAX	0x3C	/* RETRY_COUNT>=N2. The number
+						 * of retries has reached the
+						 * maximum number permissible.
+						 */
+#define LLC_STATE_INIT_PF_CYCLE		0x3F	/* INITIATE_P/F_CYCLE. The local
+						 * LLC wants to initiate a P/F
+						 * cycle. (This is only required
+						 * if the local LLC is not
+						 * generating other command PDUs
+						 * for some reason.
+						 */
+#define LLC_STATE_CLEAR_REMOTE_BUSY	0x40	/* CLEAR_REMOTE_BUSY. If
+						 * REMOTE_BUSY has a value of
+						 * one, then set REMOTE_BUSY to
+						 * zero to indicate the remote
+						 * LLC is now able to accept I
+						 * PDUs, stop the BUSY_TIMER,
+						 * inform the user by issuing
+						 * REPORT_STATUS(
+						 * REMOTE_NOT_BUSY) and, 
+						 * provided the local LLC is in
+						 * the NORMAL, REJECT, or BUSY
+						 * state, start the (re)sending
+						 * of any I PDUs that were 
+						 * waiting for the remote busy
+						 * to be cleared.
+						 */
+#define LLC_STATE_CONNECT_INDICATION	0x41	/* CONNECT_INDICATION. Inform
+						 * the user that a connection
+						 * has been requested by a
+						 * remote LLC SSAP.
+						 */
+#define LLC_STATE_CONNECT_CONFIRM	0x42	/* CONENCT_CONFIRM. The
+						 * connection service component
+						 * indicates that the remote
+						 * network entity has accepted
+						 * the connection.
+						 */
+#define LLC_STATE_DATA_INDICATION	0x43	/* DATA_INDICATION. The 
+						 * connection service component
+						 * passes the data unit from the
+						 * received I PDU to the user.
+						 */
+#define LLC_STATE_DISCONNECT_INDICATION	0x44	/* DISCONNECT_INDICATION. Inform
+						 * the user that the remote
+						 * network entity has initiated
+						 * disconnection of the data 
+						 * link connection.
+						 */
+#define LLC_STATE_REMOTE_RESET_INDICATION 0x45	/* REMOTE_RESET_INDICATION. The
+						 * remote network entity or
+						 * remote peer has initiated a
+						 * reset of the data link
+						 * connection.
+						 */
+#define LLC_STATE_LOCAL_RESET_INDICATION 0x46	/* LOCAL_RESET_INDICATION. The
+						 * local LLC has determined that
+						 * the data link connection is
+						 * in need of reinitialization.
+						 */
+#define LLC_STATE_RESET_CONFIRM		0x47	/* RESET_CONFIRM. The connection
+						 * service component indicated
+						 * that the remote network
+						 * entity has accepted the
+						 * reset.
+						 */
+#define LLC_STATE_RPT_FRMR_RECEIVED	0x48	/* REPORT_STATUS. FRMR_RECEIVED.
+						 * The local connection service
+						 * component has received a FRMR
+						 * response PDU.
+						 */
+#define LLC_STATE_RPT_FRMR_SENT		0x49	/* REPORT_STATUS. FRMR_SENT. The
+						 * local connection service
+						 * component has received an
+						 * invalid PDU, and has sent a
+						 * FRMR response PDU.
+						 */
+#define LLC_STATE_RPT_REMOTE_BUSY	0x4A	/* REPORT_STATUS. REMOTE_BUSY.
+						 * The remote LLC DSAP is busy.
+						 * The local connection service
+						 * component will not accept a
+						 * DATA_REQUEST.
+						 */
+#define LLC_STATE_RPT_REMOTE_NOT_BUSY	0x4B	/* REPORT_STATUS. 
+						 * REMOTE_NOT_BUSY. The remote
+						 * LLC DSAP is no longer busy.
+						 * The local connection service
+						 * component will now accept a
+						 * DATA_REQUEST.
+						 */
+#define LLC_STATE_IF_F_1_CLEAR_REMOTE_BUSY 0x4C	/* IF_F=1_CLEAR_REMOTE_BUSY. If
+						 * the I PDU is a response with
+						 * the F bit set to "1" in
+						 * response to a command PDU 
+						 * with the P bit set to "1",
+						 * then perform the 
+						 * CLEAR_REMOTE_BUSY action.
+						 */
+#define LLC_STATE_IF_DATA_FLAG_2_STOP_REJ_TIMER 0x4D /* 
+						 * IF_DATA_FLAG=2_STOP_REJ_TIMER
+						 * If DATA_FLAG has a value of
+						 * two, indicating that a REJ
+						 * PDU has been sent, stop the
+						 * "sent REJ" timer.
+						 */
+#define LLC_STATE_SEND_DISC_CMD		0x4E	/* SEND_DISC_CMD(P=X). Transmit
+						 * a DISC command PDU with the
+						 * P bit set to "X" to the 
+						 * remote LLC DSAP.
+						 */
+#define LLC_STATE_SEND_DM_RSP		0x4F	/* SEND_DM_RSP(F=X). Send a DM
+						 * response PDU with the F bit
+						 * set to "X" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_FRMR_RSP		0x50	/* SEND_FRMR_RSP(F=X). Send a
+						 * FRMR response PDU with the F
+						 * bit set to "X" to the remote
+						 * LLC DSAP.
+						 */
+#define LLC_STATE_RESEND_FRMR_RSP_0	0x51	/* RE-SEND_FRMR_RSP(F=0). Send
+						 * the same FRMR response PDU
+						 * with the same information
+						 * field as sent earlier to the
+						 * remote LLC DSAP. Set the F
+						 * bit to "0".
+						 */
+#define LLC_STATE_RESEND_FRMR_RSP_P	0x52	/* RE-SEND_FRMR_RSP(F=P). Send
+						 * the same FRMR response PDU
+						 * with the same information
+						 * field as sent earlier to the
+						 * remote LLC DSAP. Set the F
+						 * bit equal to the P bit of the
+						 * received command PDU.
+						 */
+#define LLC_STATE_SEND_I_CMD		0x53	/* SEND_I_CMD(P=1). Send an I
+						 * command PDU with the P bit
+						 * set to "1" to the remote LLC
+						 * DSAP with the data unit
+						 * supplied by the user with the
+						 * DATA_REQUEST. Before 
+						 * transmission, copy the 
+						 * current values of the send
+						 * state variable V(S) and the
+						 * receive state variable V(R)
+						 * into the N(S) and N(R)
+						 * fields, respectively, of the
+						 * I PDU and increment (modulo 
+						 * 128) the send state variable
+						 * V(S).
+						 */
+#define LLC_STATE_RESEND_I_CMD		0x54	/* RE-SEND_I_CMD(P=1). Start
+						 * resending all the 
+						 * unacknowledged I PDUs for 
+						 * this data link connection
+						 * begining with the N(R) given
+						 * in the received PDU. Send the
+						 * first as a command with the P
+						 * bit set to "1". If the queue
+						 * contains more than one I PDU,
+						 * the balance must be sent as
+						 * commands with the P bit set
+						 * to "0", or as response with
+						 * the F bit set to "0".
+						 */
+#define LLC_STATE_RESEND_I_CMD_OR_SEND_RR 0x55	/* RE-SEND_I_CMD(P=I)_OR_SEND_RR
+						 * Start resending all the
+						 * unacknowledged I PDUs for
+                                                 * this data link connection
+                                                 * begining with the N(R) given
+                                                 * in the received PDU. Send the                                                 * first as a command with the P                                                 * bit set to "1". If the queue
+                                                 * contains more than one I PDU,                                                 * the balance must be sent as
+                                                 * commands with the P bit set
+                                                 * to "0", or as response with
+                                                 * the F bit set to "0". It is
+						 * permissable to send a RR
+						 * command PDU with the P bit
+						 * set to "0", or as a response
+						 * with the F bit set to "0". If
+						 * no I PDU is ready to send, a							 * RR command PDU with the P bit
+						 * set to "1" must be sent to
+						 * the remote LLC DSAP.
+						 */
+#define LLC_STATE_SEND_I_XXX		0x56	/* SEND_I_XXX(X=0). Send either
+						 * an I response PDU with the
+						 * F bit set to "0" or an I
+						 * command PDU with the P bit
+						 * set to "0" to the remote LLC
+						 * DSAP with the data unit
+						 * supplied by the user with the
+						 * DATA_REQUEST. Before 
+						 * transmission, copy the
+						 * current values of the send
+						 * state variable V(S) and the
+						 * receive state variable V(R)
+						 * into the N(S) and N(R) fields
+						 * respectively, of the I PDU
+						 * and increment (modulo 128)
+						 * the send state variable V(S).
+						 */
+#define LLC_STATE_RESEND_I_XXX		0x57	/* RE-SEND_I_XXX(X=0). Start
+						 * resending all the 
+						 * unacknowledged I PDUs for
+						 * this data link connection
+						 * begining with the N(R) given
+						 * in the received PDU. They
+						 * must be sent as either 
+						 * commands with the P bit set 
+						 * to "0" or as responses with 
+						 * the F bit set to "0".
+						 */
+#define LLC_STATE_RESEND_I_XXX_OR_SEND_RR 0x58	/* RE-SEND_I_XXX(X=0)_OR_SEND_RR
+						 * Start resending all the
+                                                 * unacknowledged I PDUs for
+                                                 * this data link connection
+                                                 * begining with the N(R) given
+                                                 * in the received PDU. They
+                                                 * must be sent as either
+                                                 * commands with the P bit set
+                                                 * to "0" or as responses with
+                                                 * the F bit set to "0". It is
+						 * permissable to send either
+						 * a RR response PDU with the
+						 * F bit set to "0" or a RR
+						 * command PDU with the P bit
+						 * set to "0" to the remote
+						 * LLC DSAP before starting the
+						 * resending of the I PDUs. If
+						 * no I PDU is ready to send,
+						 * either an RR response PDU
+						 * with the F bit set to "0" or
+						 * an RR command PDU with the P
+						 * bit set to "0" must be sent
+						 * to the remote LLC DSAP.
+						 */
+#define LLC_STATE_RESEND_I_RSP		0x59	/* RE-SEND_I_RSP(F=1). Start
+						 * resending all the
+						 * unacknowledged I PDUs for
+						 * this data link connection
+						 * begining with the N(R) given
+						 * in the received PDU. Send the
+						 * first as a response with the
+						 * F bit set to "1". If the
+						 * queue contains more than one
+						 * I PDU, the balance must be
+						 * transmitted as commands with
+						 * the P bit set to "0" or as
+						 * responses with the F bit set
+						 * to "0".
+						 */
+#define LLC_STATE_SEND_REJ_CMD		0x5A	/* SEND_REJ_CMD(P=1). Send a REJ
+						 * command PDU with the P bit
+						 * set to "1" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_REJ_RSP		0x5B	/* SEND_REJ_RSP(F=1). Send a REJ
+						 * response PDU with the F bit
+						 * set to "1" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_REJ_XXX		0x5C	/* SEND_REJ_XXX(X=0). Send
+						 * either a REJ response PDU
+						 * with the F bit set to "0" or
+						 * a REJ command PDU with the P
+						 * bit set to "0" to the remote
+						 * LLC DSAP.
+						 */
+#define LLC_STATE_SEND_RNR_CMD		0x5D	/* SEND_RNR_CMD(P=1). Send a RNR
+						 * command PDU with the P bit
+						 * set to "1" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_RNR_RSP		0x5E	/* SEND_RNR_RSP(F=I). Send a RNR
+						 * response PDU with the F bit
+						 * set to "1"  to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_RNR_XXX		0x5F	/* SEND_RNR_XXX(X=0). Send
+						 * either a RNR response PDU 
+						 * with the F bit set to "0" or
+						 * a RNR command PDU with the P
+						 * bit set to "0" to the remote
+						 * LLC DSAP.
+						 */
+#define LLC_STATE_SET_REMOTE_BUSY	0x60	/* SET_REMOTE_BUSY. If 
+						 * REMOTE_BUSY is zero, then set
+						 * REMOTE_BUSY to one to 
+						 * indicate the remote LLC is in
+						 * the busy state and is no able
+						 * to accept I PDUs, start the
+						 * BUSY timer, inform the 
+						 * sublayer management function
+						 * by using REPORT_STATUS(
+						 * REMOTE_BUSY) and stop any
+						 * (re)sending of I PDUs that is
+						 * in progess.
+						 */
+#define LLC_STATE_OPTIONAL_SEND_RNR_XXX	0x61	/* OPTIONAL_SEND_RNR_XXX(X=0).
+						 * It is permissible to send a
+						 * RNR command PDU with the P
+						 * bit set to "0" or a RNR
+						 * response PDU with the
+						 * F bit set to "0" to the 
+						 * remote LLC DSAP in case the
+						 * remote LLC did no receive the
+						 * first RNR sent when the busy
+						 * state was entered.
+						 */
+#define LLC_STATE_SEND_RR_CMD		0x62	/* SEND_RR_CMD(P=1). Send a RR
+						 * command PDU with the P bit
+						 * set to "1" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_ACKNOWLEDGE_CMD	0x63	/* SEND_ACKNOWLEDGE_CMD(P=1).
+						 * Under all conditions it is
+						 * permissible to send a RR
+						 * command PDU with the P bit
+						 * set to "1" to the remote LLC
+						 * DSAP. If no I PDU is ready to
+						 * send, the RR command PDU with
+						 * the P bit set to "1" must be
+						 * sent to the remote LLC DSAP.
+						 * (This RR PDU may be delayed
+						 * by a time bounded by the
+						 * ACK_TIMER value, to wait for
+						 * the generation of an I PDU.)
+						 * However, if an I PDU is ready
+						 * send, and can be modified to
+						 * a command with the P bit set
+						 * to "1", then the RR command
+						 * PDU does not need to be sent.
+						 */
+#define LLC_STATE_SEND_RR_RSP		0x64	/* SEND_RR_RSP(F=I). Send a RR
+						 * response PDU with the F bit
+						 * set to "1" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_ACKNOWLEDGE_RSP	0x65	/* SEND_ACKNOWLEDGE_RSP(F=I).
+						 * Under all conditions it is
+						 * permissible to send a RR 
+						 * response PDU with the F bit
+						 * set to "1" to the remote LLC
+						 * DSAP. If no I PDU is ready to
+						 * send, the RR response PDU 
+						 * with the F bit set to "1" 
+						 * must be sent to the remote
+						 * LLC DSAP. However, if an I 
+						 * PDU is ready to send, and can
+						 * be modified to a response 
+						 * with the F bit set to "1," 
+						 * then the RR response PDU does
+						 * not need to be sent.
+						 */
+#define LLC_STATE_SEND_RR_XXX		0x66	/* SEND_RR_XXX(X=0). Send either
+						 * a RR response PDU with the F
+						 * bit set to "0" or a RR 
+						 * command PDU with the P bit
+						 * set to "0" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_SEND_ACKNOWLEDGE_XXX	0x67	/* SEND_ACKNOWLEDGE_XXX(X=0).
+						 * Under all conditions it is
+						 * permissible to send either a
+						 * RR response PDU with the F
+						 * bit set to "0" or a RR 
+						 * command PDU with the P bit
+						 * set to "0" to the remote LLC
+						 * DSAP. If no I PDU is ready to
+						 * send, either an RR response
+						 * with the F bit set to "0" or
+						 * an RR command PDU with the P
+						 * bit set to "0" must be sent 
+						 * to the remote LLC DSAP. (This
+						 * RR PDU may be delayed, by a
+						 * time bounded by the ACK_TIMER
+						 * value, to wait for the
+						 * generation of an I PDU.)
+						 * However, if an I PDU is ready
+						 * to send, then the RR PDU does
+						 * not need to be sent.
+						 */
+#define LLC_STATE_SEND_SABME_CMD	0x68	/* SEND_SABME_CMD(P=X). Send a
+						 * SABME command PDU with the P
+						 * bit set to "X" to the remote
+						 * LLC DSAP.
+						 */
+#define LLC_STATE_SEND_UA_RSP		0x69	/* SEND_UA_RSP(F=X). Send a UA
+						 * response PDU with the F bit
+						 * set to "X" to the remote LLC
+						 * DSAP.
+						 */
+#define LLC_STATE_S_FLAG_0		0x6A	/* S_FLAG:=0. Set S_FLAG to zero
+						 * to indicate that a SABME PDU
+						 * has not been received from
+						 * the remote LLC while the
+						 * local connection service
+						 * component is in the RESET,
+						 * SETUP, or RESET_WAIT state.
+						 */
+#define LLC_STATE_S_FLAG_1		0x6B	/* S_FLAG:=1. Set S_FLAG to one
+						 * to indicate that a SABME PDU
+						 * has been received from the
+						 * remote LLC while the local
+						 * connection service component
+						 * is in the RESET, SETUP, or
+						 * RESET_WAIT state.
+						 */
+#define LLC_STATE_START_P_TIMER		0x6C	/* START_P_TIMER. Start the P/F
+						 * cycle timer from zero; if the
+						 * P_FLAG is zero, initialize
+						 * RETRY_COUNT to zero, and set
+						 * P_FLAG to one.
+						 */
+#define LLC_STATE_START_ACK_TIMER	0x6D	/* START_ACK_TIMER. Start the
+						 * acknowledgment timer from
+						 * zero.
+						 */
+#define LLC_STATE_START_REJ_TIMER	0x6E	/* START_REJ_TIMER. Start the
+						 * "sent REJ" timer from zero.
+						 */
+#define LLC_STATE_START_ACK_TIMER_IF_NOT_RUNNING 0x6F
+						/* START_ACK_TIMER_IF_NOT_
+						 * RUNNING. If the 
+						 * acknowledgment timer is not
+						 * currently running, then start
+						 * the acknowledgment timer from
+						 * zero.
+						 */
+#define LLC_STATE_STOP_ACK_TIMER	0x6F	/* STOP_ACK_TIMER. Stop the
+						 * acknowledgment timer.
+						 */
+#define LLC_STATE_STOP_P_TIMER		0x70	/* STOP_P_TIMER. Stop the P/F
+						 * cycle timer and set P_FLAG
+						 * to zero.
+						 */
+#define LLC_STATE_STOP_REJ_TIMER	0x71	/* STOP_REJ_TIMER. Stop the
+						 * "sent REJ" timer.
+						 */
+#define LLC_STATE_STOP_ALL_TIMERS	0x72	/* STOP_ALL_TIMERS. Stop the
+						 * P/F cycle timer, the "sent
+						 * REJ" timer, the remote-busy
+						 * timer, and the acknowledgment
+						 * timer.
+						 */
+#define LLC_STATE_STOP_OTHER_TIMERS	0x73	/* STOP_OTHER_TIMERS. Stop the
+						 * P/F cycle timer, the "sent
+						 * REJ" timer, and the remote-
+						 * busy timer.
+						 */
+#define LLC_STATE_UPDATE_SEQ_RECEIVED	0x74	/* UPDATE_N(R)_RECEIVED. If the
+						 * N(R) of the received PDU
+						 * acknowledges the receipt of
+						 * one or more previously
+						 * unacknowledged I PDUs, update
+						 * the local record of 
+						 * N(R)_RECEIVED, set 
+						 * RETRY_COUNT to zero, and stop
+						 * the acknowledgment timer. If
+						 * unacknowledged I PDUs still
+						 * exist, start the 
+						 * acknowledgment timer if it
+						 * was stopped.
+						 */
+#define LLC_STATE_UPDATE_P_FLAG		0x75	/* UPDATE_P_FLAG. If the 
+						 * received PDU was a response
+						 * with the F bit set to "1",
+						 * set the P_FLAG to zero and
+						 * stop the P/F cycle timer.
+						 */
+#define LLC_STATE_DATA_FLAG_0		0x76	/* DATA_FLAG:=0. Set the 
+						 * DATA_FLAG to zero to indicate
+						 * that the data units from
+						 * received I PDUs were not
+						 * discarded during a local busy
+						 * period.
+						 */
+#define LLC_STATE_DATA_FLAG_1		0x77	/* DATA_FLAG:=1. Set the 
+						 * DATA_FLAG to one to indicate
+						 * that the data units from
+						 * receieved I PDUs were 
+						 * discarded during a local busy
+						 * period.
+						 */
+#define LLC_STATE_DATA_FLAG_2		0x78	/* DATA_FLAG:=2. Set the
+						 * DATA_FLAG to two to record
+						 * that the BUSY state was 
+						 * entered with a REJ PDU
+						 * outstanding.
+						 */
+#define LLC_STATE_DATA_FLAG_0_THEN_DATA_FLAG_1 0x79
+						/* DATA_FLAG=0_THEN_DATA_FLAG:=1
+						 * If the DATA_FLAG had been
+						 * zero, indicating that no data
+						 * units had been discarded, set
+						 * it to one to indicate that
+						 * data units have now been
+						 * discarded.
+						 */
+#define LLC_STATE_P_FLAG_0		0x7A	/* P_FLAG:=0. Initialize the
+						 * P_FLAG to zero. This 
+						 * indicates that the reception
+						 * of a response PDU with the F
+						 * bit set to "1" is not 
+						 * expected.
+						 */
+#define LLC_STATE_P_FLAG_P		0x7B	/* P_FLAG:=P. Set the P_FLAG to
+						 * the value of the P bit in the
+						 * command PDU being sent.
+						 */
+#define LLC_STATE_REMOTE_BUSY_0		0x7C	/* REMOTE_BUSY:=0. Set 
+						 * REMOTE_BUSY to zero to 
+						 * indicate that the remote LLC
+						 * is avle to accept I PDUs.
+						 */
+#define LLC_STATE_RETRY_COUNT_0		0x7D	/* RETRY_COUNT:=0. Initialize
+						 * RETRY_COUNT to zero.
+						 */
+#define LLC_STATE_RETRY_COUNT_PLUS_1	0x7E	/* RETRY_COUNT:=RETRY_COUNT+1.
+						 * Increment RETRY_COUNT by one.
+						 */
+#define LLC_STATE_RECEIVE_SEQ_0		0x7F	/* V(R):=0. Initialize the 
+						 * receive state variable. This
+						 * is the expected sequence
+						 * number of the next I PDU
+						 * received.
+						 */
+#define LLC_STATE_RECEIVE_SEQ_PLUS_1	0x80	/* V(R):=V(R)+1. Increment
+						 * (modulo 128) the receive
+						 * state variable. This is the
+						 * expected sequence number of 
+						 * the next I PDU received.
+						 */
+#define LLC_STATE_SEND_SEQ_0		0x81	/* V(S):=0. Initialize the send
+						 * state variable. This is the
+						 * sequence number of the next
+						 * I PDU to be sent.
+						 */
+#define LLC_STATE_SEND_SEQ_TO_RECEIVE_PDU 0x82	/* V(S):=N(R). Reset the send
+						 * state variable to the value
+						 * specified by the N(R) field
+						 * of the PDU just received.
+						 */
+#define LLC_STATE_F_FLAG_P		0x83	/* F_FLAG:=P. Set the F_FLAG to
+						 * the value of the P bit
+						 * received. This is the value
+						 * of the F bit to be sent in
+						 * UA or DM PDUs.
+						 */
+#define LLC_STATE_SEND_I_RSP		0x84
+#define LLC_STATE_DISCONNECT_RESPONSE	0x85
+#define LLC_STATE_SEND_RR_RESPONSE	0x86
+#define LLC_STATE_SEND_RR_REQUEST	0x87
+#define LLC_STATE_SEND_REJ_REQUEST	0x88
+#define LLC_STATE_SEND_REJ_RESPONSE	0x89
+#define LLC_STATE_SEND_RNR_REQUEST	0x8A
+#define LLC_STATE_SEND_RNR_RESPONSE	0x8B
+#define LLC_STATE_SEND_DM_RESPONSE	0x8C
+#define LLC_STATE_SEND_UA_RESPONSE	0x8D
+#define LLC_STATE_SEND_NULL_DSAP_TEST_R	0x8E
 
-void 		llc_cancel_timers(llcptr lp);
-int		llc_decode_frametype(frameptr fr);
-llcptr 		llc_find(void);
-int		llc_free_acknowledged_skbs(llcptr lp, unsigned char ack);
-void		llc_handle_xid_indication( char *chsp, short int ll, char *xid_data);
-void		llc_interpret_pseudo_code(llcptr lp, int pc_label, struct sk_buff *skb, char type);
-void		llc_add_to_queue(struct sk_buff *skb, struct sk_buff **f, struct sk_buff **b);
-void		llc_process_otype2_frame(llcptr lp, struct sk_buff *skb, char type);
-struct sk_buff *llc_pull_from_atq(llcptr lp); 
-int 		llc_resend_ipdu(llcptr lp, unsigned char ack_nr, unsigned char type, char p);
-void 		llc_sendpdu(llcptr lp, char type, char pf, int data_len, char *pdu_data);
-void 		llc_sendipdu(llcptr lp, char type, char pf, struct sk_buff *skb);
-void		llc_start_timer(llcptr lp, int t);
-void		llc_stop_timer(llcptr lp, int t);
-void		llc_timer_expired(llcptr lp, int t);
-int		llc_validate_seq_nos(llcptr lp, frameptr fr);
-
-int		llc_data_request(llcptr lp, struct sk_buff *skb);
-void		llc_unit_data_request(llcptr lp, int ll, char * data);
-void		llc_disconnect_request(llcptr lp);
-void		llc_connect_request(llcptr lp);
-void		llc_xid_request(llcptr lp, char opt, int data_len, char *pdu_data);
-void		llc_test_request(llcptr lp, int data_len, char *pdu_data);
-
-int		register_cl2llc_client(llcptr llc, const char *device, void (*ops)(llcptr), u8 *rmac, u8 ssap, u8 dsap);
-void		unregister_cl2llc_client(llcptr lp);
-int 		llc_mac_data_indicate(llcptr lp, struct sk_buff *skb );
+extern int llc_queue_xmit(struct sk_buff *skb);
+extern struct datalink_proto *register_8022_client(unsigned char type,
+        int (*rcvfunc)(struct sk_buff*,struct net_device*,struct packet_type*),
+        int (*msgrcvfunc)(int rsp, struct sk_buff *));
+extern void unregister_8022_client(unsigned char type);
+extern int llc_connect(struct datalink_proto *dl, struct net_device *dev,
+        __u8 *dmac, __u8 dsap, int rsp);
+extern int llc_reset(struct datalink_proto *dl, struct net_device *dev,
+        __u8 *dmac, __u8 dsap, int rsp);
+extern int llc_disconnect(struct datalink_proto *dl, struct net_device *dev,
+        __u8 *dmac, __u8 dsap, int rsp);
+extern int llc_decode_pdu(llchdr *llc);
+extern int llc_data(__u8 ssap, __u8 dsap, __u8 *dmac,
+        struct sk_buff *skb, struct net_device *dev);
+extern int llc_test(__u8 ssap, __u8 dsap, __u8 *dmac,
+        struct sk_buff *skb, struct net_device *dev);
 
+#endif /* __NET_LLC_H */
diff -ruN linux-2.4.4/include/net/llc_frame.h linux/include/net/llc_frame.h
--- linux-2.4.4/include/net/llc_frame.h	Thu Dec 12 06:54:21 1996
+++ linux/include/net/llc_frame.h	Wed Dec 31 16:00:00 1969
@@ -1,98 +0,0 @@
-/* if_ether.h needed for definition of ETH_DATA_LEN and ETH_ALEN
- */
-#include "linux/if_ether.h"
-
-/* frame layout based on par3.2 "LLC PDU format"
- */
-typedef union {			/* pdu layout from pages 40 & 44 */
-    struct {			/* general header, all pdu types */
-	unsigned dsap : 8;	/* dest service access point */
-	unsigned ssap : 8;	/* source service access point */
-	unsigned f1 : 1;	/* I- U- or S- format id bits */
-	unsigned f2 : 1;
-	unsigned : 6;
-	unsigned : 8;
-   } pdu_hdr;
-   struct {
-        char dummy1[2];   	/* dsap + ssap */
-	char byte1;
-	char byte2;
-   } pdu_cntl;			/* unformatted control bytes */
-   struct {			/* header of an Information pdu */
-	unsigned char dummy2[2];
-	unsigned : 1;
-	unsigned ns : 7;
-	unsigned i_pflag : 1;   /* poll/final bit */
-	unsigned nr : 7;	/* N(R)  */	
-	unsigned char is_info[ ETH_DATA_LEN ];
-   }  i_hdr;
-   struct {			/* header of a Supervisory pdu */
- 	unsigned char dummy3[2];
-	unsigned : 2;
-	unsigned ss : 2;	/* supervisory function bits */
-	unsigned : 4;
-	unsigned s_pflag : 1;   /* poll/final bit  */
-	unsigned nr : 7;	/* N(R)  */
-   } s_hdr;
-
-/* when accessing the P/F bit or the N(R) field there's no need to distinguish
-   I pdus from S pdus i_pflag and s_pflag / i_nr and s_nr map to the same
-   physical location.
- */ 
-   struct {			/* header of an Unnumbered pdu */
-	unsigned char dummy4[2];
-	unsigned : 2;
-	unsigned mm1 : 2;	/* modifier function part1 */
-	unsigned u_pflag : 1;    /* P/F for U- pdus */
-	unsigned mm2 : 3;	/* modifier function part2 */
-	unsigned char u_info[ ETH_DATA_LEN-1];
-   } u_hdr;
-   struct {			/* mm field in an Unnumbered pdu */
-	unsigned char dummy5[2];
-	unsigned : 2;
-	unsigned mm : 6;	/* must be masked to get ridd of P/F !  */
-   } u_mm;
-   	 
-} frame_type, *frameptr;
-
-/* frame format test macros: */
-
-#define IS_UFRAME( fr ) ( ( (fr)->pdu_hdr.f1) & ( (fr)->pdu_hdr.f2) )
-
-#define IS_IFRAME( fr ) ( !( (fr)->pdu_hdr.f1) )
-
-#define IS_SFRAME( fr ) ( ( (fr)->pdu_hdr.f1) & !( (fr)->pdu_hdr.f2) )
-
-#define IS_RSP( fr ) ( fr->pdu_hdr.ssap & 0x01 )
-
-
-/* The transition table, the _encode tables and some tests in the
-   source code depend on the numeric order of these values.
-   Think twice before changing.
- */
-
-/* frame names for TYPE 2 operation: */
-#define I_CMD		0
-#define RR_CMD		1
-#define RNR_CMD		2
-#define REJ_CMD		3
-#define DISC_CMD	4
-#define SABME_CMD	5
-#define I_RSP		6
-#define RR_RSP		7
-#define RNR_RSP		8
-#define REJ_RSP		9
-#define UA_RSP		10
-#define DM_RSP		11
-#define FRMR_RSP	12
-
-/* junk frame name: */
-#define BAD_FRAME	13
-#define NO_FRAME	13
-
-/* frame names for TYPE 1 operation: */
-#define UI_CMD		14
-#define XID_CMD		15
-#define TEST_CMD	16
-#define XID_RSP		17
-#define TEST_RSP	18
diff -ruN linux-2.4.4/include/net/llc_name.h linux/include/net/llc_name.h
--- linux-2.4.4/include/net/llc_name.h	Thu Dec 12 06:54:21 1996
+++ linux/include/net/llc_name.h	Wed Dec 31 16:00:00 1969
@@ -1,7 +0,0 @@
-char *frame_names[] =
-    {"I_CMD","RR_CMD","RNR_CMD","REJ_CMD","DISC_CMD",
-    "SABME_CMD","I_RSP","RR_RSP","RNR_RSP","REJ_RSP",
-    "UA_RSP","DM_RSP","FRMR_RSP","BAD_FRAME","UI_CMD",
-    "XID_CMD","TEST_CMD","XID_RSP","TEST_RSP"
-};
- 
diff -ruN linux-2.4.4/include/net/llc_state.h linux/include/net/llc_state.h
--- linux-2.4.4/include/net/llc_state.h	Thu Dec 12 06:54:21 1996
+++ linux/include/net/llc_state.h	Wed Dec 31 16:00:00 1969
@@ -1,4 +0,0 @@
-char *state_names[] = { 
-	"ADM","CONN","RESET_WAIT","RESET_CHECK","SETUP",
-	"RESET","D_CONN","ERROR","NORMAL"
-};
diff -ruN linux-2.4.4/include/net/p8022.h linux/include/net/p8022.h
--- linux-2.4.4/include/net/p8022.h	Wed Aug 18 11:38:47 1999
+++ linux/include/net/p8022.h	Wed Dec 31 16:00:00 1969
@@ -1,7 +0,0 @@
-#ifndef _NET_P8022_H
-#define _NET_P8022_H
-
-extern struct datalink_proto *register_8022_client(unsigned char type, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *));
-extern void unregister_8022_client(unsigned char type);
-
-#endif
diff -ruN linux-2.4.4/include/net/p8023.h linux/include/net/p8023.h
--- linux-2.4.4/include/net/p8023.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/p8023.h	Mon May 14 19:57:11 2001
@@ -0,0 +1,2 @@
+extern struct datalink_proto *make_8023_client(void);
+extern void destroy_8023_client(struct datalink_proto *);
diff -ruN linux-2.4.4/include/net/sna_cbs.h linux/include/net/sna_cbs.h
--- linux-2.4.4/include/net/sna_cbs.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_cbs.h	Mon May 14 21:05:34 2001
@@ -0,0 +1,1896 @@
+/* sna_cbs.h: Linux-SNA Control blocks and layer specific declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_CBS_H
+#define __NET_SNA_CBS_H
+
+#ifdef __KERNEL__
+
+#include <linux/netdevice.h>
+
+/* CREATE.
+ */
+
+struct sna_hs_create_parms {
+        __u8 lu_id;
+        __u8 hs_id;
+};
+
+struct sna_ps_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+
+        struct sna_tcb *tcb_list_ptr;
+        __u8 tcb_id;
+
+        struct sna_rcb *rcb_list_ptr;
+};
+
+struct sna_rm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_sm_create_parms {
+        struct sna_lucb *lucb_list_ptr;
+        __u8 lu_id;
+};
+
+struct sna_rm_created {
+        __u8 lu_id;
+};
+
+/* ASM.
+ */
+
+struct sna_session_id {
+        __u16   sidh:8,
+                sidl:8;
+};
+
+/* Structure size is 17bits */
+struct sna_lfsid {
+        __u8    odai:1;		/* Pri = 0x0, Sec = 0x1 */
+        union {
+                __u16 raw;
+                struct sna_session_id hl;
+        } sid;
+};
+
+struct sna_assign_lfsid {
+	unsigned char 	 pc_id[8];
+	unsigned short	 sm_id;
+        struct sna_lfsid lfsid;
+};
+
+struct sna_free_lfsid {
+	unsigned char	 pc_id[8];
+	unsigned short	 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_linfo{
+	__u8		 active:1;	/* 1 = active, 0 = inactive */ 
+	__u16		 sm_id;
+	struct sna_lfsid lfsid;
+};
+
+struct sna_lfsid_block {
+	struct sna_lfsid_block *next;
+	struct sna_lfsid_block *prev;
+
+	struct sna_linfo l[256];
+};
+
+/* one for each PC */
+struct sna_asm_pinfo {
+        struct sna_asm_pinfo *next;
+        struct sna_asm_pinfo *prev;
+
+	unsigned char	pc_id[8];
+	unsigned char   intranode;      /* 0 = internode, 1 = intranode */
+        unsigned char   odai;           /* 0 = Pri, 1 = Sec */
+        unsigned short  max_btu;
+        unsigned char   tx_rx_bind_pacing;
+        unsigned char   dependent_lulu;
+        unsigned char   adp_bind_pacing_dep_lulu;
+        unsigned char   generalized_oadi;
+
+	/* list of 256 unique addresses */
+	unsigned short		blk_count;
+	struct sna_lfsid_block	*l_blks;
+};
+
+struct sna_activate_as {
+	unsigned char	pc_id[8];
+	unsigned char	intranode;	/* 0 = internode, 1 = intranode */
+	unsigned char	odai;		/* 0 = Pri, 1 = Sec */
+	unsigned short	max_btu;
+	unsigned char	tx_rx_bind_pacing;
+	unsigned char	dependent_lulu;
+	unsigned char	adp_bind_pacing_dep_lulu;
+	unsigned char	generalized_oadi;
+};
+
+/* CS.
+ */
+
+typedef enum {
+	SNA_XID_REMOTE_INIT = 1,
+	SNA_XID_LOCAL_INIT,
+	SNA_XID_INPUT,
+	SNA_XID_ACTIVE,
+	SNA_XID_RESET
+} xid_inputs;
+
+typedef enum {
+	SNA_XID_NULL = 1,
+	SNA_XID_PN,
+	SNA_XID_NEG
+} xid_packets;
+
+typedef enum {
+	XID_RESET = 1,
+	XID_S_NULL,
+	XID_S_PN,
+	XID_S_NEG,
+	XID_S_PRI,
+	XID_S_SEC,
+	XID_R_NULL,
+	XID_R_PN,
+	XID_R_NEG,
+	XID_R_PRI,
+	XID_R_SEC,
+	XID_ACTIVE,
+	XID_FAIL
+} xid_state;
+
+typedef enum {
+	XID_BEGIN = 1,
+	XID_NULL,
+	XID_PN,
+	XID_NEG,
+	XID_PRI,
+	XID_SEC
+} xid_input;
+
+#define	XID_OUTBOUND	0x00		/* XID CMD */
+#define XID_INBOUND	0x01		/* XID RSP */
+
+struct sna_xid_info {
+        struct sk_buff  *last_tx_xid;
+        struct sk_buff  *last_rx_xid;
+
+        xid_state               xid_status;
+        struct timer_list       xid_timer;
+        __u32                   xid_idle_limit;
+        __u32                   xid_retry_interval;
+        __u32                   xid_retry_limit;
+	__u32			xid_retries;
+
+        __u8    xid_initiator;		/* 0x00 = Local / 0x01 = Remote */
+	__u8	xid_direction;		/* 0x00 = cmd / 0x01 = rsp */
+        __u32   xid_count;              /* number of xids exchanged */
+
+        __u16   i_tx_window;
+        __u16   i_rx_window;
+        __u16   i_mtu;                  /* max btu size */
+
+        __u8    tg_type;
+        __u8    tg_id;
+
+	/* detailed xid information */
+	__u8	init_self;
+	__u8	tx_bind_wo_init_self;
+	__u8	tx_bind_piu;
+	__u8	rx_bind_piu;
+
+	__u8	adaptive_tx_bind;
+	__u8	adaptive_rx_bind;
+
+	/* Junk below but keeping around for a while */
+	__u32   adj_node_id;
+        char    real_adj_cp_name[8];
+        __u32   local_odai_value;
+        __u32   sscp_med_sessions;
+        __u32   adj_node_bind_reassembly;
+        __u32   local_cpcp_sessions_supp_status;
+        __u32   adj_node_cpcp_sessions_supp_status;
+        __u32   curr_cpcp_sessions_supp_status;
+        __u32   ss_cpcp_sessions_supp_override;
+        __u32   partner_node_type;
+        __u32   tg_sec_init_nonact_xchg;
+        __u32   restart_nonact_xid3_xchg;
+};
+
+typedef enum {
+	BIND_RESET = 1,
+	BIND_S_BIND,
+	BIND_S_BIND_W_AF,
+	BIND_S_PR_FMD,
+	BIND_S_PR_FMD_W_AF,
+	BIND_S_PR_BIND,
+	BIND_S_PR_BIND_W_AF,
+	BIND_ACTIVE
+} bind_state;
+
+struct sna_session_initiation_info {
+        char    adj_cp_name[8];
+        __u32   real_node_tgs;
+        __u32   virtual_node_tgs;
+        char    virtual_node_cp_name[8];
+};
+
+struct sna_xid_error_info {
+        __u32   sense;
+        __u32   *procedure_name;
+        __u32   byte_offset;
+        __u32   bit_offset;
+        __u32   send_xid;
+};
+
+struct sna_adj_node_cb {
+        struct sna_adj_node_cb *next;
+        struct sna_adj_node_cb *prev;
+
+        char    real_adj_cp_name[8];
+        __u32   last_adj_cp_contacted;
+        __u32   parallel_tgs;
+        __u32   tg_numbers;
+
+        struct sna_cs_process_data *cs_instance;
+};
+
+/*
+ * Link Station data structures.
+ */
+
+struct sna_activate_route {
+	unsigned char	pc_id[8];	/* associated path control */
+	unsigned long	tg_id;		/* tg to use, 0 if intranode */
+	struct sna_netid cp_name;	/* name of adjacent node */
+};
+
+#define SNA_LS_TYPE_DEFINED             0x01
+#define SNA_LS_TYPE_DYNAMIC             0x02
+#define SNA_LS_TYPE_TEMP                0x04
+struct sna_ls_cb {
+        struct sna_ls_cb *next;
+        struct sna_ls_cb *prev;
+
+        __u32 proc_id;
+        __u16 flags;
+
+        struct sna_port_cb *port;
+        struct sna_dlc_cb *dlc;
+        struct sna_netid netid;
+        unsigned char auto_act;
+        unsigned char auto_deact;
+
+        char devname[8];
+        unsigned char sport;
+
+        /* Destination node information. This is still ugly. */
+	struct sna_netid plu_name;
+        char dname[MAX_ADDR_LEN];                 /* Mac Addr */
+        char daddr[SNA_PORT_ADDR_LEN];  /* Dst. Port */
+
+	unsigned char pc_id[8];
+	unsigned char tg_id;	/* TG used by this LS */
+
+/* Data below is questionable */
+        __u32                   node_act;
+        __u32                   ls_entered_act_state;
+        __u32                   ls_activation;  /* LS capabilities. */
+
+        __u32                   adj_node_type;
+        char                    adj_node_id[8];
+        __u32                   adj_node_session;
+
+        __u32                   bind_pacing_cnt;
+        __u32                   max_tx_btu_size;
+        __u32                   max_rx_btu_size;
+
+        __u32                   tx_win_size;
+        __u32                   rx_win_size;
+
+        __u32   direction;
+        __u32   adj_ls_id;
+
+        struct sna_session_initiation_info *session_initiation_info;
+        struct sna_activate_route *activate_route_list;
+};
+
+/*
+ * Port data structures.
+ */
+
+struct sna_port_cb {
+        struct sna_port_cb *next;
+        struct sna_port_cb *prev;
+
+        struct sna_ls_cb *ls_list;
+        __u32 ls_qlen;
+
+        struct sna_netid netid;
+        struct net_device *dev;
+        char saddr[12];
+
+        __u32   proc_id;
+        __u16   flags;
+        __u32   role;
+
+        __u32   btu;
+        __u32   mia;
+        __u32   moa;
+
+#ifdef CONFIG_SNA_LLC
+        struct datalink_proto *llc_dl;
+#endif
+#ifdef CONFIG_SNA_ATM
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+#endif
+#ifdef CONFIG_SNA_SDLC
+#endif
+#ifdef CONFIG_SNA_HDLC
+#endif
+
+/* Not used below */
+        unsigned long   max_adjacent_ls;
+        unsigned long   real_adjacent_ls;
+
+        unsigned long   real_inbound_activation;
+        unsigned long   inbound_activation_cnt;
+
+        unsigned long   real_outbound_activation;
+        unsigned long   outbound_activation_cnt;
+
+        unsigned long   link_station_txrx;
+        unsigned long   max_nonack_xid;
+
+        unsigned long   xid_exchange_type;
+};
+
+/*
+ * DLC data structures.
+ */
+
+struct sna_dlc_cb {
+        struct sna_dlc_cb *next;
+        struct sna_dlc_cb *prev;
+
+        struct sna_port_cb *port_list;
+        __u32 port_qlen;
+
+        struct net_device *dev;
+        __u16 flags;
+        __u32 proc_id;
+};
+
+struct sna_cs_pinfo {
+        struct sna_cs_pinfo *next;
+        struct sna_cs_pinfo *prev;
+
+        struct sna_netid        netid;
+	struct sna_nodeid	nodeid;
+        struct sna_dlc_cb       *dlc_list;
+
+	unsigned char		node_type;
+	unsigned char		intranode_pc_id[8];
+
+
+/* Not used below */
+        struct sna_adj_node_cb  *adj_node_cb;
+        struct sna_fq_netid     *netid_cp;
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* DFC.
+ */
+
+struct sna_lulu_cb {
+	struct sna_lulu_cb *next;
+	struct sna_lulu_cb *prev;
+
+        struct sna_netid netid;
+	struct sna_netid plu_netid;
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+
+	unsigned char polarity;
+	unsigned long proc_id;
+	unsigned char fqpcid[8];
+	
+
+/*	Not used anymore.
+
+        __u8    ps_id;
+        __u8    bracket_id;
+        __u8    first_speaker;
+
+        struct sna_ct   ct_rcv;
+        struct sna_ct   ct_send;
+
+        sna_snf sqn_send_cnt;
+        sna_snf phs_bb_register;
+        sna_snf shs_bb_register;
+        sna_snf current_bracket_sqn;
+
+        __u8    rqd_required_on_ceb;
+        __u8    deallocate_abend;
+
+        __u16   normal_flow_rq_cnt;
+
+        __u8    sig_received;
+        sna_snf sig_snf;
+
+        __u8    betc;
+        __u8    send_error_rsp_state;
+        __u8    bb_rsp_state;
+        __u32   bb_rsp_sense;
+
+        __u8    rtr_rsp_state;
+        __u32   rtr_rsp_sense;
+
+        __u8    sig_rq_outstanding;
+        __u8    alternate_code;
+        __u8    session_just_started;
+        struct sna_mu   *saved_mu_ptr;
+*/
+};
+
+#ifdef NOT
+
+#define SNA_DFC_RQD1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 0)
+#define SNA_DFC_RQE1(X)         (X->dr1i == 1 && X->dr2i == 0 && X->eri == 1)
+#define SNA_DFC_RQ1(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQE1(X))
+#define SNA_DFC_RQD1_HEX        0x100
+#define SNA_DFC_RQE1_HEX        0x101
+
+#define SNA_DFC_SET_RQD1(X)     (X->dr1i = 1, X->dr2i = 0, X->eri = 0)
+
+#define SNA_DFC_RQD2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE2(X)         (X->dr1i == 0 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ2(X)          (SNA_DFC_RQD2(X) || SNA_DFC_RQE2(X))
+#define SNA_DFC_RQD2_HEX        0x010
+#define SNA_DFC_RQE2_HEX        0x011
+
+#define SNA_DFC_RQD3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 0)
+#define SNA_DFC_RQE3(X)         (X->dr1i == 1 && X->dr2i == 1 && X->eri == 1)
+#define SNA_DFC_RQ3(X)          (SNA_DFC_RQD3(req_h) || SNA_DFC_RQE3(req_h))
+#define SNA_DFC_RQD3_HEX        0x110
+#define SNA_DFC_RQE3_HEX        0x111
+
+#define SNA_DFC_RQD(X)          (SNA_DFC_RQD1(X) || SNA_DFC_RQD2(X) || SNA_DFC_RQD3(X))
+#define SNA_DFC_RQE(X)          (SNA_DFC_RQE1(X) || SNA_DFC_RQE2(X) || SNA_DFC_RQE3(X))
+
+#define SNA_DFC_POS_RSP(X)      (SNA_DFC_RQD(X))
+#define SNA_DFC_NEG_RSP(X)      (SNA_DFC_RQE(X))
+
+#define SNA_DFC_TRUE    0x1
+#define SNA_DFC_FALSE   0x0
+
+#define SNA_DFC_YES     0x1
+#define SNA_DFC_NO      0x0
+
+#define SNA_DFC_NEG     0x0
+#define SNA_DFC_POS     0x1
+
+#define SNA_DFC_SIG_CURRENT     0x0
+#define SNA_DFC_SIG_STRAY       0x1
+#define SNA_DFC_SIG_FUTURE      0x2
+
+#define SNA_DFC_RESET           0x0
+#define SNA_DFC_NEG_OWED        0x1
+#define SNA_DFC_POS_OWED        0x2
+
+#define SNA_CT_CRV      0x0
+#define SNA_CT_BIS      0x1
+#define SNA_CT_LUSTAT   0x2
+#define SNA_CT_RTR      0x3
+#define SNA_CT_SIG      0x4
+#define SNA_CT_OTHER    0x5
+
+#define SNA_CT_RQCODE_EC        0x6
+
+struct sna_ct {
+        __u8    entry_present;
+        sna_snf snf;
+        __u32   neg_rsp_sense;
+        struct sna_rh rh;
+        __u16   rq_code;
+};
+
+/* Finite State Machine definitions and structures. */
+#define SNA_DFC_FSM_CURRENT     0x0     /* Current FSM state. */
+
+#define SNA_DFC_FSM_R           0x0     /* MU is being received. */
+#define SNA_DFC_FSM_S           0x1     /* MU is being sent. */
+
+#define SNA_DFC_FSM_NO_CHAIN    0x0
+#define SNA_DFC_FSM_BEGIN_CHAIN 0x1
+#define SNA_DFC_FSM_END_CHAIN   0x2
+
+#define SNA_DFC_FSM_BETB        0x01
+#define SNA_DFC_FSM_BETC        0x01
+#define SNA_DFC_FSM_INB         0x02
+#define SNA_DFC_FSM_INC         0x02
+#define SNA_DFC_FSM_NEG         0x03
+#define SNA_DFC_FSM_RSP         0x03
+#define SNA_DFC_FSM_SENT        0x03
+#define SNA_DFC_FSM_PEND        0x04
+#define SNA_DFC_FSM_SEND        0x05
+
+#define SNA_DFC_FSM_PEND_SEND_REPLY     0x06
+#define SNA_DFC_FSM_PEND_RCV_REPLY      0x07
+#define SNA_DFC_FSM_PEND_REPLY          0x08
+
+#define SNA_DFC_FSM_BB                  0x0
+#define SNA_DFC_FSM_RQD                 0x0
+#define SNA_DFC_FSM_RQE                 0x1
+#define SNA_DFC_FSM_REPLY               0x2
+#define SNA_DFC_FSM_BIS                 0x3
+#define SNA_DFC_FSM_RTR                 0x4
+#define SNA_DFC_FSM_FMH5                0x5
+#define SNA_DFC_FSM_FMH12               0x6
+#define SNA_DFC_FSM_LUSTAT              0x7
+#define SNA_DFC_FSM_NOT_BID_REPLY       0x8
+#define SNA_DFC_FSM_CEB_UNCOND          0x9
+
+#endif
+
+/* DS.
+ */
+
+struct sna_ds_pinfo {
+        struct sna_ds_pinfo *next;
+        struct sna_ds_pinfo *prev;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* HS.
+ */
+
+#define SNA_LOCAL_CRV           0x00
+#define SNA_LOCAL_NO_CRV        0x01
+#define SNA_LOCAL_BIS           0x10
+#define SNA_LOCAL_NO_BIS        0x11
+#define SNA_LOCAL_LUSTAT        0x20
+#define SNA_LOCAL_NO_LUSTAT     0x21
+#define SNA_LOCAL_RTR           0x30
+#define SNA_LOCAL_NO_RTR        0x31
+#define SNA_LOCAL_SIG           0x40
+#define SNA_LOCAL_NO_SIG        0x41
+#define SNA_LOCAL_OTHER         0x50
+#define SNA_LOCAL_NO_OTHER      0x51
+
+#define SNA_HS_SEND             0x0
+#define SNA_HS_RECEIVE          0x1
+
+#ifdef NOT
+
+struct sna_hs_local {
+        __u8    hs_id;          /* ID of this HS. */
+        __u8    lu_id;          /* The LU for this HS. */
+        __u8    half_session;   /* SNA_PRI or SNA_SEC. */
+        __u32   sense;
+        __u8    perm_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    rq_code;
+
+        __u8    state;
+
+        struct sna_lulu_cb lulu;       /* Fields only used by DFC. */
+
+        /* Fields only used by TC. */
+        struct sna_tc_cb tcb;
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported:4,
+                crypto:4;
+
+        struct sna_mu *catch_mu;
+
+        struct sna_hs_local *next;
+        struct sna_hs_local *prev;
+};
+
+#endif
+
+/* IPC.
+ */
+
+struct sna_hs_ps_connected {
+        __u8    ps_id;
+        __u8    bracket_id;
+};
+
+struct sna_abend_notification {
+        unsigned char *abending_process;
+        __u8 process_id;
+        __u8 reason;
+};
+
+struct sna_abort_hs {
+        __u8 hs_id;
+        __u8 sense_code;
+};
+
+struct sna_activate_session_rsp {
+        __u8 correlator;
+        __u8 type;
+        __u8 session_information;
+        __u8 error_type;
+};
+
+struct sna_allocate_rcb {
+        __u8 tcb_id;
+        __u8 specific_conv_group;
+        __u8 conversation_group_id;
+        __u8 *lu_name;
+        __u8 *mode_name;
+        __u8 immediate_session;
+        __u8 sync_level;
+        __u8 security_select;
+};
+
+/* request and response structure */
+struct sna_assign_pcid {
+        unsigned short sm_proc_id;
+        unsigned char duplicate_pcid;	/* 0 = no, 1 = yes */
+	unsigned char fqpcid[8];
+};
+
+struct sna_bid {
+        __u8 hs_id;
+};
+
+struct sna_bid_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u32 sense;
+};
+
+struct sna_bid_without_attach {
+        /* Blame IBM */
+};
+
+struct sna_bis_reply {
+        __u8 hs_id;
+};
+
+struct sna_bis_rq {
+        __u8 hs_id;
+};
+
+struct sna_bracket_freed {
+        __u8 bracket_id;
+};
+
+struct sna_cos {
+	unsigned short	type;
+	unsigned char	rsv:5,
+			network_priority:1,
+			tx_priority:2;
+	unsigned char	len;
+	unsigned char	cos_name[8];
+};
+
+struct sna_cos_tpf_vector {
+	unsigned char	mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_cos	v;
+};
+
+/* Control vector 0x80 */
+struct sna_tg_id {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	pcp_len;
+	unsigned char	*pcp_name;
+	unsigned char	pcp_name_id_cn:1,
+			more_cfg_info:1,
+			hpr_support:1,
+			tg_type:2,
+			intersubnet_tg:1,
+			rsv1:1,
+			rtp_support:1;
+	unsigned short	subarea_number;
+};
+
+/* Control vector 0x81 */
+struct sna_tg_cn {
+	unsigned short	type;
+	unsigned char	tg_number;
+	unsigned char	ptg_number;
+	unsigned short	rsv1;
+};
+
+/* Control vector 0x82 */
+struct sna_tg_dlc_signal {
+	unsigned short	type;
+	unsigned char	mac[MAX_ADDR_LEN];
+	unsigned char	lsap;
+};
+
+/* Control vector 0x83 */
+struct sna_tg_cp_name {
+	unsigned char	type;
+	unsigned char	len;
+	unsigned char	*cp_name;
+	unsigned char	intersubnet_tg;
+};
+
+/* Control vector 0x46 */
+struct sna_tg_desc {
+	unsigned short	type;
+	struct sna_tg_id		id;
+	struct sna_tg_dlc_signal	dlc;
+};
+
+/* Control vector 0x47 */
+struct sna_tg_chars {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	status:1,
+			garbage:1,
+			quiescing:1,
+			cpcp_session:2,
+			rsv1:3;
+	unsigned char	effective_capacity;
+	unsigned char	rsv2[5];
+	unsigned char	cost_per_connect;
+	unsigned char	cost_per_byte;
+	unsigned char	rsv3;
+	unsigned char	security;
+	unsigned char	propagation_delay;
+	unsigned char	rsv4;
+	unsigned char	user1;
+	unsigned char	user2;
+	unsigned char	user3;
+};
+
+struct sna_tg_ttl {
+	unsigned short	type;
+	unsigned char	days;
+};
+
+/* Control vector 0x48 */
+struct sna_tg_trd {
+	unsigned short		type;
+	struct sna_tg_ttl	*ttl;
+};
+
+struct sna_tg_vector {
+	struct sna_tg_vector 	*next;
+	struct sna_tg_vector	*prev;
+
+	struct sna_tg_desc      desc;		/* Cv 0x46 */
+        struct sna_tg_chars     chars;		/* Cv 0x47 */
+	struct sna_tg_trd	trd;
+};
+
+struct sna_tg_update {
+	unsigned char		node_type;
+	unsigned char		routing;
+	struct net_device	*dev;
+	unsigned char		lsap;
+	struct sna_tg_desc	tg_desc;
+	struct sna_tg_chars	tg_chars;
+};
+
+/* Control vector 0x44 */
+struct sna_node_desc {
+	unsigned short	type;
+	unsigned char	cp_len;
+	struct sna_netid cp_name;
+	unsigned char	rsv_len;
+	unsigned char	cn:1,
+			rsv1:7;
+};
+
+/* Control vector 0x80 */
+struct sna_node_type {
+	unsigned short	type;
+	unsigned long	rsn;
+	unsigned char	route_resistance;
+	unsigned char	congested:1,
+			interoute_depelted:1,
+			rsv1:1,
+			garbage:1,
+			rsv2:1,
+			quiescing:1,
+			rsv3:2;
+	unsigned char	gateway:1,
+			cds:1,
+			interoute:1,
+			rsv4:1,		/* Set to 1 */
+			rsv5:2,
+			rsv6:2;		/* Set to 11 */
+	unsigned char	peripheral:1,
+			interchange:1,
+			extended:1,
+			hpr:2,
+			rsv7:3;
+};
+
+/* Control vector 0x45 */
+struct sna_node_chars {
+	unsigned short		type;
+	struct sna_node_type	info;
+};
+
+struct sna_node_vector {
+	struct sna_node_desc	desc;
+	struct sna_node_chars	chars;
+};
+
+#define CO_TIMEOUT	3 * HZ
+#define CO_MAX_RETRIES	10
+
+typedef enum {
+	CO_FAIL = 0,
+	CO_RESET,
+	CO_ACTIVE,
+	CO_S_TEST_C,
+	CO_R_TEST_R,
+	CO_TEST_OK,
+} connect_out_status;
+
+struct sna_tg_cb {
+	struct sna_tg_cb	*next;
+	struct sna_tg_cb 	*prev;
+
+	connect_out_status	co_status;
+	struct timer_list	co_retry;
+	int			co_interval;
+	int			co_retries;
+	int			co_max_retries;
+
+	wait_queue_head_t       sleep;
+
+	unsigned char		lsap;
+	struct net_device 	*dev;
+
+	struct sna_xid_info 	*xid_info;
+
+	unsigned long		frsn;
+	struct timeval		updated;
+	unsigned char		tg_type;
+	unsigned char		partner_node_type;
+	unsigned char		intermediate_routing;
+
+	struct sna_tg_vector	tg_vector;
+	struct sna_cos_array	*cos_list;
+};
+
+struct sna_tdm_node_cb {
+	struct sna_tdm_node_cb	*next;
+	struct sna_tdm_node_cb	*prev;
+
+	struct sna_netid	netid;
+	unsigned long		frsn;
+	struct timeval		updated;
+
+	struct sna_node_vector	node_vector;
+	struct sna_tg_cb	*tg_list;
+	struct sna_cos_array	*cos_list;
+};
+
+struct sna_tdm_an_cb {
+	struct sna_tdm_an_cb	*next;
+	struct sna_tdm_an_cb	*prev;
+};
+
+struct sna_rss_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+};
+
+/* Control vector 0x0E */
+struct sna_cv_nn {
+	unsigned short		type;
+	unsigned char		nn_type;
+	struct sna_netid	nq_name;
+};
+
+/* Control vector 0x2B */
+struct sna_cv_rs {
+	unsigned short		type;
+	unsigned char		max_hops;
+	unsigned char		current_hops;
+	struct sna_cv_nn	nn;
+	struct sna_tg_desc	tg_desc;
+};
+
+
+struct sna_rq_single_hop_route {
+	unsigned char		cos_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid	dst_cp_name;
+	unsigned char		sscp;
+	unsigned char		tg_alive;
+	unsigned char		tg_types;
+	struct sna_cv_rs 	rs;
+};
+
+struct sna_rq_tg_vectors {
+	struct sna_netid	org_cp_name;
+	struct sna_netid	dst_cp_name;
+	unsigned char		type;
+	unsigned char		sscp;
+	unsigned char		tg_type;
+	unsigned char		tg_alive;
+	struct sna_tg_vector	*tg_vectors;
+};
+
+struct sna_cinit_signal {
+        __u8 fqpcid;
+        __u8 path_control_id;
+        struct sna_pc_characteristics *pc_characteristics;
+        __u8 cos_tpf_present;
+        struct sna_cos_tpf *cos_tpf;
+};
+
+struct sna_confirmed {
+        __u8 bracket_id;
+};
+
+struct sna_cosm_tg_cb {
+	struct sna_cosm_tg_cb *next;
+	struct sna_cosm_tg_cb *prev;
+
+	unsigned short  rsn;
+
+	unsigned short	min_cost_per_connect;
+	unsigned short	max_cost_per_connect;
+	unsigned short	min_cost_per_byte;
+	unsigned short	max_cost_per_byte;
+	unsigned short	min_security;
+	unsigned short	max_security;
+	unsigned short	min_propagation_delay;
+	unsigned short	max_propagation_delay;
+	unsigned short	min_effective_capacity;
+	unsigned short	max_effective_capacity;
+	unsigned short	min_user1;
+	unsigned short	max_user1;
+	unsigned short	min_user2;
+	unsigned short	max_user2;
+	unsigned short	min_user3;
+	unsigned short	max_user3;
+
+	unsigned char	operational;
+	unsigned char	quiescing;
+	unsigned char	garbage_collection;
+	unsigned char	cpcp_session_status;
+};
+
+struct sna_cosm_node_cb {
+	struct sna_cosm_node_cb *next;
+	struct sna_cosm_node_cb *prev;
+
+	unsigned short	rsn;
+
+	unsigned short	route_resistance;
+	unsigned short	node_congested;
+	unsigned short	inter_routing_depleted;
+	unsigned short	garbage_collection;
+	unsigned short	quiescing;
+	unsigned short	gateway_support;
+	unsigned short	central_directory;
+};
+
+/* Transmission Priorities */
+#define SNA_TP_LOW              0x0
+#define SNA_TP_MEDIUM           0x1
+#define SNA_TP_HIGH             0x2
+#define SNA_TP_NETWORK          0x3
+
+struct sna_cosm_cb {
+	struct sna_cosm_cb *next;
+	struct sna_cosm_cb *prev;
+
+	unsigned char	name[SNA_RESOURCE_NAME_LEN];
+	unsigned short	weight;
+	unsigned short	tx_priority;
+
+	struct sna_cosm_tg_cb	*tg;
+	struct sna_cosm_node_cb	*node;
+
+	unsigned char	default_cos_invalid;
+	unsigned char	default_cos_null;
+};
+
+struct sna_conversation_failure {
+        __u8 rcb_id;
+        __u8 reason;
+};
+
+struct sna_deallocate_rcb {
+        __u8 tcb_id;
+        __u8 rcb_id;
+};
+
+struct sna_init_hs {
+        __u8    hs_id;
+        __u8    lu_id;
+        __u8    pc_id;
+        __u8    type;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        struct sna_lfsid lfsid;
+        __u8    tx_priority;
+
+        struct sna_ru_bind bind;
+};
+
+struct sna_init_hs_rsp {
+        __u8 type;
+        __u8 sense;
+        __u8 hs_id;
+};
+
+struct sna_init_signal_neg_rsp {
+        __u8 fqpcid;
+};
+
+struct sna_init_signal {
+        unsigned short sm_proc_id;
+        unsigned char fqpcid[8];
+	unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	struct sna_netid slu_name;
+	struct sna_netid plu_name;	/* Local netid */
+};
+
+struct sna_lfsid_in_use_rsp {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_lfsid_in_use {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+        __u8 answer;
+};
+
+struct sna_pc_hs_disconnect {
+        __u8 path_control_id;
+        struct sna_lfsid *lfsid;
+};
+
+struct sna_rcb_deallocated {
+        /* Blame IBM */
+};
+
+struct sna_receive_error {
+        __u8 bracket_id;
+};
+
+struct sna_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rm_act_session_rq {
+        unsigned long tcb_id;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+};
+
+struct sna_sm_act_session_rq {
+	unsigned short correlator;
+	struct sna_netid plu_netid;
+        unsigned char mode_name[SNA_RESOURCE_NAME_LEN];
+	unsigned char polarity;
+};
+
+#define SNA_ACT_SESS_RETRY	0
+
+#define SNA_SESSION_ACTIVE		0
+#define SNA_SESSION_AT_LEAST_INIT_SENT	1
+#define SNA_SESSION_AT_LEAST_BIND_SENT	2
+
+struct sna_rm_deactivate_conv_group {
+        __u8 tcb_id;
+        __u8 gid;
+        __u8 sense;
+};
+
+struct sna_rm_deactivate_session {
+        __u8 tcb_id;
+        __u8 session_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_rm_hs_connected {
+        /* Blame IBM */
+};
+
+struct sna_rsp_to_request_to_send {
+        __u8 bracket_id;
+};
+
+struct sna_rtr_rq {
+        __u8 hs_id;
+};
+
+struct sna_rtr_rsp {
+        __u8 hs_id;
+        __u8 rti;
+        __u8 sense;
+};
+
+struct sna_send_error {
+        /* Blame IBM */
+};
+
+struct sna_send_rtr {
+        /* Blame IBM */
+};
+
+struct sna_deactivate_session {
+        __u8 status;
+        __u8 correlator;
+        __u8 hs_id;
+        __u8 type;
+        __u8 sense;
+};
+
+struct sna_sessend_signal {
+        __u8 sense;
+        __u8 fqpcid;
+        __u8 path_control_id;
+};
+
+struct sna_sessst_signal {
+        __u8 path_control_id;
+};
+
+struct sna_start_tp_reply {
+        __u8 rcode;
+        __u8 tcb_id;
+};
+
+struct sna_terminate_ps {
+        __u8 tcb_id;
+};
+
+struct sna_unbind_protocol_error {
+        __u8 tcb_id;
+        __u8 hs_id;
+        __u8 sense;
+};
+
+struct sna_yield_session {
+        /* Blame IBM */
+};
+
+/* IPM.
+ */
+
+#define SNA_RH_IPM_TYPE         0x830100
+
+struct sna_ipm {
+        __u8    type:2,
+                rscwrc:1,
+                rsv1:5;
+        __u16   format:1,
+                nws:15;
+};
+
+/* IPM type indicators */
+#define SNA_IPM_TYPE_SOL        0x0
+#define SNA_IPM_TYPE_UNSOL      0x1
+#define SNA_IPM_TYPE_RS_ACK     0x2
+#define SNA_IPM_TYPE_RSV        0x3
+
+/* Reset residual-count indicators */
+#define SNA_IPM_RS_CNT_FALSE    0x0
+#define SNA_IPM_RS_CNT_TRUE     0x1
+
+/* Next-window size format indicators. */
+#define SNA_IPM_NWS_FORMAT_0    0x0
+
+/* Path control
+ */
+#define SNA_BIND_RQ		0x01
+#define SNA_BIND_RSP		0x02
+#define SNA_UNBIND_RQ		0x03
+#define SNA_UNBIND_RSP		0x04
+
+#define SNA_LS_FLUSHED          0x0302
+#define SNA_FREE_LFSID          0x0305
+#define SNA_PC_TO_DLC           0x0306
+#define SNA_SEND_MU             0x0307
+#define SNA_FLUSH_LS            0x0308
+#define SNA_INIT_PC             0x0309
+#define SNA_LOCAL_BIND_RQ_SEND  0x030A
+#define SNA_LOCAL_BIND_RSP_SEND 0x030B
+#define SNA_LOCAL_FLUSH_LS      0x030C
+#define SNA_LOCAL_UNBIND_RQ_SEND        0x030D
+#define SNA_LOCAL_UNBIND_RSP_SEND       0x030E
+#define SNA_BIND_IPM_SEND               0x030F
+#define SNA_PC_HS_DISCONNECT            0x0310
+
+#define	SNA_PC_INTRANODE		0x0
+#define SNA_PC_INTERNODE		0x1
+
+struct sna_pc_pinfo {
+        struct sna_pc_pinfo *next;
+        struct sna_pc_pinfo *prev;
+
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;		/* Only for Internode */
+        struct sna_ls_cb        *ls;		/* Only for Internode */
+        struct sna_port_cb	*port;		/* Only for Internode */
+	unsigned char		pc_id[8];
+	unsigned char		type;
+
+	/* TG characteristics */
+	unsigned short	max_tx_btu;
+	unsigned short	max_rx_btu;
+	unsigned char	bind_seg;
+	unsigned char	limited_tg;
+	unsigned char   tg_number;
+
+	unsigned char	odai;		/* 0 pri or 1 sec */
+
+	unsigned char	local_seg;
+	unsigned char	godai;
+};
+
+struct sna_pc_create_parms {
+	struct sna_netid	fqcp;
+
+	struct sna_dlc_cb       *dlc;
+        struct sna_ls_cb        *ls;
+        struct sna_port_cb      *port;
+	unsigned char		type;
+
+	unsigned char	pc_id[8];
+
+	/* TG characteristics */
+        unsigned short  max_tx_btu;
+        unsigned short  max_rx_btu;
+        unsigned char   bind_seg;
+        unsigned char   limited_tg;
+        unsigned char   tg_number;
+
+        unsigned char   odai;           /* 0 pri or 1 sec */
+        unsigned char   local_seg;
+        unsigned char   godai;
+};
+
+struct sna_pc_hs_table {
+        struct sna_pc_hs_table *next;
+        struct sna_pc_hs_table *prev;
+
+        __u8    odai;   /* OAF/DAF Assignor indicator. */
+        __u8    oaf;    /* Origin Address field. */
+        __u8    daf;    /* Destination Address field. */
+        __u8    sidh;   /* Session identifier high (OAF). */
+        __u8    sidl;   /* Session identifier low (DAF). */
+
+        /* These below may be garbage, we'll see what works best. */
+        __u8    hs_id;
+        __u8    sc_id;
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+/* PS.
+ */
+
+typedef enum {
+        ALLOCATE = 1,
+        CONFIRM,
+        CONFIRMED,
+        DEALLOCATE,
+        FLUSH,
+        GET_ATTRIBUTES,
+        POST_ON_RECEIPT,
+        PREPARE_TO_RECEIVE,
+        RECEIVE_AND_WAIT,
+        RECEIVE_IMMEDIATE,
+        REQUEST_TO_SEND,
+        SEND_DATA,
+        SEND_ERROR,
+        TEST,
+        MC_ALLOCATE,
+        MC_CONFIRM,
+        MC_CONFIRMED,
+        MC_DEALLOCATE,
+        MC_FLUSH,
+        MC_GET_ATTRIBUTES,
+        MC_POST_ON_RECEIPT,
+        MC_PREPARE_TO_RECEIVE,
+        MC_RECEIVE_AND_WAIT,
+        MC_REQUEST_TO_SEND,
+        MC_SEND_DATA,
+        MC_SEND_ERROR,
+        MC_TEST,
+        INITIALIZE_SESSION_LIMIT,
+        CHANGE_SESSION_LIMIT,
+        RESET_SESSION_LIMIT,
+        SET_LUCB,
+        SET_PARTNER_LU,
+        SET_MODE,
+        SET_MODE_OPTIONS,
+        SET_TRANSACTION_PROGRAM,
+        SET_PRIVILAEGED_FUNCTION,
+        SET_RESOURCE_SUPPORTED,
+        SET_SYNC_LEVEL_SUPPORTED,
+        SET_MC_FUNCTION_SUPPORTED_TP,
+        GET_LUCB,
+        GET_PARTNER_LU,
+        GET_MODE,
+        GET_LU_OPTION,
+        GET_MODE_OPTION,
+        GET_TRANSACTION_PROGRAM,
+        GET_PRIVILEGED_FUNCTION,
+        GET_RESOURCE_SUPPORTED,
+        GET_SYNC_LEVEL_SUPPORTED,
+        GET_MC_FUNCTION_SUPPORTED_LU,
+        GET_MC_FUNCTION_SUPPORTED_TP,
+        LIST_PARTNER_LU,
+        LIST_MODE,
+        LIST_LU_OPTION,
+        LIST_MODE_OPTION,
+        LIST_TRANSACTION_PROGRAM,
+        LIST_PRIVILEGED_FUNCTION,
+        LIST_RESOURCE_SUPPORTED,
+        LIST_SYNC_LEVEL_SUPPORTED,
+        LIST_MC_FUNCTION_SUPPORTED_LU,
+        LIST_MC_FUNCTION_SUPPORTED_TP,
+        PROCESS_SESSION_LIMIT,
+        ACTIVATE_SESSION,
+        DEACTIVATE_CONVERSATION_GROUP,
+        DEACTIVATE_SESSION,
+        SYNCPT,
+        BACKOUT,
+        GET_TP_PROPERTIES,
+        GET_TYPE,
+        WAIT
+} ps_verbs;
+
+/* RM.
+ */
+
+#define SNA_RM_FALSE    0x0
+#define SNA_RM_TRUE     0x1
+
+struct sna_lu_cb {
+        struct sna_lu_cb *next;
+        struct sna_lu_cb *prev;
+
+        struct sna_netid netid;
+        __u8    lu_name[SNA_RESOURCE_NAME_LEN];
+        __u8    sync_point;
+        __u32   lu_sess_limit;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_plu_cb {
+        struct sna_plu_cb *next;
+        struct sna_plu_cb *prev;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        struct sna_netid netid_fqcp;
+
+        __u8    parallel_ss;
+        __u8    cnv_security;
+
+        __u16   flags;
+        __u32   proc_id;
+};
+
+struct sna_lu_count {
+        __u16   sessions;
+        __u16   conwinners;
+        __u16   conlosers;
+};
+
+#define SNA_MODE_MAX_SESSIONS		1200
+#define SNA_MODE_MIN_CONWINNERS		10
+#define SNA_MODE_MIN_CONLOSERS		10
+
+struct sna_mode_cb {
+        struct sna_mode_cb *next;
+        struct sna_mode_cb *prev;
+
+        struct sna_netid netid;
+        struct sna_netid netid_plu;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+	__u8	cos_name[SNA_RESOURCE_NAME_LEN];
+
+        __u32   tx_pacing;
+        __u32   rx_pacing;
+        __u32   max_tx_ru;
+        __u32   max_rx_ru;
+        __u32   crypto;         /* 0 = off / 1 = on */
+
+        __u16   flags;
+        __u32   proc_id;
+
+	struct 	sna_lu_count	active;
+	struct 	sna_lu_count	pending;
+
+	__u16	max_sessions;
+        __u16   min_conwinners;
+        __u16   min_conlosers;
+	__u16	auto_activation;
+};
+
+struct sna_tcb {
+        struct sna_tcb  *next;
+        struct sna_tcb  *prev;
+
+        __u32           tcb_id;
+        __u32           rcb_id;
+	pid_t		pid;
+
+        cpic_state      state;
+
+        __u8            oaf;
+        __u8            daf;
+
+        struct sk_buff_head     receive_queue;
+        struct sk_buff_head     transmit_queue;
+        wait_queue_head_t       sleep;
+
+        /* cmspln */
+        unsigned char   partner_lu_name[18];
+        int             partner_lu_name_length;
+
+        /* cmsmn */
+        unsigned char   mode_name[9];
+        int             mode_name_length;
+
+        /* cmstpn */
+        unsigned char   tp_name[65];
+        int             tp_name_length;
+
+        /* cmsid */
+        unsigned char   init_data[10000];
+        int	        init_data_length;
+
+        /* cmsld */
+        unsigned char   log_data[512];
+        int	        log_data_length;
+
+        /* cmsrt */
+        unsigned long	 receive_type;
+
+        /* cmsaeq */
+        unsigned char   ae_qualifier[1024];
+        unsigned long   ae_qualifier_length;
+        unsigned char   ae_qualifier_format;
+
+        unsigned char   allocate_confirm;
+
+        /* cmsapt */
+        unsigned char   ap_title[1024];
+        unsigned long   ap_title_length;
+        unsigned char   ap_title_format;
+
+        /* cmsacn */
+        unsigned char   application_context_name[256];
+        unsigned long   application_context_length;
+
+        /* cmsbt */
+        unsigned char   begin_transaction;
+
+        /* cmssrm */
+        unsigned long	send_receive_mode;
+
+        /* cmssl */
+        unsigned long	   sync_level;
+
+        /* cmsst */
+        unsigned long	    send_type;
+
+        /* cmsptr */
+        unsigned long	      prepare_to_receive_type;
+
+        /* cmsdt */
+        unsigned long	      deallocate_type;
+
+        /* cmsf */
+        unsigned long	         fill;
+};
+
+/* SCM.
+ */
+
+#define sna_scm_create(x)       sna_isr_create(x);
+#define sna_scm(x)              sna_isr(x);
+
+/* SM.
+ */
+
+#ifdef NOT
+struct sna_session_info {
+        __u8    hs_id;
+        __u8    hs_type;
+        __u8    bracket_type;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    session_id;
+        __u8    *random;
+        __u8    limit_resource;
+};
+
+struct sna_security {
+        __u8    *profile;
+        __u8    *passwd;
+        __u8    *user_id;
+};
+
+struct sna_abend_notify {
+        __u8    process;
+        __u8    process_id;
+        __u8    reason;
+};
+
+struct sna_free_lfsid {
+        __u8    pc_id;
+        __u8    lfsid;
+};
+
+struct sna_free_session {
+        __u8    hs_id;
+};
+
+struct sna_get_session {
+        __u8    tcb_id;
+        __u8    rcb_id;
+        __u8    type;
+        __u8    conv_gid;
+};
+
+struct sna_session_activated {
+        struct sna_session_info session_info;
+        __u8    *lu_name;
+        __u8    *mode_name;
+};
+
+struct sna_session_allocated {
+        __u16   send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    in_conver;
+        __u8    rcode;
+};
+
+struct sna_session_deactivated {
+        __u8    hs_id;
+        __u8    reason;
+        __u32   sense;
+};
+
+struct sna_session_route_inop {
+        __u8    pc_id;
+};
+
+struct sna_act_sess_rsp {
+        __u8    correlator;
+        __u8    type;
+        __u8    err_type;
+        struct  sna_session_info sess_info;
+};
+
+struct sna_rcb_allocated {
+        __u8    rcode;
+        __u8    rcb_id;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+};
+
+struct sna_change_sessions {
+        __u8    tcb_id;
+        __u8    rsp;
+        __u8    *lu_name;
+        __u8    *mode_name;
+        __u8    delta;
+};
+
+struct sna_luw {
+        __u8    *fq_lu_name;
+        __u8    instance;
+        __u8    sequence;
+};
+
+/* Transaction control block. */
+struct sna_tcb {
+        struct sna_tcb *next;
+        struct sna_tcb *prev;
+
+        __u8    tcb_id;
+        __u8    tp_name;
+        __u8    own_lu_id;
+
+        struct sna_luw luw_id;
+        struct sna_resource resource_list;
+
+        __u8    ctrl_cmpnt;
+
+        struct sna_security security;
+};
+
+struct sna_scb {
+        __u8    hs_id;
+        __u8    session_id;
+
+        struct sna_conver conversation;
+
+        __u8    *lu_name;
+        __u8    *mode_name;
+
+        __u8    rcb_id;
+        __u8    first_speaker;
+        __u8    send_ru_size;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+        __u8    bracket_id;
+
+        __u8    rtr_owed;
+        __u8    *fq_name;
+        __u8    *random;
+
+        __u8    limit_resource;
+
+        struct timer *timer_unique_id;
+};
+
+struct sna_received_info {
+        __u8    type;
+};
+
+struct sna_conver {
+        __u8    correlator;
+        __u8    gid;
+};
+
+struct sna_post_cond {
+        __u8    fill;
+        __u8    max_length;
+};
+
+#endif
+
+typedef enum {
+        FSM_RCB_STATUS_FSP = 1
+} rcb_state;
+
+/* Resource control block. */
+struct sna_rcb {
+        struct sna_rcb *next;
+        struct sna_rcb *prev;
+
+        rcb_state       state;
+
+        unsigned long   rcb_id;
+        unsigned long   tcb_id;
+        unsigned long   hs_id;
+        unsigned long   bracket_id;
+
+        unsigned long   conversation_correlator;
+        unsigned long   session_id;
+
+        unsigned long   lfsid;          /* XXX */
+        unsigned char   oaf;            /* XXX */
+        unsigned char   daf;            /* XXX */
+
+        __u8    lu_name_length;
+        __u8    lu_name[SNA_FQCP_NAME_LEN];
+
+        __u8    mode_name_length;
+        __u8    mode_name[SNA_RESOURCE_NAME_LEN];
+
+        __u8    tp_name_length;
+        __u8    tp_name[64];
+
+        union {
+                struct sna_ps_to_hs ps_to_hs;
+        } l;
+
+/* Everything below here is questionable */
+
+        __u8    sync_level;
+        __u8    security_select;
+
+//      struct sna_session_parm *sessions_parm_ptr;
+
+        __u8    conversation_type;
+        __u8    limit_buf_pool_id;
+        __u8    perm_buf_pool_id;
+
+//      struct sna_post_cond post_conditions;
+
+        __u8    locks;
+        __u16   send_ru_size;
+        __u8    rq_ro_send_rcvd;
+
+        __u32   mapper_save_area;
+        __u16   mc_max_send_size;
+        __u8    mc_rq_to_send_rcvd;
+};
+
+#ifdef NOT
+
+struct sna_tp {
+        struct sna_tp *next;
+        struct sna_tp *prev;
+
+        __u8    *tp_name;
+
+        struct sna_priv_funct priv_functs;
+        struct sna_rcb rcb;
+
+        __u8    verify_pip;
+        __u8    sub_pips;
+
+        struct sna_sync_level sync_level;
+
+        __u8    max_tp;
+        __u8    tp_cnt;
+        __u8    status;
+
+        struct sna_wait_init_rqs wait_init_rqs;
+
+        struct sna_mc_funct mc_funct;
+};
+
+struct sna_start_tp {
+        __u8    reply;
+        __u8    *tp_name;
+        __u8    security_select;
+        struct sna_security security;
+        __u8    tcb_id;
+        __u8    *pip_data;
+        __u8    fq_lu_name;
+};
+
+struct sna_plu {
+        struct sna_plu *next;
+        struct sna_plu *prev;
+
+        __u8    *lu_name;
+        __u8    *fq_name;
+        __u8    parallel_lus;
+
+        struct sna_mode mode;
+};
+
+struct sna_lucb {
+        struct sna_lucb *next;
+        struct sna_lucb *prev;
+
+        __u8    lu_id;          /* LU ID. */
+        __u8    *fq_lu_name;
+        __u8    slimit;         /* Session limit. */
+
+        struct sna_plu          plu;
+        struct sna_tp           tp;
+        struct sna_rand_data    random;
+};
+
+#endif
+
+/* SS.
+ */
+
+struct sna_ss_pinfo {
+        struct sna_ss_pinfo *next;
+        struct sna_ss_pinfo *prev;
+
+        struct sna_netid netid;
+
+        unsigned long   bind_reassembly;
+        unsigned long   adaptive_bind_pacing;
+};
+
+/* TC.
+ */
+
+#ifdef NOT
+
+#define SNA_PACING_TYPE_NONE            0x01
+#define SNA_PACING_TYPE_FIXED           0x02
+#define SNA_PACING_TYPE_ADAPTIVE        0x03
+
+struct sna_send_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    first_ws;
+        __u8    rlwi;
+};
+
+struct sna_receive_pacing {
+        __u8    type;
+        __u8    rpc;
+        __u8    nws;
+        __u8    unsolicited_ipm_outstanding;
+        __u8    adjust_ipm_ack_outstanding;
+        __u8    unsolicited_nws;
+};
+
+#define SNA_COMMON_CB_RESERVE_NO        0x01
+#define SNA_COMMON_CB_RESERVE_ALL       0x02
+#define SNA_COMMON_CB_RESERVE_MORE      0x03
+
+#define SNA_CCB_NO_RLW          0x0
+#define SNA_CCB_RLW             0x1
+
+#define SNA_CCB_NO              0x0
+#define SNA_CCB_MORE            0x1
+#define SNA_CCB_ALL             0x2
+
+struct sna_common_cb {
+        __u8    caller;
+        __u8    pc_id;
+        struct sna_lfsid lfsid;
+        __u8    perm_buf_pool_id;
+        __u8    dynamic_buf_pool_id;
+        __u8    limit_buf_pool_id;
+        __u8    tx_priority;
+        __u8    num_bufs_per_ru;
+        __u8    reserve_flag;
+
+        struct sna_send_pacing          send_pacing;
+        struct sna_receive_pacing       receive_pacing;
+};
+
+struct sna_tc_cb {
+        __u16   max_rcv_ru_size;
+        __u16   sqn_rcv_cnt;
+        __u8    segmenting_supported;
+        __u8    crypto;
+        struct sna_common_cb    ccb;
+};
+
+#define SNA_IPM_TYPE_SOLICITED          0x01
+#define SNA_IPM_TYPE_UNSOLICITED        0x02
+#define SNA_IPM_TYPE_RESET_ACK          0x03
+
+#define SNA_IPM_RWI_RESET_WINDOW        0x01
+#define SNA_IPM_RWI_NO_RESET_WINDOW     0x02
+
+#define SNA_IPM_FORMAT_0                0x01
+
+struct sna_ipm_extension {      /* Should only be 3 bytes long. */
+        __u8    type;
+        __u8    rwi;
+        __u8    format_indicator;
+        __u8    nws;
+};
+
+#endif
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_CBS_H */
diff -ruN linux-2.4.4/include/net/sna_errors.h linux/include/net/sna_errors.h
--- linux-2.4.4/include/net/sna_errors.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_errors.h	Mon May 14 19:57:47 2001
@@ -0,0 +1,46 @@
+/* sna_errors.h: Linux-SNA Error codes and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_ERRORS_H
+#define __NET_SNA_ERRORS_H
+
+#ifdef __KERNEL__
+
+#define	RESOURCE_FAILURE_NO_RETRY	1008600B
+
+/* Allocation error codes */
+#define TPN_NOT_RECOGNIZED		10086021
+#define PIP_NOT_ALLOWED			10086031
+#define PIP_NOT_SPECIFIED_CORRECTLY	10086032
+#define CONVERSATION_TYPE_MISMATCH	10086034
+#define SYNC_LEVEL_NOT_SUPPORTED_BY_PGM	10086041
+#define ACCESS_DENIED			080F0983
+#define SECURITY_NOT_VALID		080F6051
+#define BACKED_OUT			08240000
+#define TP_NOT_AVAIL_RETRY		084B6031
+#define TP_NOT_AVAIL_NO_RETRY		084C0000
+#define DEALLOCATE_ABEND_PROG		08640000
+#define DEALLOCATE_ABEND_SVC		08640001
+#define DEALLOCATE_ABEND_TIMER		08640002
+#define PROG_ERROR_NO_TRUNC		08890000
+#define PROG_ERROR_PURGING		08890000
+#define PROG_ERROR_TRUNC		08890001
+#define SVC_ERROR_NO_TRUNC		08890100
+#define SVC_ERROR_PURGING		08890100
+#define SVC_ERROR_TRUNC			08890101
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_ERRORS_H */
diff -ruN linux-2.4.4/include/net/sna_externs.h linux/include/net/sna_externs.h
--- linux-2.4.4/include/net/sna_externs.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_externs.h	Mon May 14 21:05:34 2001
@@ -0,0 +1,276 @@
+/* sna_externs.h: Linux-SNA external function declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_EXTERNS_H
+#define __NET_SNA_EXTERNS_H
+
+#ifdef __KERNEL__
+
+extern int sna_netid_to_char(struct sna_netid *n, unsigned char *c);
+extern struct sna_netid *sna_char_to_netid(unsigned char *c);
+extern char *sna_pr_ether(unsigned char *ptr);
+extern char *sna_pr_netid(struct sna_netid *n);
+extern char *sna_pr_nodeid(struct sna_nodeid *n);
+
+/* ASM. */
+extern int sna_asm_assign_lfsid(struct sna_assign_lfsid *as);
+extern int sna_asm_create(struct sna_start_node *start);
+extern int sna_asm_destroy(struct sna_delete_node *delete);
+extern int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_asm_activate_as(struct sna_activate_as *as);
+extern int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* Attach. */
+extern int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb);
+extern int sna_attach_create(struct sna_start_node *start);
+extern int sna_attach_destroy(struct sna_delete_node *delete);
+
+/* COSM. */
+extern int sna_cosm_query_cos(char *arg);
+extern int sna_cosm_create(struct sna_start_node *start);
+extern int sna_cosm_destroy(struct sna_delete_node *delete);
+extern void sna_cosm_init(void);
+extern void sna_cosm_cleanup(void);
+extern int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cosm_define_cos(struct sna_define_cos *cos);
+extern int sna_cosm_delete_cos(struct sna_delete_cos *cos);
+extern int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos);
+extern int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length);
+
+/* CPIC. */
+extern struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id);
+extern unsigned long sna_cpic_create_tcb(void);
+extern int sna_cpic_ioctl(int cmd, void *arg);
+extern int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length);
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+extern struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf);
+
+/* CS. */
+extern struct sna_port_cb *sna_cs_find_port(struct sna_port_cb *plist,
+        char *saddr);
+extern struct sna_dlc_cb *sna_cs_find_dlc_name(char *name);
+extern int sna_cs_connect_in(struct sk_buff *skb, struct net_device *dev);
+extern int sna_cs_rcv_xid(struct sk_buff *skb, struct net_device *dev);
+extern int sna_cs_query_dlc(char *arg);
+extern int sna_cs_query_port(char *arg);
+extern int sna_cs_query_ls(char *arg);
+extern int sna_cs_create(struct sna_start_node *start);
+extern int sna_cs_destroy(struct sna_delete_node *delete);
+extern int sna_cs_define_dlc(struct net_device *dev);
+extern int sna_cs_delete_dlc(struct net_device *dev);
+extern int sna_cs_define_port(struct sna_define_port *port);
+extern int sna_cs_delete_port(struct sna_delete_port *port);
+extern int sna_cs_start_port(struct sna_start_port *port);
+extern int sna_cs_stop_port(struct sna_stop_port *port);
+extern int sna_cs_define_ls(struct sna_define_link_station *dls);
+extern int sna_cs_delete_ls(struct sna_delete_link_station *dls);
+extern int sna_cs_start_ls(struct sna_start_link_station *sls);
+extern int sna_cs_stop_ls(struct sna_stop_link_station *sls);
+extern int sna_cs_activate_route(struct sna_activate_route *ar);
+extern void sna_cs_connect_out(unsigned long data);
+extern int sna_cs_xid_xchg_state(struct sk_buff *skb);
+
+#ifdef CONFIG_PROC_FS
+extern int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length);
+#endif
+
+#ifdef CONFIG_SNA_LLC
+extern int sna_dlc_llc_rcv(struct sk_buff *skb, struct net_device *dev,
+        struct packet_type *pt);
+extern int sna_dlc_llc_event(int rsp, struct sk_buff *skb);
+#endif
+
+/* DFC. */
+extern int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb);
+extern int sna_dfc_rcv(struct sk_buff *skb);
+
+/* DS. */
+extern int sna_ds_create(struct sna_start_node *start);
+extern int sna_ds_destroy(struct sna_delete_node *delete);
+
+/* EBCDIC. */
+extern unsigned char etor(unsigned char a);
+extern unsigned char etoa(unsigned char a);
+extern unsigned char atoe(unsigned char a);
+extern char *atoe_strcpy(char *dest, char *src);
+extern char *etoa_strcpy(char *dest, char *src);
+extern char *etor_strncpy(char *dest, char *src, size_t count);
+extern char *atoe_strncpy(char *dest, char *src, size_t count);
+extern char *etoa_strncpy(char *dest, char *src, size_t count);
+extern int atoe_strcmp(const char *acs, const char *ect);
+extern int etoa_strcmp(const char *ecs, const char *act);
+extern int atoe_strncmp(const char *acs, const char *ect, size_t count);
+extern int etoa_strncmp(const char *ecs, const char *act, size_t count);
+extern char *fatoe_strncpy(char *dest, char *src, size_t count);
+
+/* HS. */
+extern int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+        struct sna_rcb *rcb);
+
+/* ISR. */
+extern void sna_isr_init(void);
+extern void sna_isr_cleanup(void);
+
+/* LAR. */
+extern int sna_lar_ioctl(int cmd, void *arg);
+extern int sna_lar_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen);
+extern int sna_lar_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_lar_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_lar_record(struct sna_netid *netid, char *group,
+        struct sna_lar_snpa *snpa, __u32 rtcap, __u8 ldev);
+extern int sna_lar_erase(char *name, char *net);
+extern int sna_lar_create(void);
+extern int sna_lar_destroy(void);
+extern unsigned char flip_byte(unsigned char v);
+
+/* NOF. */
+extern int sna_nof_ioctl(int cmd, void *arg);
+extern int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen);
+extern int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *len);
+extern int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_nof_define_dlc(struct net_device *dev);
+extern int sna_nof_delete_dlc(struct net_device *dev);
+extern struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n);
+
+/* PC. */
+extern void sna_pc_cleanup(void);
+extern void sna_pc_init_layer(void);
+extern int sna_pc_init(struct sna_pc_create_parms *npc);
+extern int sna_pc_destroy(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id);
+extern struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n);
+extern int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_pc_mu_error_checker(struct sk_buff *skb);
+extern int sna_pc_mu_rcv_router(struct sk_buff *skb);
+extern struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb);
+
+/* PS. */
+extern int sna_ps_conv(int verb, struct sna_tcb *tcb);
+extern int sna_ps_mc(int verb, struct sna_tcb *tcb);
+extern int sna_ps_copr(int verb, struct sna_tcb *tcb);
+extern int sna_ps_sync(int verb, struct sna_tcb *tcb);
+extern int sna_ps_verb_router(int verb, struct sna_tcb *tcb);
+extern int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb);
+
+/* RM. */
+extern struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id);
+extern __u8 sna_rm_allocate_rcb(struct sna_tcb *tcb);
+extern int sna_rm_process_hs_to_rm(struct sk_buff *skb);
+extern struct sna_rcb *sna_search_rcb(__u8 id);
+extern struct sna_tcb *sna_search_tcb(__u8 id);
+extern struct sna_scb *sna_search_scb(__u8 id);
+extern struct sna_tp *sna_search_tp(__u8 id);
+extern struct sna_partner_lu *sna_search_plu(__u8 id);
+extern struct sna_lucb *sna_search_lucb(__u8 id);
+extern struct sna_lu_lu_cb *sna_search_lulucb(__u8 id);
+extern int sna_rm_destroy(struct sna_delete_node *d);
+extern int sna_rm_define_mode(struct sna_define_mode *dm);
+extern int sna_rm_delete_mode(struct sna_delete_mode *dm);
+extern int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu);
+extern int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu);
+extern int sna_rm_define_local_lu(struct sna_define_local_lu *dlu);
+extern int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu);
+extern int sna_rm_query_mode(char *arg);
+extern int sna_rm_query_lu(char *arg);
+extern int sna_rm_query_plu(char *arg);
+extern int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_rm_activate_session(struct sna_rm_act_session_rq *as);
+extern struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id);
+extern struct sna_mode_cb *sna_rm_find_mode(char *mode_name);
+
+/* RSS. */
+extern int sna_rss_create(struct sna_start_node *start);
+extern int sna_rss_destroy(struct sna_delete_node *delete);
+extern void sna_rss_init(void);
+extern void sna_rss_cleanup(void);
+extern int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r);
+
+/* SM. */
+extern int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l);
+extern int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal);
+extern int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as);
+
+/* SS. */
+extern int sna_ss_create(struct sna_start_node *start);
+extern int sna_ss_destroy(struct sna_delete_node *delete);
+extern int sna_ss_process_init_signal(struct sna_init_signal *init);
+extern int sna_ss_assign_pcid(struct sna_assign_pcid *pcid);
+extern int sna_ss_generate_pcid(char *net, char *name);
+extern int sna_ss_update_pcid(unsigned char *r);
+
+/* TC. */
+extern int sna_attach_rcv(struct sk_buff *skb);
+extern int sna_tc_transmit(struct sk_buff *skb);
+extern int sna_tc_send_data(struct sk_buff *skb);
+extern struct sk_buff *sna_tc_receive_data(void);
+extern int sna_tc_init(void);
+extern int sna_tc_send_mu(struct sk_buff *skb);
+extern int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid);
+
+/* TDM. */
+extern int sna_tdm_create(struct sna_start_node *start);
+extern int sna_tdm_destroy(struct sna_delete_node *delete);
+extern void sna_tdm_init(void);
+extern void sna_tdm_cleanup(void);
+extern int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length);
+extern int sna_tdm_define_node_chars(struct sna_define_node_chars *n);
+extern int sna_tdm_tg_update(struct sna_tg_update *utg);
+extern int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v);
+extern struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid);
+extern struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n,
+        unsigned char tg_num);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num);
+extern int sna_tdm_init_tg_update(struct sna_tg_update *tg);
+extern struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac);
+
+/* TRS. */
+extern int sna_trs_create(struct sna_start_node *start);
+extern int sna_trs_destroy(struct sna_delete_node *delete);
+
+#endif	/* __KERNEL__ */
+#endif	/* __NET_SNA_EXTERNS_H */
diff -ruN linux-2.4.4/include/net/sna_formats.h linux/include/net/sna_formats.h
--- linux-2.4.4/include/net/sna_formats.h	Wed Dec 31 16:00:00 1969
+++ linux/include/net/sna_formats.h	Mon May 14 19:57:47 2001
@@ -0,0 +1,4554 @@
+/* sna_formats.h: Linux-SNA data headers and declarations.
+ * - Kept in one place to ease maintance headaches
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#ifndef __NET_SNA_FORMATS_H
+#define __NET_SNA_FORMATS_H
+
+#ifdef __KERNEL__
+
+/* MU.
+ */
+
+#ifdef NOT
+struct sna_sender {
+        __u8 id;
+        __u8 type;
+};
+
+struct sna_bind_rq_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        struct sna_lfsid *lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_send {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 path_id;
+        __u8 free_lfsid;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_unbind_rq {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptaive_pace;
+};
+
+struct sna_unbind_rsp_send {
+        __u8 lu_id;
+        struct sna_sender *sender;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_pc_character {
+        __u16 max_send_btu_size;
+        __u16 max_rcv_btu_size;
+        __u8 adjacent_node_bind_reasm;
+        __u8 limit_resource;
+};
+
+struct sna_bind_rq_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 trans_prior;
+        __u8 free_lfsid;
+        __u8 path_id;
+        struct sna_pc_character *pc_characteristics;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+struct sna_bind_rsp_rcv {
+        struct sna_sender *sender;
+        struct sna_lfsid *lfsid;
+        __u8 hs_id;
+        __u8 tx_priority;
+        __u8 free_lfsid;
+        __u8 path_id;
+        __u8 parallel;
+        __u8 adaptive_pace;
+};
+
+#endif
+
+struct sna_hs_to_rm {
+        __u8 hs_id;
+};
+
+struct sna_rm_to_ps {
+        __u8 hs_id;
+        __u8 tcb_id;
+        __u8 rcb_id;
+        __u8 send_ru_size;
+        __u8 limit_buf_pool_id;
+        __u8 perm_buf_pool_id;
+        __u8 rcode;
+};
+
+struct sna_hs_to_ps {
+        __u8 bracket_id;
+        __u8 fmh;
+        __u8 type;
+};
+
+struct sna_ps_to_hs {
+        __u8 bracket_id;
+        __u8 ps_to_hs_variant;
+        __u8 allocate;
+        __u8 fmh;
+        __u8 type;
+};
+
+/* LAR.
+ */
+
+/*
+ * Major and Sub Vector packet formats.
+ */
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        __u32   correlator      __attribute__ ((packed));
+} lar_correlator;                       /* 6 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        __u32 rtcap             __attribute__ ((packed));
+} lar_rtcap;                            /* 6 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        unsigned char mac[6]    __attribute__ ((packed));
+} lar_mac;                              /* 8 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        __u8    lsap:8          __attribute__ ((packed));
+} lar_lsap;                             /* 3 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        unsigned char netid[8]  __attribute__ ((packed));
+} lar_netid;                            /* 10 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        unsigned char name[8]   __attribute__ ((packed));
+} lar_name;                             /* 10 Bytes */
+
+typedef struct {
+        __u8    svlen:8         __attribute__ ((packed));
+        __u8    svid:8          __attribute__ ((packed));
+
+        lar_name        gname           __attribute__ ((packed));
+} lar_group;                            /* 12+ Bytes */
+
+typedef struct {
+        lar_netid       tnetid;
+        lar_name        gname;
+} lar_solicit;
+
+typedef struct {
+        lar_netid       rnetid;
+        lar_name        rname;
+        lar_lsap        rlsap;
+        lar_mac         rmac;
+        lar_rtcap       rtcap;
+
+        /* Connection Network ID */
+
+        lar_group       group;
+        lar_mac         cce_mac;
+} lar_advertise;
+
+typedef struct {
+        lar_correlator  correlator;
+        lar_netid       tnetid;
+        lar_name        tname;
+        lar_netid       onetid;
+        lar_name        oname;
+        lar_lsap        olsap;
+        lar_mac         omac;
+        lar_mac         cce_mac;
+} lar_find;
+
+typedef struct {
+        lar_correlator  correlator;
+        lar_lsap        resrc_lsap;
+        lar_mac         resrc_mac;
+} lar_found;
+
+typedef struct {
+        lar_correlator  correlator __attribute__ ((packed));
+        lar_netid       tnetid __attribute__ ((packed));
+        lar_name        gname __attribute__ ((packed));
+        lar_rtcap       rtcap __attribute__ ((packed));
+        lar_mac         cce_mac __attribute__ ((packed));
+} lar_query;
+
+typedef struct {
+        lar_correlator  correlator;
+        lar_lsap        rlsap __attribute__ ((packed));
+        lar_mac         rmac __attribute__ ((packed));
+        lar_netid       rnetid __attribute__ ((packed));
+        lar_name        rname __attribute__ ((packed));
+        lar_group       group __attribute__ ((packed));
+        lar_rtcap       rtcap __attribute__ ((packed));
+        lar_mac         cce_mac __attribute__ ((packed));
+} lar_notify;
+
+struct larhdr {
+        __u16   mvlen:16;               /* Major Vector length */
+        __u8    mvid:8;                 /* Major Vector ID */
+
+        union {
+                lar_solicit     solicit         __attribute__ ((packed));
+                lar_advertise   advertise       __attribute__ ((packed));
+                lar_find        find            __attribute__ ((packed));
+                lar_found       found           __attribute__ ((packed));
+                lar_query       query           __attribute__ ((packed));
+                lar_notify      notify          __attribute__ ((packed));
+                __u8            raw             __attribute__ ((packed));
+        } mv;
+};
+
+#define SNA_LAR_T_SOLICIT               0x01
+#define SNA_LAR_T_ADVERTISE             0x02
+#define SNA_LAR_T_FIND                  0x03
+#define SNA_LAR_T_FOUND                 0x04
+#define SNA_LAR_T_QUERY                 0x05
+#define SNA_LAR_QUERY_SIZE              43
+#define SNA_LAR_T_NOTIFY                0x06
+#define SNA_LAR_NOTIFY_SIZE             66
+
+#define SNA_LAR_FIND_TIMER_EXPIRE       9
+#define SNA_LAR_FIND_TIMER_MAX          20
+#define SNA_LAR_FIND_COUNT              2
+#define SNA_LAR_FIND_COUNT_MAX          6
+
+#define SNA_LAR_AD_TIMER_EXPIRE         5
+#define SNA_LAR_AD_TIMER_MAX            60
+#define SNA_LAR_AD_COUNT                10
+#define SNA_LAR_AD_COUNT_MAX            20
+
+#define SNA_LAR_SOLICIT_TIMER_EXPIRE    10
+#define SNA_LAR_SOLICIT_TIMER_MAX       20
+#define SNA_LAR_QUERY_TIMER_EXPIRE      9
+#define SNA_LAR_QUERY_TIMER_MAX         20
+
+struct sna_lar_gname {
+        char name[SNA_RESOURCE_NAME_LEN];
+};
+
+/* Sub Network Point of Attachment - MAC Address */
+struct sna_lar_snpa {
+        __u8 mac[ETH_ALEN];
+        __u8 lsap;
+};
+
+struct sna_lar_dinfo {
+        struct sna_lar_dinfo    *next;
+        struct sna_lar_dinfo    *prev;
+
+	__u8			ldev;	/* local interface */
+        struct sna_netid        netid;
+        struct sna_lar_snpa     snpa;
+        __u8                    group[SNA_RESOURCE_NAME_LEN];
+        __u32                   rtcap;
+};
+
+/* COMPRESSION.
+ */
+
+#ifdef NOT
+
+/* Compression algorithms */
+#define RU_COMPRESS_RLE 000
+#define RU_COMPRESS_LZ  001
+
+/* Compression header */
+struct sna_ru_compress
+{
+        unsigned char   compress:4,     /* Compression algorithm */
+                        length:4;       /* Uncmprssd data type/cmprssn hdr sz */        __u16           size;
+};
+
+/* SCB data type */
+#define RU_SCB_RAW      00
+#define RU_SCB_RESRV    01
+#define RU_SCB_MSTR_CHR 10
+#define RU_SCB_DUP_CHR  11
+
+struct sna_ru_compress_scb
+{
+        __u8    type:2,         /* SCB type */
+                count:6;        /* Uncompressed size of following data */
+};
+
+/* LZ command indicators */
+#define LZ_RESET        0x001
+#define LZ_FREEZE       0x002
+#define LZ_UNFREEZE     0x003
+
+/* LZ control sequence header */
+struct sna_lz_9bit
+{
+        __u16   cntl:9,         /* 9 bit LZ compression */
+                cmd:7;          /* LZ command */
+};
+
+struct sna_lz_10bit
+{
+        __u16   cntl:10,        /* 10 bit LZ compression */
+                cmd:6;          /* LZ command */
+};
+
+struct sna_lz_12bit
+{
+        __u16   cntl:12,        /* 12 but LZ compression  */
+                cmd:4;          /* LZ command */
+};
+
+struct sna_ru_compress_lz
+{
+        union {
+                struct sna_lz_9bit      9bit;
+                struct sna_lz_10bit     10bit;
+                struct sna_lz_12bit     12bit;
+        } size;
+};
+
+#endif
+
+/* EBCDIC.
+ */
+
+static unsigned char const ebcdic_to_rotated[256] = {
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,         /* 24 -   31 */
+         32,  33,  34,  35,  36,  37,  38,  39,         /* 32 -   39 */
+         40,  41,  42,  43,  44,  45,  46,  47,         /* 40 -   47 */
+         48,  49,  50,  51,  52,  53,  54,  55,         /* 48 -   55 */
+         56,  57,  58,  59,  60,  61,  62,  63,         /* 56 -   63 */
+         1,  65,  66,  67,  68,  69,  70,  71,          /* 64 -   71 */
+         72,  73,  74,  75,  76,  77,  78,  79,         /* 72 -   79 */
+         80,  81,  82,  83,  84,  85,  86,  87,         /* 80 -   87 */
+         88,  89,  90, 109,  92,  93,  94,  95,         /* 88 -   95 */
+         96,  97,  98,  99, 100, 101, 102, 103,         /* 96 -  103 */
+        104, 105, 106, 107, 108, 109, 110, 111,         /* 104 - 111 */
+        112, 113, 114, 115, 116, 117, 118, 119,         /* 112 - 119 */
+        120, 121, 122, 237, 241, 125, 126, 127,         /* 120 - 127 */
+        128, 129, 130, 131, 132, 133, 134, 135,         /* 128 - 135 */
+        136, 137, 138, 139, 140, 141, 142, 143,         /* 136 - 143 */
+        144, 145, 146, 147, 148, 149, 150, 151,         /* 144 - 151 */
+        152, 153, 154, 155, 156, 157, 158, 159,         /* 152 - 159 */
+        160, 161, 162, 163, 164, 165, 166, 167,         /* 160 - 167 */
+        168, 169, 170, 171, 172, 173, 174, 175,         /* 168 - 175 */
+        176, 177, 178, 179, 180, 181, 182, 183,         /* 176 - 183 */
+        184, 185, 186, 187, 188, 189, 190, 191,         /* 184 - 191 */
+        192,   7,  11,  14,  19,  23,  27,  31,         /* 192 - 199 */
+         35,  39, 202, 203, 204, 205, 206, 207,         /* 200 - 207 */
+        208,  71,  75,  79,  83,  87,  91,  95,         /* 208 - 215 */
+         99, 103, 218, 219, 220, 221, 222, 223,         /* 216 - 223 */
+        224, 225, 139, 143, 147, 151, 155, 159,         /* 224 - 231 */
+        163, 167, 234, 235, 236, 237, 238, 239,         /* 232 - 239 */
+        195, 199, 203, 207, 211, 215, 219, 223,         /* 240 - 247 */
+        227, 231, 250, 251, 252, 253, 254, 255          /* 248 - 255 */
+};
+
+static unsigned char const ebcdic_to_ascii_sna[256] =
+{
+          0,   1,   2,   3,   4,   5,   6,   7,         /* 0 -     7 */
+          8,   9,  10,  11,  12,  13,  14,  15,         /* 8 -    15 */
+         16,  17,  18,  19,  20,  21,  22,  23,         /* 16 -   23 */
+         24,  25,  26,  27,  28,  29,  30,  31,
+         32,  33,  34,  35,  36,  37,  38,  39,
+         40,  41,  42,  43,  44,  45,  46,  47,
+         48,  49,  50,  51,  52,  53,  54,  55,
+         56,  57,  58,  59,  60,  61,  62,  63,
+         32,  65,  66,  67,  68,  69,  70,  71,
+         72,  73,  74,  75,  76,  77,  78,  79,
+         80,  81,  82,  83,  84,  85,  86,  87,
+         88,  89,  90,  91,  92,  93,  94,  95,
+         96,  97,  98,  99, 100, 101, 102, 103,
+        104, 105, 106, 107, 108, 109, 110, 111,
+        112, 113, 114, 115, 116, 117, 118, 119,
+        120, 121, 122, 123, 124, 125, 126, 127,
+        128, 129, 130, 131, 132, 133, 134, 135,
+        136, 137, 138, 139, 140, 141, 142, 143,
+        144, 145, 146, 147, 148, 149, 150, 151,
+        152, 153, 154, 155, 156, 157, 158, 159,
+        160, 161, 162, 163, 164, 165, 166, 167,
+        168, 169, 170, 171, 172, 173, 174, 175,
+        176, 177, 178, 179, 180, 181, 182, 183,
+        184, 185, 186, 187, 188, 189, 190, 191,
+        192,  65,  66,  67,  68,  69,  70,  71,
+         72,  73, 202, 203, 204, 205, 206, 207,
+        208,  74,  75,  76,  77,  78,  79,  80,
+         81,  82, 218, 219, 220, 221, 222, 223,
+        224, 225,  83,  84,  85,  86,  87,  88,
+         89,  90, 234, 235, 236, 237, 238, 239,
+        240, 241, 242, 243, 244, 245, 246, 247,
+        248, 249, 250, 251, 252, 253, 254, 255
+};
+
+static unsigned char const ascii_to_ebcdic_sna[256] =
+{
+          0,   1,   2,   3,  55,  45,  46,  47,         /* 0  -    7 */
+         22,   5,  37,  11,  12,  13,  14,  15,         /* 8  -   15 */
+         16,   0,   0,   0,   0,  61,  50,  38,         /* 16 -   23 */
+         24,  25,  63,  39,   0,   0,   0,   0,         /* 24 -   31 */
+         64,   0, 127, 123,  80, 108,  91, 121,         /* 32 -   39 */
+         77,  93,  53,  78, 107,  96,  75,  97,         /* 40 -   47 */
+        240, 241, 242, 243, 244, 245, 246, 247,         /* 48 -   55 */
+        248, 249, 122,  94,  76, 126, 110, 111,         /* 56 -   63 */
+        124, 193, 194, 195, 196, 197, 198, 199,         /* 64 -   71 */
+        200, 201, 209, 210, 211, 212, 213, 214,         /* 72 -   79 */
+        215, 216, 217, 226, 227, 228, 229, 230,         /* 80 -   87 */
+        231, 232, 233,  74, 224,   0,  95, 109,         /* 88 -   95 */
+        125, 129, 130, 131, 132, 133, 134, 135,         /* 96 -  103 */
+        136, 137, 145, 146, 147, 148, 149, 150,         /* 104 - 111 */
+        151, 152, 153, 162, 163, 164, 165, 166,         /* 112 - 119 */
+        167, 168, 169, 192, 106, 208, 161,   7,         /* 120 - 127 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 128 - 135 */
+          0,   0,   0,   0,   0,   0,   0,   0,		/* 136 - 143 */
+          0,   0,   0,   0,   0,   0,   0		/* 144 - 150 */
+};
+
+/* FM.
+ */
+
+/* FMH type indicators */
+#define FMH_1                   0x01            /* FMH-1 */
+#define FMH_2                   0x02            /* FMH-2 */
+#define FMH_3			0x03
+#define FMH_4                   0x04            /* FMH-4 */
+#define FMH_5                   0x05            /* FMH-5 */
+#define FMH_6                   0x06            /* FMH-6 */
+#define FMH_7                   0x07            /* FMH-7 */
+#define FMH_10                  0x0A       	/* FMH-10 */
+#define FMH_12                  0x0C            /* FMH-12 */
+#define FMH_18			0x12
+#define FMH_19			0x13
+
+/* FMH header descriptions. */
+#define SNA_FMH_HDR_ERROR       FMH_1
+#define SNA_FMH_HDR_ATTACH      FMH_1
+#define SNA_FMH_HDR_SECURITY    FMH_1
+
+/* FMH concatenation indicators */
+#define FMH_CONCAT_TRUE         1
+#define FMH_CONCAT_FALSE        0
+
+/* FMH media indicators */
+#define FMH_CONSOLE             0000    /* Console */
+#define FMH_XCHANGE             0001    /* Exchange */
+#define FMH_CARD                0010    /* Card */
+#define FMH_DOCUMENT            0011    /* Document */
+#define FMH_NXCHANGE_DISK       0100    /* Non-exchange disk */
+#define FMH_XDOCUMENT           0101    /* Extended document */
+#define FMH_XCARD               0110    /* Extended card */
+#define FMH_DATA_SELECT         0111    /* Data set name select destination */
+#define FMH_WP_1                1000    /* Word processing media 1 */
+#define FMH_WP_2                1001    /* Word processing media 2 */
+#define FMH_WP_3                1010    /* Word processing media 3 */
+#define FMH_RESRV_1             1011    /* Reserved */
+#define FMH_WP_4                1100    /* Word processing media 4 */
+#define FMH_RESRV_2             1101    /* Reserved */
+#define FMH_RESRV_3             1110    /* Reserved */
+#define FMH_RESRV_4             1111    /* Reserved */
+
+/* FMH data stream profile indicators */
+#define DSP_DEFAULT             0000    /* Default */
+#define DSP_BASE                0001    /* Base */
+#define DSP_GENERAL             0010    /* General */
+#define DSP_JOB                 0011    /* Job */
+#define DSP_WP_RAW              0100    /* WP raw-form text */
+#define DSP_WP_XCHANGE_DISK     0101    /* WP exchange diskette */
+#define DSP_RESRV_1             0110    /* Reserved */
+#define DSP_OII_2               0111    /* Office Info. Interchange level 2 */
+#define DSP_RESRV_2             1000    /* Reserved */
+#define DSP_RESRV_3             1001    /* Reserved */
+#define DSP_DOC_INTERCHANGE     1010    /* Document interchange */
+#define DSP_STRUCT              1011    /* Structured field */
+#define DSP_RESRV_4             1100    /* Reserved */
+#define DSP_RESRV_5             1101    /* Reserved */
+#define DSP_RESRV_6             1110    /* Reserved */
+#define DSP_RESRV_7             1111    /* Reserved */
+
+/* FMH destination selection indicators */
+#define DSSEL_RESUME            000     /* Resume */
+#define DSSEL_END               001     /* End */
+#define DSSEL_BEGIN             010     /* Begin */
+#define DSSEL_BEGIN_END         011     /* Begin/end */
+#define DSSEL_SUSPEND           100     /* Suspend */
+#define DSSEL_END_ABORT         101     /* End-abort */
+#define DSSEL_CONTINUE          110     /* Continue */
+#define DSSEL_RESRV_1           111     /* Reserved */
+
+/* FMH compaction indicators */
+#define FMH_COMPACT_TRUE        1       /* Compaction */
+#define FMH_COMPACT_FLASE       0       /* No compaction */
+
+/* SNA Function Managment 1 header */
+struct sna_fmh1
+{
+        __u8    medium:4,       /* Desired medium for data */
+                lsubaddr:4;     /* Logical subaddress */
+        __u8    sri:1,          /* Stack Reference indicator */
+                dmsel:1,        /* Demand select */
+                rsv_1:2,        /* Reserved */
+                dsp:4;          /* Data stream profiles */
+        __u8    dssel:3,        /* Destination selection */
+                dst:1,          /* Data set transmission */
+                rsv_2:1,        /* Reserved */
+                cmi:1,          /* FMH-1 SCB compression indicator */
+                cpi:1,          /* Compaction indicator */
+                rsv_3:1;        /* Reserved */
+        __u8    ecrl;           /* Exchange record length */
+        __u16   rsv_4;          /* Reserved */
+        __u8    dslen;          /* Length of destination name */
+
+        unsigned char *dsname;  /* Destination name, unlimited length */
+};
+
+/* FMH-2 function indicators */
+#define FMH2_PDIR               0x01    /* Peripheral data information record */#define FMH2_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH2_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH2_XCUTE_PG_OFFLN     0x07    /* Execute program offline */
+#define FMH2_CREATE_DATA_SET    0x20    /* Create data set */
+#define FMH2_SCRATCH_DATA_SET   0x21    /* Scratch data set */
+#define FMH2_ERASE_DATA_SET     0x22    /* Erase data set */
+#define FMH2_PASSWORD           0x23    /* Password */
+#define FMH2_ADD                0x24    /* Add */
+#define FMH2_REPLACE            0x25    /* Replace */
+#define FMH2_ADD_REPLICATE      0x26    /* Add replicate */
+#define FMH2_REPLACE_REPLIACTE  0x27    /* Replace replicate */
+#define FMH2_QUERY_DATA_SET     0x28    /* Query for data set */
+#define FMH2_NOTE               0x29    /* Note */
+#define FMH2_REC_ID             0x2B    /* Record ID */
+#define FMH2_ERASE_REC          0x2C    /* Erase record */
+#define FMH2_SCRATCH_ALL_SETS   0x2D    /* Scratch all data sets */
+#define FMH2_VOL_ID             0x2E    /* Volume ID */
+#define FMH2_NOTE_REPLY         0xAA    /* Note reply */
+
+/* FMH-3 function indicators */
+#define FMH3_COMPACT_TABLE      0x02    /* Compaction table */
+#define FMH3_QUERY_COMPACT_TBLE 0x03    /* Query for compaction table */
+#define FMH3_SCB_COMP_CHAR      0x04    /* Prime SCB compression character */
+#define FMH3_STATUS             0x05    /* Status */
+#define FMH3_SERIES_ID          0x06    /* Series ID */
+
+/* SNA Function Managment 2 and 3 header */
+struct sna_fmh2
+{
+        __u8    sri:1,          /* Stack reference indicator */
+                fmh2cmd:7;      /* FMH-2 function to be performed */
+
+        unsigned char *fmh2opt; /* Parameter fields, unlimited length */
+};
+
+/* FMH-4 block transmission type indicators */
+#define FMH4_INHERIT            0x00    /* Inherit code */
+/* FMH4 0x01 - 0x3F */                  /* Reserved */
+#define FMH4_FFR_FNI            0x40    /* FFR-FNI record */
+#define FMH4_FFR_FS             0x41    /* FFR-FS record */
+#define FMH4_FFR_FS2            0x42    /* FFR-FS2 record */
+/* FMH4 0x43 - 0x4F */                  /* Reserved */
+/* FMH4 0x50 - 0xFF */                  /* Reserved */
+
+/* FMH-4 command indicators */
+#define FMH4_CRT_NU_BLK         0x00    /* CRT-NU-BLK */
+#define FMH4_CRT_SU_BLK         0x02    /* CRT-SU-BLK */
+#define FMH4_CRT_SN_BLK         0x03    /* CRT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_CONT_NU_BLK        0x10    /* CONT-NU-BLK */
+#define FMH4_CONT_SU_BLK        0x12    /* CONT-SU-BLK */
+#define FMH4_CONT_SN_BLK        0x13    /* CONT-SN-BLK */
+#define FMH4_DEL_SN_BLK         0x23    /* DEL-SN-BLK */
+#define FMH4_UPD_SU_BLK         0x32    /* UPD-SU-BLK */
+#define FMH4_UPD_SN_BLK         0x33    /* UPD-SN-BLK */
+#define FMH4_RPL_SU_BLK         0x42    /* RPL-SU-BLK */
+#define FMH4_RPL_SN_BLK         0x43    /* RPL-SN-BLK */
+
+/* SNA Function Managment 4 header */
+struct sna_fmh4
+{
+        __u8    fmh4fxct;       /* Length of fixed length parameters */
+        __u8    fmh4tt1;        /* Block transmission type */
+        __u8    fm4htt2;        /* Block transmission type qualifier */
+        __u8    fmh4cmd;        /* Command */
+        __u8    rsv1:2,         /* Reserved */
+                f4rdescr:2,     /* Record descriptor flag */
+                rsv2:2,         /* Reserved */
+                fmh4bdtf:1,     /* Block data transform flag */
+                fmh4rdtf:1;     /* Reserved */
+        __u8    fmh4lbn;        /* Length of FMH4BN */
+
+        __u8    *fmh4bn;        /* Name of block */
+
+        __u8    fmh4lbdt;       /* Length of FMH4BDT */
+
+        unsigned char fmh4bdt;  /* Block data transform */
+
+        __u8    fmh4lvid;       /* Length of FMH4VID */
+
+        unsigned char fmh4vid;  /* Version identifier */
+};
+
+struct fmh5_sec_access
+{
+        __u8    length;         /* Length */
+        __u8    type;           /* Subfield type */
+        unsigned char data;     /* Security data about receiver */
+};
+
+/* PIP header */
+struct piph
+{
+        __u16   length;
+        __u16   gds;            /* GDS indicator */
+
+        /* PIP sub-fields of structure piph, unlimited length */
+        unsigned char sub_pip;
+};
+
+/* SNA Function Managment 5 header (LU 6.2) */
+struct sna_fmh5
+{
+        __u16   cmd     __attribute__ ((packed));               /* Command code
+*/
+        __u8    vid:1,          /* Already-verified indicator */
+                pvid:2,         /* Persistent-verification indicator */
+                spwdi:1,        /* Substituted password indicator */
+                pipi:1,         /* Program init parameter (PIP) presence */
+                xaid:1,         /* Extended authentication indicator */
+                rsv1:2;         /* Reserved */
+        __u8    fxct    __attribute__ ((packed));               /* Fixed length
+parameters */
+
+        __u8    resrc_type      __attribute__ ((packed));
+        __u8    rsv2    __attribute__ ((packed));
+        __u8    sync_level:2,
+                rsv3:6;
+        /* The options start here */
+        __u8    raw;
+};
+
+#ifdef NOT_LU62
+
+/* SNA Function Managment 5 header (Not LU 6.2) */
+struct sna_fmh5
+{
+        __u8    length;         /* Length of FMH-5 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000101 */
+        __u8    fmh5cmd;        /* Command code */
+        __u8    fmh5mod;        /* Modifier */
+        __u8    fmh5fxct;       /* Fixed length parameters */
+        __u8    attdsp;
+        __u8    attdba;
+
+        unsigned char *names;   /* Resource names, unlimited length */
+};
+
+#endif  /* CONFIG_SNA_LU62 */
+
+/* SNA Function Managment 6 header */
+struct sna_fmh6
+{
+        __u8    length;         /* Length of FMH-6 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0000110 */
+        __u8    fmh6cmd;        /* Command code */
+        __u8    fmh6lnsz:1,     /* Length of parameter length fields */
+                rsv1:7;         /* Reserved */
+
+        /* Many variable lenth params */
+};
+
+/* SNA Function Managment 7 header (LU 6.2) */
+struct sna_fmh7
+{
+        __u8    length;         /* Length of FMH-7 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0000111 */
+        __u32   erpsense;       /* Sense Data */
+        __u8    erplog:1,       /* Error log variable presence */
+                rsv2:7;         /* Reserved */
+};
+
+/* SNA Function Managment 8 header (LU 6.1) */
+struct sna_fmh8
+{
+        __u8    *raw;
+};
+
+/* SNA Function Managment 10 header */
+struct sna_fmh10
+{
+        __u8    length;         /* Length of FMH-10 + Length byte */
+        __u8    frag:1,         /* FMH concatenation */
+                type:7;         /* FMH type - 0001010 */
+        __u16   spccmd;         /* Sync point command */
+        __u16   spcmod;         /* Sync point modifier */
+};
+
+/* SNA Function Managment 12 header (LU 6.2) */
+struct sna_fmh12
+{
+        __u8    length;         /* Length of FMH-12 + Length byte */
+        __u8    rsv1:1,         /* Reserved */
+                type:7;         /* FMH type - 0001100 */
+
+        unsigned char fmh12mac[7];      /* DES Message Authentication Code */
+};
+
+struct fmhdr {
+        __u8    len     __attribute__ ((packed));
+	__u8	type	__attribute__ ((packed));
+/*
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    type:7  __attribute__ ((packed));
+*/
+
+        union {
+                struct sna_fmh1         f1      __attribute__ ((packed));
+                struct sna_fmh2         f2      __attribute__ ((packed));
+                struct sna_fmh4         f4      __attribute__ ((packed));
+                struct sna_fmh5         f5      __attribute__ ((packed));
+                struct sna_fmh6         f6      __attribute__ ((packed));
+                struct sna_fmh7         f7      __attribute__ ((packed));
+                struct sna_fmh8         f8      __attribute__ ((packed));
+                struct sna_fmh10        f10     __attribute__ ((packed));
+                struct sna_fmh12        f12     __attribute__ ((packed));
+        } fm;
+};
+
+/* GDS.
+ */
+
+/*
+ * SNA GDS (Global Data Stream) definitions
+ *
+ * Identifer registery
+ * 0000 - 01FF          3270
+ * 03xx                 3270
+ * 06xx                 3270
+ * 09xx                 3270
+ * 0B00 - 0EFF          3270
+ * 0Fxx                 3270
+ * 101x                 3270
+ * 1030 - 1034          Print Job Restart
+ * 1058 - 105B          Workstation Platform/2
+ * 1100 - 1104          SNA Character String
+ * 12xx                 LU 6.2 and APPN
+ * 13xx                 SNA/Management Services
+ * 140x                 3820 Page Priner
+ * 1500                 Dependent LU Requester/Server
+ * 1501                 Subarea Routing Services
+ * 1520                 DLSw Capabilities eXchange
+ * 1521                 DLSw Capabilities eXchange Positive Response
+ * 1522                 DLSw Capabilities eXchange Negative Response
+ * 1530 - 1531          SNA File Services
+ * 1532                 SNA Condition Report
+ * 1533 - 154F          SNA File Services
+ * 1550 - 155F          SNA File Services
+ * 1570 - 158F          SNA/Distribution Services
+ * 4000 - 41FF          3270
+ * 4A00 - 4CFF          3270
+ * 71xx                 3250
+ * 8000 - 81FF          3270
+ * C00x                 Document Interchange Architecture
+ * C100 - C104          Document Interchange Architecture
+ * C105                 SNA/Distribution Services
+ * C10A - C122          Document Interchange Architecture
+ * C123 - C124          SNA/Distribution Services
+ * C219                 Document Interchange Architecture
+ * C300 - C345          Document Interchange Architecture
+ * C350 - C361          SNA/Distribution Services
+ * C366 - C46F          Document Interchange Architecture
+ * C500 - C56F          Document Interchange Architecture
+ * C600 - C66F          Document Interchange Architecture
+ * C7xx                 Graphical Display Data Manager
+ * C800 - C87F          Document Interchange Architecture
+ * C900 - CB0F          Document Interchange Architecture
+ * CC00 - CC3F          Document Interchange Architecture
+ * CF0x                 Document Interchange Architecture
+ * D0xx                 Distributed Data Management
+ * D3xx                 Document Content Architecture
+ * D6xx                 Intelligent Printer Data Stream
+ * D780 - D7BF          Facsimile Architecture
+ * D820 - D821          AS/400 (5250)
+ * D822 - D826          AS/400 (5394)
+ * D930 - D95F          AS/400 (5250)
+ * E10x                 Level-3 Document Content Architecture
+ * E20x                 Level-3 Document Content Architecture
+ * E30x                 Level-3 Document Content Architecture
+ * E40x                 Level-3 Document Content Architecture
+ * E50x                 Level-3 Document Content Architecture
+ * E60x                 Level-3 Document Content Architecture
+ * E70x                 Level-3 Document Content Architecture
+ * E80x                 Level-3 Document Content Architecture
+ * E90x                 Level-3 Document Content Architecture
+ * EA0x                 Level-3 Document Content Architecture
+ * EFFF                 IBM TokenRing Network PC Adapter
+ * F000 - FEFF          Non-IBM Reserve Block
+ * FFxx                 Context-Dependent Block
+ */
+
+/*
+ * SNA Service Transaction Programs (STPs)
+ */
+#define SNA_GDS_CHG_NUM_SESS            0x1210
+typedef struct {
+        __u8    rsv1:4,
+                service_flag:4;
+        __u8    reply_mod;
+        __u8    action;
+        __u8    rsv2:3,
+                src_lu_drain:1,
+                rsv3:3,
+                dst_lu_drain:1;
+        __u8    rsv4:7,
+                sess_deact_resp:1;
+        __u16   rsv5:1,
+                max_sess_cnt:15;
+        __u16   rsv6:1,
+                src_g_min_cont_win:15;
+        __u16   rsv7:1,
+                dst_g_min_cont_win:15;
+        __u8    rsv8:7,
+                affect_mode_names:1;
+        __u8    mode_name_len;
+        __u8    mode_name;                      /* Start of Mode Name */
+} gds_chg_num_sess;
+
+struct sna_gds {
+        __u16   cvlen:16;
+        __u16   cvid:16;
+
+        union {
+
+        } cv;
+};
+
+/* HPR.
+ */
+
+/* Switching mode defines */
+#define HPR_FUNCT_RT    101
+#define HPR_ANR         110
+
+/* NLP Time-Sensitivity */
+#define NLP_NOT_TIME_SENSE      0
+#define NLP_TIME_SENSE          1
+
+/* Congestion defines */
+#define NLP_SLOW1_TRUE          1
+#define NLP_SLOW1_FLASE         0
+#define NLP_SLOW2_TRUE          1
+#define NLP_SLOW2_FLASE         0
+
+/* HPR Network Layer Header (NHDR) */
+struct sna_nhdr
+{
+        __u8    sm:3,           /* Switching mode */
+                __pad1:2,
+                tpf:2,          /* Transmission priority field */
+                __pad2:1;
+        __u8    ftype:4,        /* Function type */
+                tsdata:1,       /* Time-sensitive packet indicator */
+                slow1:1,        /* Slowdown (minor) indicator */
+                slow2:1,        /* Slowdown (significant) indicator */
+                __pad3:1;
+
+        /* Variable length data fields */
+};
+
+/* PS.
+ */
+
+/* Flag structures for PS10 header */
+struct psh10_prepare
+{
+        __u8    luname:1,       /* LU names indicator */
+                wait:1,         /* Wait for outcome indicator */
+                __pad1:3,
+                locks:1,        /* LOCKS parameter indicator */
+                __pad2:2;
+};
+
+struct psh10_rqcommit
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                wait:1,         /* Wait for outcome indicator */
+                reliable:1,     /* Resource reliability indicator */
+                sprq:1,         /* OK to leave out sync-point request */
+                rreport:1,      /* Initiator read-only reporting */
+                locks:1,        /* LOCKS parameter indicator */
+                __pad1:2;
+};
+
+struct psh10_committed
+{
+        __u8    __pad1:1,
+                resync:1,       /* Resync processing status */
+                sluwid:1,       /* Source of next LUWID */
+                sprq:1,         /* OK to leave out sync-point request */
+                ifexcpt:1,      /* Implied Forget expectation indicator */
+                __pad2:3;
+};
+
+struct psh10_forget
+{
+        __u8    luwid:1,        /* Support of the New LUWID PS header */
+                resync:1,       /* Resync processing status */
+                __pad1:6;
+};
+
+struct psh10_hm
+{
+        __u8    __pad1:2,
+                sluwid:1,       /* Source of next LUWID */
+                __pad2:5;
+};
+
+struct psh10_nluwid
+{
+        __u8    __pad1;
+};
+
+/* PS10 header */
+struct sna_psh10
+{
+        __u8    length;         /* Length */
+
+        __u8    rsv:1,
+                type:7;
+
+        union {
+                struct psh10_prepare    prepare;
+                struct psh10_rqcommit   rqcommit;
+                struct psh10_committed  committed;
+                struct psh10_forget     forget;
+                struct psh10_hm         hm;
+                struct psh10_nluwid     nluwid;
+        } flags;
+
+        __u8    spptype;        /* Sync-point command type */
+
+        /* Command specific data here */
+
+        __u16   flowmod;        /* Modifier specifying next flow */
+
+        unsigned char sndlen[7];        /* Number of bytes sent */
+
+        /* All kinds of variable length structures */
+};
+
+/* TH.
+ */
+
+#define SNA_TH_FID0     0x0
+#define SNA_TH_FID1     0x1
+#define SNA_TH_FID2     0x2
+#define SNA_TH_FID3     0x3
+#define SNA_TH_FID4     0x4
+#define SNA_TH_FID5     0x5
+#define SNA_TH_FIDF     0xF
+
+#define SNA_TH_MPF_BBIU         0x2     /* 10 */
+#define SNA_TH_MPF_EBIU         0x1     /* 01 */
+#define SNA_TH_MPF_WHOLE_BIU    0x3     /* 11 */
+#define SNA_TH_MPF_NO_BIU       0x0     /* 00 */
+#define SNA_TH_MPF_MID_MIU      SNA_TH_MPF_NO_BIU
+
+#define SNA_TH_EFI_NORM         0x0
+#define SNA_TH_EFI_EXP          0x1
+
+typedef struct {
+        __u16   biui:1,
+                sqn:15;
+} sna_snf;
+
+/* FID0 and FID1 formats are used between adjacent subarea nodes when
+ * either or both nodes do not support ER and VR protocols.
+ */
+struct sna_fid0 {
+	__u8	ft:4;
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                 efi:1;         /* Expedited Flow Indicator. */
+        __u8    rsv2;
+        __u16   daf;            /* Destination Address Field. */
+        __u16   oaf;            /* Origin Address Field. */
+        sna_snf snf;            /* Sequence Number Field. */
+        __u16   dcf;            /* Data Count Field. */
+};
+
+struct sna_fid2_cheat {
+	__u8	bits[6];
+};
+
+struct sna_fid2 {
+	__u8    ft:4    __attribute__ ((packed));
+        __u8    mpf:2   __attribute__ ((packed));
+        __u8    odai:1  __attribute__ ((packed));
+        __u8    efi:1   __attribute__ ((packed));
+        __u8    rsv1    __attribute__ ((packed));
+        __u8    daf     __attribute__ ((packed));
+        __u8    oaf     __attribute__ ((packed));
+        sna_snf snf     __attribute__ ((packed));
+};
+
+struct sna_fid3 {
+        __u8    mpf:2,          /* Mapping Field. */
+                rsv1:1,
+                efi:1;          /* Expedited Flow indicator. */
+        __u8    lsid;           /* Local session identification. */
+};
+
+struct sna_fid4 {
+        __u8    tg_sweep:1,
+                er_vr_supp_ind:1,
+                vr_pac_cnt_ind:1,
+                ntwk_prty:1;
+
+        __u8    tgsf:2,
+                rsv1:2,
+                chk:1,
+                hft:1,
+                piubf:2;
+
+        __u8    nlpoi:1,
+                nlp_cnt:3,
+                ern:4;
+
+        __u8    vrn:4,
+                rsv2:2,
+                tpf:2;
+
+        __u16   vr_cwi:1,
+                tg_nonfifo_ind:1,
+                vr_sqti:2,
+                tg_snf:12;
+
+        __u16   vrprq:1,
+                vrprs:1,
+                vr_cwri:1,
+                vr_rwi:1,
+                vr_snf_send:12;
+
+        __u8    dsaf[4];
+        __u8    osaf[4];
+
+        __u8    rsv3:3,
+                snai:1,
+                mpf:2,
+                rsv4:1,
+                efi:1;
+
+        __u8    rsv5;
+
+        __u16   def;
+        __u16   oef;
+        sna_snf snf;
+        __u16   dcf;
+};
+
+struct sna_fid5 {
+        __u8    mpf:2,
+                rsv1:1,
+                efi:1;
+
+        __u8    rsv2;
+
+        sna_snf snf;
+
+        __u8    sa[8];
+};
+
+struct sna_fidf {
+        __u8    rsv1:4;
+        __u8    rsv2;
+        __u8    cmd_fmt;        /* 0x01. */
+        __u8    cmd_type;       /* 0x01. */
+        __u16   cmd_snf;
+        __u8    rsv3[18];
+        __u16   dcf;
+};
+
+struct snathdr {
+        union {
+                struct sna_fid0 f0      __attribute__ ((packed));
+                struct sna_fid2 f2      __attribute__ ((packed));
+                struct sna_fid3 f3      __attribute__ ((packed));
+                struct sna_fid4 f4      __attribute__ ((packed));
+                struct sna_fid5 f5      __attribute__ ((packed));
+                struct sna_fidf ff      __attribute__ ((packed));
+        } fid;
+};
+
+/* RH.
+ */
+
+#define SNA_RH_RRI_REQ          0x0
+#define SNA_RH_RRI_RSP          0x1
+
+#define SNA_RH_RU_FMD           0x0     /* 00 */
+#define SNA_RH_RU_NC            0x1     /* 01 */
+#define SNA_RH_RU_DFC           0x2     /* 10 */
+#define SNA_RH_RU_SC            0x3     /* 11 */
+
+#define SNA_RH_FI_NO_FMH        0x0
+#define SNA_RH_FI_FMH           0x1
+
+#define SNA_RH_SDI_NO_SD        0x0
+#define SNA_RH_SDI_SD           0x1
+
+#define SNA_RH_BCI_NO_BC        0x0
+#define SNA_RH_BCI_BC           0x1
+
+#define SNA_RH_ECI_NO_EC        0x0
+#define SNA_RH_ECI_EC           0x1
+
+#define SNA_RH_DR1I_NO_DR1      0x0
+#define SNA_RH_DR1I_DR1         0x1
+
+#define SNA_RH_LLCI_NO_LLC      0x0
+#define SNA_RH_LLCI_LLC         0x1
+
+#define SNA_RH_DR2I_NO_DR2      0x0
+#define SNA_RH_DR2I_DR2         0x1
+
+#define SNA_RH_RTI_POS          0x0
+#define SNA_RH_RTI_NEG          0x1
+
+#define SNA_RH_RLWI_NO_RLW      0x0
+#define SNA_RH_RLWI_RLW         0x1
+
+#define SNA_RH_QRI_NO_QR        0x0
+#define SNA_RH_QRI_QR           0x1
+
+#define SNA_RH_PI_NO_PAC        0x0
+#define SNA_RH_PI_PAC           0x1
+
+#define SNA_RH_BBI_NO_BB        0x0
+#define SNA_RH_BBI_BB           0x1
+
+#define SNA_RH_EBI_NO_EB        0x0
+#define SNA_RH_EBI_EB           0x1
+
+#define SNA_RH_CDI_NO_CD        0x0
+#define SNA_RH_CDI_CD           0x1
+
+#define SNA_RH_CSI_CODE0        0x0
+#define SNA_RH_CSI_CODE1        0x1
+
+#define SNA_RH_EDI_NO_ED        0x0
+#define SNA_RH_EDI_ED           0x1
+
+#define SNA_RH_PDI_NO_PD        0x0
+#define SNA_RH_PDI_PD           0x1
+
+#define SNA_RH_CEBI_NO_CEB      0x0
+#define SNA_RH_CEBI_CEB         0x1
+
+struct snarhdr {
+        /* 1st byte */
+        __u8    rri:1   __attribute__ ((packed));
+        __u8    ru:2    __attribute__ ((packed));
+        __u8    rsv1:1  __attribute__ ((packed));
+        __u8    fi:1    __attribute__ ((packed));
+        __u8    sdi:1   __attribute__ ((packed));
+        __u8    bci:1   __attribute__ ((packed));
+        __u8    eci:1   __attribute__ ((packed));
+
+        /* 2nd byte */
+        __u8    dr1i:1  __attribute__ ((packed));
+        __u8    llci:1  __attribute__ ((packed));
+        __u8    dr2i:1  __attribute__ ((packed));
+        __u8    rti:1   __attribute__ ((packed));
+        __u8    rsv2:1  __attribute__ ((packed));
+        __u8    rlwi:1  __attribute__ ((packed));
+        __u8    qri:1   __attribute__ ((packed));
+        __u8    pi:1    __attribute__ ((packed));
+
+        /* 3rd byte */
+        __u8    bbi:1   __attribute__ ((packed));
+        __u8    ebi:1   __attribute__ ((packed));
+        __u8    cdi:1   __attribute__ ((packed));
+        __u8    rsv3:1  __attribute__ ((packed));
+        __u8    csi:1   __attribute__ ((packed));
+        __u8    edi:1   __attribute__ ((packed));
+        __u8    pdi:1   __attribute__ ((packed));
+        __u8    cebi:1  __attribute__ ((packed));
+};
+
+/* RU.
+ */
+
+/* ABCONN (Abandon Connection) */
+struct sna_abconn {
+        __u16 ena;
+};
+
+/* ABCONNOUT (Abandon Connect Out) */
+struct sna_abconnout {
+        __u16 ena;
+};
+
+/* Type of activation indicators */
+#define COLD    0x1
+#define ERP     0x2
+
+struct sna_sscp_id {
+        __u8    format:4,
+                pu_type:4;
+        char    id[4];
+};
+
+/* ACTDRM (Activate Cross-Domain Resource Manager) */
+struct sna_actcdrm {
+        __u8    request;        /* 0x14 */
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile;
+        __u8    ts_profile;
+        char    contents_id[7];
+        struct  sna_sscp_id *sscp_id;
+        __u8    __pad1:2,
+                primary_hs_rcv_win_size:6;
+};
+
+/* ACTCONNIN (Activate Conect In) */
+struct sna_actconnin {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    incoming_call:1,
+                info_rq:1,
+                __pad1:6;
+};
+
+/* ACTLINK (Activate Link) */
+struct sna_actlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    switched_subarea:1,
+                sub_llink:1,
+                __pad1:6;
+};
+
+/* ACTLU (Activate Logical Unit) */
+struct sna_actlu {
+        __u8    request_code;
+        __u8    eami:1,         /* Enhanced Addr. Management Indicator */
+                sdai:1,         /* Static/dynamic addr. indicator */
+                __pad1:4,
+                type_activation:2;
+        __u8    fm_profile:4,
+                ts_profile:4;
+};
+
+/* ACTPU (Activate Physical Unit) */
+struct sna_actpu {
+        __u8    request_code;
+        __u8    format:4,
+                type_activation:4;
+        __u8    fm_profile:4,
+                ts_profile:4;
+        struct sna_sscp_id *sscp_id;
+};
+
+/* ACTTRACE (Activate Trace) */
+struct sna_trace_bit {
+        __u8    tx_group:1,
+                piu:1,
+                __pad1:2,
+                scanner_internal:1,
+                __pad2:1,
+                all_frames:1,
+                link:1;
+};
+
+struct sna_acttrace {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct sna_trace_bit *trace;
+
+        /* Some trace specific trailers */
+};
+
+/* ADDLINK (Add Link) */
+struct sna_addlink {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u16   __pad1;
+        __u8    size_llink_id;
+        /* 8-n llink ID */
+};
+
+/* ADDLINKSTA (Add Link Station) */
+struct sna_fid_bit {
+        __u8    fid0:1,
+                fid1:1,
+                fid2:1,
+                fid3:1,
+                fid4:1,
+                __pad1:3;
+};
+
+struct sna_addlinksta {
+        /* 0-2 NS header */
+        __u16   ena;
+        struct  sna_fid_bit *fid;
+        __u8    __pad1;
+        __u8    size_linksta_id;
+        /* 8-n Link station ID */
+};
+
+/* ANA (Assign Network Addresses) */
+struct sna_ana {
+        /* Retired */
+};
+
+/* BFCINIT (BF Control Initiate) */
+struct sna_bfcinit {
+        /* 0-2 NS header */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:1,
+                sub_source:1,
+                save_rscv:1,
+                copy_rscv:1,
+                sub_names:2,
+                ext_bind:1,
+                __pad3:1;
+        char    __pad4[4];
+        __u16   size_bind_image;
+        /* Bind Image */
+        /* Other variable length goodies */
+};
+
+/* BFCLEANUP (BF Cleanup) */
+struct sna_bfcleanup {
+        /* 0-2 NS header, 0x812629 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   __pad2;
+
+        /* Session keys */
+        /* Control Vectors */
+};
+
+/* BFINIT (BF Initiate) */
+struct sna_bfinit {
+        /* 0-2 NS header, 0x812681 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u16   size_bind_image;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSEND (BF Session Ended) */
+struct sna_bfsessend {
+        /* 0-2 NS header, 0x812688 */
+        __u16   ena;
+        __u8    format:4,
+                lu_role:1,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFSESSINFO (BF Session Information) */
+struct sna_bfsessinfo {
+        /* 0-2 NS header, 0x81268C */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    als_takeover:1,
+                lu_takeover:1,
+                auth_lu:1,
+                sdai:1,
+                static_lu_addr_status:1,
+                __pad2:3;
+        __u16   __pad3;
+        __u8    size_lu_name;
+
+        /* Network Qualified LU name */
+        /* Control Vectors */
+};
+
+/* BFSESSST (BF Session Started) */
+struct sna_bfsessst {
+        /* 0-2 NS header, 0x812686 */
+        __u16   ena;
+        __u8    format:4,
+                __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BFTERM (BF Terminate) */
+struct sna_bfterm {
+        /* 0-2 NS header, 0x812683 */
+        __u16   ena;
+        __u8    format:4,
+                __pad1:4;
+        __u8    cause;
+        __u8    __pad2;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BID (BID) Not for LU6.2 */
+struct sna_nonlu62_bid {
+        __u8    request_code;
+};
+
+/* BIND (BIND Session) */
+#define BIND_RQ			0x31
+
+#define BIND_FORMAT_NEG		0x00
+#define BIND_FORMAT_NONNEG	0x01
+
+#define TSH_2			0x02
+#define TSH_3			0x03
+#define TSH_4			0x04
+#define TSH_7			0x07
+
+#define CV_COS_TPF		0x2C
+#define CV_FQ_PCID		0x60
+#define CV_ROUTE_SEL		0x2B
+#define CV_TG_DESC		0x46
+#define CV_TG_ID		0x80
+
+#pragma pack(1)
+struct sna_bind {
+/* 0 */ __u8    request_code		__attribute__ ((packed));
+/* 1 */ __u8    format:4,
+                type:4			__attribute__ ((packed));
+/* 2 */ __u8    fm_profile		__attribute__ ((packed));
+/* 3 */ __u8    ts_profile		__attribute__ ((packed));
+/* 4 */ __u8	pri_flags		__attribute__ ((packed));
+/* 5 */ __u8 	sec_flags		__attribute__ ((packed));
+/* 6 */ __u8	cm1_flags		__attribute__ ((packed));
+/* 7 */	__u8	cm2_flags		__attribute__ ((packed));
+
+/* TS Usage */
+/* 8 */ __u8    sec_tx_win_size		__attribute__ ((packed));
+/* 9 */ __u8    sec_rx_win_size		__attribute__ ((packed));
+/*10 */ __u8    shs_max_ru_size		__attribute__ ((packed));
+/*11 */ __u8    phs_max_ru_size		__attribute__ ((packed));
+/*12 */ __u8    pri_tx_win_size		__attribute__ ((packed));
+/*13 */ __u8    pri_rx_win_size		__attribute__ ((packed));
+
+/* PS profile */
+/*14 */ __u8    lu_type			__attribute__ ((packed));
+
+/* PS usage */
+/*15 */ __u8    lu6_level		__attribute__ ((packed));
+/*16 */ __u8    __pad5[7]		__attribute__ ((packed));
+/*23 */ __u8    ps1_flags		__attribute__ ((packed));
+/*24 */ __u8    ps2_flags		__attribute__ ((packed));
+
+/* User data and control vectors */
+	__u8	raw;
+};
+#pragma pack()
+
+typedef struct {
+        __u8    chain_sel:1,
+                request_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                __pad1:1,
+                scbi:1,
+                send_end_bracket:1;
+} sna_fm_usage_bit;
+
+struct sna_reason_bit {
+        __u8    plu:1,
+                bind:1,
+                setup_rej_plu:1,
+                setup_rej_slu:1,
+                __pad1:4;
+};
+
+/* BINDF (Bind Failure) */
+struct sna_bindf {
+        /* 0-2 NS header, 0x810685 */
+        char    sense_data[3];
+        struct  sna_reason_bit *reason;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* BIS (Bracket Initiation Stopped) */
+struct sna_bis {
+        __u8    request_code;
+};
+
+/* CANCEL (Cancel) */
+struct sna_cancel {
+        __u8    request_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate) */
+struct sna_cdcinit {
+        /* 0-2 NS header, 0x81864B */
+        __u8    format:4,
+                __pad1:4;
+        __u8    __pad2:7,
+                xrf_bind:1;
+        char    pcid[7];
+
+        /* Session pair identifiers */
+};
+
+/* CDINIT (Cross-Domain Initiate) */
+struct sna_cdinit {
+        /* 0-2 NS header, 0x818641 */
+        __u8    format:4,
+                __pad1:4;
+
+        /* A mess of stuff after here */
+};
+
+/* CDSESSEND (Cross-Domain Session Ended) */
+struct sna_cdsessend {
+        /* 0-2 NS header, 0x818648 */
+        char    pcid[7];
+        __u8    format:4,
+                __pad1:4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSSF (Cross-Domain Session Setup Failure) */
+struct sna_cdsesssf {
+        /* Retired */
+};
+
+/* CDSESSST (Cross-Domain Session Started) */
+struct sna_cdsessst {
+        /* 0-2 NS header, 0x818646 */
+        char    pcid[7];
+        __u8    __pad1;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CDSESSTF (Cross-Domain Session Takedown Failure) */
+struct sna_cdsesstf {
+        /* Retired */
+};
+
+struct sna_cdtaked {
+        /* 0-2 NS header, 0x818649 */
+        char    pcid[7];
+        __u8    type:2,
+                takedown:2,
+                sscp_sscp_term:1,
+                __pad1:3;
+        struct  sna_reason_bit *reason;
+};
+
+/* CDTAKEDC (Cross-Domain Takedown Complete) */
+struct sna_cdtakedc {
+        /* 0-2 NS header, 0x81864A */
+        char    pcid[7];
+        __u8    type;
+        __u8    status;
+};
+
+/* CDTERM (Cross-Domain Terminate) */
+struct sna_cdterm {
+        /* 0-2 NS header, 0x818643 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    type:2,
+                termination_type:1,
+                send_dactlu_to_dlu:1,
+                __pad2:1,
+                __pad3:2,
+                __termination:1;
+        char    pcid[7];
+        __u8    network:1,
+                normal:1,
+                reason_code:1,
+                sess_setup:1,
+                cinit_cterm_err:1,
+                bind_unbind_err:1,
+                setup_taked_rej:1,
+                setup_rej:1;
+        __u16   __pad4;
+
+        /* Session Keys */
+        /* Control Vectors */
+};
+
+/* CHASE (Chase) */
+struct sna_chase {
+        __u8    request_code;
+};
+
+/* CINIT (Control Initiate) */
+struct sna_cinit {
+        /* 0-2 NS header, 0x810601 */
+        __u8    format:4,
+                __pad1:4;
+        __u8    init_lu_olu:1,
+                sub_source:1,
+                lu_olu:1,
+                __pad2:1,
+                name_sub:2,
+                ext_bind:1,
+                bind_xrf:1;
+        char    sess_key[4];
+        __u16   size_bind_image;
+
+        /* Lots of variable length crap */
+};
+
+/* RU packet type */
+#define RU_RQ	0	/* Request Unit */
+#define RU_RSP	1	/* Response Unit */
+
+/* RU category */
+#define RU_FM_DATA_UNIT	00
+#define RU_NC_UNIT	01
+#define RU_DFC_UNIT	10
+#define RU_SC_UNIT	11
+
+/* RU format indicator */
+#define RU_FMH_TRUE	1
+#define RU_FMH_FALSE	0
+
+/* RU sense data indicator */
+#define RU_SDI_TRUE	1
+#define RU_SDI_FALSE	0
+
+/* Begin/End chain indicator */
+#define RU_BC_FIRST_TRUE	1
+#define RU_BC_FIRST_FALSE	0 
+#define RU_EC_LAST_TRUE		1
+#define RU_EC_LAST_FALSE	0
+
+/* Definite response 1 indicator */
+#define RU_DR1_TRUE	1
+#define RU_DR1_FALSE	0
+
+/* Length checked compression indicator */
+#define RU_LCC_TRUE	1
+#define RU_LCC_FALSE	0
+
+/* Definate response 2 indicator */
+#define RU_DR2_TRUE	1
+#define RU_DR2_FLASE	0
+
+/* Response type indicators */
+#define RU_RT_POSITIVE	0
+#define RU_RT_NEGATIVE	1
+
+/* Request larger window indicator */
+#define RU_RLW_TRUE	1
+#define RU_RLW_FLASE	0
+
+/* Queue response indicators */
+#define RU_QR_PASS_TC_QUEUE	0
+#define RU_QR_TC_QUEUE		1
+
+/* Pacing indicators */
+#define RU_PACE_TRUE	1
+#define RU_PACE_FLASE	0
+
+/* Begin bracket indicators */
+#define RU_BB_TRUE	1
+#define RU_BB_FLASE	0
+
+/* End bracket indicators */
+#define RU_EB_TRUE	1
+#define RU_EB_FLASE	0
+
+/* Change direction indicators */
+#define RU_CD_TRUE	1
+#define RU_CD_FALSE	0
+
+/* Code selection indicators */
+#define RU_CS_TRUE	1
+#define RU_CS_FASE	0
+
+/* Enciphered data indicators */
+#define RU_ED_TRUE	1
+#define RU_ED_FALSE	0
+
+/* Padded data indicators */
+#define RU_PD_TRUE	1
+#define RU_PD_FALSE	0
+
+/* Conditional end bracket indicator */
+#define RU_CEB_TRUE	1
+#define RU_CEB_FALSE	0
+
+/* Session-level crypto indicators. */
+#define SNA_RU_CRYPTO_NO	0x0
+#define SNA_RU_CRYPTO_SELECT	0x1
+#define SNA_RU_CRYPTO_MANDATORY	0x3
+
+struct sna_ru_ipm {
+	__u8	ipmtype:2,
+		rwi:1,
+		rsv1:5;
+	__u16	nwfmt:1,
+		nws:15;
+};
+
+struct sna_send_parm {
+	__u8	allocate;
+	__u8	fmh;
+	__u8	type;
+	__u8	*data;
+};
+
+struct sna_security_reply_2 {
+	struct sna_send_parm send_parm;
+};
+
+/* ABCONN (Abandon Connection). Request the PU to deactive the link connection
+ * for the specified link.
+ */
+struct sna_ru_abconn {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACONNOUT (Abandon Connection Out). Requests the PU to terminate a
+ * connect-out procedure on the designated link.
+ */
+struct sna_ru_abconnout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* ACTCDRM (Activate Cross-Domain Resource Manager). ACTCDRM is sent
+ * from one SSCP to another SSCP to activate a session between them and
+ * to exchange information about the SSCPs.
+ */
+struct sna_ru_actcdrm {
+	__u8	req_code;	/* 0x14 request code. */
+	__u8	format:4,	/* Format: 0x0. */
+		act_type:4;	/* Type of activation requested:
+				 * 0x1 - cold.
+				 * 0x2 - ERP.
+				 */
+	__u8	fm_profile;
+	__u8	ts_profile;
+	__u8	contents_id[8];
+	__u8	sscp_id[6];
+
+	__u8	rsv1:2,
+		pri_hs_rcv_window_size:6;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTCONNIN (Activate Connection In). ACTCONNIN requests the PU to enable
+ * the specified link to accept incomming calls. It can also be used to
+ * solicit information about an existing connection on the link.
+ */
+struct sna_ru_actconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	incomming_call:1,
+		info_reqi:1,
+		rsv1:6;
+	__u8	*ctrl_vectors;
+};
+
+/* ACTLINK (Activate Link). ACTLINK initiates a procedure at the PU to
+ * activate the protocol boundary between a link station in the node (as
+ * specified by the link network address parameter in the request) and
+ * the link connection attached to it.
+ */
+struct sna_ru_actlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	swsai:1,	/* Switched subarea support indicator. */
+		slli:1,		/* Subordinate logical link indicator. */
+		rsv1:6;
+};
+
+/* ACTLU (Activate Logical Unit). ACTLU is sent from an SSCP to an LU to
+ * activate a session betwrrn the SSCP and the LU and to establish common
+ * session parameters.
+ */
+struct sna_ru_actlu {
+	__u8	req_code;	/* 0x0D. */
+	__u8	eami:1,		/* Enhanced Address Managment indicator. */
+		sdai:1,		/* Static/Dynamic Address indicator. */
+		rsv1:4,
+		act_type:2;	/* Activation type request. */
+
+	__u8	fm_profile:4,
+		ts_profile:4;
+
+	__u8	*ctrl_vectors;
+};
+
+/* ACTPU (Activate Physical Unit). ACTPU is sent by the SSCP to activate a
+ * session with the PU, and to obtain certain information about the PU.
+ */
+struct sna_ru_actpu {
+	__u8	req_code;		/* 0x11. */
+	__u8	format:4,
+		act_type:4;
+	__u8	fm_profile:4,
+		ts_profile:4;
+	__u8	sscp_id_format:4,	/* 0x0000. */
+		sscp_node_type:4;
+	__u8	sscp_id_desc[5];
+	__u8	*ctrl_vectors;
+};
+
+/* ACTTRACE (Activate Trace). ACTTRACE requests the PU to activate a
+ * specified type of trace for a specified resource or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_acttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* Trace type. */
+	__u8	tg_trace:1,	/* Transmission group trace. */
+		piu_trace:1,	/* Generalized PIU trace (GPT). */
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	/* Trace specific data. */
+};
+
+/* ADDLINK (Add Link). ADDLINK is sent from the SSCP to the PU to obtain a
+ * link network address that will be mapped to the locally-used link
+ * identifier specified in the request.
+ */
+struct sna_ru_addlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u16	rsv1;
+	__u8	llid_len;	/* Local Link ID length. */
+	__u8	*llid;		/* Local Link ID. */
+};
+
+/* ADDLINKSTA (Add Link Station). ADDLINKSTA is sent from the SSCP to the PU
+ * to obtain an adjacent link station network address to be associated with
+ * the locally-used link station identifier specified in the request.
+ */
+struct sna_ru_addlinksta {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+
+	/* FID type supported. */
+	__u8	fid0:1,
+		fid1:1,
+		fid2:1,
+		fid3:1,
+		fid4:1,
+		rsv1:3;
+	__u8 	rsv2;
+	__u8	lsid_len;		/* Link Station ID length. */
+	__u8	*lsid;			/* Link Station ID. */
+};
+
+/* BFCINIT (BF Control Initiate). BCFINIT requests the BF(LU) to attempt to
+ * activate, via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_bfcinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+
+	__u8	rsv2:1,
+		sub_src:1,	/* Substitution source. */
+		save_rscv:1,
+		copy_rscv:1,
+		names_sub:2,
+		no_ext_bind:1,
+		ext_bind:1;
+
+	__u8	rsv3[5];
+
+	__u16	bind_image_len;
+
+	__u8	*bind_image;
+};
+
+/* BFCLEANUP (BF Cleanup). BFCLEANUP is sent with definite response
+ * requested to request that the BF(PLU) ot BF(SLU) attempt to deactivate
+ * the identified session.
+ */
+struct sna_ru_bfcleanup {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFINIT (BF Initiate). BFINIT from the BF(LU) requests the initiation of
+ * a session between the two LUs named in the BIND image.
+ */
+struct sna_ru_bfinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+};
+
+/* BFSESSEND (BF Session Ended). BFSESSEND notifies the SSCP that the LU-LU
+ * session identified has been deactivated.
+ */
+struct sna_ru_bfsessend {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESSINFO (BF Session Information). BFSESSINFO provides the SSCP with
+ * information about sessions with SSCP-independent LUs in a peripheral
+ * node taken over by the receiving SSCP.
+ */
+struct sna_ru_bfsessinfo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		rsv1:4;
+	__u8	als_takeover:1,
+		lu_takeover:1,
+		auth_lui:1,		/* Authorized LU indicator. */
+		sdai:1,			/* Static/Dynamic address indicator. */
+		slu_addr:1,		/* Static LU address. */
+		rsv2:2;
+	__u16	rsv3;
+
+	__u8	nq_lu_name_len;
+	__u8	*nq_lu_name;
+	__u8	*ctrl_vectors;
+};
+
+/* BFSESST (BF Session Started). BFSESSST informs the SSCP that a new LU-LU
+ * session has been activated and provides information about the active
+ * session.
+ */
+struct sna_ru_bfsessst {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format:4,
+		lu_role:1,
+		rsv1:3;
+
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BFTERM (BF Terminate). BFTERM from the BF(LU) requests that the SSCP
+ * assist in the termination of the identified LU-LU session.
+ */
+struct sna_ru_bfterm {
+	__u8	ns_hdr[3];
+	__u16	element_type;
+	__u8	format:4,
+		rsv1:4;
+	__u8	cause;
+	__u8	rsv2;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BID (BID). BID is used by the bidder to request permission to initiate
+ * a bracket, and is used only when using brackets. This RU is not used for
+ * LU 6.2.
+ */
+struct sna_ru_bid {
+	__u8	req_code;
+};
+
+/* BIND (BIND Session). BIND is sent from a primary LU to a seconday LU to
+ * activate a session between the LUs. The secondary LU uses the BIND
+ * parameters to help determine whether it will response positively or
+ * negativly to BIND.
+ */
+struct sna_ru_bind_fm_use {
+	__u8    chaining:1,
+                req_cntl_mode:1,
+                chain_rsp_proto:2,
+                phase2_sync_point:1,
+                rsv1:1,
+                fmh1_scb_cmp:1,
+                sebi:1;                 /* Send end bracket indicator. */
+};
+
+struct sna_ru_bind_crypto {
+	__u8	opts:2,
+		sess_level_crypto:2,
+		sess_level_crypto_opts:4;
+	__u8	sess_crypto_key_meth:2,
+		rsv1:2,
+		crypto_cipher_meth:4;
+	__u8	*crypto_key;
+};
+
+struct sna_ru_bind_user_data {
+	__u8	urc_len;
+	__u8	*urc;
+
+	__u8	sec_lu_name_len;
+	__u8	*sec_lu_name;
+
+	__u8	*ctrl_vectors;
+};
+
+#define SNA_RU_BIND_ADAPT_NO_SUPP	0x0
+#define SNA_RU_BIND_ADAPT_SUPP		0x1
+
+struct sna_ru_bind {
+	__u8	req_code;
+	__u8	format:4,
+		type:4;
+	__u8	fm_profile;
+	__u8	ts_profile;
+
+	struct sna_ru_bind_fm_use	pri_lu_proto;
+	struct sna_ru_bind_fm_use	sec_lu_proto;
+
+	__u8	whole_biu:1,
+		fm_hdr:1,
+		bracket_use:1,
+		backet_term:1,
+		alt_code:1,
+		seq_avail_sync_point:1,
+		bis_send:1,
+		bind_queue:1;
+
+	__u8	normal_flow_mode:2,
+		recovery:1,
+		contention:1,
+		alt_code_proc:2,
+		ctrl_vect_include:1,
+		half_dup_ff_reset:1;
+
+	__u8	staging:1,
+		rsv1:1,
+		sec_sws:6;		/* Secondary send window size. */
+
+	__u8	adapt_pace:1,
+		rsv2:1,
+		sec_rws:6;		/* Secondary receive window size. */
+
+	__u8	pri_hs_max_ru_size_sent;
+	__u8	sec_hs_max_ru_size_sent;
+
+	__u8	pri_sec_staging:1,
+		rsv3:1,
+		pri_sws:6;	/* Primary send window size. */
+	__u8	rsv4:2,
+		pri_rws:6;	/* Primary receive window size. */
+
+	__u8	ps_use_format:1,
+		lu_type:7;
+
+	__u8	lu6_level;
+	__u8	rsv6[5];
+
+	__u8	ext_security:1,
+		ext_security_sense:1,
+		rsv7:6;
+
+	__u8	rsv8:3,
+		converstation_level_security:1,
+		lu_lu_verification:1,
+		passwd_sub:1,
+		already_verified:1,
+		persistent_verification:1;
+
+	__u8	rsv9:1,
+		sync_level:2,
+		rsv10:1,
+		reinit_responsibility:2,
+		parallel_sess:1,
+		chg_num_sess:1;
+
+	__u8	rsv11:1,
+		limit_resc_sess:1,
+		rsv12:4,
+		len_chk_compression:2;
+
+	/* End of short bind image. */
+
+	struct sna_ru_bind_crypto crypto;
+
+	__u8	pri_lu_name_len;
+	__u8	*pri_lu_name;
+
+	/* User data field. */
+	__u8	user_data_len;
+	__u8	user_data_key;
+
+	union {
+		__u8	*user_data;
+		struct	sna_ru_bind_user_data *struct_user_data;
+	} data;
+};
+
+/* BINDF (BIND Failure). BINDF is sent, with no-response requested, by the
+ * PLU to notify the SSCP that the attempt to activate the session between
+ * the specified LUs has failed.
+ */
+struct sna_ru_bindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	reason;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* BIS (Bracket Initiation Stopped). BIS is sent by the half-session to
+ * indicate that it will not attempt to begin any more brackets.
+ */
+struct sna_ru_bis {
+	__u8	req_code;
+};
+
+/* CANCEL (Cancel). CANCEL may be sent by a half-session to terminate a
+ * partially sent chain of FMD requests. CANCEL may be sent only when
+ * a chain is in process. The sending half-session may send CANCEL to end
+ * a partially sent chain if a negative response is received for a request
+ * in the chain, or for some other reason. This RU is not used by LU 6.2.
+ */
+struct sna_ru_cancel {
+	__u8	req_code;
+};
+
+/* CDCINIT (Cross-Domain Control Initiate). CDCINIT passes information about
+ * the SLU from the SSCP(SLU) to the SSCP(PLU) and requests that the SSCP(PLU)
+ * send CINIT to the PLU.
+ */
+struct sna_ru_cdcinit_format0 {
+	__u16	plu_addr;
+	__u16	slu_addr;
+};
+
+struct sna_ru_cdcinit_format1 {
+	__u8	*session_key;
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	__u16	char_field;
+	__u8	char_format;
+	__u8	*desc;
+
+	__u8	sess_crypto_key_len;
+	__u8	*pri_sess_crypto_key;
+
+	__u8	*ctrl_vectors;
+};
+
+struct sna_ru_cdcinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:7,
+		xrf_slu_supp:1;
+	__u8	*sess_pair_id;
+
+	union {
+		struct sna_ru_cdcinit_format0 format0;
+		struct sna_ru_cdcinit_format1 format1;
+	} format1;
+};
+
+/* CDINIT (Cross-Domain Initiate). CDINIT requests another SSCP to assist in
+ * initiating an LU-LU session for the specified (OLU,DLU) pair.
+ */
+struct sna_ru_cdinit {
+	__u8	*raw;
+};
+
+/* CDSESSEND (Cross-Domain Session Ended). CDSESSEND notifies the SSCP that the
+ * LU-LU session identified by the session key has been successfully
+ * deactivated, or that knowledge of session deactivation has been lost due to
+ * session outage with one or more of the participating LUs, gatewat nodes, or
+ * adjacent SSCPs. In the latter case, the session may still be active, but
+ * explicit notification of session deactivation is no longer possible.
+ */
+struct sna_ru_cdsessend {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDSESSST (Cross-Domain Session Started). CDSESSST notifies the SSCP(SLU)
+ * that the LU-LU session identified by the Session Key content field and
+ * the specified PCID for the initiation procedure has been sucessfully
+ * activated.
+ */
+struct sna_ru_cdsessst {
+	__u8	ns_hdr[3];
+	__u8	fcid[8];
+	__u8	rsv1;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CDTAKED (Cross-Domain Take Down). CDTAKED initiates a procedure to cause
+ * the takedown of all cross-domain LU-LU sessions (active, pending-active,
+ * and queued) involving the domains of both the sending and receiving SSCP.
+ * It also prevents the initiation of new LU-LU sessions between these domains.
+ */
+struct sna_ru_cdtaked {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	lu_lu_type:2,
+		takedown:2,
+		sscp_sscp_term:1,
+		rsv1:3;
+
+	/* Reason. */
+	__u8	user:1,
+		state:1,
+		rsv2:6;
+};
+
+/* CDTAKEDC (Cross-Domain Take-Down Complete). Except when the Cleanup
+ * option was specified, the SSCP that received CDTAKED (and responded
+ * positively to it) sends CDTAKEDC upon completion of its domain takedown
+ * procedure. The other SSCP, after completing its domain takedown procedure
+ * and receivinf a CDTAKEDC, also sends a CDTAKEDC.
+ */
+struct sna_ru_cdtakedc {
+	__u8	ns_hdr[3];
+	__u8	pcid[8];
+	__u8	type;
+	__u8	status;
+};
+
+/* CDTERM (Cross-Domain Terminate). CDTERM requests that the receiving SSCP
+ * assist in the termination of the cross-domain LU-LU session identified
+ * by the Session Key and the Type byte of the RU. Each SSCP executes that
+ * portion of termination processing that relates to the LU in its domain.
+ */
+struct sna_ru_cdterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	type;
+	__u8	pcid[8];
+	__u8	reason;
+	__u16	rsv2;
+	__u8	*session_key;
+	__u16	rsv3;
+	__u8	*ctrl_vectors;
+};
+
+/* CHASE (Chase). CHASE is sent by a half-session to request the receiving
+ * half-session to return all outstanding normal-flow responses to requests
+ * previously received from the issuer of CHASE. The receiver of CHASE sends
+ * the response to CHASE after processing (and sending any necessary responses
+ * to) all requests received before the CHASE. This RU is not used for LU 6.2.
+ */
+struct sna_ru_chase {
+	__u8	req_code;
+};
+
+/* CINIT (Control Initiate). CINIT requests the PLU to attempt to activate,
+ * via a BIND request, a session with the specified SLU.
+ */
+struct sna_ru_cinit {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	init_origin:1,
+		sub_source:1,
+		slu_plu_olu:1,
+		rsv2:1,
+		name_sub_plu_slu:2,
+		ext_bind_slu:1,
+		xrf_supp_slu:1;
+	__u8	session_key[5];
+
+	__u16	bind_image_len;
+	__u8	*bind_image;
+
+	/* There is more. */
+};
+
+/* CLEANUP (Clean Up session). CLEANUP is sent by the SSCP to an LU (in a
+ * subarea node or BF for peripheral LU) requesting that the LU of BF
+ * attempt to deactivate the session for the specified (PLU, SLU) network
+ * address pair.
+ */
+struct sna_ru_cleanup {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2;
+	__u8	user:1,
+		status:1,
+		rsv3:6;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* CLEAR (Clear). CLEAR is sent by primary session control to reset the
+ * data traffic. FSMs and subtrees (for example, brackets, pacing, sequence
+ * numbers) in the primary and seconday half-session (and boundary function,
+ * if any). CLEAR also resets compression and decompression tables in sessions
+ * using length-checked compression. This RU is not used for LU 6.2.
+ */
+struct sna_ru_clear {
+	__u8	req_code;
+};
+
+/* CONNOUT (Connect Out). CONNOUT requests the PU to initiate a connect-out
+ * procedure on the specified link.
+ */
+struct sna_ru_connout {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	ls_id;		/* Link station ID. */
+	__u8	connect_type:1,
+		connect_out_feature:2,
+		rsv1:2,
+		connect_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		sdai:1;		/* Static/Dynamic address indicator. */
+
+	__u8	retry_limit;
+	__u8	number;
+	__u8	*dial_digits;
+
+	__u8	id_number;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACT (Contact). CONTACT requests the initiation of a procedure at the
+ * PU to activate DLC-level contact with the adjacent link station specified
+ * in the request. The DLC-level contact must be activated before any PIUs
+ * can be exchanged with the adjacent node over the link.
+ */
+struct sna_ru_contact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1:1,
+		eami:1,		/* Enhanced addr managment indicator. */
+		sdai:1,
+		limit_resource:1,
+		cp_cp_sess_supp:1,
+		conn_supp:1,
+		nci:1,		/* Networking capabilities indicator. */
+		nnn_id_usage:1;	/* Nonnative network id usage indicator. */
+
+	__u8	tg_num;
+	__u8	*ctrl_vectors;
+};
+
+/* CONTACTED (Contacted). CONTACTED is issued by the PU to indicate to the
+ * SSCP the completion of the DLC contact procedure. A status parameter
+ * conveyed by this request informs SSCP configuration services whether or
+ * not the contact procedure was successful; if not sucessful, the status
+ * indicates whether an adjacent node load is required or whether an error
+ * occured on the contact procedure.
+ */
+struct sna_ru_contacted {
+	__u8	*raw;
+};
+
+/* CRV (Cryptogrpahy Verification). CRV, a valid request only when
+ * session-level cryptography was selected in BIND, is sent by the primary
+ * LU sesion control to verify cryptography security and thereby enable
+ * sending and receiving of FMD requests by both half-sessions.
+ */
+struct sna_ru_crv {
+	__u8	rq_code;
+	__u8	crypto_seed[7];
+};
+
+/* CTERM (Control Terminate). CTERM requests that the PLU attempt to deactivate
+ * a session identified by the specified (PLU,SLU) network address pair.
+ */
+struct sna_ru_cterm {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	rsv2:2,
+		type:2,
+		rsv3:4;
+	__u8	user:1,
+		status:1,
+		rsv4:6;
+	__u16	rsv5;
+	__u8	*session_key;
+	__u16	rsv6;
+};
+
+/* DACTCDRM (Deactivate Cross-Domain Resource Manager). DACTCDRM is sent
+ * to deactivate a SSCP-SSCP session.
+ */
+struct sna_ru_dactcdrm {
+	__u8	req_code;
+	__u8	format:4,
+		deact_type:4;
+
+	/* Type 2 cont. */
+	__u32	reason;
+
+	/* Type 3 cont. */
+	__u8	cause;
+	__u8	rsv1;
+
+	/* Type 4 cont. */
+	__u8	rsv2;
+};
+
+/* DACTCONNIN (Deactivate Connect In). DACTCONNIN requests the PU to
+ * disable the specified link from accepting incoming calls.
+ */
+struct sna_ru_dactconnin {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DACTLINK (Deactivate Link). DACTLINK initiates a procedure at the PU to
+ * deactivate the protocol boundary between a link station in the node
+ * (as specified by the link network address parameter in the request) and
+ * the link connection attached to it. The normal type is used after all
+ * adjacent link stations on the specified link have been discontacted.
+ * The unconditional type may be used at any time to reset immediately a
+ * link and its attached stations, regardless of their current state. If any
+ * other control points were actively sharing control of the link at the time
+ * of reset, thy are notified via INOP with a unique code. The give-back type
+ * gives back link ownership without disrupting LU-LU sessions.
+ */
+struct sna_ru_dactlink {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dactlink_type;
+};
+
+/* DACTLU (Deactivate Logical Unit). DACTLU is sent to deactivate the session
+ * between the SSCP and the LU.
+ */
+struct sna_ru_dactlu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTPU (Deactivate Physical Unit). DACTPU is sent to deactivate the
+ * session between the SSCP and the PU.
+ */
+struct sna_ru_dactpu {
+	__u8	req_code;
+	__u8	deact_type;
+	__u8	cause;
+};
+
+/* DACTTRACE (Deactivate Trace). DACTTRACE requests the PU to deactivate
+ * a specified type of trace for a specified resource (or hierachy of
+ * resources for a generalized PIU trace.
+ */
+struct sna_ru_dacttrace {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	tg_trace:1,
+		piu_trace:1,
+		rsv1:2,
+		scanner_int_trace:1,
+		rsv2:1,
+		trace_all_frames:1,
+		link_trace:1;
+
+	__u8	*trace_data;
+};
+
+/* DELETENR (Delete Network Resource). DELETENR is sent to free a network
+ * address addigned to a link or adjacent link station.
+ */
+struct sna_ru_deletenr {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISCONTACT (Discontact). DISCONTACT requests the PU to deactivate DLC-level
+ * contact with the specified adjacent node. The discontact procedure is
+ * DLC-dependent; if applicable, polling is stopped. DISCONTACT may be used
+ * to terminate contact, IPL, or dump procedures before their completion. The
+ * PU responds negatively to DISCONTACT if any uninterruptable link-level
+ * procedure is in progress at the primary link station of the specified link.
+ */
+struct sna_ru_discontact {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DISPSTOR (Display Storage). DISPSTOR requests the PU to send a RECSTOR RU
+ * containing a specified number of bytes of storage beginning at a specified
+ * location, or the names and related information for load modules and dump
+ * (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_dispstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	target_addr_space:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	display_bytes;
+	__u32	begin_local_display;
+};
+
+/* DSRLST (Direct Search List). DSRLST specifies a list search argument to
+ * be used at the receiving SSCP to identify a control list type to be
+ * returned on RSP(DSRLST).
+ */
+struct sna_ru_dsrlst {
+	__u8	ns_hdr[3];
+	__u8	search_arg;
+	__u8	*ctrl_vectors;
+};
+
+/* DUMPFINAL (Dump Final). DUMPFINAL performs one of two functions depending
+ * on the address used in the request:
+ * - When the DUMPFINAL request contains the link station address of an
+ *   adjacent T4 node. DUMPFINAL terminates the dump sequence in progress
+ *   (whether DUMPTEST is used or not). A positive response by the T4/5 node
+ *   to this form of DUMPFINAL indicates that the dump sequence is complete.
+ * - Then the DUMPFINAL request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node) and a link station address of
+ *   0x0000, the DUMPFINAL request causes an ABEND at the T4 node. The T4
+ *   node then dumps to local disk. No response is returned to the requester
+ *   for this form of DUMPFINAL.
+ */
+struct sna_ru_dumpfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* DUMPINIT (Dump Initial). DUMPINIT performs one of two functions, depending
+ * on the address used in the request:
+ * - When the node to be dumped is identified by an adjacent link station
+ *   address, DUMPINIT causes the receiving T4/5 node to initiate a DLC-level
+ *   dump from the adjacent T4 node (identified in the DUMPINIT) to the
+ *   receiving T4/5 node; this dump is sent to the SSCP on subsequent
+ *   RSP(DUMPTEXT)s.
+ * - When the DUMPINIT request contains the network address of the receiving
+ *   T4 node (not applicable to a T5 node), a link station address of 0x0000
+ *   and a Dump Control byte equal to 0x80, the DUMPINIT interrogates the
+ *   status of the receiving node's system-defined local options (to react
+ *   to a subsequent DUMPFINAL), and its capacity to store a dump of its own
+ *   contents to local disk storage. A positive response to the request
+ *   indicates that a DUMPFINAL request can be accepted ( and the local dump
+ *   be performed). A negative response indicates either that the system
+ *   defined local options conflict with those of the requester, or
+ *   insufficient disk capacity exists to at the DUMPINIT receiver hold the
+ *   dump.
+ */
+struct sna_ru_dumpinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dump_type;
+};
+
+/* DUMPTEXT (Dump Text). If further dump data is required, DUMPINIT may be
+ * followed by DUMPTEXT. DUMPTEXT causes the dump data specified by the
+ * starting-address parameter to be returned to the SSCP on the response.
+ * The T4/5 obtains the dump data from the T4 node, using a DLC-level
+ * interchange.
+ */
+struct sna_ru_dumptext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	start_dump_addr;
+	__u16	text_len;
+};
+
+/* ER_TESTED (Explicit Route Tested). ER_TESTED is sent by a subarea node
+ * to one or more SSCPs to provide the status of an ER as determined by
+ * explicit route test procedures.
+ */
+struct sna_ru_er_tested {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	er_max_len;
+	__u32	subarea_addr_dst;
+	__u8	rsv1;
+	__u8	rsv2:4,
+		ern_of_er:4;
+	__u32	subarea_addr_src;
+	__u16	rev_ern_mask;
+	__u16	max_piu_len;
+	__u16	max_piu_size;
+	__u16	ns_er_test_origin_sscp_subarea_num;
+	__u16	ns_er_test_origin_sscp_element_num;
+	__u8	req_corr[9];
+
+	/* More. */
+};
+
+/* ESLOW (Entering Slowdown) ESLOW informs the SSCP that the node of the
+ * sending PU has entered a slowdown state. This state is generally
+ * associated with buffer depletion, and requires traffic through the node
+ * to be selectively reduced or suspended.
+ */
+struct sna_ru_eslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* EXECTEST (Execute Test). EXECTEST requests the PU to activate the specified
+ * test type related to the specified network address. The test code specifies
+ * the test type and defines the contents of the test data field. The test may
+ * be for the PU, or for the LUs or links supported by the PU.
+ */
+struct sna_ru_exectest {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*test_data;
+};
+
+/* EXPD (Expedited Data). EXPD is an expediated-flow request that can be
+ * sent between half-sessions, regardless of the status of the normal flows,
+ * to carry TP-defined data. This RU is defined for LU 6.2 only.
+ */
+struct sna_ru_expd {
+	__u8	req_code;
+	__u8	rsv1;
+	__u16	exp_data_len;
+	__u8	*exp_data;
+};
+
+/* EXSLOW (Exiting Slowdown). EXSLOW informs the SSCP that the node of the
+ * sending PU is no longer in the slowdown state and regular traffic can
+ * resume.
+ */
+struct sna_ru_exslow {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* FNA (Free Network Addresses). FNA is sent from an SSCP to request the PU
+ * T4/5 to free the identified element address(es) associated with the
+ * target resource. If ENA is not supported, the entire network address is
+ * in each Element Address field throughout this RU.
+ */
+struct sna_ru_fna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	num_element_addrs;
+
+	__u8	rsv1:1,
+		eami:1,			/* Enhanced Address Managment Indi. */
+		sdai:1,			/* Static/Dynamic Addr Indi. */
+		rsv2:5;
+
+	__u16	first_element_addr;
+	__u16	*other_element_addrs;
+};
+
+/* INIT_OTHER (Initiate Other). INIT_OTHER from the ILU requests the initiation
+ * of a session between the two LUs named in the RU. The requester may be a
+ * third-party LU or one of the two named LUs. This RU is not used by LU 6.2
+ * although it can be used by a third-party LU for LU 6.2.
+ */
+struct sna_ru_init_other {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	iqi:2,		/* Initiate/Enqueue Indicator. */
+		rsv21:4,
+		pluslu_spec:1,
+		rsv2:1;
+};
+
+/* INITPROC (Initiate Procedure). INITPROC is sent to the subarea PU adjacent
+ * to a PU T2 in order to initiate a PU T4/5 PU T2 load operation.
+ */
+struct sna_ru_initproc {
+	__u8	ns_hdr[3];
+	__u8	rsv1[3];
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	*ipl_load_module;
+};
+
+/* IPLFINAL (IPL Final). IPLFINAL completes an IPL sequence and supplies the
+ * load-module entry point to the T4 node. A positive response to IPLFINAL
+ * indicates that the T4 node is successfully loaded, or the load module
+ * has been successfully added to or replaced on the T4 node's local disk.
+ */
+struct sna_ru_iplfinal {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	entry_point;
+	__u8	ipl_sli:1,	/* IPL save load indicator. */
+		ui:1,		/* Usage indicator. */
+		daipli:1,	/* Disk automatic IPL indicator. */
+		dadi:1,		/* Disk automatic dump indicator. */
+		rsv1:4;
+};
+
+/* IPLINIT (IPL Initial). IPLINIT either initiates a DLC-level load of an
+ * adjacent T4 node from the T4 node receiving the IPLINIT, when the node to
+ * be loaded is identified by the adjacent link station address contained in
+ * the request, or initiates the adding, replacing, or purging of the load
+ * module on the local disk of the T4 node receiving the request when the
+ * address in the request is the network address of the PU T4 receiving the
+ * request. In the case of purging, no IPLFINAL is sent, a positive response
+ * to IPLINIT indicates that the load module has been successfully purged.
+ */
+struct sna_ru_iplinit {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	dipli:1,	/* Disk IPL indicator. */
+		rsv1:7;
+	__u8	load_module_name[8];
+	__u8	lmi:2,
+		rsv2:6;
+};
+
+/* IPLTEXT (IPL Text). IPLTEXT transfers load module information to the PU T4,
+ * which passes it in a DLC-level load to the T4 adjacent node or adds or
+ * replaces the load module on its local disk. Following an IPLINIT, any
+ * number of IPLTEXT commands are valid, except that for purging and loading
+ * from local disk, IPLTEXT is not sent.
+ */
+struct sna_ru_ipltext {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*text;
+};
+
+/* LCP (Lost Control Point). LCP notifies the SSCP that a subarea PU's session
+ * with another SSCP has failed. The SSCP displays the information for the
+ * network operator.
+ */
+struct sna_ru_lcp {
+	__u8	ns_hdr[3];
+	__u8	reason_code;
+	__u8	rsv1;
+	__u8	net_addr[5];
+};
+
+/* LUSTAT (Logical Unit Status). LUSTAT is used by one half-session to send
+ * up to four bytes of status information to its paired half-session. The
+ * RU format allows the sending of either end-user information or LU status
+ * information. If the high-order two bytes of the status information are 0,
+ * the low-order two bytes carry end-user information and may be set to any
+ * value. In general, LUSTAT is used to report about failures and error
+ * recovery conditions for a local device of an LU.
+ */
+struct sna_ru_lustat {
+	__u8	req_code;
+	__u32	status;
+};
+
+/* NC_ACTVR (Activate Virtual-Route). NC_ACTVR initializes the state and
+ * attributes of the VR at each of its end nodes.
+ */
+struct sna_ru_nc_actvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u16	rcv_ern_mask;
+	__u16	send_ern_mask;
+	__u16	rsv3:4,
+		init_vr_send_sqn:12;
+	__u8	rsv4;
+	__u8	max_vr_window;
+	__u8	rsv5;
+	__u8	min_vr_window;
+	__u16	max_piu_size;
+	__u16	max_piu_len;
+};
+
+/* NC_DACTVR (Deactivate Virtual Route). NC_DACTVR deactivates a virtual
+ * route.
+ */
+struct sna_ru_nc_dactvr {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+};
+
+/* NC_ER_ACT (Explicit Route Activate). NC_ER_ACT is sent by the ER manager
+ * in a subarea node in order to activate an explicit route.
+ */
+struct sna_ru_nc_er_act {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	route_def_cap:1,
+		rsv3:7;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	src_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_len;
+	__u8	rsv5[8];
+	__u8	act_req_sni[8];
+};
+
+/* NC_ER_INOP (Explicit Route Inoperative). NC_ER_INOP is initiated when the
+ * last remaining link of the transmission group has failed or is disconnected
+ * via a link-level procedure.
+ */
+struct sna_ru_nc_er_inop {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	reason_code;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	num_dst_subareas;
+	__u8	inop_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	inop_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_OP (Explicit Route Operative). NC_ER_OP is generated when a link of
+ * an inoperative transmission group becomes operative.
+ */
+struct sna_ru_nc_er_op {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u32	home_subarea_addr;
+	__u32	remote_subarea_addr;
+	__u8	tg_number;
+	__u8	num_subarea_addrs;
+	__u8	op_er_field[6];
+	__u32	dst_subarea_addr;
+	__u16	op_er_mask;
+	__u8	*data;
+};
+
+/* NC_ER_TEST (Explicit Route Test). NC_ER_TEST is sent by a subarea node that
+ * requires testing of an explicit route to a specified destination subarea.
+ */
+struct sna_ru_nc_er_test {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	rsv2;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv3;
+	__u8	rsv4:4,
+		ern:4;
+	__u32	orig_subarea_addr;
+	__u16	reverse_er_mask;
+	__u16	max_piu_size;
+	__u16	rsv5;
+	__u8	orig_sscp_net_addr[6];
+	__u8	rq_cv[10];		/* Request Correlation Value. */
+};
+
+/* NC_ER_TEST_REPLY (Explicit Route Test Reply). NC_ER_TEST_REPLY is returned
+ * to signal the successful or unsuccessful completion of te NC_ER_TEST.
+ */
+struct sna_ru_nc_er_test_reply {
+	__u8	req_code;
+	__u16	rsv1;
+	__u8	format;
+	__u8	type;
+	__u8	er_len;
+	__u8	max_er_len;
+	__u32	dst_subarea_addr;
+	__u8	rsv2;
+	__u8	rsv3:4,
+		ern:4;
+	__u32	orig1_subarea_addr;
+	__u16	reverse_ern_mask;
+	__u16	max_piu_size_permit;
+	__u16	max_piu_size_accum;
+	__u8	orig_network_addr[6];
+	__u8	rq_cv[10];
+	__u32	orig2_subarea_addr;
+	__u32	subarea_addr_type;
+	__u8	tgn;
+	__u8	*ctrl_vectors;
+};
+
+/* NC_IPL_ABORT (NC IPL Abort). NC_IPL_ABORT contains sense data indicating
+ * the reason for a failure during IPL.
+ */
+struct sna_ru_nc_ipl_abort {
+	__u8	req_code;
+	__u32	sense;
+};
+
+/* NC_IPL_FINAL (NC IPL Final). NC_IPL_FINAL contains the entry point location
+ * of the IPL module.
+ */
+struct sna_ru_nc_ipl_final {
+	__u8	req_code;
+	__u32	entry_point;
+};
+
+/* NC_IPL_INIT (NC IPL Init). NC_IPL_INIT is sent from a PU T4/5 to a PU T2
+ * after the PU T4/5 processes an INITPROC (Type = IPL) RU.
+ */
+struct sna_ru_nc_ipl_init {
+	__u8	req_code;
+	__u8	rsv1;
+	__u8	ipl_load_module[8];
+};
+
+/* NC_IPL_TEXT (NC IPL Text). NC_IP_TEXT contains the IPL data. */
+struct sna_ru_nc_ipl_text {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* NMVT (Network Managment Vector Transport). NMVT carries management services
+ * (MS) requests and replies between an SSCP and a PU.
+ */
+struct sna_ru_nmvt {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	rsv2:2,
+		rsv3:2,
+		prid:12;
+	__u8	si:1,		/* Solicitation Indicator. */
+		sf:2,		/* Sequence field. */
+		sna_addr_list:1,
+		rsv4:4;
+	__u8	*ms_ctrl_vectors;
+};
+
+/* PROCSTAT (Procedure Status). PROCSTAT reports to the SSCP either the 
+ * successful completion or the failure of the load operation. If the procedure
+ * failed, the request code of the failing RU and sense data are included as
+ * parameters in the PROCSTAT RU.
+ */
+struct sna_ru_procstat {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u16	element_addr;
+	__u8	proc_type;
+	__u8	proc_status;
+	__u16	rsv2;
+	__u8	status_qualifier[5];
+	__u8	fail_ru_req_code;
+	__u32	sense;
+};
+
+/* QC (Quiesce Complete). QC is sent by a halfpsession after receving QEC, to
+ * indicate that it has quiesced. This RU is not used for LU 6.2
+ */
+struct sna_ru_qc {
+	__u8	req_code;
+};
+
+/* QEC (Quiesce at End of Chain). QEC is sent by a half session to quiesce its
+ * partner half-session after it (the partner) finishes sending the current
+ * chain (if any). This RU is not used for LU 6.2.
+ */
+struct sna_ru_qec {
+	__u8	req_code;
+};
+
+/* RECFMS (Record Formatted Maintenance Statistics). RECFMS permits the passing
+ * of maintenance related information from a PU to managment services at the
+ * SSCP.
+ */
+struct sna_ru_recfms {
+	__u8	ns_hdr[3];
+	__u16	cnm_target;
+	__u16	rsv1:2,
+		cnm_target_id:2,
+		prid:12;
+	__u8	si:1,
+		ntri:1,
+		req_type_code:6;
+	__u32	block_num:12,
+		id_num:20;
+	__u16	rsv2;
+
+	/* There is more. */
+};
+
+/* RECSTOR (Record Storage). RECSTOR carries the storage dump as requested by
+ * a DISPSTOR RU, or the names and related information for load modules and
+ * dump (if present) on the disk attached to the T4 node.
+ */
+struct sna_ru_recstor {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	display_src:4,
+		display_type:4;
+	__u8	rsv1;
+	__u16	size;
+	__u32	begin_location;
+	__u8	*storage_display;
+};
+
+/* RECTD (Record Test Data). RECTD returns the status and results of a test
+ * requested by EXECTEST to SSCP maintenance services.
+ */
+struct sna_ru_rectd {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u32	test_code;
+	__u8	*data;
+};
+
+/* RELQ (Release Quiesce). RELQ is used to release a half-session from a
+ * quiesced state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_relq {
+	__u8	req_code;
+};
+
+/* REQACTCDRM (Request Acitivation of Cross-Network Resource Manager).
+ * REQACTCDRM prompts the receiving SSCP to issue RNAA and SETCV to setup a
+ * cross-network address transform. ACTCDRM will then be sent to activate an
+ * SSCP-SSCP session with the other-network SSCP identified in this request.
+ */
+struct sna_ru_reqactcdrm {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format;
+	__u8	tsr:1,
+		vrid:1,
+		rsv2:6;
+	__u8	*session_key;
+	__u8	*bad_actcdrm;
+};
+
+/* REQACTLU (Request Activate Logical Unit). REQACTLU is sent from the PU to an
+ * SSCP to request that ACTLU be sent to the LU named in the RU.
+ */
+struct sna_ru_reqactlu {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	type;
+	__u8	len;
+	__u8	*symbol_name;
+};
+
+/* REQACTPU (Request Activate Physical Unit). REQACTPU is sent from the PU to
+ * SSCP to request that ACTPU be sent to the PU named in the corresponding
+ * FID2 Encapsulation (0x1500) GDS variable.
+ */
+struct sna_ru_reqactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+};
+
+/* REQCONT (Request Contact). REQCONT notifies the SSCP that a connection with
+ * an adjacent secondary link station (in a T1/2 node) has be activated via a
+ * successful connect-in or connect-out procedure. A DLC-level indentification
+ * exchange (XID) is required before issuing REQCONT.
+ */
+struct sna_ru_reqcontx {
+	__u16	vector_hdr;
+	__u8	tg_status:1,
+		rsv1:7;
+};
+
+struct sna_ru_reqcont {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	*xid_ifield_image;
+	__u8	*ctrl_vectors;
+};
+
+/* REQDACTPU (Request Deactivate Physical Unit). REQDACTPU is sent from the PU
+ * to an SSCP to request that DACTPU be sent to the PU.
+ */
+struct sna_ru_reqdactpu {
+	__u8	ns_hdr[3];
+	__u16	rsv1;
+	__u8	format:4,
+		rsv2:4;
+	__u8	cause;
+};
+
+/* REQDISCONT (Request Discontact). With REQDISCONT, the PU T2 requests the
+ * SSCP to start a procedure that will ultimately discontact the secondary
+ * station in the T2 node.
+ */
+struct sna_ru_reqdiscont {
+	__u8	ns_hdr[3];
+	__u8	type:4,
+		contact:4;
+};
+
+/* REQFNA (Request Free Network Address). REQFNA is sent from a PU T4/5 to an
+ * SSCP to request the SSCP to send FNA to the PU T4/5 in order to free all
+ * addresses for the specified LU.
+ */
+struct sna_ru_reqfna {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	rsv1;
+	__u8	req_type;
+};
+
+/* REQMS (Request Maintenance Statisitics). REQMS requests the managment
+ * services associated with the PU to provide maintenance statistics for the
+ * resource indicated by the CNM target ID in the CNM header.
+ */
+struct sna_ru_reqms {
+	__u8	*raw;
+};
+
+/* RNAA (Request Network Address Assignment). RNAA requests the PU to
+ * assign addresses:
+ * - To an adjacent link station, as identified in the RNAA request by a link
+ *   element address and secondary link station link-level address.
+ * - To a dependent LU, where the LU is identified in the RNAA by a adjacent
+ *   link station address and the LU local address.
+ * - To a subarea LU that supports parallel sessions; in order to assign an
+ *   additional element address, the LU is identified in the RNAA request
+ *   by the LU element address used for the SSCP-LU session.
+ * - As alias addresses for a cross-network SSCP-SSCP or LU-LU session, where
+ *   the name pair and session characteristics are identified in the RNAA
+ *   request.
+ * - To an LU to be used as a PLU address for an independent LU or to be used
+ *   as an indepenedent or depenedent LU, where the LU is identified by an ALS
+ *   address, an LU name, and an optional LU address.
+ *
+ * If ENA is not supported on this SSCP-to-PU T4/5 session, the entire network
+ * address is in each element address field throughout this RU.
+ */
+struct sna_ru_rnaa {
+	__u8	*raw;
+};
+
+/* ROUTE_INOP (Route Inoperative). ROUTE_INOP notifies the CP when either a
+ * virtual route or an explicit route has become inoperative as the result of
+ * a transmission group having become inoperative somewhere in the network.
+ * This RU is retired for route dynamics.
+ */
+struct sna_ru_route_inop {
+	__u8	*raw;
+};
+
+/* ROUTE_SETUP (Route Setup). ROUTE_SETUP is used between adjacent HPR CPs when
+ * at leat one of them does not support the Control Flows over RTP (1402) option
+ * set; it carries the Route Setup GDS variable and is preceded by a FID2 TH
+ * set to FID2, BBIU, EBIU, ODAI = 0, EFI = 1, DAF = 0, OAF - 0, and SNA = 0
+ * (ie, TH = 0x2D0000000000) and an RH set to RQ, NC, FI = 1, SDI = 0, BC, EC
+ * DR1 = DR2 = ECI = 0 (RQN or no-response requested), with all other bits
+ * 0 (ie RH = 0x2B0000).
+ */
+struct sna_ru_route_setup {
+	__u8	req_code;
+	__u8	*data;
+};
+
+/* ROUTE_TEST (Route Test). ROUTE_TEST requests the PC_ROUTE_MANAGER component
+ * of PU.SVC_MGR to return the status (for example, active, operative, not
+ * defined), as know in the control blocks in the node, of various explicit
+ * and/or virutal routes.
+ */
+struct sna_ru_route_test {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+	__u8	format;
+	__u8	test_code;
+	__u8	test_routes;
+	__u8	rsv1:6,
+		tx_priority:2;
+	__u8	rsv2:1,
+		congestion_data:1,
+		vrdi:1,
+		rsv3:5;
+	__u8	max_exp_er_len;
+	__u32	dst_subarea_addr;
+	__u16	bit_route_test;
+	__u8	req_cf[10];
+	__u8	network_id[8];
+};
+
+/* RPO (Remote Power Off). RPO Causes the receiving PU T4/5 to initiate a
+ * DLC-level power-off sequence to the T4 node specified by the adjacent link
+ * station address conveyed in the request. The node being powered off does not
+ * need to have an active SSCP-PU half-session not be contacted.
+ */
+struct sna_ru_rpo {
+	__u8	ns_hdr[3];
+	__u16	element_addr;
+};
+
+/* RQR (Request Recovery). RQR is sent by the secondary to request the primary
+ * to initiate recovery for the session by sending CLEAR or to deactivate the
+ * session. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rqr {
+	__u8	req_code;
+};
+
+/* RSHUTD (Request Shutdown). RSHUTD is sent from the secondary to the primary
+ * to indicate that the secondary is ready to have the session deactivated.
+ * RSHUTD does not request a shutdown; therefor, SHUTD is not a proper reply;
+ * RSHUTD requests an UNBIND. This RU is not used for LU 6.2.
+ */
+struct sna_ru_rshutd {
+	__u8	req_code;
+};
+
+/* RTR (Ready to Receive). RTR indicates to the bidder that it is now allowed
+ * to initiate a bracket. RTR is sent only be the first speaker.
+ */
+struct sna_ru_rtr {
+	__u8	req_code;
+};
+
+/* SBI (Stop Bracket Indication). SBI is sent by either half-session to request
+ * that the receiving half-session stop initiating brackets by continued sending
+ * of BB and the BID request. This RU is not used by LU 6.2.
+ */
+struct sna_ru_sbi {
+	__u8	req_code;
+};
+
+/* SDT (Start Data Traffic). SDT is sent by the primary session control to the
+ * secondary session control to enable the sending and receiving of FMD and
+ * DFC requests and responses by both half-sessions. This RU is not used
+ * by LU 6.2.
+ */
+struct sna_ru_sdt {
+	__u8	req_code;
+};
+
+/* SESSEND (Session Ended). SESSEND is sent, with no-response requested, by
+ * the LU (or boundary function on behalf of the LU in a periheral node) to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully deactivated.
+ */
+struct sna_ru_sessend {
+	__u8	ns_hdr[3];
+	__u8	format:4,
+		rsv1:4;
+	__u8	*raw;
+};
+
+/* SESSST (Session Started). SESSST is sent, with no response requested, to
+ * notify the SSCP that the session between the specified LUs has been
+ * successfully activated.
+ */
+struct sna_ru_sessst {
+	__u8	ns_hdr[3];
+	__u8	format;
+	__u8	*raw;
+};
+
+/* SHUTC (Shutdown Complete). SHUTC is sent by a secondary to indicate that it
+ * is in the shutdown (quiesced) state. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutc {
+	__u8	req_code;
+};
+
+/* SHUTD (Shutdown). SHUTD is sent by the primary to request that the secondary
+ * shut down (quiesce) as soon as convenient. This RU is not used for LU 6.2.
+ */
+struct sna_ru_shutd {
+	__u8	req_code;
+};
+
+/* SIG (Signal). SIG is an expediated request that can be sent between
+ * half-sessions, regardless of the status of the normal flows. It carries a
+ * four-byte value, of which the first two bytes are the signal code and the
+ * last two bytes are the signal extension value.
+ */
+struct sna_ru_sig {
+	__u8	req_code;
+	__u16	signal_code;
+	__u16	signal_ext;
+};
+
+/* STSN (Set and Test Sequence Numbers). STSN is sent by the primary 
+ * half-session sync point manager to resynchronize the values of the 
+ * half-session sequence numbers, for one or both of the normal flows at both
+ * ends of the session. The RU is not used for LU 6.2.
+ */
+struct sna_ru_stsn {
+	__u8	req_code;
+	__u8	sp_act_code:2,
+		ps_act_code:2,
+		rsv1:4;
+	__u16	sp_snf;
+	__u16	ps_snf;
+};
+
+/* SWITCH (Switch Data Traffic). SWITCH is sent by the PLU to the SLU to change
+ * the (XRF) state of their LU-LU session from XRF-backup to XRF-active.
+ */
+struct sna_ru_switch {
+	__u8	req_code;
+	__u8	type;
+};
+
+/* TERM_OTHER (Terminate Other). TERM_OTHER from the TLU requests that the
+ * SSCP assist in terminating one or more sessions between the two LUs named in
+ * the RU. The requester may be a third-party LU or onr of the two named LUs.
+ * This RU is not used by LU 6.2, although it can be used by a third party
+ * LU for LU 6.2.
+ */
+struct sna_ru_term_other {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 0 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender
+ * of the request (TLU = OLU) and the DLU. This RU is not used for LU 6.2;
+ * refer to TERM_SELF FORMAT 1.
+ */
+struct sna_ru_term_self_fmt0 {
+	__u8	*raw;
+};
+
+/* TERM_SELF FORMAT 1 (Terminate Self). TERM_SELF from the TLU requests that the
+ * SSCP assist in the termination of one or more sessions between the sender of
+ * the request (TLU = OLU) and the DLU.
+ */
+struct sna_ru_term_self_fmt1 {
+	__u8	*raw;
+};
+
+/* TESTMODE (Test Mode). TESTMODE requests the management services associated
+ * with the PU to manage a test procedure. The test procedure begins with the
+ * TESTMODE request that initiates a test and ends when the test results and
+ * status are returned in a RECTR reply request corresponding to the initial
+ * TESTMODE request.
+ */
+struct sna_ru_testmode {
+	__u8	ns_hdr[3];
+	__u16	cnm_target_id;
+	__u16	rsv1:2,
+		cnm_target_id_desc:2,
+		prid:12;
+	__u8	*data;
+};
+
+/* UNBIND (Unbind Session). UNBIND is sent to deactivate an active session
+ * between the two LUs.
+ */
+struct sna_ru_unbind {
+	__u8	req_code;
+	__u8	unbind_type;
+	__u32	sense;
+	__u8	*ctrl_vectors;
+};
+
+/* UNBINDF (Unbind Failure). UNBINDF is sent, with no-response requested, by
+ * the PLU to notify the SSCP that the attempt to deactivate the session
+ * between the specified LUs has failed (for example, because of a path failure)
+ */
+struct sna_ru_unbindf {
+	__u8	ns_hdr[3];
+	__u32	sense;
+	__u8	rsv1:1,
+		unbind_err_slu:1,
+		takedown_rej_plu:1,
+		rsv2:5;
+	__u8	*session_key;
+	__u8	*ctrl_vectors;
+};
+
+/* RU NS Header indicators. */
+#define SNA_RU_NS_CONTACT		0x010201
+#define SNA_RU_NS_DISCONTACT		0x010202
+#define SNA_RU_NS_IPLINIT		0x010203
+#define SNA_RU_NS_IPLTEXT		0x010204
+#define SNA_RU_NS_IPLFINAL		0x010205
+#define SNA_RU_NS_DUMPINIT		0x010206
+#define SNA_RU_NS_DUMPTEXT		0x010207
+#define SNA_RU_NS_DUMPFINAL		0x010208
+#define SNA_RU_NS_RPO			0x010209
+#define SNA_RU_NS_ACTLINK		0x01020A
+#define SNA_RU_NS_DACTLINK		0x01020B
+#define SNA_RU_NS_CONNOUT		0x01020E
+#define SNA_RU_NS_ABCONN		0x01020F
+#define SNA_RU_NS_SETCV			0x010211
+#define SNA_RU_NS_ESLOW			0x010214
+#define SNA_RU_NS_EXSLOW		0x010215
+#define SNA_RU_NS_ACTCONNIN		0x010216
+#define SNA_RU_NS_DACTCONNIN		0x010217
+#define SNA_RU_NS_ABCONNOUT		0x010218
+#define SNA_RU_NS_ANA			0x010219
+#define SNA_RU_NS_FNA			0x01021A
+#define SNA_RU_NS_REQDISCONT		0x01021B
+#define SNA_RU_NS_CONTACTED		0x010280
+#define SNA_RU_NS_INOP			0x010281
+#define SNA_RU_NS_REQCONT		0x010284
+#define SNA_RU_NS_NS_LSA		0x010285
+#define SNA_RU_NS_EXECTEST		0x010301
+#define SNA_RU_NS_ACTTRACE		0x010302
+#define SNA_RU_NS_DISPSTOR		0x010331
+#define SNA_RU_NS_RECSTOR		0x010334
+#define SNA_RU_NS_RECMS			0x010381
+#define SNA_RU_NS_RECTD			0x010382
+#define SNA_RU_NS_RECTRD		0x010383
+#define SNA_RU_NS_NSPE			0x010604
+#define SNA_RU_NS_INIT_SELF_FMT0	0x010681
+#define SNA_RU_NS_TERM_SELF_FMT0	0x010683
+#define SNA_RU_NS_RNAA			0x410210
+#define SNA_RU_NS_DELETENR		0x41021C
+#define SNA_RU_NS_ER_INOP		0x41021D
+#define SNA_RU_NS_ADDLINK		0x41021E
+#define SNA_RU_NS_ADDLINKSTA		0x410221
+#define SNA_RU_NS_VR_INOP		0x410223
+#define SNA_RU_NS_INITPROC		0x410235
+#define SNA_RU_NS_PROCSTAT		0x410236
+#define SNA_RU_NS_LDREQD		0x410237
+#define SNA_RU_NS_REQACTPU		0x41023E
+#define SNA_RU_NS_REQDACTPU		0x41023F
+#define SNA_RU_NS_REQACTLU		0x410240
+#define SNA_RU_NS_NS_IPL_INIT		0x410243
+#define SNA_RU_NS_NS_IPL_TEXT		0x410244
+#define SNA_RU_NS_NS_IPL_FINAL		0x410245
+#define SNA_RU_NS_NS_IPL_ABORT		0x410246
+#define SNA_RU_NS_REQFNA		0x410286
+#define SNA_RU_NS_LCP			0x410287
+#define SNA_RU_NS_ROUTE_INOP		0x410289
+#define SNA_RU_NS_REQACTCDRM		0x41028A
+#define SNA_RU_NS_REQMS			0x410304
+#define SNA_RU_NS_TESTMODE		0x410305
+#define SNA_RU_NS_ROUTE_TEST		0x410307
+#define SNA_RU_NS_RECFMS		0x410384
+#define SNA_RU_NS_RECTR			0x410385
+#define SNA_RU_NS_ER_TESTED		0x410386
+#define SNA_RU_NS_NMVT			0x41038D
+#define SNA_RU_NS_REQECHO		0x810387
+#define SNA_RU_NS_ECHOTEST		0x810389
+#define SNA_RU_NS_CINIT			0x810601
+#define SNA_RU_NS_CTERM			0x810602
+#define SNA_RU_NS_NOTIFY		0x810620
+#define SNA_RU_NS_CLEANUP		0x810629
+#define SNA_RU_NS_INIT_OTHER		0x810680
+#define SNA_RU_NS_INIT_SELF_FMT1	0x810681
+#define SNA_RU_NS_TERM_OTHER		0x810682
+#define SNA_RU_NS_TERM_SELF_FMT1	0x810683
+#define SNA_RU_NS_BINDF			0x810685
+#define SNA_RU_NS_SESSST		0x810686
+#define SNA_RU_NS_UNBINDF		0x810687
+#define SNA_RU_NS_SESSEND		0x810688
+#define SNA_RU_NS_FORWARD		0x810810
+#define SNA_RU_NS_DELIVER		0x810812
+#define SNA_RU_NS_BFCINIT		0x812601
+#define SNA_RU_NS_BFCLEANUP		0x812629
+#define SNA_RU_NS_BFINIT		0x812681
+#define SNA_RU_NS_BFTERM		0x812683
+#define SNA_RU_NS_BFSESSST		0x812686
+#define SNA_RU_NS_BFSESSEND		0x812688
+#define SNA_RU_NS_BFSESSINFO		0x81268C
+#define SNA_RU_NS_DSRLST		0x818627
+#define SNA_RU_NS_INIT_OTHER_CD		0x818640
+#define SNA_RU_NS_CDINIT		0x818641
+#define SNA_RU_NS_CDTERM		0x818643
+#define SNA_RU_NS_CDSESSF		0x818645
+#define SNA_RU_NS_CDSESST		0x818646
+#define SNA_RU_NS_CDSESSTF		0x818647
+#define SNA_RU_NS_CDSESSEND		0x818648
+#define SNA_RU_NS_CDTAKED		0x818649
+#define SNA_RU_NS_CDTAKEDC		0x81864A
+#define SNA_RU_NS_CDCINIT		0x81864B
+
+/* RU Request Codes. */
+#define SNA_RU_RC_NC_IPL_FINAL		0x02
+#define SNA_RU_RC_NC_IPL_INIT		0x03
+#define SNA_RU_RC_EXPD			0x03
+#define SNA_RU_RC_LUSTAT		0x04
+#define SNA_RU_RC_NC_IPL_TEXT		0x04
+#define SNA_RU_RC_RTR			0x05
+#define SNA_RU_RC_LSA			0x05
+#define SNA_RU_RC_NC_ER_INOP		0x06
+#define SNA_RU_RC_NC_ER_TEST		0x09
+#define SNA_RU_RC_NC_ER_TEST_REPLY	0x0A
+#define SNA_RU_RC_NC_ER_ACT		0x0B
+#define SNA_RU_RC_NC_ER_ACT_REPLY	0x0C
+#define SNA_RU_RC_ACTLU			0x0D
+#define SNA_RU_RC_NC_ACTVR		0x0D
+#define SNA_RU_RC_DACTLU		0x0E
+#define SNA_RU_RC_NC_DACTVR		0x0E
+#define SNA_RU_RC_NC_ER_OP		0x0F
+#define SNA_RU_RC_ROUTE_SETUP		0x10
+#define SNA_RU_RC_ACTPU			0x11
+#define SNA_RU_RC_DACTPU		0x12
+#define SNA_RU_RC_ACTCDRM		0x14
+#define SNA_RU_RC_DACTCDRM		0x15
+#define SNA_RU_RC_BIND			0x31
+#define SNA_RU_RC_UNBIND		0x32
+#define SNA_RU_RC_SWITCH		0x33
+#define SNA_RU_RC_NC_IPL_ABORT		0x46
+#define SNA_RU_RC_BIS			0x70
+#define SNA_RU_RC_SBI			0x71
+#define SNA_RU_RC_QEC			0x80
+#define SNA_RU_RC_QC			0x81
+#define SNA_RU_RC_RELQ			0x82
+#define SNA_RU_RC_CANCEL		0x83
+#define SNA_RU_RC_CHASE			0x84
+#define SNA_RU_RC_SDT			0xA0
+#define SNA_RU_RC_CLEAR			0xA1
+#define SNA_RU_RC_STSN			0xA2
+#define SNA_RU_RC_RQR			0xA3
+#define SNA_RU_RC_SHUTD			0xC0
+#define SNA_RU_RC_CRV			0xC0
+#define SNA_RU_RC_SHUTC			0xC1
+#define SNA_RU_RC_RSHUTD		0xC2
+#define SNA_RU_RC_BID			0xC8
+#define SNA_RU_RC_SIG			0xC9
+
+struct snaruhdr {
+	union {
+		struct sna_ru_abconn		abconn;
+		struct sna_ru_abconnout		abconnout;
+		struct sna_ru_actcdrm		actcdrm;
+		struct sna_ru_actconnin		actconnin;
+		struct sna_ru_actlink		actlink;
+		struct sna_ru_actlu		actlu;
+		struct sna_ru_actpu		actpu;
+		struct sna_ru_acttrace		acttrace;
+		struct sna_ru_addlink		addlink;
+		struct sna_ru_addlinksta	addlinksta;
+		struct sna_ru_bfcinit		bfcinit;
+		struct sna_ru_bfcleanup		bfcleanup;
+		struct sna_ru_bfinit		bfinit;
+		struct sna_ru_bfsessend		bfsessend;
+		struct sna_ru_bfsessinfo	bfsessinfo;
+		struct sna_ru_bfsessst		bfsessst;
+		struct sna_ru_bfterm		bfterm;
+		struct sna_ru_bid		bid;
+		struct sna_ru_bind		bind;
+		struct sna_ru_bindf		bindf;
+		struct sna_ru_bis		bis;
+		struct sna_ru_cancel		cancel;
+		struct sna_ru_cdcinit		cdcinit;
+		struct sna_ru_cdinit		cdinit;
+		struct sna_ru_cdsessend		cdsessend;
+		struct sna_ru_cdsessst		cdsessst;
+		struct sna_ru_cdtaked		cdtaked;
+		struct sna_ru_cdtakedc		cdtakedc;
+		struct sna_ru_cdterm		cdterm;
+		struct sna_ru_chase		chase;
+		struct sna_ru_cinit		cinit;
+		struct sna_ru_cleanup		cleanup;
+		struct sna_ru_clear		clear;
+		struct sna_ru_connout		connout;
+		struct sna_ru_contact		contact;
+		struct sna_ru_contacted		contacted;
+		struct sna_ru_crv		crv;
+		struct sna_ru_cterm		cterm;
+		struct sna_ru_dactcdrm		dactcdrm;
+		struct sna_ru_dactconnin	dactconnin;
+		struct sna_ru_dactlink		dactlink;
+		struct sna_ru_dactlu		dactlu;
+		struct sna_ru_dactpu		dactpu;
+		struct sna_ru_dacttrace		dacttrace;
+		struct sna_ru_deletenr		deletenr;
+		struct sna_ru_discontact	discontact;
+		struct sna_ru_dispstor		dispstor;
+		struct sna_ru_dsrlst		dsrlst;
+		struct sna_ru_dumpfinal		dumpfinal;
+		struct sna_ru_dumpinit		dumpinit;
+		struct sna_ru_dumptext		dumptext;
+		struct sna_ru_er_tested		er_tested;
+		struct sna_ru_eslow		eslow;
+		struct sna_ru_exectest		exectest;
+		struct sna_ru_expd		expd;
+		struct sna_ru_exslow		exslow;
+		struct sna_ru_fna		fna;
+		struct sna_ru_init_other	init_other;
+		struct sna_ru_initproc		initproc;
+		struct sna_ru_iplfinal		iplfinal;
+		struct sna_ru_iplinit		iplinit;
+		struct sna_ru_ipltext		ipltext;
+		struct sna_ru_lcp		lcp;
+		struct sna_ru_lustat		lustat;
+		struct sna_ru_nc_actvr		nc_actvr;
+		struct sna_ru_nc_er_act		nc_er_act;
+		struct sna_ru_nc_er_inop	nc_er_inop;
+		struct sna_ru_nc_er_op		nc_er_op;
+		struct sna_ru_nc_er_test	nc_er_test;
+		struct sna_ru_nc_er_test_reply	nc_er_test_reply;
+		struct sna_ru_nc_ipl_abort	nc_ipl_abort;
+		struct sna_ru_nc_ipl_final	nc_ipl_final;
+		struct sna_ru_nc_ipl_init	nc_ipl_init;
+		struct sna_ru_nc_ipl_text	nc_ipl_text;
+		struct sna_ru_nmvt		nmvt;
+		struct sna_ru_procstat		procstat;
+		struct sna_ru_qc		qc;
+		struct sna_ru_qec		qec;
+		struct sna_ru_recfms		recfms;
+		struct sna_ru_recstor		recstor;
+		struct sna_ru_rectd		rectd;
+		struct sna_ru_relq		relq;
+		struct sna_ru_reqactcdrm	reqactcdrm;
+		struct sna_ru_reqactlu		reqactlu;
+		struct sna_ru_reqactpu		reqactpu;
+		struct sna_ru_reqcontx		reqcontx;
+		struct sna_ru_reqcont		reqcont;
+		struct sna_ru_reqdactpu		reqdactpu;
+		struct sna_ru_reqdiscont	reqdiscont;
+		struct sna_ru_reqfna		reqfna;
+		struct sna_ru_reqms		reqms;
+		struct sna_ru_rnaa		rnaa;
+		struct sna_ru_route_inop	route_inop;
+		struct sna_ru_route_setup	route_setup;
+		struct sna_ru_route_test	route_test;
+		struct sna_ru_rpo		rpo;
+		struct sna_ru_rqr		rqr;
+		struct sna_ru_rshutd		rshutd;
+		struct sna_ru_rtr		rtr;
+		struct sna_ru_sbi		sbi;
+		struct sna_ru_sdt		sdt;
+		struct sna_ru_sessend		sessend;
+		struct sna_ru_sessst		sessst;
+		struct sna_ru_shutc		shutc;
+		struct sna_ru_shutd		shutd;
+		struct sna_ru_sig		sig;
+		struct sna_ru_stsn		stsn;
+		struct sna_ru_switch		ru_switch;
+		struct sna_ru_term_other	term_other;
+		struct sna_ru_term_self_fmt0	term_self_fmt0;
+		struct sna_ru_term_self_fmt1	term_self_fmt1;
+		struct sna_ru_testmode		testmode;
+		struct sna_ru_unbind		unbind;
+		struct sna_ru_unbindf		unbindf;
+		struct sna_security_reply_2	security_reply_2;
+		struct sna_fmh1			fmh1;
+		struct sna_fmh2			fmh2;
+		struct sna_fmh4			fmh4;
+		struct sna_fmh5			fmh5;
+		struct sna_fmh6			fmh6;
+		struct sna_fmh7			fmh7;
+		struct sna_fmh8			fmh8;
+		struct sna_fmh10		fmh10;
+		struct sna_fmh12		fmh12;
+		struct sna_ru_ipm		ipm;
+		__u16				*raw;
+	} ru;
+};
+
+/* MS.
+ */
+
+/* Solicitation indicators */
+#define NMVT_UNSOL      0x0
+#define NMVT_SOL        0x1
+
+/* NMVT sequence indicators */
+#define NMVT_SINGLE     0x00
+#define NMVT_LAST       0x01
+#define NMVT_FIRST      10
+#define NMVT_MIDDLE     11
+
+/* Network Managment Vector Transport (NMVT) header */
+struct sna_nmvt
+{
+//         sna_ru_request  *ru_request;
+
+        unsigned char __pad1[2];
+
+        __u16   __pad2:2,
+                __pad3:2,
+                prid:12;        /* Procedure related identifier */
+
+        __u8    si:1,           /* Solicitation indicator */
+                seqf:2,
+                sals:1,         /* SNA Address List subvector indicator */
+                __pad4:4;
+
+        unsigned char msvect;   /* One or more MS major vectors */
+};
+
+/* Record formatted maintenance statistics headers */
+
+/* CNM indicators */
+#define CNM_LSID        00
+#define CNM_ELEMENT     01
+
+/* Not last indicators */
+#define CNM_LAST_REQUEST_TRUE   0
+#define CNM_LAST_REQUEST_FALSE  1
+
+struct recfms_request
+{
+        __u8    solic:1,        /* Solicitation indicator */
+                nlri:1,         /* Not-last request indicator */
+                rqcode:6;       /* Request-specific type code */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+
+        __u16   __pad1;
+};
+
+#ifdef NOT
+
+/* Alert indicators */
+#define ALERT_EPERM             0x1     /* Permanent error */
+#define ALERT_ETEMP             0x2     /* Temporary error */
+#define ALERT_EPERFORMANCE      0x3     /* Performance error */
+#define ALERT_EINVALD           0x4     /* Unsupported or invalid use */
+#define ALERT_EBUSY             0x4     /* Busy */
+#define ALERT_EAPP              0x5     /* Application generated */
+#define ALERT_EOPRTR            0x6     /* Operator triggered */
+#define ALERT_SNA               0x7     /* SNA summary */
+
+/* Alert Major probable cause indicators */
+#define ALERT_MJ_HRDW           0x1     /* hardware */
+#define ALERT_MJ_SFTW           0x2     /* software */
+#define ALERT_MJ_LINK           0x3     /* link connection */
+#define ALERT_MJ_PROTO          0x4     /* protocol */
+#define ALERT_MJ_ENVIR          0x5     /* environment */
+#define ALERT_MJ_RMMEDIA        0x6     /* removable media */
+#define ALERT_MJ_HRDW_SFTW      0x7     /* hardware or software */
+#define ALERT_MJ_LOGIC          0x8     /* logical */
+#define ALERT_MJ_OPRTR_SNDPD    0x9     /* operator of sending product */
+#define ALERT_MJ_UNDEFINE       0xF     /* undetermined */
+
+/* Alert Minor probablt casue indicators */
+#define ALERT_MN_BPROCESSOR     0x01    /* base processor */
+#define ALERT_MN_SPROCESSOR     0x02    /* service processor */
+#define ALERT_MN_MICROCODE      0x03    /* microcode */
+#define ALERT_MN_MAINSTORAGE    0x04    /* main storage */
+#define ALERT_MN_DASD           0x05    /* DASD drive */
+#define ALERT_MN_PRINTER        0x06    /* printer */
+#define ALERT_MN_CARD           0x07    /* card reader/punch */
+#define ALERT_MN_TAPE           0x08    /* tape drive */
+#define ALERT_MN_KEYBOARD       0x09    /* keyboard */
+#define ALERT_MN_PEN            0x0A    /* selector pen */
+#define ALERT_MN_MAGREADER      0x0B    /* magnetic stripe reader */
+#define ALERT_MN_DIS_PRINTER    0x0C    /* display or printer */
+#define ALERT_MN_DISPLAY        0x0D    /* display unit */
+#define ALERT_MN_REMOTE         0x0E    /* remote product */
+#define ALERT_MN_POWER_INT      0x0F    /* power internal to this product */
+#define ALERT_MN_IOCTRLR        0x10    /* I/O attached controller */
+#define ALERT_MN_COMM_SCAN      0x11    /* communications controller scanner */
+#define ALERT_MN_COMM_ADPTR     0x12    /* communications link adapter  */
+#define ALERT_MN_LINK_ADPTR     0x13    /* link adapter */
+#define ALERT_MN_CHNL_ADPTR     0x14    /* channel adapter */
+#define ALERT_MN_LOOP_ADPTR     0x15    /* loop adapter */
+#define ALERT_MN_DIR_ADPTR      0x16    /* adapter for direct attach devices */
+#deifne ALERT_MN_MISC_ADPTR     0x17    /* miscellaneous adapter */
+#define ALERT_MN_S390_CHNL      0x18    /* System/390 channel */
+#define ALERT_MN_LINK           0x19    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LINK_COMN      0x1A    /* common carrier transmission medium */#define ALERT_MN_LINK_CUST      0x1B    /* customer transmission medium */
+#define ALERT_MN_LOOP           0x1C    /* transmiss medium-ownership unknwn */
+#define ALERT_MN_LOOP_COMN      0x1D    /* common carrier transmission medium */#define ALERT_MN_LOOP_CUST      0x1E    /* customer transmission medium */
+#define ALERT_MN_X21_EXT        0x1F    /* X.21 link conn ext to this prod */
+#define ALERT_MN_X25_EXT        0x20    /* X.25 link conn ext to this prod */
+#define ALERT_MN_X21_IFACE      0x21    /* local X.21 interface:  DTE-DCE */
+#define ALERT_MN_X25_IFACE      0x22    /* local X.25 interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_MODEM    0x23    /* local modem */
+#define ALERT_MN_REMOTE_MODEM   0x24    /* remote modem */
+#define ALERT_MN_MODEM_LIFACE   0x25    /* local modem interface:  DTE-DCE */
+#define ALERT_MN_MODEM_RIFACE   0x26    /* remote modem interface:  DTE-DCE */
+#define ALERT_MN_LOCAL_PROBE    0x27    /* local probe */
+#define ALERT_MN_REMOTE_PROBE   0x28    /* remote probe */
+#define ALERT_MN_PROBE_LIFACE   0x29    /* local probe interface */
+#define ALERT_MN_PROBE_RIFACE   0x2A    /* remote probe interface */
+#define ALERT_MN_NETCONN        0x2B    /* network connection */
+#define ALERT_MN_IBM_HOST_PG    0x2C    /* IBM host program */
+#define ALERT_MN_IBM_HOST_APP   0x2D    /* IBM host application program */
+#define ALERT_MN_IBM_HOST_TELE  0x2E    /* IBM host telecommunication access */
+#define ALERT_MN_CUST_APP       0x2F    /* customer host application */
+#define ALERT_MN_IBM_COMM_CTRL  0x30    /* IBM comm controller program */
+#define ALERT_MN_IBM_CTRL_PG    0x31    /* IBM control program */
+#define ALERT_MN_RMT_IFMDM      0x32    /* remote modem iface or remote prod */
+#define ALERT_MN_RMT_MDM_TRANS  0x33    /* transmission med. or remote modem */
+#define ALERT_MN_SDLC_XFMT      0x34    /* SDLC format exception */
+#define ALERT_MN_BSC_XFMT       0x35    /* BSC format exception */
+#define ALERT_MN_SS_XFMT        0x36    /* start/stop format exception */
+#define ALERT_MN_SNA_XFMT       0x37    /* SNA format exception */
+#define ALERT_MN_POWER_EXT      0x38    /* power external to product */
+#define ALERT_MN_THERMAL        0x39    /* thermal */
+#define ALERT_MN_PAPER          0x3A    /* paper */
+#define ALERT_MN_TAPE           0x3B    /* tape */
+#define ALERT_MN_DASD           0x3C    /* DASD - removable media */
+#define ALERT_MN_CARD           0x3D    /* card */
+#define ALERT_MN_MAG_STRIP      0x3E    /* magnetic stripe card */
+#define ALERT_MN_NEG_SNA_RESP   0x3F    /* negative SNA response */
+#define ALERT_MN_SYS_DEF_ERR    0x40    /* system definition error */
+#define ALERT_MN_INSTALL_REST   0x41    /* installation restrictions */
+#define ALERT_MN_LS_OFFLINE     0x42    /* adjacent link station offline */
+#define ALERT_MN_LS_BUSY        0x43    /* adjacent link station busy */
+#define ALERT_MN_DEVICE         0x44    /* controller or device */
+#define ALERT_MN_LOCAL_PROBE    0x45    /* local probe or modem */
+#define ALERT_MN_DRIVE          0x46    /* tape or drive */
+#define ALERT_MN_CARD           0x47    /* card readr/punch or display/printr */#define ALERT_MN_CTRL_APP       0x48    /* controller application program */
+#define ALERT_MN_KEY_DISPLAY    0x49    /* keyboard or display */
+#define ALERT_MN_SCU            0x4A    /* storage control unit */
+#define ALERT_MN_CHNL_SCU       0x4B    /* channel or storage control unit */
+#define ALERT_MN_SCU_CTRL       0x4C    /* storage control unit or controller */#define ALERT_MN_CU             0x4D    /* control unit */
+#define ALERT_MN_DASD_M_D_D     0x4E    /* DASD data or media or drive */
+#define ALERT_MN_DASD_M_D       0x4F    /* DASD data or media */
+#define ALERT_MN_DISK           0x50    /* diskette */
+#define ALERT_MN_DISK_DRIVE     0x51    /* diskette or drive */
+#define ALERT_MN_UNDETERMINE    0xFF    /* undetermined */
+
+#endif
+
+struct recfms_alert
+{
+        __u8    alert:2,        /* 00 - Alert */
+                acode:6;        /* Alert type code - 0000 */
+
+        unsigned char nid[5];   /* 48 bit Node Identification */
+
+        __u32   blk:12,         /* Block number */
+                blkid:20;       /* Block ID number */
+        __u16   __pad1;
+
+        /* Alert classification */
+        __u8    aformat:2,      /* Alert Class Format */
+                __pad2:6;
+        __u8    atype:4,        /* Alert type, see Alert codes */
+                amjcause:4;     /* Alert major cause */
+        __u8    amncause;       /* Alert minor cause */
+        __u8    __pad3;
+        __u8    actcode;        /* User action code */
+        __u8    __pad4;
+
+        unsigned char cnmvectors;       /* Appended CNM vectors */
+};
+
+struct sna_sdlc_stats
+{
+        struct recfms_request *request; /* header */
+        __u16   wvfcs;
+        __u16   vfcs;
+};
+
+struct sna_summary_err
+{
+        struct recfms_request *request; /* header */
+        __u16   errcnt:1,       /* 1 if product error counter is valid */
+                commcnt:1,      /* 1 if comm adapter error counter is valid */
+                negcnt:1,       /* 1 if SNA neg response counter is valid */
+                __pad1:5;
+
+        __u8    __pad2;
+
+        __u8    __pad3:7,
+                commflag:1;     /* Comm adapter err flg RECFMS types 02 or 03 */
+        __u16   prodcnt;        /* Product error counter */
+        __u16   comadptr;       /* Communication adapter error counter */
+        __u16   snaneg;         /* SNA neg resps originating at this node */
+};
+
+/* Comm adapter error set indicators */
+#define COMM_ADPTR_SET1         0x01
+#define COMM_ADPTR_SET2         0x02
+#define COMM_ADPTR_SET3         0x03
+#define COMM_ADPTR_SET4         0x04
+#define COMM_ADPTR_SET5         0x05
+#define COMM_ADPTR_SET6         0x06
+
+/* Data for counters sets 1 and 2 */
+struct sna_comm_adptr_set1
+{
+        /* Communication adapter counter validity mask bytes */
+
+        __u8    nonprod_to:1,   /* Nonproductive time-out */
+                idle_to:1,      /* Idle time-out counter */
+                wrty:1,         /* Write retry counter */
+                ovrn:1,         /* Overrun counter */
+                undrn:1,        /* Underrun counter */
+                connprb:1,      /* Connection problem counter */
+                fcserr:1,       /* FCS error counter */
+                psabort:1;      /* Primary station abort counter */
+
+        __u8    cmdrej:1,       /* SDLC Command reject counter */
+                dceerr:1,       /* SDLC DCE error counter */
+                wto:1,          /* Write time-out counter */
+                inval:1,        /* Invalid status counter */
+                comm_chk:1,     /* Comm adapter machine check counter */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u8    nonprod_to_cnt; /* Nonproductive time-out counter */
+        __u8    idle_to_cnt;    /* Idle time-out counter */
+        __u8    wrty_cnt;       /* Write retry counter */
+        __u8    ovrn_cnt;       /* Overrun counter */
+        __u8    undrn_cnt;      /* Underrun counter */
+        __u8    connprb_cnt;    /* Connection problem counter */
+        __u8    fcserr_cnt;     /* FCS error counter */
+        __u8    psabort_cnt;    /* Primary station abort counter */
+        __u8    cmdrej_cnt;     /* SDLC command reject counter */
+        __u8    dceerr_cnt;     /* SDLC DCE error counter */
+        __u8    wto_cnt;        /* Write time-out counter */
+        __u8    inval_cnt;      /* Invalid status counter */
+        __u8    comm_chk_cnt;   /* Communication adapter machine check cntr */
+};
+
+/* Data for counters set 3 */
+struct sna_comm_adptr_set3
+{
+        __u8    tx_iframes:1,   /* Total transmitted I-frames counter */
+                wrty:1,         /* Write retry counter */
+                rx_iframes:1,   /* Total received I-frames counter */
+                fcserr:1,       /* FCS error counter */
+                cmdrej:1,       /* SDLC command reject counter */
+                dceerr:1,       /* DCE error counter */
+                noprod_to:1,    /* Nonproductive time-out counter */
+                __pad1;
+
+        __u16   __pad2;
+
+        __u16   tx_iframes_cnt; /* Total transmitted I-frames counter */
+        __u16   wrty_cnt;       /* Write retry counter */
+        __u16   rx_iframes_cnt; /* Total received I-frames counter */
+        __u16   fcserr_cnt;     /* FCS error counter */
+        __u16   cmdrej_cnt;     /* SDLC command reject counter */
+        __u16   dceerr_cnt;     /* DCE error counter */
+        __u16   noprod_to_cnt;  /* Nonproductive time-out counter */
+};
+
+struct sna_comm_adptr_set4
+{
+        __u8    cmdrejwni:1,    /* Command-reject-while-not-initialized cnt */
+                cmdnrec:1,      /* Command-not-recognized counter */
+                sensewni:1,     /* Sense-while-not-initialized counter */
+                chnlpcdss:1,    /* Channel-prty-chk-during-selection-seq cnt */
+                chnlpcddws:1,   /* Channel-parity-chk-during-data-wrt-seq cnt */                oppcacu:1,      /* Output-parity-check-at-control-unit cnt */
+                ippcacu:1,      /* Input-parity-check-at-control-unit counter */
+                ipcaac:1;       /* Input-parity-check-at-adapter counter */
+
+        __u8    dataeaa:1,      /* Data-error-at-adapter counter */
+                datasseq:1,     /* Data-stop-sequence counter */
+                shrtfolchk:1,   /* Short-frame-or-length-check counter */
+                connrcvwac:1,   /* Connect-rcvd-when-already-connected cnt */
+                disrcvwpuact:1, /* Disconnect-received-while-PU-active cnt */
+                longru:1,       /* Long-RU counter */
+                connprmold:1,   /* Connect-parameter-error counter */
+                rdstrtoldrcv:1; /* Read-Start-Old-received counter */
+
+        __u8    __pad1;
+
+        __u8    cmdrejwni_cnt;  /* Command-reject-while-not-initialized cnt */
+        __u8    cmdnrec_cnt;    /* Command-not-recognized counter */
+        __u8    sensewni_cnt;   /* Sense-while-not-initialized counter */
+        __u8    chnlpcdss_cnt;  /* Channel-prty-chk-during-selection-seq cnt */
+        __u8    chnlpcddws_cnt; /* Channel-parity-chk-during-data-wrt-seq cnt */        __u8    oppcacu_cnt;    /* Output-parity-check-at-control-unit cnt */
+        __u8    ippcacu_cnt;    /* Input-parity-check-at-control-unit counter */        __u8    ipcaac_cnt;     /* Input-parity-check-at-adapter counter */
+        __u8    dataeaa_cnt;    /* Data-error-at-adapter counter */
+        __u8    datasseq_cnt;   /* Data-stop-sequence counter */
+        __u8    shrtfolchk_cnt; /* Short-frame-or-length-check counter */
+        __u8    connrcvwac_cnt; /* Connect-rcvd-when-already-connected cnt */
+        __u8    disrcvwpuact_cnt;       /* Disconn-rcvd-while-PU-active cnt */
+        __u8    longru_cnt;     /* Long-RU counter */
+        __u8    connprmold_cnt; /* Connect-parameter-error counter */
+        __u8    rdstrtoldrcv_cnt;       /* Read-Start-Old-received counter */
+};
+
+struct sna_comm_adptr_set5
+{
+        __u8    tx_iframes:1,   /* I-frames transmitted counter */
+                rx_iframes:1,   /* I-frames received counter */
+                tx_rrframes:1,  /* RR frames transmitted counter */
+                rx_rrframes:1,  /* RR frames received counter */
+                tx_rnrframes:1, /* RNR frames transmitted counter */
+                rx_rnrframes:1, /* RNR frames received counter */
+                tx_rejframes:1, /* REJ frames transmitted counter */
+                rx_rejframes:1; /* REJ frames received counter */
+
+        __u8    retransmit:1,   /* Number of retransmissions counter */
+                fcs_frames:1,   /* Number of frames rcvd with FCS errors cnt */
+                rcverr:1,       /* Number of errors on receive side counter */
+                ovrn_rxs:1,     /* Number of overruns on receive side counter */                undrn_txs:1,    /* Number of underruns on transmit side cntr */
+                __pad1:3;
+
+        __u8    __pad2;
+
+        __u16   tx_iframes_cnt; /* I-frames transmitted counter */
+        __u16   rx_iframes_cnt; /* I-frames received counter */
+        __u16   tx_rrframes_cnt;        /* RR frames transmitted counter */
+        __u16   rx_rrframes_cnt;        /* RR frames received counter */
+        __u16   tx_rnrframes_cnt;       /* RNR frames transmitted counter */
+        __u16   rx_rnrframes_cnt;       /* RNR frames received counter */
+        __u16   tx_rejframes_cnt;       /* REJ frames transmitted counter */
+        __u16   rx_rejframes_cnt;       /* REJ frames received counter */
+        __u16   retransmit_cnt; /* Number of retransmissions counter */
+        __u16   fcs_frames_cnt; /* Number of frames rcvd with FCS errors cnt */
+        __u16   rcverr_cnt;     /* Number of errors on receive side counter */
+        __u16   ovrn_rxs_cnt;   /* Number of overruns on receive side counter */        __u16   undrn_txs_cnt;  /* Number of underruns on transmit side cnt */
+};
+
+struct sna_comm_adptr_set6
+{
+        __u8    tx_ipackets:1,  /* data packets transmitted counter */
+                rx_ipackets:1,  /* data packets received counter */
+                tx_rrpackets:1, /* RR packets transmitted counter */
+                rx_rrpackets:1, /* RR packets received counter */
+                tx_rnrpackets:1,        /* RNR packets transmitted counter */
+                rx_rnrpackets:1,        /* RNR packets received counter */
+                tx_intpackets:1,        /* interrupt packets transmitted cnt */
+                rx_intpackets:1;        /* interrupt packets received counter */
+        __u8    connreq:1,      /* Number of connection requests counter */
+                conns:1,        /* Number of connections counter */
+                rstindic:1,     /* Number of reset indications counter */
+                clrindic:1,     /* Number of clear indications counter */
+                tx_dbit:1,      /* data packets with D-bit transmitted cnt */
+                rx_dbit:1,      /* data packets with D-bit received counter */
+                __pad1:2;
+
+        __u8    __pad2;
+
+        __u16   tx_ipackets_cnt;        /* I packets transmitted */
+        __u16   rx_ipackets_cnt;        /* I packets received */
+        __u16   tx_rrpackets_cnt;       /* RR packets transmitted */
+        __u16   rx_rrpackets_cnt;       /* RR packets received */
+        __u16   tx_rnrpackets_cnt;      /* RNR packets transmitted counter */
+        __u16   rx_rnrpackets_cnt;      /* RNR packets received counter */
+        __u16   tx_intpackets_cnt;      /* interrupt packets transmitted cnt */
+        __u16   rx_intpackets_cnt;      /* interrupt packets received counter */        __u16   connreq_cnt;    /* Total number of connection requests */
+        __u16   conns_cnt;      /* Total number of connections*/
+        __u16   rstindic_cnt;   /* Number of reset indications */
+        __u16   clrindic_cnt;   /* Number of clear indications */
+        __u16   tx_dbit_cnt;    /* Number of data pkts with D-bit transmitted */        __u16   rx_dbit_cnt;    /* Number of data packets with D-bit received */};
+
+struct sna_comm_adptr_stats
+{
+        struct recfms_request *request; /* header */
+        __u8    errset;         /* Comm adapter error counter sets */
+
+        union {         /* Data sets */
+                struct sna_comm_adptr_set1      set1;
+                struct sna_comm_adptr_set1      set2;
+                struct sna_comm_adptr_set3      set3;
+                struct sna_comm_adptr_set4      set4;
+                struct sna_comm_adptr_set5      set5;
+                struct sna_comm_adptr_set6      set6;
+        } counter;
+};
+
+struct sna_generic_stats
+{
+        struct recfms_request *request;
+        unsigned char *data;
+};
+
+/* Data selection indicators */
+#define LCSUB_LSC_SEQ           0x02
+#define LCSUB_RMT_DTE_STATS     0x03
+#define LCSUB_RMT_MDM_STEST     0x04
+
+/* Link connection subsystem type */
+#define LCSUB_TYPE1     0x01
+#define LCSUB_TYPE2     0x02
+
+/* Validity indicators */
+#define LCSUB_DATA_VALID        00
+#define LCSUB_NRSP_MDM          01
+#define LCSUB_ERSP_MDM          10
+#define LCSUB_DATA_NOTVALID     11
+
+struct sna_lcsub_stats
+{
+        struct recfms_request *request;
+
+        __u8    datasel;        /* Data selection */
+        __u8    lctype;         /* Link connection subsystem type */
+
+        /* Validity indicators */
+        __u16   rmodem_stat:2,  /* Remote modem status */
+                lmodem_stat:2,  /* Local modem status */
+                modem_stest:2,  /* Modem self test */
+                __pad1:2,
+                rdte_stat:2,    /* Remote DTE interface status */
+                __pad2:4,
+                lfmt:2;         /* Link conn subsystem data format indicator */
+
+        /* Remote modem status */
+        __u16   rhcount:6,      /* Hit count */
+                rrinit:1,       /* Modem reinitialization was performed */
+                rlrcvsig:1,     /* Loss of receive line signal */
+                rquaderr:4,     /* Quadratic error value */
+                rrdtepwroff:1,  /* Remote DTE power off detected */
+                rldtr:1,        /* Data Terminal Ready loss detected */
+                rswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                rdtestream:1;   /* DTE streaming condition detected */
+
+        /* Local modem status */
+        __u16   lhcount:6,      /* Hit count */
+                lrinit:1,       /* Modem reinitialization was performed */
+                llrcvsig:1,     /* Loss of receive line signal */
+                lquaderr:4,     /* Quadratic error value */
+                lrdtepwroff:1,  /* Remote DTE power off detected */
+                lspeed:1,       /* Speed */
+                lswntwkbkup:1,  /* Switched-Network-Back-Up connected */
+                ldtestream:1;   /* DTE streaming condition detected */
+
+        __u16   modelbits:3,    /* Model bits */
+                linktype:1,     /* Link connection type */
+                config:1,       /* Configuration */
+                mrole:1,        /* Modem role */
+                ctds:1,         /* Clear To Send delay */
+                rcvlsigdet:1,   /* Received line signal detector sensitivity */
+                modelbit1:1,    /* Model bit */
+                stest:1,        /* Modem self-test result */
+                rttest:1,       /* Remote tone test result */
+                fcarderr:1,     /* Feature card suspected in error */
+                rcvxcard:1,     /* Receiver card extension suspected in error */                frntcard:1,     /* Front end card is suspected in error */
+                modelbit2:1,    /* Model bit */
+                fcardinst:1;    /* Feature card installed */
+        __u8    swntwkbkup:1,   /* Switched-Network-Back-Up installed */
+                modelbit3:1,    /* Model bit */
+                modelbit4:1,    /* Model bit */
+                microcode:5;    /* Microcode EC level */
+
+        __u8    rts:1,          /* Request To Send */
+                cts:1,          /* Clear To Send */
+                __pad3:1,
+                td:1,           /* Transmit Data */
+                __pad4:1,
+                dtr:1,          /* Data Terminal Ready */
+                speed:1,        /* Speed */
+                dtepwrloss:1;   /* DTE power loss */
+
+        __u8    rtqc:1,         /* Request To Send changed at least once */
+                ctsc:1,         /* Clear To Send changed at least once */
+                rdc:1,          /* Received Data changed state */
+                tdc:1,          /* Transmit Data changed state */
+                rcvlsigc:1,     /* Received Line Signal loss was detected */
+                dtrd:1,         /* Data Terminal Ready dropped */
+                speedc:1,       /* Modem speed was changed */
+                dtepwrlossc:1;  /* DTE power loss was detected */
+
+                /* Channelization status */
+        __u8    channelized:1,  /* Is associated with a channelized modem */
+                tailed:1,       /* Is associated with a tailed link chnl mdm */
+                channela:1,     /* associated with channel A */
+                __pad5:5;
+
+        __u16   channelnum;     /* Channelization correlation number */
+
+        __u8    ldblvl;         /* Local modem receive dB level */
+        unsigned char __pad6[6];
+
+        __u8    rdblvl;         /* Remote modem receive dB level */
+        unsigned char __pad7[6];
+
+        __u8    lladdr;         /* Link-level addr used to addr the rmt modem */        __u8    rdteifacex;     /* Remote DTE Interface Extension */
+
+        unsigned char   __pad8[5];
+};
+
+/* CNM Vectors not included here */
+
+struct sna_recfms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {         /* Request specific information */
+                struct sna_sdlc_stats           sdlc;
+                struct sna_summary_err          sna;
+                struct sna_comm_adptr_stats     adptr;
+                struct sna_generic_stats        pulu;
+                struct sna_generic_stats        enginr;
+                struct sna_lcsub_stats          lcsub;
+        } stats;
+};
+
+struct sna_rms_gen_specific
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+};
+
+struct sna_rms_pulu
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        unsigned char *data;    /* PU- or LU-dependent request parameters */
+};
+
+struct sna_rms_lcsub
+{
+        __u8    reset:1,        /* Reset indicator */
+                __pad1:1,
+                tcode:6;        /* Type code */
+        __u8    dselrq;         /* Data selection requested */
+
+};
+
+struct sna_rms
+{
+//        sna_ru_request  *ru_request;
+
+        __u16   cmntid;         /* CNM target ID */
+
+        __u16   __pad1:2,
+                cnmtidd:2,      /* CNM target ID descriptor */
+                prid:12;        /* Procedure related identifier */
+
+        union {
+                struct sna_rms_gen_specific     request;
+                struct sna_rms_gen_specific     sdlc;
+                struct sna_rms_gen_specific     sna;
+                struct sna_rms_gen_specific     adptr;
+                struct sna_rms_pulu             pulu;
+                struct sna_rms_gen_specific     enginr;
+                struct sna_rms_lcsub            lcsub;
+        } rms;
+};
+
+/* Control Vectors.
+ */
+
+typedef enum {
+	CV_NETNAME = 1,
+	CV_PRODUCT_ID
+} cv_type;
+
+#define CV_KEY_NETNAME		0x0E
+#define CV_KEY_PRODUCT_ID	0x10
+
+#define CV_CP_NAME		0xF4
+
+/* XID.
+ */
+
+/* Default timer values */
+#define SNA_XID_RETRY_LIMIT     10
+#define SNA_XID_IDLE_LIMIT      (60 * HZ)
+#define SNA_XID_RETRY_INTERVAL  (10 * HZ)
+
+/* XID I-field structures. The goal is to provide one set of XID headers
+ * for all device types, Eth, Tr, Sdlc, X.25, Channel, etc, etc..
+ */
+#define SNA_XID_TYPE_0          0x00    /* Xid Type 0 */
+#define SNA_XID_TYPE_1          0x01    /* Xid Type 1 */
+#define SNA_XID_TYPE_2          0x02    /* Xid Type 2 */
+#define SNA_XID_TYPE_3          0x03    /* Xid Type 3 */
+
+#define SNA_XID_NODE_T1         0x01    /* T1 node */
+#define SNA_XID_NODE_T2         0x02    /* T2.0 or T2.1 node */
+#define SNA_XID_NODE_T4         0x04    /* T4 or T5 node */
+#define SNA_XID_NODE_T5         SNA_XID_NODE_T4
+
+#define SNA_XID_XSTATE_NOSUPP	0x00
+#define SNA_XID_XSTATE_NONACT	0x01
+#define SNA_XID_XSTATE_NEG	0x02
+#define SNA_XID_XSTATE_PN	0x03
+
+typedef struct {
+        __u16   rsv1;
+        __u8    rsv2:2,
+                ls_role:1,
+                rsv3:1,
+                ls_txrx_cap:4;
+        __u8    rsv4:2,
+                seg_asm_cap:2,
+                rsv5:2,
+                sh_mode_status:1,
+                sh_mode_support:1;
+        __u16   format:1,
+                max_ifield_len:15;
+        __u8    rsv6:4,
+                sdlc_cmd_rsp_profile:4;
+        __u8    rsv7:2,
+                sdlc_init_mode:1,
+                rsv8:5;
+        __u16   rsv9;
+        __u8    rsv10:1,
+                max_rx_iframe_win:7;
+        __u8    rsv11;
+
+        /* SDLC address assignment field */
+        /*
+         * Not supported yet.
+         */
+} sna_xid1;
+
+typedef struct {
+        __u8    raw;
+} sna_xid2;
+
+typedef struct {
+        unsigned        rsv1:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+        unsigned        abm_nonact_xid:1        __attribute__ ((packed));
+        unsigned        rsv2:7                  __attribute__ ((packed));
+        unsigned        max_btu_len_format:1    __attribute__ ((packed));
+        __u16           max_btu_len:15          __attribute__ ((packed));
+        unsigned        rsv3                    __attribute__ ((packed));
+        unsigned        rsv4:2                  __attribute__ ((packed));
+        unsigned        dlc_init_mode:1         __attribute__ ((packed));
+        unsigned        rsv5:5                  __attribute__ ((packed));
+        __u16           rsv6                    __attribute__ ((packed));
+        unsigned        rsv7:1                  __attribute__ ((packed));
+        unsigned        max_rx_iframes:7        __attribute__ ((packed));
+} sna_xid_dlc_satf;
+
+typedef struct {
+        __u16   cdlc_chg:1,
+                attn_timeout_sup:1,
+                data_stream:1,
+                cdlc_chg_sup:1,
+                rsv1:12;
+        __u16   max_lpiu_len;
+        __u8    buf_prefetch;
+        __u16   num_read_cmds;
+        __u16   buf_size;
+        __u16   blocking_delay;
+        __u16   attn_timeout;
+        __u16   pre_num_read_cmds;
+        __u16   prev_pri_buf_size;
+        __u8    time_unit;
+} sna_xid_dlc_s390_channel;
+
+typedef struct {
+        __u8    rsv1:2,
+                xid_role:2,
+                rsv2:4;
+        __u8    rsv3;
+        __u16   max_btu_size;
+
+        /* Start of Control Vectors */
+        __u8    cv;
+} sna_xid_dlc_appn_channel;
+
+#pragma pack(1)
+typedef struct {
+	/* Byte 0 */
+	__u8    xid_node:4              	__attribute__ ((packed));
+        __u8    xid_type:4              	__attribute__ ((packed));
+
+	/* Byte 1 */
+        __u8    len:8                   	__attribute__ ((packed));
+
+	/* Byte 2 - 5 */
+        __u32   block_id:12,
+		pu_id:20			__attribute__ ((packed));
+
+	/* Byte 6 - 7 */
+        __u16   rsv1                            __attribute__ ((packed));
+
+	/* Byte 8 - 9 */
+	__u8		nc1			__attribute__ ((packed));
+	__u8		nc2			__attribute__ ((packed));
+/*
+        __u16        	init_self:1,
+                	stand_alone_bind:1,
+                	whole_bind:1,
+                	whole_bind_piu_req:1,
+        	        rsv2:4,
+        	        actpu_suppression:1,
+        	        network_node:1,
+        	        cp_services:1,
+        	        cp_cp_support:1,
+        	        xid_xstate:2,
+        	        nonact_xchg_sec:1,
+        	        cp_name_chg:1           __attribute__ ((packed));
+*/
+
+	/* Byte 10 */
+        /* Bind pacing support over TG */
+        __u8        	tx_adptv_bind_pacing:1,
+        		rx_adprv_bind_pacing:1,
+        		quiesce_tg_req:1,
+        		pu_cap_sup:1,
+        		appn_pbn:1,
+        		rsv3:1,
+        		adptv_bind_pacing:2     __attribute__ ((packed));
+
+	/* Byte 11 */
+        __u8        	rsv4:1,
+                	tg_sharing_prohibited:1,
+                	dedicated_scv:1,
+              		rsv5:5                  __attribute__ ((packed));
+
+	/* Byte 12 - 14 */
+	__u8		rsv6[3]			__attribute__ ((packed));
+
+	/* byte 15 */
+        __u8        	parallel_tg_sup:1,
+             		dlur_actpu:1,
+               		dlus_lu_reg:1,
+                	xhpr_bn:1,
+                	gen_odai_usage_opt_set:1,
+			rsv7:3			__attribute__ ((packed));
+
+	/* byte 16 */
+        __u8            tg_num                  __attribute__ ((packed));
+
+	/* Byte 17 */
+        __u8            dlc_type                __attribute__ ((packed));
+
+	/* Byte 18 */
+	__u8		dlc_len			__attribute__ ((packed));
+
+	/* byte 19 */
+	__u8		ls_flags		__attribute__ ((packed));
+
+/*
+	unsigned        rsv8:1                  __attribute__ ((packed));
+        unsigned        abm:1                   __attribute__ ((packed));
+        unsigned        ls_role_xid_sender:2    __attribute__ ((packed));
+        unsigned        sh_mode_status:1        __attribute__ ((packed));
+        unsigned        sh_mode:1               __attribute__ ((packed));
+        unsigned        ls_txrx_cap:2           __attribute__ ((packed));
+*/
+
+	/* byte 20 */
+        __u8		abm_nonact_xid:1,
+        		rsv9:7                  __attribute__ ((packed));
+
+	/* byte 21 - 22 */
+	__u16		max_btu_len		__attribute__ ((packed));
+/*
+        __u16		max_btu_len_format:1,
+        		max_btu_len:15          __attribute__ ((packed));
+*/
+
+	/* byte 23 */
+        __u8        	rsv10                   __attribute__ ((packed));
+
+	/* byte 24 */
+        __u8		rsv11:2,
+        		dlc_init_mode:1,
+        		rsv12:5                  __attribute__ ((packed));
+
+	/* byte 25 - 26 */
+        __u16           rsv13                    __attribute__ ((packed));
+
+	/* byte 27 */
+	__u8		max_rx_iframes		__attribute__ ((packed));
+/*
+        __u8		rsv14:1,
+        		max_rx_iframes:7        __attribute__ ((packed));
+*/
+} sna_xid3;
+#pragma pack()
+
+struct sna_xid {
+        __u8    xid_node:4              __attribute__ ((packed));
+        __u8    xid_type:4              __attribute__ ((packed));
+        __u8    len:8                   __attribute__ ((packed));
+        __u32   node_block_num:12       __attribute__ ((packed));
+        __u32   node_id_num:20          __attribute__ ((packed));
+
+        union {
+                sna_xid1        x1 __attribute__ ((packed));
+                sna_xid2        x2 __attribute__ ((packed));
+                sna_xid3        x3 __attribute__ ((packed));
+        } fmt;
+};
+
+#endif  /* __KERNEL__ */
+#endif  /* __NET_SNA_FORMATS_H */
diff -ruN linux-2.4.4/include/net/sock.h linux/include/net/sock.h
--- linux-2.4.4/include/net/sock.h	Fri Apr 27 15:49:39 2001
+++ linux/include/net/sock.h	Mon May 14 20:47:16 2001
@@ -605,6 +605,11 @@
 	struct sk_filter      	*filter;
 #endif /* CONFIG_FILTER */
 
+#if defined(CONFIG_LLC_UI) || defined(CONFIG_LLC_UI_MODULE)
+        __u8                    sap;
+        struct datalink_proto   *llc_proto;
+#endif
+
 	/* This is where all the private (optional) areas that don't
 	 * overlap will eventually live. 
 	 */
@@ -655,6 +660,9 @@
 #endif
 #if defined(CONFIG_WAN_ROUTER) || defined(CONFIG_WAN_ROUTER_MODULE)
                struct wanpipe_opt      *af_wanpipe;
+#endif
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+               struct sna_opt          *af_sna;
 #endif
 	} protinfo;  		
 
diff -ruN linux-2.4.4/net/802/TODO linux/net/802/TODO
--- linux-2.4.4/net/802/TODO	Fri Apr  6 10:51:19 2001
+++ linux/net/802/TODO	Wed Dec 31 16:00:00 1969
@@ -1,29 +0,0 @@
-Remaining Problems:
-
-1. Serialization of access to variables in the llc structure
-by mac_data_indicate(), timer expired functions, and data_request() .
-There is not serialization of any kind right now.
-While testing, I have not seen any problems that stem from this lack of
-serialization, but it wories me...
-
-2. The code is currently able to handle one connection only,
-there is more work in register_cl2llc_client() to make a chain
-of llc structures and in mac_data_indicate() to find back
-the llc structure addressed by an incoming frame.
-According to IEEE, connections are identified by (remote mac + local mac
-+ dsap + ssap). dsap and ssap do not seem important: existing applications
-always use the same dsap/ssap. Its probably sufficient to index on 
-the remote mac only. 
- 
-3. There is no test to see if the transmit window is full in data_request()
-as described in the doc p73, "7.5.1 Sending I PDUs" 3th alinea.
-The pdus presented to data_request() could probably go on the 
-awaiting-transmit-queue (atq). The real difficulty is coding a test
-to see if the transmit window is used up and to send the queue
-when space in the window becomes available.
-As I have no network layer that can generate a continous flow of pdus it is
-difficult to simulate a remote busy condition and hence to test the code
-to handle it.
- 
-4. A simple flow control algorithm, steering the size of the transmit
-window would be nice to have.
diff -ruN linux-2.4.4/net/802/cl2llc.c linux/net/802/cl2llc.c
--- linux-2.4.4/net/802/cl2llc.c	Fri Apr  6 10:51:19 2001
+++ linux/net/802/cl2llc.c	Wed Dec 31 16:00:00 1969
@@ -1,615 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of 
- *		state machines and callbacks for higher networking layers.
- *
- *		Class 2 llc algorithm.
- *		Pseudocode interpreter, transition table lookup,
- *			data_request & indicate primitives...
- *
- *		Code for initialization, termination, registration and 
- *		MAC layer glue.
- *
- *		Copyright Tim Alpaerts, 
- *			<Tim_Alpaerts@toyota-motor-europe.com>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed into Linux format
- *					Modified to use llc_ names
- *					Changed callbacks
- *
- *	This file must be processed by sed before it can be compiled.
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <net/p8022.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <asm/byteorder.h>
-
-#include "pseudo/pseudocode.h"
-#include "transit/pdutr.h"
-#include "transit/timertr.h"
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-/*
- *	Data_request() is called by the client to present a data unit
- *	to the llc for transmission.
- *	In the future this function should also check if the transmit window
- *	allows the sending of another pdu, and if not put the skb on the atq
- *	for deferred sending.
- */
-
-int llc_data_request(llcptr lp, struct sk_buff *skb)
-{
-	if (skb_headroom(skb) < (lp->dev->hard_header_len +4)){
-		printk("cl2llc: data_request() not enough headroom in skb\n");
-		return -1;
-	};
-
-	skb_push(skb, 4);
-
-	if ((lp->state != NORMAL) && (lp->state != BUSY) && (lp->state != REJECT))
-	{
-		printk("cl2llc: data_request() while no llc connection\n"); 
-		return -1;  
-	}
-
-	if (lp->remote_busy)
-	{     /* if the remote llc is BUSY, */
-		ADD_TO_ATQ(skb);      /* save skb in the await transmit queue */
-		return 0;
-	}                           
-	else
-	{
-		/*
-		 *	Else proceed with xmit 
-		 */
-
-		switch(lp->state)
-		{
-			case NORMAL:
-				if(lp->p_flag)
-					llc_interpret_pseudo_code(lp, NORMAL2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, NORMAL1, skb, NO_FRAME);
-				break;
-			case BUSY:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, BUSY2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, BUSY1, skb, NO_FRAME);
-				break;
-			case REJECT:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, REJECT2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, REJECT1, skb, NO_FRAME);
-				break;
-			default:;
-		}
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		return 0;  
-	}              
-}
-
-
-
-/* 
- *	Disconnect_request() requests that the llc to terminate a connection
- */
-
-void disconnect_request(llcptr lp)
-{
-	if ((lp->state == NORMAL) ||
-    		(lp->state == BUSY) ||
-		(lp->state == REJECT) ||
-		(lp->state == AWAIT) ||
-		(lp->state == AWAIT_BUSY) ||
-		(lp->state == AWAIT_REJECT))
-	{
-		lp->state = D_CONN;
-		llc_interpret_pseudo_code(lp, SH1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Connect_request() requests that the llc to start a connection
- */
-
-void connect_request(llcptr lp)
-{
-	if (lp->state == ADM)
-	{
-		lp->state = SETUP;
-		llc_interpret_pseudo_code(lp, ADM1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Interpret_pseudo_code() executes the actions in the connection component
- *	state transition table. Table 4 in document on p88.
- *
- *	If this function is called to handle an incoming pdu, skb will point
- *	to the buffer with the pdu and type will contain the decoded pdu type.
- *
- *	If called by data_request skb points to an skb that was skb_alloc-ed by 
- *	the llc client to hold the information unit to be transmitted, there is
- *	no valid type in this case.  
- *
- *	If called because a timer expired no skb is passed, and there is no 
- *	type.
- */
-
-void llc_interpret_pseudo_code(llcptr lp, int pc_label, struct sk_buff *skb, 
-		char type)
-{    
-	short int pc;	/* program counter in pseudo code array */ 
-	char p_flag_received;
-	frameptr fr;
-	int resend_count;   /* number of pdus resend by llc_resend_ipdu() */
-	int ack_count;      /* number of pdus acknowledged */
-	struct sk_buff *skb2;
-
-	if (skb != NULL) 
-	{
-		fr = (frameptr) skb->data;
-	}
-	else
-		fr = NULL;
-
-	pc = pseudo_code_idx[pc_label];
-	while(pseudo_code[pc])
-	{
-		switch(pseudo_code[pc])
-		{
-			case 9:
-				if ((type != I_CMD) || (fr->i_hdr.i_pflag == 0))
-					break;
-			case 1:
-				lp->remote_busy = 0;
-				llc_stop_timer(lp, BUSY_TIMER);
-				if ((lp->state == NORMAL) ||
-					(lp->state == REJECT) ||
-					(lp->state == BUSY))
-				{
-					skb2 = llc_pull_from_atq(lp);
-					if (skb2 != NULL) 
-						llc_start_timer(lp, ACK_TIMER);
-					while (skb2 != NULL)
-					{
-						llc_sendipdu( lp, I_CMD, 0, skb2);
-						skb2 = llc_pull_from_atq(lp);
-					}
-				}	   
-				break;
-			case 2:
-				lp->state = NORMAL;  /* needed to eliminate connect_response() */
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_INDICATION;
-				break;
-			case 3:
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_CONFIRM;
-				break;
-			case 4:
-				skb_pull(skb, 4);
-				lp->inc_skb=skb;
-				lp->llc_callbacks|=LLC_DATA_INDIC;
-				break;
-			case 5:
-				lp->llc_mode = MODE_ADM;
-				lp->llc_callbacks|=LLC_DISC_INDICATION;
-				break;
-			case 70:
-				lp->llc_callbacks|=LLC_RESET_INDIC_LOC;
-				break;
-			case 71:
-				lp->llc_callbacks|=LLC_RESET_INDIC_REM;
-				break;
-			case 7:
-				lp->llc_callbacks|=LLC_RST_CONFIRM;
-				break;
-			case 66:
-				lp->llc_callbacks|=LLC_FRMR_RECV;
-				break;
-			case 67:
-				lp->llc_callbacks|=LLC_FRMR_SENT;
-				break;
-			case 68:
-				lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				break;
-			case 69:
-				lp->llc_callbacks|=LLC_REMOTE_NOTBUSY;
-				break;
-			case 11:
-				llc_sendpdu(lp, DISC_CMD, lp->f_flag, 0, NULL);
-				break;
-			case 12:
-				llc_sendpdu(lp, DM_RSP, 0, 0, NULL);
-				break;
-			case 13:                        
-				lp->frmr_info_fld.cntl1 = fr->pdu_cntl.byte1;
-				lp->frmr_info_fld.cntl2 = fr->pdu_cntl.byte2;
-				lp->frmr_info_fld.vs = lp->vs;
-				lp->frmr_info_fld.vr_cr = lp->vr;
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case 14:
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case 15:
-				llc_sendpdu(lp, FRMR_RSP, lp->p_flag,
-					5, (char *) &lp->frmr_info_fld);
-				break;
-			case 16:
-				llc_sendipdu(lp, I_CMD, 1, skb);   
-				break;
-			case 17:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				break;
-			case 18:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				}    
-				break;
-			case 19:
-				llc_sendipdu(lp, I_CMD, 0, skb);   
-				break;
-			case 20:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				break;
-			case 21:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				}    
-				break;
-			case 22:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_RSP, 1);
-				break;
-			case 23:
-				llc_sendpdu(lp, REJ_CMD, 1, 0, NULL);
-				break;
-			case 24:
-				llc_sendpdu(lp, REJ_RSP, 1, 0, NULL);
-				break;
-			case 25:
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, REJ_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, REJ_RSP, 0, 0, NULL);
-				break;
-			case 26:
-				llc_sendpdu(lp, RNR_CMD, 1, 0, NULL);
-				break;
-			case 27:
-				llc_sendpdu(lp, RNR_RSP, 1, 0, NULL);
-				break;
-			case 28:
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case 29:
-				if (lp->remote_busy == 0)
-				{
-					lp->remote_busy = 1;
-					llc_start_timer(lp, BUSY_TIMER);
-					lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				}
-				else if (lp->timer_state[BUSY_TIMER] == TIMER_IDLE)
-				{
-					llc_start_timer(lp, BUSY_TIMER);
-				}
-				break;
-			case 30:
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case 31:
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case 32:
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case 33:
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case 34:
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case 35:
-				llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case 36:
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case 37:
-				llc_sendpdu(lp, SABME_CMD, 0, 0, NULL);
-				lp->f_flag = 0;
-				break;
-			case 38:
-				llc_sendpdu(lp, UA_RSP, lp->f_flag, 0, NULL);
-				break;
-			case 39:
-				lp->s_flag = 0;
-				break;
-			case 40:
-				lp->s_flag = 1;
-				break;
-			case 41:
-				if(lp->timer_state[P_TIMER] == TIMER_RUNNING)
-					llc_stop_timer(lp, P_TIMER);
-				llc_start_timer(lp, P_TIMER);
-				if (lp->p_flag == 0)
-				{
-					lp->retry_count = 0;
-					lp->p_flag = 1;
-				}
-				break;
-			case 44:
-				if (lp->timer_state[ACK_TIMER] == TIMER_IDLE)
-					llc_start_timer(lp, ACK_TIMER);
-				break;
-			case 42:
-				llc_start_timer(lp, ACK_TIMER);
-				break;
-			case 43:
-				llc_start_timer(lp, REJ_TIMER);
-				break;
-			case 45:
-				llc_stop_timer(lp, ACK_TIMER);
-				break;
-			case 46:
-				llc_stop_timer(lp, ACK_TIMER);
-				lp->p_flag = 0;
-				break;
-			case 10:
-				if (lp->data_flag == 2)
-					llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case 47:
-				llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case 48:
-				llc_stop_timer(lp, ACK_TIMER);
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case 49:
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case 50:             
-				ack_count = llc_free_acknowledged_skbs(lp,
-					(unsigned char) fr->s_hdr.nr);
-				if (ack_count > 0)
-				{
-					lp->retry_count = 0;
-					llc_stop_timer(lp, ACK_TIMER);  
-					if (skb_peek(&lp->rtq) != NULL)
-					{
-						/*
- 						 *	Re-transmit queue not empty 
-						 */
-						llc_start_timer(lp, ACK_TIMER);  
-					}
-				}        
-				break;
-			case 51:
-				if (IS_UFRAME(fr)) 
-					p_flag_received = fr->u_hdr.u_pflag;
-				else
-					p_flag_received = fr->i_hdr.i_pflag;
-				if ((fr->pdu_hdr.ssap & 0x01) && (p_flag_received))
-				{
-					lp->p_flag = 0;
-					llc_stop_timer(lp, P_TIMER);  
-				}
-				break;
-			case 52:
-				lp->data_flag = 2;
-				break;
-			case 53:
-				lp->data_flag = 0;
-				break;
-			case 54:
-				lp->data_flag = 1;
-				break;
-			case 55:
-				if (lp->data_flag == 0)
-					lp->data_flag = 1;
-				break;
-			case 56:
-				lp->p_flag = 0;
-				break;
-			case 57:
-				lp->p_flag = lp->f_flag;
-				break;
-			case 58:
-				lp->remote_busy = 0;
-				break;
-			case 59:
-				lp->retry_count = 0;
-				break;
-			case 60:
-				lp->retry_count++;
-				break;
-			case 61:
-				lp->vr = 0;
-				break;
-			case 62:
-				lp->vr++;
-				break;
-			case 63:
-				lp->vs = 0;
-				break;
-			case 64:
-				lp->vs = fr->i_hdr.nr;
-				break;
-			case 65:
-				if (IS_UFRAME(fr)) 
-					lp->f_flag = fr->u_hdr.u_pflag;
-				else
-					lp->f_flag = fr->i_hdr.i_pflag;
-				break;
-			default:;
-		}
-		pc++;	
-	}
-}
-
-
-/*
- *	Process_otype2_frame will handle incoming frames
- *	for 802.2 Type 2 Procedure.
- */
-
-void llc_process_otype2_frame(llcptr lp, struct sk_buff *skb, char type)
-{
-	int idx;		/*	index in transition table */
-	int pc_label;		/*	action to perform, from tr tbl */
-	int validation;		/*	result of validate_seq_nos */
-	int p_flag_received;	/*	p_flag in received frame */
-	frameptr fr;
-
-	fr = (frameptr) skb->data;
-
-	if (IS_UFRAME(fr))
-		p_flag_received = fr->u_hdr.u_pflag;
-	else
-		p_flag_received = fr->i_hdr.i_pflag;
-
-	switch(lp->state)
-	{
-		/*	Compute index in transition table: */
-		case ADM:
-			idx = type;
-			idx = (idx << 1) + p_flag_received;
-			break;
-		case CONN:
-		case RESET_WAIT:
-		case RESET_CHECK:
-		case ERROR:
-			idx = type;
-			break;
-		case SETUP:
-		case RESET:
-		case D_CONN:
-			idx = type;
-			idx = (idx << 1) + lp->p_flag;
-			break;
-		case NORMAL:
-		case BUSY:
-		case REJECT:
-		case AWAIT:
-		case AWAIT_BUSY:
-		case AWAIT_REJECT:
-			validation = llc_validate_seq_nos(lp, fr);
-			if (validation > 3) 
-				type = BAD_FRAME;
-			idx = type;
-			idx = (idx << 1);
-			if (validation & 1) 
-				idx = idx +1;
-			idx = (idx << 1) + p_flag_received;
-			idx = (idx << 1) + lp->p_flag;
-		default:
-			printk("llc_proc: bad state\n");
-			return;
-	}
-	idx = (idx << 1) + pdutr_offset[lp->state];
-	lp->state = pdutr_entry[idx +1]; 
-	pc_label = pdutr_entry[idx];
-	if (pc_label != 0)
-	{ 
-		llc_interpret_pseudo_code(lp, pc_label, skb, type);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may no longer be valid after this point. Be
-		 *	careful what is added!
-		 */
-	}
-}
-
-
-void llc_timer_expired(llcptr lp, int t)
-{
-	int idx;		/* index in transition table	*/
-	int pc_label;       	/* action to perform, from tr tbl */
-
-	lp->timer_state[t] = TIMER_EXPIRED;
-	idx = lp->state;            /* Compute index in transition table: */
-	idx = (idx << 2) + t;
-	idx = idx << 1;
-	if (lp->retry_count >= lp->n2) 
-		idx = idx + 1;
-	idx = (idx << 1) + lp->s_flag;
-	idx = (idx << 1) + lp->p_flag;
-	idx = idx << 1;             /* 2 bytes per entry: action & newstate */
-
-	pc_label = timertr_entry[idx];
-	if (pc_label != 0)
-	{
-		llc_interpret_pseudo_code(lp, pc_label, NULL, NO_FRAME);
-		lp->state = timertr_entry[idx +1];
-	}
-	lp->timer_state[t] = TIMER_IDLE;
-	if(lp->llc_callbacks)
-	{
-		lp->llc_event(lp);
-		lp->llc_callbacks=0;
-	}
-	/*
- 	 *	And lp may have vanished in the event callback
- 	 */
-}
-
diff -ruN linux-2.4.4/net/802/cl2llc.pre linux/net/802/cl2llc.pre
--- linux-2.4.4/net/802/cl2llc.pre	Fri Apr  6 10:51:19 2001
+++ linux/net/802/cl2llc.pre	Wed Dec 31 16:00:00 1969
@@ -1,615 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of 
- *		state machines and callbacks for higher networking layers.
- *
- *		Class 2 llc algorithm.
- *		Pseudocode interpreter, transition table lookup,
- *			data_request & indicate primitives...
- *
- *		Code for initialization, termination, registration and 
- *		MAC layer glue.
- *
- *		Copyright Tim Alpaerts, 
- *			<Tim_Alpaerts@toyota-motor-europe.com>
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed into Linux format
- *					Modified to use llc_ names
- *					Changed callbacks
- *
- *	This file must be processed by sed before it can be compiled.
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/malloc.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <net/p8022.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <asm/byteorder.h>
-
-#include "pseudo/pseudocode.h"
-#include "transit/pdutr.h"
-#include "transit/timertr.h"
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-/*
- *	Data_request() is called by the client to present a data unit
- *	to the llc for transmission.
- *	In the future this function should also check if the transmit window
- *	allows the sending of another pdu, and if not put the skb on the atq
- *	for deferred sending.
- */
-
-int llc_data_request(llcptr lp, struct sk_buff *skb)
-{
-	if (skb_headroom(skb) < (lp->dev->hard_header_len +4)){
-		printk("cl2llc: data_request() not enough headroom in skb\n");
-		return -1;
-	};
-
-	skb_push(skb, 4);
-
-	if ((lp->state != NORMAL) && (lp->state != BUSY) && (lp->state != REJECT))
-	{
-		printk("cl2llc: data_request() while no llc connection\n"); 
-		return -1;  
-	}
-
-	if (lp->remote_busy)
-	{     /* if the remote llc is BUSY, */
-		ADD_TO_ATQ(skb);      /* save skb in the await transmit queue */
-		return 0;
-	}                           
-	else
-	{
-		/*
-		 *	Else proceed with xmit 
-		 */
-
-		switch(lp->state)
-		{
-			case NORMAL:
-				if(lp->p_flag)
-					llc_interpret_pseudo_code(lp, NORMAL2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, NORMAL1, skb, NO_FRAME);
-				break;
-			case BUSY:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, BUSY2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, BUSY1, skb, NO_FRAME);
-				break;
-			case REJECT:
-				if (lp->p_flag)
-					llc_interpret_pseudo_code(lp, REJECT2, skb, NO_FRAME);
-				else
-					llc_interpret_pseudo_code(lp, REJECT1, skb, NO_FRAME);
-				break;
-			default:
-		}
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		return 0;  
-	}              
-}
-
-
-
-/* 
- *	Disconnect_request() requests that the llc to terminate a connection
- */
-
-void disconnect_request(llcptr lp)
-{
-	if ((lp->state == NORMAL) ||
-    		(lp->state == BUSY) ||
-		(lp->state == REJECT) ||
-		(lp->state == AWAIT) ||
-		(lp->state == AWAIT_BUSY) ||
-		(lp->state == AWAIT_REJECT))
-	{
-		lp->state = D_CONN;
-		llc_interpret_pseudo_code(lp, SH1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Connect_request() requests that the llc to start a connection
- */
-
-void connect_request(llcptr lp)
-{
-	if (lp->state == ADM)
-	{
-		lp->state = SETUP;
-		llc_interpret_pseudo_code(lp, ADM1, NULL, NO_FRAME);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may be invalid after the callback
-		 */
-	}
-}
-
-
-/*
- *	Interpret_pseudo_code() executes the actions in the connection component
- *	state transition table. Table 4 in document on p88.
- *
- *	If this function is called to handle an incoming pdu, skb will point
- *	to the buffer with the pdu and type will contain the decoded pdu type.
- *
- *	If called by data_request skb points to an skb that was skb_alloc-ed by 
- *	the llc client to hold the information unit to be transmitted, there is
- *	no valid type in this case.  
- *
- *	If called because a timer expired no skb is passed, and there is no 
- *	type.
- */
-
-void llc_interpret_pseudo_code(llcptr lp, int pc_label, struct sk_buff *skb, 
-		char type)
-{    
-	short int pc;	/* program counter in pseudo code array */ 
-	char p_flag_received;
-	frameptr fr;
-	int resend_count;   /* number of pdus resend by llc_resend_ipdu() */
-	int ack_count;      /* number of pdus acknowledged */
-	struct sk_buff *skb2;
-
-	if (skb != NULL) 
-	{
-		fr = (frameptr) skb->data;
-	}
-	else
-		fr = NULL;
-
-	pc = pseudo_code_idx[pc_label];
-	while(pseudo_code[pc])
-	{
-		switch(pseudo_code[pc])
-		{
-			case IF_F=1_CLEAR_REMOTE_BUSY:
-				if ((type != I_CMD) || (fr->i_hdr.i_pflag == 0))
-					break;
-			case CLEAR_REMOTE_BUSY:
-				lp->remote_busy = 0;
-				llc_stop_timer(lp, BUSY_TIMER);
-				if ((lp->state == NORMAL) ||
-					(lp->state == REJECT) ||
-					(lp->state == BUSY))
-				{
-					skb2 = llc_pull_from_atq(lp);
-					if (skb2 != NULL) 
-						llc_start_timer(lp, ACK_TIMER);
-					while (skb2 != NULL)
-					{
-						llc_sendipdu( lp, I_CMD, 0, skb2);
-						skb2 = llc_pull_from_atq(lp);
-					}
-				}	   
-				break;
-			case CONNECT_INDICATION:
-				lp->state = NORMAL;  /* needed to eliminate connect_response() */
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_INDICATION;
-				break;
-			case CONNECT_CONFIRM:
-				lp->llc_mode = MODE_ABM;
-				lp->llc_callbacks|=LLC_CONN_CONFIRM;
-				break;
-			case DATA_INDICATION:
-				skb_pull(skb, 4);
-				lp->inc_skb=skb;
-				lp->llc_callbacks|=LLC_DATA_INDIC;
-				break;
-			case DISCONNECT_INDICATION:
-				lp->llc_mode = MODE_ADM;
-				lp->llc_callbacks|=LLC_DISC_INDICATION;
-				break;
-			case RESET_INDICATION(LOCAL):
-				lp->llc_callbacks|=LLC_RESET_INDIC_LOC;
-				break;
-			case RESET_INDICATION(REMOTE):
-				lp->llc_callbacks|=LLC_RESET_INDIC_REM;
-				break;
-			case RESET_CONFIRM:
-				lp->llc_callbacks|=LLC_RST_CONFIRM;
-				break;
-			case REPORT_STATUS(FRMR_RECEIVED):
-				lp->llc_callbacks|=LLC_FRMR_RECV;
-				break;
-			case REPORT_STATUS(FRMR_SENT):
-				lp->llc_callbacks|=LLC_FRMR_SENT;
-				break;
-			case REPORT_STATUS(REMOTE_BUSY):
-				lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				break;
-			case REPORT_STATUS(REMOTE_NOT_BUSY):
-				lp->llc_callbacks|=LLC_REMOTE_NOTBUSY;
-				break;
-			case SEND_DISC_CMD(P=X):
-				llc_sendpdu(lp, DISC_CMD, lp->f_flag, 0, NULL);
-				break;
-			case SEND_DM_RSP(F=X):
-				llc_sendpdu(lp, DM_RSP, 0, 0, NULL);
-				break;
-			case SEND_FRMR_RSP(F=X):                        
-				lp->frmr_info_fld.cntl1 = fr->pdu_cntl.byte1;
-				lp->frmr_info_fld.cntl2 = fr->pdu_cntl.byte2;
-				lp->frmr_info_fld.vs = lp->vs;
-				lp->frmr_info_fld.vr_cr = lp->vr;
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case RE-SEND_FRMR_RSP(F=0):
-				llc_sendpdu(lp, FRMR_RSP, 0, 5, (char *) &lp->frmr_info_fld);
-				break;
-			case RE-SEND_FRMR_RSP(F=P):
-				llc_sendpdu(lp, FRMR_RSP, lp->p_flag,
-					5, (char *) &lp->frmr_info_fld);
-				break;
-			case SEND_I_CMD(P=1):
-				llc_sendipdu(lp, I_CMD, 1, skb);   
-				break;
-			case RE-SEND_I_CMD(P=1):
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				break;
-			case RE-SEND_I_CMD(P=1)_OR_SEND_RR:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 1);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				}    
-				break;
-			case SEND_I_XXX(X=0):
-				llc_sendipdu(lp, I_CMD, 0, skb);   
-				break;
-			case RE-SEND_I_XXX(X=0):
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				break;
-			case RE-SEND_I_XXX(X=0)_OR_SEND_RR:
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_CMD, 0);
-				if (resend_count == 0) 
-				{
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				}    
-				break;
-			case RE-SEND_I_RSP(F=1):
-				resend_count = llc_resend_ipdu(lp, fr->i_hdr.nr, I_RSP, 1);
-				break;
-			case SEND_REJ_CMD(P=1):
-				llc_sendpdu(lp, REJ_CMD, 1, 0, NULL);
-				break;
-			case SEND_REJ_RSP(F=1):
-				llc_sendpdu(lp, REJ_RSP, 1, 0, NULL);
-				break;
-			case SEND_REJ_XXX(X=0):
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, REJ_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, REJ_RSP, 0, 0, NULL);
-				break;
-			case SEND_RNR_CMD(F=1):
-				llc_sendpdu(lp, RNR_CMD, 1, 0, NULL);
-				break;
-			case SEND_RNR_RSP(F=1):
-				llc_sendpdu(lp, RNR_RSP, 1, 0, NULL);
-				break;
-			case SEND_RNR_XXX(X=0):
-				if (IS_RSP(fr))
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case SET_REMOTE_BUSY:
-				if (lp->remote_busy == 0)
-				{
-					lp->remote_busy = 1;
-					llc_start_timer(lp, BUSY_TIMER);
-					lp->llc_callbacks|=LLC_REMOTE_BUSY;
-				}
-				else if (lp->timer_state[BUSY_TIMER] == TIMER_IDLE)
-				{
-					llc_start_timer(lp, BUSY_TIMER);
-				}
-				break;
-			case OPTIONAL_SEND_RNR_XXX(X=0):
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RNR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RNR_RSP, 0, 0, NULL);
-				break;
-			case SEND_RR_CMD(P=1):
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case SEND_ACKNOWLEDGE_CMD(P=1):
-				llc_sendpdu(lp, RR_CMD, 1, 0, NULL);
-				break;
-			case SEND_RR_RSP(F=1):
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case SEND_ACKNOWLEDGE_RSP(F=1):
-				llc_sendpdu(lp, RR_RSP, 1, 0, NULL);
-				break;
-			case SEND_RR_XXX(X=0):
-				llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case SEND_ACKNOWLEDGE_XXX(X=0):
-				if (IS_RSP(fr)) 
-					llc_sendpdu(lp, RR_CMD, 0, 0, NULL);
-				else
-					llc_sendpdu(lp, RR_RSP, 0, 0, NULL);
-				break;
-			case SEND_SABME_CMD(P=X):
-				llc_sendpdu(lp, SABME_CMD, 0, 0, NULL);
-				lp->f_flag = 0;
-				break;
-			case SEND_UA_RSP(F=X):
-				llc_sendpdu(lp, UA_RSP, lp->f_flag, 0, NULL);
-				break;
-			case S_FLAG:=0:
-				lp->s_flag = 0;
-				break;
-			case S_FLAG:=1:
-				lp->s_flag = 1;
-				break;
-			case START_P_TIMER:
-				if(lp->timer_state[P_TIMER] == TIMER_RUNNING)
-					llc_stop_timer(lp, P_TIMER);
-				llc_start_timer(lp, P_TIMER);
-				if (lp->p_flag == 0)
-				{
-					lp->retry_count = 0;
-					lp->p_flag = 1;
-				}
-				break;
-			case START_ACK_TIMER_IF_NOT_RUNNING:
-				if (lp->timer_state[ACK_TIMER] == TIMER_IDLE)
-					llc_start_timer(lp, ACK_TIMER);
-				break;
-			case START_ACK_TIMER:
-				llc_start_timer(lp, ACK_TIMER);
-				break;
-			case START_REJ_TIMER:
-				llc_start_timer(lp, REJ_TIMER);
-				break;
-			case STOP_ACK_TIMER:
-				llc_stop_timer(lp, ACK_TIMER);
-				break;
-			case STOP_P_TIMER:
-				llc_stop_timer(lp, ACK_TIMER);
-				lp->p_flag = 0;
-				break;
-			case IF_DATA_FLAG=2_STOP_REJ_TIMER:
-				if (lp->data_flag == 2)
-					llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case STOP_REJ_TIMER:
-				llc_stop_timer(lp, REJ_TIMER);
-				break;
-			case STOP_ALL_TIMERS:
-				llc_stop_timer(lp, ACK_TIMER);
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case STOP_OTHER_TIMERS:
-				llc_stop_timer(lp, P_TIMER);
-				llc_stop_timer(lp, REJ_TIMER);
-				llc_stop_timer(lp, BUSY_TIMER);
-				break;
-			case UPDATE_N(R)_RECEIVED:             
-				ack_count = llc_free_acknowledged_skbs(lp,
-					(unsigned char) fr->s_hdr.nr);
-				if (ack_count > 0)
-				{
-					lp->retry_count = 0;
-					llc_stop_timer(lp, ACK_TIMER);  
-					if (skb_peek(&lp->rtq) != NULL)
-					{
-						/*
- 						 *	Re-transmit queue not empty 
-						 */
-						llc_start_timer(lp, ACK_TIMER);  
-					}
-				}        
-				break;
-			case UPDATE_P_FLAG:
-				if (IS_UFRAME(fr)) 
-					p_flag_received = fr->u_hdr.u_pflag;
-				else
-					p_flag_received = fr->i_hdr.i_pflag;
-				if ((fr->pdu_hdr.ssap & 0x01) && (p_flag_received))
-				{
-					lp->p_flag = 0;
-					llc_stop_timer(lp, P_TIMER);  
-				}
-				break;
-			case DATA_FLAG:=2:
-				lp->data_flag = 2;
-				break;
-			case DATA_FLAG:=0:
-				lp->data_flag = 0;
-				break;
-			case DATA_FLAG:=1:
-				lp->data_flag = 1;
-				break;
-			case IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1:
-				if (lp->data_flag == 0)
-					lp->data_flag = 1;
-				break;
-			case P_FLAG:=0:
-				lp->p_flag = 0;
-				break;
-			case P_FLAG:=P:
-				lp->p_flag = lp->f_flag;
-				break;
-			case REMOTE_BUSY:=0:
-				lp->remote_busy = 0;
-				break;
-			case RETRY_COUNT:=0:
-				lp->retry_count = 0;
-				break;
-			case RETRY_COUNT:=RETRY_COUNT+1:
-				lp->retry_count++;
-				break;
-			case V(R):=0:
-				lp->vr = 0;
-				break;
-			case V(R):=V(R)+1:
-				lp->vr++;
-				break;
-			case V(S):=0:
-				lp->vs = 0;
-				break;
-			case V(S):=N(R):
-				lp->vs = fr->i_hdr.nr;
-				break;
-			case F_FLAG:=P:
-				if (IS_UFRAME(fr)) 
-					lp->f_flag = fr->u_hdr.u_pflag;
-				else
-					lp->f_flag = fr->i_hdr.i_pflag;
-				break;
-			default:
-		}
-		pc++;	
-	}
-}
-
-
-/*
- *	Process_otype2_frame will handle incoming frames
- *	for 802.2 Type 2 Procedure.
- */
-
-void llc_process_otype2_frame(llcptr lp, struct sk_buff *skb, char type)
-{
-	int idx;		/*	index in transition table */
-	int pc_label;		/*	action to perform, from tr tbl */
-	int validation;		/*	result of validate_seq_nos */
-	int p_flag_received;	/*	p_flag in received frame */
-	frameptr fr;
-
-	fr = (frameptr) skb->data;
-
-	if (IS_UFRAME(fr))
-		p_flag_received = fr->u_hdr.u_pflag;
-	else
-		p_flag_received = fr->i_hdr.i_pflag;
-
-	switch(lp->state)
-	{
-		/*	Compute index in transition table: */
-		case ADM:
-			idx = type;
-			idx = (idx << 1) + p_flag_received;
-			break;
-		case CONN:
-		case RESET_WAIT:
-		case RESET_CHECK:
-		case ERROR:
-			idx = type;
-			break;
-		case SETUP:
-		case RESET:
-		case D_CONN:
-			idx = type;
-			idx = (idx << 1) + lp->p_flag;
-			break;
-		case NORMAL:
-		case BUSY:
-		case REJECT:
-		case AWAIT:
-		case AWAIT_BUSY:
-		case AWAIT_REJECT:
-			validation = llc_validate_seq_nos(lp, fr);
-			if (validation > 3) 
-				type = BAD_FRAME;
-			idx = type;
-			idx = (idx << 1);
-			if (validation & 1) 
-				idx = idx +1;
-			idx = (idx << 1) + p_flag_received;
-			idx = (idx << 1) + lp->p_flag;
-		default:
-			printk("llc_proc: bad state\n");
-			return;
-	}
-	idx = (idx << 1) + pdutr_offset[lp->state];
-	lp->state = pdutr_entry[idx +1]; 
-	pc_label = pdutr_entry[idx];
-	if (pc_label != NOP)
-	{ 
-		llc_interpret_pseudo_code(lp, pc_label, skb, type);
-		if(lp->llc_callbacks)
-		{
-			lp->llc_event(lp);
-			lp->llc_callbacks=0;
-		}
-		/*
- 		 *	lp may no longer be valid after this point. Be
-		 *	careful what is added!
-		 */
-	}
-}
-
-
-void llc_timer_expired(llcptr lp, int t)
-{
-	int idx;		/* index in transition table	*/
-	int pc_label;       	/* action to perform, from tr tbl */
-
-	lp->timer_state[t] = TIMER_EXPIRED;
-	idx = lp->state;            /* Compute index in transition table: */
-	idx = (idx << 2) + t;
-	idx = idx << 1;
-	if (lp->retry_count >= lp->n2) 
-		idx = idx + 1;
-	idx = (idx << 1) + lp->s_flag;
-	idx = (idx << 1) + lp->p_flag;
-	idx = idx << 1;             /* 2 bytes per entry: action & newstate */
-
-	pc_label = timertr_entry[idx];
-	if (pc_label != NOP)
-	{
-		llc_interpret_pseudo_code(lp, pc_label, NULL, NO_FRAME);
-		lp->state = timertr_entry[idx +1];
-	}
-	lp->timer_state[t] = TIMER_IDLE;
-	if(lp->llc_callbacks)
-	{
-		lp->llc_event(lp);
-		lp->llc_callbacks=0;
-	}
-	/*
- 	 *	And lp may have vanished in the event callback
- 	 */
-}
-
diff -ruN linux-2.4.4/net/802/llc_macinit.c linux/net/802/llc_macinit.c
--- linux-2.4.4/net/802/llc_macinit.c	Fri Feb  9 11:34:13 2001
+++ linux/net/802/llc_macinit.c	Wed Dec 31 16:00:00 1969
@@ -1,214 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of
- *		state machines and callbacks for higher networking layers.
- *
- *		Code for initialization, termination, registration and
- *		MAC layer glue.
- *
- *		Written by Tim Alpaerts, Tim_Alpaerts@toyota-motor-europe.com
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed to Linux format
- *					Added llc_ to names
- *					Started restructuring handlers
- *
- *              Horst von Brand :      Add #include <linux/string.h>
- */
-
-#include <linux/module.h>
-#include <linux/version.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/unistd.h>
-#include <linux/string.h>
-#include <linux/netdevice.h>
-#include <linux/init.h>
-#include <net/p8022.h>
-
-#include <asm/byteorder.h>
-
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-/*
- *	All incoming frames pass thru mac_data_indicate().
- *	On entry the llc structure related to the frame is passed as parameter. 
- *	The received sk_buffs with pdus other than I_CMD and I_RSP
- *	are freed by mac_data_indicate() after processing,
- *	the I pdu buffers are freed by the cl2llc client when it no longer needs
- *	the skb.
-*/
-
-int llc_mac_data_indicate(llcptr lp, struct sk_buff *skb)
-{
-	int ll;      		/* logical length == 802.3 length field */
-	unsigned char p_flag;
-	unsigned char type;
-	frameptr fr;
-	int free=1;
-
-	lp->inc_skb=NULL;
-	
-	/*
-	 *	Truncate buffer to true 802.3 length
-	 *	[FIXME: move to 802.2 demux]
-	 */
-
-	ll = *(skb->data -2) * 256 + *(skb->data -1);
-	skb_trim( skb, ll );
-
-	fr = (frameptr) skb->data;
-	type = llc_decode_frametype( fr );
-
-
-	if (type <= FRMR_RSP)
-	{
-		/*
-		 *	PDU is of the type 2 set
-		 */
-		if ((lp->llc_mode == MODE_ABM)||(type == SABME_CMD))
-			llc_process_otype2_frame(lp, skb, type);
-
-	}
-	else
-	{
-		/*
-		 *	PDU belongs to type 1 set
-		 */
-	        p_flag = fr->u_hdr.u_pflag;
-        	switch(type)
-        	{
-		        case TEST_CMD:
-				llc_sendpdu(lp, TEST_RSP, 0,ll -3,
-					fr->u_hdr.u_info);
-				break;
-			case TEST_RSP:
-				lp->llc_callbacks|=LLC_TEST_INDICATION;
-				lp->inc_skb=skb;
-				free=0;
-				break;
-			case XID_CMD:
-				/*
-				 *	Basic format XID is handled by LLC itself
-				 *	Doc 5.4.1.1.2 p 48/49
-				 */
-
-				if ((ll == 6)&&(fr->u_hdr.u_info[0] == 0x81))
-				{
-					lp->k = fr->u_hdr.u_info[2];
-					llc_sendpdu(lp, XID_RSP,
-						fr->u_hdr.u_pflag, ll -3,
-						fr->u_hdr.u_info);
-				}
-				break;
-
-			case XID_RSP:
-				if( ll == 6 && fr->u_hdr.u_info[0] == 0x81 )
-				{
-					lp->k = fr->u_hdr.u_info[2];
-				}
-				lp->llc_callbacks|=LLC_XID_INDICATION;
-				lp->inc_skb=skb;
-				free=0;
-				break;
-
-			case UI_CMD:
-				lp->llc_callbacks|=LLC_UI_DATA;
-				skb_pull(skb,3);
-				lp->inc_skb=skb;
-				free=0;
-				break;
-
-			default:;
-				/*
-				 *	All other type 1 pdus ignored for now
-				 */
-		}
-	}
-
-	if (free&&(!(IS_IFRAME(fr))))
-	{
-		/*
-		 *	No auto free for I pdus
-		 */
-		skb->sk = NULL;
-		kfree_skb(skb);
-	}
-
-	if(lp->llc_callbacks)
-	{
-		if ( lp->llc_event != NULL ) lp->llc_event(lp);
-		lp->llc_callbacks=0;
-	}
-	return 0;
-}
-
-
-/*
- *	Create an LLC client. As it is the job of the caller to clean up
- *	LLC's on device down, the device list must be locked before this call.
- */
-
-int register_cl2llc_client(llcptr lp, const char *device, void (*event)(llcptr), u8 *rmac, u8 ssap, u8 dsap)
-{
-	char eye_init[] = "LLC\0";
-
-	memset(lp, 0, sizeof(*lp));
-	lp->dev = __dev_get_by_name(device);
-	if(lp->dev == NULL)
-		return -ENODEV;
-	memcpy(lp->eye, eye_init, sizeof(lp->eye));
-	lp->rw = 1;
-	lp->k = 127;
-	lp->n1 = 1490;
-	lp->n2 = 10;
-	lp->timer_interval[P_TIMER] = HZ;    /* 1 sec */
-	lp->timer_interval[REJ_TIMER] = HZ/8;
-	lp->timer_interval[ACK_TIMER] = HZ/8;
-	lp->timer_interval[BUSY_TIMER] = HZ*2;
-	lp->local_sap = ssap;
-	lp->llc_event = event;
-	memcpy(lp->remote_mac, rmac, sizeof(lp->remote_mac));
-	lp->state = 0;
-	lp->llc_mode = MODE_ADM;
-	lp->remote_sap = dsap;
-	skb_queue_head_init(&lp->atq);
-	skb_queue_head_init(&lp->rtq);
-	MOD_INC_USE_COUNT;
-	return 0;
-}
-
-
-void unregister_cl2llc_client(llcptr lp)
-{
-	llc_cancel_timers(lp);
-	MOD_DEC_USE_COUNT;
-	kfree(lp);
-}
-
-
-EXPORT_SYMBOL(register_cl2llc_client);
-EXPORT_SYMBOL(unregister_cl2llc_client);
-EXPORT_SYMBOL(llc_data_request);
-EXPORT_SYMBOL(llc_unit_data_request);
-EXPORT_SYMBOL(llc_test_request);
-EXPORT_SYMBOL(llc_xid_request);
-EXPORT_SYMBOL(llc_mac_data_indicate);
-EXPORT_SYMBOL(llc_cancel_timers);
-
-#define ALL_TYPES_8022 0
-
-static int __init llc_init(void)
-{
-	printk(KERN_NOTICE "IEEE 802.2 LLC for Linux 2.1 (c) 1996 Tim Alpaerts\n");
-	return 0;
-}
-
-
-module_init(llc_init);
diff -ruN linux-2.4.4/net/802/llc_sendpdu.c linux/net/802/llc_sendpdu.c
--- linux-2.4.4/net/802/llc_sendpdu.c	Fri Apr  6 10:51:19 2001
+++ linux/net/802/llc_sendpdu.c	Wed Dec 31 16:00:00 1969
@@ -1,357 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of 
- *		state machines and callbacks for higher networking layers.
- *
- *		llc_sendpdu(), llc_sendipdu(), resend() + queue handling code
- *
- *		Written by Tim Alpaerts, Tim_Alpaerts@toyota-motor-europe.com
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed into Linux format, style
- *					Added llc_ to function names
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <net/p8022.h>
-#include <linux/stat.h>
-#include <asm/byteorder.h>
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-static unsigned char cntl_byte_encode[] = 
-{
-	0x00,   /* I_CMD */
-	0x01,   /* RR_CMD */
-	0x05,   /* RNR_CMD */
-	0x09,   /* REJ_CMD */
-	0x43,   /* DISC_CMD */
-	0x7F,   /* SABME_CMD */
-	0x00,   /* I_RSP */
-	0x01,   /* RR_RSP */
-	0x05,   /* RNR_RSP */
-	0x09,   /* REJ_RSP */
-	0x63,   /* UA_RSP */
-	0x0F,   /* DM_RSP */
-	0x87,   /* FRMR_RSP */
-	0xFF,   /* BAD_FRAME */
-	0x03,   /* UI_CMD */
-	0xBF,   /* XID_CMD */
-	0xE3,   /* TEST_CMD */
-	0xBF,   /* XID_RSP */
-	0xE3    /* TEST_RSP */
-};
-
-static unsigned char fr_length_encode[] = 
-{
-	0x04,   /* I_CMD */
-	0x04,   /* RR_CMD */
-	0x04,   /* RNR_CMD */
-	0x04,   /* REJ_CMD */
-	0x03,   /* DISC_CMD */
-	0x03,   /* SABME_CMD */
-	0x04,   /* I_RSP */
-	0x04,   /* RR_RSP */
-	0x04,   /* RNR_RSP */
-	0x04,   /* REJ_RSP */
-	0x03,   /* UA_RSP */
-	0x03,   /* DM_RSP */
-	0x03,   /* FRMR_RSP */
-	0x00,   /* BAD_FRAME */
-	0x03,   /* UI_CMD */
-	0x03,   /* XID_CMD */
-	0x03,   /* TEST_CMD */
-	0x03,   /* XID_RSP */
-	0x03    /* TEST_RSP */
-};
-
-static unsigned char cr_bit_encode[] = {
-	0x00,   /* I_CMD */
-	0x00,   /* RR_CMD */
-	0x00,   /* RNR_CMD */
-	0x00,   /* REJ_CMD */
-	0x00,   /* DISC_CMD */
-	0x00,   /* SABME_CMD */
-	0x01,   /* I_RSP */
-	0x01,   /* RR_RSP */
-	0x01,   /* RNR_RSP */
-	0x01,   /* REJ_RSP */
-	0x01,   /* UA_RSP */
-	0x01,   /* DM_RSP */
-	0x01,   /* FRMR_RSP */
-	0x00,   /* BAD_FRAME */
-	0x00,   /* UI_CMD */
-	0x00,   /* XID_CMD */
-	0x00,   /* TEST_CMD */
-	0x01,   /* XID_RSP */
-	0x01    /* TEST_RSP */
-};
-
-/*
- *	Sendpdu() constructs an output frame in a new skb and
- *	gives it to the MAC layer for transmission.
- *	This function is not used to send I pdus.
- *	No queues are updated here, nothing is saved for retransmission.
- *
- *	Parameter pf controls both the poll/final bit and dsap
- *	fields in the output pdu. 
- *	The dsap trick was needed to implement XID_CMD send with
- *	zero dsap field as described in doc 6.6 item 1 of enum.  
- */
-
-void llc_sendpdu(llcptr lp, char type, char pf, int data_len, char *pdu_data)
-{
-	frameptr fr;                /* ptr to output pdu buffer */
-	unsigned short int fl;      /* frame length == 802.3 "length" value */
-	struct sk_buff *skb;
-
-	fl = data_len + fr_length_encode[(int)type];
-	skb = alloc_skb(16 + fl, GFP_ATOMIC); 
-	if (skb != NULL)
-	{
-		skb->dev = lp->dev;	
-	        skb_reserve(skb, 16);
-		fr = (frameptr) skb_put(skb, fl);
-		memset(fr, 0, fl);
-                /*
-                 *	Construct 802.2 header 
-                 */
-		if (pf & 0x02) 
-			fr->pdu_hdr.dsap = 0;
-		else
-			fr->pdu_hdr.dsap = lp->remote_sap;
-		fr->pdu_hdr.ssap = lp->local_sap + cr_bit_encode[(int)type];
-		fr->pdu_cntl.byte1 = cntl_byte_encode[(int)type];
-		/* 
-		 *	Fill in pflag and seq nbrs: 
-		 */
-		if (IS_SFRAME(fr)) 
-		{
-		  	/* case S-frames */
-			if (pf & 0x01) 
-				fr->i_hdr.i_pflag = 1;
-			fr->i_hdr.nr = lp->vr;
-		}
-		else
-		{
-			/* case U frames */ 
-			if (pf & 0x01) 
-				fr->u_hdr.u_pflag = 1;
-		}
-                       
-		if (data_len > 0) 
-		{ 			/* append data if any  */ 
-			if (IS_UFRAME(fr)) 
-			{
-				memcpy(fr->u_hdr.u_info, pdu_data, data_len);
-			}
-			else 
-			{
-				memcpy(fr->i_hdr.is_info, pdu_data, data_len);
-			}
-		}
-		lp->dev->hard_header(skb, lp->dev, ETH_P_802_3,
-			 lp->remote_mac, NULL, fl);
-		skb->dev=lp->dev;
-		dev_queue_xmit(skb);
-	}
-	else
-		printk(KERN_DEBUG "cl2llc: skb_alloc() in llc_sendpdu() failed\n");     
-}
-
-void llc_xid_request(llcptr lp, char opt, int ll, char * data)
-{
-	llc_sendpdu(lp, XID_CMD, opt, ll, data); 
-}
-
-void llc_test_request(llcptr lp, int ll, char * data)
-{
-	llc_sendpdu(lp, TEST_CMD, 0, ll, data); 
-}
-
-void llc_unit_data_request(llcptr lp, int ll, char * data)
-{
-	llc_sendpdu(lp, UI_CMD, 0, ll, data); 
-}
-
-
-/*
- *	llc_sendipdu() Completes an I pdu in an existing skb and gives it
- *	to the MAC layer for transmission.
- *	Parameter "type" must be either I_CMD or I_RSP.
- *	The skb is not freed after xmit, it is kept in case a retransmission
- *	is requested. If needed it can be picked up again from the rtq.
- */
-
-void llc_sendipdu(llcptr lp, char type, char pf, struct sk_buff *skb)
-{
-	frameptr fr;                /* ptr to output pdu buffer */
-	struct sk_buff *tmp;
-	
-	fr = (frameptr) skb->data;
-
-	fr->pdu_hdr.dsap = lp->remote_sap;
-	fr->pdu_hdr.ssap = lp->local_sap + cr_bit_encode[(int)type];
-	fr->pdu_cntl.byte1 = cntl_byte_encode[(int)type];
-			
-	if (pf)
-		fr->i_hdr.i_pflag = 1; /* p/f and seq numbers */  
-	fr->i_hdr.nr = lp->vr;
-	fr->i_hdr.ns = lp->vs;
-	lp->vs++;
-	if (lp->vs > 127) 
-		lp->vs = 0;
-	lp->dev->hard_header(skb, lp->dev, ETH_P_802_3,
-		lp->remote_mac, NULL, skb->len);
-	ADD_TO_RTQ(skb);		/* add skb to the retransmit queue */
-	tmp=skb_clone(skb, GFP_ATOMIC);
-	if(tmp!=NULL)
-	{
-		tmp->dev=lp->dev;
-		dev_queue_xmit(tmp);
-	}
-}
-
-
-/*
- *	Resend_ipdu() will resend the pdus in the retransmit queue (rtq)
- *	the return value is the number of pdus resend.
- *	ack_nr is N(R) of 1st pdu to resent.
- *	Type is I_CMD or I_RSP for 1st pdu resent.
- *	p is p/f flag 0 or 1 for 1st pdu resent.
- *	All subsequent pdus will be sent as I_CMDs with p/f set to 0
- */ 
-
-int llc_resend_ipdu(llcptr lp, unsigned char ack_nr, unsigned char type, char p)
-{
-	struct sk_buff *skb,*tmp;
-	int resend_count;
-	frameptr fr;
-	unsigned long flags;
-	
-
-	resend_count = 0;
-	
-	save_flags(flags);
-	cli();
-	
-	skb = skb_peek(&lp->rtq);
-
-	while(skb && skb != (struct sk_buff *)&lp->rtq)
-	{
-		fr = (frameptr) (skb->data + lp->dev->hard_header_len);
-		if (resend_count == 0) 
-		{
-			/* 
-			 *	Resending 1st pdu: 
-			 */
-
-			if (p) 
-				fr->i_hdr.i_pflag = 1;
-			else
-				fr->i_hdr.i_pflag = 0;
-            
-			if (type == I_CMD)           
-				fr->pdu_hdr.ssap = fr->pdu_hdr.ssap & 0xfe;
-			else
-				fr->pdu_hdr.ssap = fr->pdu_hdr.ssap | 0x01;
-		}
-	        else
-	        {
-	        	/*
-	        	 *	Resending pdu 2...n 
-	        	 */
-
-			fr->pdu_hdr.ssap = fr->pdu_hdr.ssap & 0xfe;
-			fr->i_hdr.i_pflag = 0;
-		}
-		fr->i_hdr.nr = lp->vr;
-		fr->i_hdr.ns = lp->vs;
-		lp->vs++;
-		if (lp->vs > 127) 
-			lp->vs = 0;
-		tmp=skb_clone(skb, GFP_ATOMIC);
-		if(tmp!=NULL)
-		{
-			tmp->dev = lp->dev;
-			dev_queue_xmit(skb);
-		}
-		resend_count++;
-		skb = skb->next;
-	}
-	restore_flags(flags);
-	return resend_count;
-}
-
-/* ************** internal queue management code ****************** */
-
-
-/*
- *	Remove one skb from the front of the awaiting transmit queue
- *	(this is the skb longest on the queue) and return a pointer to 
- *	that skb. 
- */ 
-
-struct sk_buff *llc_pull_from_atq(llcptr lp) 
-{
-	return skb_dequeue(&lp->atq);
-}
- 
-/*
- *	Free_acknowledged_skbs(), remove from retransmit queue (rtq)
- *	and free all skbs with an N(S) chronologicaly before 'pdu_ack'.
- *	The return value is the number of pdus acknowledged.
- */
- 
-int llc_free_acknowledged_skbs(llcptr lp, unsigned char pdu_ack)
-{
-	struct sk_buff *pp;
-	frameptr fr; 
-	int ack_count;
-	unsigned char ack; 	/* N(S) of most recently ack'ed pdu */
-	unsigned char ns_save; 
-	unsigned long flags;
-
-	if (pdu_ack > 0) 
-		ack = pdu_ack -1;
-	else 
-		ack = 127;
-
-	ack_count = 0;
-
-	save_flags(flags);
-	cli();
-
-	pp = skb_dequeue(&lp->rtq); 
-	while (pp != NULL)
-	{
-		/* 
-		 *	Locate skb with N(S) == ack 
-		 */
-
-		/*
-		 *	BUG: FIXME - use skb->h.*
-		 */
-		fr = (frameptr) (pp->data + lp->dev->hard_header_len);
-		ns_save = fr->i_hdr.ns;
-
-		kfree_skb(pp);
-		ack_count++;
-
-		if (ns_save == ack) 
-			break;  
-		pp = skb_dequeue(&lp->rtq);
-	}
-	restore_flags(flags);
-	return ack_count; 
-}
-
diff -ruN linux-2.4.4/net/802/llc_utility.c linux/net/802/llc_utility.c
--- linux-2.4.4/net/802/llc_utility.c	Thu Dec 12 06:54:22 1996
+++ linux/net/802/llc_utility.c	Wed Dec 31 16:00:00 1969
@@ -1,253 +0,0 @@
-/*
- * NET		An implementation of the IEEE 802.2 LLC protocol for the
- *		LINUX operating system.  LLC is implemented as a set of 
- *		state machines and callbacks for higher networking layers.
- *
- *		Small utilities, Linux timer handling.
- *
- *		Written by Tim Alpaerts, Tim_Alpaerts@toyota-motor-europe.com
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- *	Changes
- *		Alan Cox	:	Chainsawed into Linux form.
- *					Added llc_ function name prefixes.
- *					Fixed bug in stop/start timer.
- *					Added llc_cancel_timers for closing
- *						down an llc
- */
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <net/llc_frame.h>
-#include <net/llc.h>
-
-int llc_decode_frametype(frameptr fr)
-{
-	if (IS_UFRAME(fr)) 
-	{      /* unnumbered cmd/rsp */
-		switch(fr->u_mm.mm & 0x3B)
-		{
-			case 0x1B:
-			    return(SABME_CMD);
-			    break;
-			case 0x10:
-			    return(DISC_CMD);
-			    break;
-			case 0x18:
-			    return(UA_RSP);
-			    break;
-			case 0x03:
-			    return(DM_RSP);
-			    break;
-			case 0x21:
-			    return(FRMR_RSP);
-			    break;
-			case 0x00:
-			    return(UI_CMD);
-			    break;
-			case 0x2B:
-		 	    if (IS_RSP(fr)) 
-		 	    	return(XID_RSP);
-			    else
-			    	return(XID_CMD);
-			    break;
-			case 0x38:
-		    	    if (IS_RSP(fr))
-		    	    	return(TEST_RSP);
-			    else
-				return(TEST_CMD);
-			    break;
-			default:
-			    return(BAD_FRAME);
-		}
-	}
-	else if (IS_SFRAME(fr))
-	{  /* supervisory cmd/rsp */
-		switch(fr->s_hdr.ss)
-		{
-			case 0x00:
-			    if (IS_RSP(fr)) 
-			    	return(RR_RSP);
-			    else
-			    	return(RR_CMD);
-			    break;
-			case 0x02:
-			    if (IS_RSP(fr))
-			    	return(REJ_RSP);
-			    else
-			    	return(REJ_CMD);
-			    break;
-			case 0x01:
-			    if (IS_RSP(fr))
-			    	return(RNR_RSP);
-			    else
-			    	return(RNR_CMD);
-			    break;
-			default:
-			    return(BAD_FRAME);
-		}
-	}
-	else
-	{			  /* information xfer */
-		if (IS_RSP(fr)) 
-			return(I_RSP);
-		else	
-			return(I_CMD);
-	}
-}
-
-
-/*
- *	Validate_seq_nos will check N(S) and N(R) to see if they are
- *	invalid or unexpected.
- *	"unexpected" is explained on p44 Send State Variable.
- *	The return value is:
- *		4 * invalid N(R) +
- *		2 * invalid N(S) +
- *		1 * unexpected N(S)
- */
-
-int llc_validate_seq_nos(llcptr lp, frameptr fr)
-{
-	int res;
-     
-	/*
-	 *	A U-frame is always good 
-	 */
-
-	if (IS_UFRAME(fr)) 
-		return(0);	
-
-	/*
-	 *	For S- and I-frames check N(R): 
-	 */
-
-	if (fr->i_hdr.nr == lp->vs) 
-	{    	/* if N(R) = V(S)  */
-        	res = 0;                        /* N(R) is good */
-	}
-	else
-	{				/* lp->k = transmit window size */
-    		if (lp->vs >= lp->k) 
-    		{	/* if window not wrapped around 127 */
-			if ((fr->i_hdr.nr < lp->vs) &&
-				(fr->i_hdr.nr > (lp->vs - lp->k)))
-				res = 0;
-			else 
-				res = 4;		/* N(R) invalid */
-		}
-		else
-		{	/* window wraps around 127 */
-			if ((fr->i_hdr.nr < lp->vs) ||
-				(fr->i_hdr.nr > (128 + lp->vs - lp->k))) 
-				res = 0;
-			else
-				res = 4;		/* N(R) invalid */
-		}
-	}
-
-	/*
-	 *	For an I-frame, must check N(S) also:  
-	 */
-
-	if (IS_IFRAME(fr)) 
-	{
-    		if (fr->i_hdr.ns == lp->vr) 
-    			return res;   /* N(S) good */
-		if (lp->vr >= lp->rw) 
-		{
-			/* if receive window not wrapped */
-
-			if ((fr->i_hdr.ns < lp->vr) &&
-				(fr->i_hdr.ns > (lp->vr - lp->k)))
-				res = res +1;   	/* N(S) unexpected */
-			else  
-				res = res +2;         /* N(S) invalid */            
-		}
-		else
-		{
-			/* Window wraps around 127 */
-
-			if ((fr->i_hdr.ns < lp->vr) ||
-				(fr->i_hdr.ns > (128 + lp->vr - lp->k)))
-				res = res +1;   	/* N(S) unexpected */
-			else
-				res = res +2;         /* N(S) invalid */            
-		}
-	}					
-	return(res);
-}
-
-/* **************** timer management routines ********************* */
-
-static void llc_p_timer_expired(unsigned long ulp)
-{
-	llc_timer_expired((llcptr) ulp, P_TIMER);
-}
-
-static void llc_rej_timer_expired(unsigned long ulp)
-{
-	llc_timer_expired((llcptr) ulp, REJ_TIMER);
-}
-
-static void llc_ack_timer_expired(unsigned long ulp)
-{
-	llc_timer_expired((llcptr) ulp, ACK_TIMER);
-} 
-
-static void llc_busy_timer_expired(unsigned long ulp)
-{
-	llc_timer_expired((llcptr) ulp, BUSY_TIMER);
-}
-
-/* exp_fcn is an array holding the 4 entry points of the
-   timer expiry routines above.
-   It is required to keep start_timer() generic.
-   Thank you cdecl.
- */
-
-static void (* exp_fcn[])(unsigned long) = 
-{
-	llc_p_timer_expired,
-	llc_rej_timer_expired,
-	llc_ack_timer_expired,
-	llc_busy_timer_expired
-};   
-
-void llc_start_timer(llcptr lp, int t)
-{
-	if (lp->timer_state[t] == TIMER_IDLE)
-	{
-    		lp->tl[t].expires = jiffies + lp->timer_interval[t];
-    		lp->tl[t].data = (unsigned long) lp;
-    		lp->tl[t].function = exp_fcn[t];
-    		add_timer(&lp->tl[t]);
-    		lp->timer_state[t] = TIMER_RUNNING;
-	}
-}
-
-void llc_stop_timer(llcptr lp, int t)
-{
-	if (lp->timer_state[t] == TIMER_RUNNING)
-	{
-        	del_timer(&lp->tl[t]);
-        	lp->timer_state[t] = TIMER_IDLE;
-	}
-}
-
-void llc_cancel_timers(llcptr lp)
-{
-	llc_stop_timer(lp, P_TIMER);
-	llc_stop_timer(lp, REJ_TIMER);
-	llc_stop_timer(lp, ACK_TIMER);
-	llc_stop_timer(lp, BUSY_TIMER);
-}
-
diff -ruN linux-2.4.4/net/802/pseudo/Makefile linux/net/802/pseudo/Makefile
--- linux-2.4.4/net/802/pseudo/Makefile	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/Makefile	Wed Dec 31 16:00:00 1969
@@ -1,13 +0,0 @@
-all:	pseudocode.h actionnm.h
-
-clean:
-	touch pseudocode.h actionnm.h
-	rm pseudocode.h actionnm.h
-
-pseudocode.h: pseudocode opcd2num.sed compile.awk
-	sed -f opcd2num.sed pseudocode |  awk -f compile.awk >pseudocode.h
-
-actionnm.h: pseudocode.h actionnm.awk
-	awk -f actionnm.awk pseudocode.h>actionnm.h
-
-	
diff -ruN linux-2.4.4/net/802/pseudo/actionnm.awk linux/net/802/pseudo/actionnm.awk
--- linux-2.4.4/net/802/pseudo/actionnm.awk	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/actionnm.awk	Wed Dec 31 16:00:00 1969
@@ -1,27 +0,0 @@
-# usage: awk -f actionnm.awk pseudocode.h
-#
-BEGIN { "date" | getline
-	today = $0
-	printf("\n/* this file generated on %s  */\n", today )
-	printf("\nstatic char *action_names[] = { \n    " )
-	opl = 0
-}
-
-/^#define/ {			
-	if ( opl > 3 ) {
-	    printf("\n    ")
-	    opl = 0
-	}
-	opl = opl +1
-	t = sprintf("\"%s\"", $2 )
-	printf("%-15s ,", t )
-#	printf("%-10s", $2 )
-}
-
-END {		
-	if ( opl > 3 ) {
-	    printf("\n    ")
-	}
-	printf("\t  0\n};\n\n")
-}
-
diff -ruN linux-2.4.4/net/802/pseudo/actionnm.h linux/net/802/pseudo/actionnm.h
--- linux-2.4.4/net/802/pseudo/actionnm.h	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/actionnm.h	Wed Dec 31 16:00:00 1969
@@ -1,51 +0,0 @@
-
-/* this file generated on Thu Oct 24 11:42:37 GMT 1996  */
-
-static char *action_names[] = { 
-    "NOP"           ,"ADM1"          ,"ADM2"          ,"ADM3"          ,
-    "ADM4"          ,"ADM5"          ,"CONN2"         ,"CONN3"         ,
-    "CONN4"         ,"CONN5"         ,"RESWAIT1"      ,"RESWAIT2"      ,
-    "RESWAIT3"      ,"RESWAIT4"      ,"RESWAIT5"      ,"RESWAIT6"      ,
-    "RESWAIT7"      ,"RESWAIT8"      ,"RESCHK1"       ,"RESCHK2"       ,
-    "RESCHK3"       ,"RESCHK4"       ,"RESCHK5"       ,"RESCHK6"       ,
-    "SETUP1"        ,"SETUP2"        ,"SETUP3"        ,"SETUP4"        ,
-    "SETUP5"        ,"SETUP6"        ,"SETUP7"        ,"SETUP8"        ,
-    "RESET1"        ,"RESET2"        ,"RESET3"        ,"RESET4"        ,
-    "RESET5"        ,"RESET6"        ,"RESET7"        ,"RESET8"        ,
-    "D_CONN1"       ,"D_CONN2"       ,"D_CONN3"       ,"D_CONN4"       ,
-    "D_CONN5"       ,"D_CONN6"       ,"D_CONN7"       ,"ERR1"          ,
-    "ERR2"          ,"ERR3"          ,"ERR4"          ,"ERR5"          ,
-    "ERR6"          ,"ERR7"          ,"ERR8"          ,"SH1"           ,
-    "SH2"           ,"SH3"           ,"SH4"           ,"SH5"           ,
-    "SH6"           ,"SH7"           ,"SH8"           ,"SH9"           ,
-    "SH10"          ,"SH11"          ,"NORMAL1"       ,"NORMAL2"       ,
-    "NORMAL3"       ,"NORMAL4"       ,"NORMAL5"       ,"NORMAL6"       ,
-    "NORMAL7"       ,"NORMAL8A"      ,"NORMAL8B"      ,"NORMAL9"       ,
-    "NORMAL10"      ,"NORMAL11"      ,"NORMAL12"      ,"NORMAL13"      ,
-    "NORMAL14"      ,"NORMAL15"      ,"NORMAL16"      ,"NORMAL17"      ,
-    "NORMAL18"      ,"NORMAL19"      ,"NORMAL20"      ,"BUSY1"         ,
-    "BUSY2"         ,"BUSY3"         ,"BUSY4"         ,"BUSY5"         ,
-    "BUSY6"         ,"BUSY7"         ,"BUSY8"         ,"BUSY9"         ,
-    "BUSY10"        ,"BUSY11"        ,"BUSY12"        ,"BUSY13"        ,
-    "BUSY14"        ,"BUSY15"        ,"BUSY16"        ,"BUSY17"        ,
-    "BUSY18"        ,"BUSY19"        ,"BUSY20"        ,"BUSY21"        ,
-    "BUSY22"        ,"BUSY23"        ,"BUSY24"        ,"BUSY25"        ,
-    "BUSY26"        ,"REJECT1"       ,"REJECT2"       ,"REJECT3"       ,
-    "REJECT4"       ,"REJECT5"       ,"REJECT6"       ,"REJECT7"       ,
-    "REJECT8"       ,"REJECT9"       ,"REJECT10"      ,"REJECT11"      ,
-    "REJECT12"      ,"REJECT13"      ,"REJECT14"      ,"REJECT15"      ,
-    "REJECT16"      ,"REJECT17"      ,"REJECT18"      ,"REJECT19"      ,
-    "REJECT20"      ,"AWAIT1"        ,"AWAIT2"        ,"AWAIT3"        ,
-    "AWAIT4"        ,"AWAIT5"        ,"AWAIT6"        ,"AWAIT7"        ,
-    "AWAIT8"        ,"AWAIT9"        ,"AWAIT10"       ,"AWAIT11"       ,
-    "AWAIT12"       ,"AWAIT13"       ,"AWAIT14"       ,"AWAIT_BUSY1"   ,
-    "AWAIT_BUSY2"   ,"AWAIT_BUSY3"   ,"AWAIT_BUSY4"   ,"AWAIT_BUSY5"   ,
-    "AWAIT_BUSY6"   ,"AWAIT_BUSY7"   ,"AWAIT_BUSY8"   ,"AWAIT_BUSY9"   ,
-    "AWAIT_BUSY10"  ,"AWAIT_BUSY11"  ,"AWAIT_BUSY12"  ,"AWAIT_BUSY13"  ,
-    "AWAIT_BUSY14"  ,"AWAIT_BUSY15"  ,"AWAIT_BUSY16"  ,"AWAIT_REJECT1" ,
-    "AWAIT_REJECT2" ,"AWAIT_REJECT3" ,"AWAIT_REJECT4" ,"AWAIT_REJECT5" ,
-    "AWAIT_REJECT6" ,"AWAIT_REJECT7" ,"AWAIT_REJECT8" ,"AWAIT_REJECT9" ,
-    "AWAIT_REJECT10" ,"AWAIT_REJECT11" ,"AWAIT_REJECT12" ,"AWAIT_REJECT13" ,
-    	  0
-};
-
diff -ruN linux-2.4.4/net/802/pseudo/compile.awk linux/net/802/pseudo/compile.awk
--- linux-2.4.4/net/802/pseudo/compile.awk	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/compile.awk	Wed Dec 31 16:00:00 1969
@@ -1,57 +0,0 @@
-# usage: cat pseudocode | sed -f act2num | awk -f compile.awk
-#
-#
-BEGIN { "date" | getline
-	today = $0
-	printf("\n/* this file generated on %s  */\n", today )
-	printf("\nstatic char pseudo_code [ ] = { \n" )
-	opl = 0			# op codes on the current line
-
-	opc = 0			# opcode counter
-	fpi = 0			# fill pointer for idx array
-}
-
-/^;/ { } 			# line starting with semicolon is comment 
-
-/^[A-Z]/ {			# start of a new action 
-	emit( 0 )
-	idx[ ++fpi ] = opc
-	name[ fpi ] = $1 
-	emit( $2 )
-}
-
-/^[\t ]/ { 
-        emit( $1 )
-}
-
-END {		
-	if ( opl > 8 ) {
-	    printf("\n")
-	}
-	printf("\t  0\n};\n\n")
-	printf("static short int pseudo_code_idx [ ] ={\n")
-	opl = 0
-	emit( 0 )
-	for( ii = 1; ii <= fpi; ii++ )
-	   emit( idx[ ii ] )
-	if ( opl > 8 ) {
-	    printf("\n")
-	}
-	printf("\t  0\n};\n\n")
-
-	printf("#define %-10s \t %3d \n", "NOP", 0 )
-	for( ii = 1; ii <= fpi; ii++ )
-	    printf("#define %-10s \t %3d \n", name[ ii ], ii )
-	printf("\n")
-}
-
-function emit( opcode ){	# Niclaus Wirth
-	if ( opl > 8 ) {
-	    printf("\n")
-	    opl = 0
-	}
-	opl = opl +1
-	printf("\t%4d,", opcode )
-	opc++
-}
-
diff -ruN linux-2.4.4/net/802/pseudo/opcd2num.sed linux/net/802/pseudo/opcd2num.sed
--- linux-2.4.4/net/802/pseudo/opcd2num.sed	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/opcd2num.sed	Wed Dec 31 16:00:00 1969
@@ -1,72 +0,0 @@
-s/NOP/0/
-s/DUMMY_6/6/
-s/DUMMY_8/8/
-s/IF_F=1_CLEAR_REMOTE_BUSY/9/
-s/CLEAR_REMOTE_BUSY/1/
-s/CONNECT_CONFIRM/3/
-s/DISCONNECT_INDICATION/5/
-s/CONNECT_INDICATION/2/
-s/IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1/55/
-s/DATA_FLAG:=0/53/
-s/DATA_FLAG:=1/54/
-s/DATA_FLAG:=2/52/
-s/DATA_INDICATION/4/
-s/F_FLAG:=P/65/
-s/IF_DATA_FLAG=2_STOP_REJ_TIMER/10/
-s/OPTIONAL_SEND_RNR_XXX(X=0)/30/
-s/P_FLAG:=0/56/
-s/P_FLAG:=P/57/
-s/RE-SEND_FRMR_RSP(F=0)/14/
-s/RE-SEND_FRMR_RSP(F=P)/15/
-s/RE-SEND_I_CMD(P=1)_OR_SEND_RR/18/
-s/RE-SEND_I_CMD(P=1)/17/
-s/RE-SEND_I_RSP(F=1)/22/
-s/RE-SEND_I_XXX(X=0)_OR_SEND_RR/21/
-s/RE-SEND_I_XXX(X=0)/20/
-s/REMOTE_BUSY:=0/58/
-s/REPORT_STATUS(FRMR_RECEIVED)/66/
-s/REPORT_STATUS(FRMR_SENT)/67/
-s/REPORT_STATUS(REMOTE_BUSY)/68/
-s/REPORT_STATUS(REMOTE_NOT_BUSY)/69/
-s/RESET_CONFIRM/7/
-s/RESET_INDICATION(LOCAL)/70/
-s/RESET_INDICATION(REMOTE)/71/
-s/RETRY_COUNT:=RETRY_COUNT+1/60/
-s/RETRY_COUNT:=0/59/
-s/SEND_ACKNOWLEDGE_CMD(P=1)/32/
-s/SEND_ACKNOWLEDGE_RSP(F=1)/34/
-s/SEND_ACKNOWLEDGE_XXX(X=0)/36/
-s/SEND_DISC_CMD(P=X)/11/
-s/SEND_DM_RSP(F=X)/12/
-s/SEND_FRMR_RSP(F=X)/13/
-s/SEND_I_CMD(P=1)/16/
-s/SEND_I_XXX(X=0)/19/
-s/SEND_REJ_CMD(P=1)/23/
-s/SEND_REJ_RSP(F=1)/24/
-s/SEND_REJ_XXX(X=0)/25/
-s/SEND_RNR_CMD(F=1)/26/
-s/SEND_RNR_RSP(F=1)/27/
-s/SEND_RNR_XXX(X=0)/28/
-s/SEND_RR_CMD(P=1)/31/
-s/SEND_RR_RSP(F=1)/33/
-s/SEND_RR_XXX(X=0)/35/
-s/SEND_SABME_CMD(P=X)/37/
-s/SEND_UA_RSP(F=X)/38/
-s/SET_REMOTE_BUSY/29/
-s/START_ACK_TIMER_IF_NOT_RUNNING/44/
-s/START_ACK_TIMER/42/
-s/START_P_TIMER/41/
-s/START_REJ_TIMER/43/
-s/STOP_ACK_TIMER/45/
-s/STOP_ALL_TIMERS/48/
-s/STOP_OTHER_TIMERS/49/
-s/STOP_P_TIMER/46/
-s/STOP_REJ_TIMER/47/
-s/S_FLAG:=0/39/
-s/S_FLAG:=1/40/
-s/UPDATE_N(R)_RECEIVED/50/
-s/UPDATE_P_FLAG/51/
-s/V(R):=0/61/
-s/V(R):=V(R)+1/62/
-s/V(S):=0/63/
-s/V(S):=N(R)/64/
diff -ruN linux-2.4.4/net/802/pseudo/opcodes linux/net/802/pseudo/opcodes
--- linux-2.4.4/net/802/pseudo/opcodes	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/opcodes	Wed Dec 31 16:00:00 1969
@@ -1,72 +0,0 @@
-   0	NOP
-   1	CLEAR_REMOTE_BUSY
-   2	CONNECT_INDICATION
-   3	CONNECT_CONFIRM
-   4	DATA_INDICATION
-   5	DISCONNECT_INDICATION
-   6	DUMMY_6
-   7	RESET_CONFIRM
-   8	DUMMY_8
-   9	IF_F=1_CLEAR_REMOTE_BUSY
-  10	IF_DATA_FLAG=2_STOP_REJ_TIMER
-  11	SEND_DISC_CMD(P=X)
-  12	SEND_DM_RSP(F=X)
-  13	SEND_FRMR_RSP(F=X)
-  14	RE-SEND_FRMR_RSP(F=0)
-  15	RE-SEND_FRMR_RSP(F=P)
-  16	SEND_I_CMD(P=1)
-  17	RE-SEND_I_CMD(P=1)
-  18	RE-SEND_I_CMD(P=1)_OR_SEND_RR
-  19	SEND_I_XXX(X=0)
-  20	RE-SEND_I_XXX(X=0)
-  21	RE-SEND_I_XXX(X=0)_OR_SEND_RR
-  22	RE-SEND_I_RSP(F=1)
-  23	SEND_REJ_CMD(P=1)
-  24	SEND_REJ_RSP(F=1)
-  25	SEND_REJ_XXX(X=0)
-  26	SEND_RNR_CMD(F=1)
-  27	SEND_RNR_RSP(F=1)
-  28	SEND_RNR_XXX(X=0)
-  29	SET_REMOTE_BUSY
-  30	OPTIONAL_SEND_RNR_XXX(X=0)
-  31	SEND_RR_CMD(P=1)
-  32	SEND_ACKNOWLEDGE_CMD(P=1)
-  33	SEND_RR_RSP(F=1)
-  34	SEND_ACKNOWLEDGE_RSP(F=1)
-  35	SEND_RR_XXX(X=0)
-  36	SEND_ACKNOWLEDGE_XXX(X=0)
-  37	SEND_SABME_CMD(P=X)
-  38	SEND_UA_RSP(F=X)
-  39	S_FLAG:=0
-  40	S_FLAG:=1
-  41	START_P_TIMER
-  42	START_ACK_TIMER
-  43	START_REJ_TIMER
-  44	START_ACK_TIMER_IF_NOT_RUNNING
-  45	STOP_ACK_TIMER
-  46	STOP_P_TIMER
-  47	STOP_REJ_TIMER
-  48	STOP_ALL_TIMERS
-  49	STOP_OTHER_TIMERS
-  50	UPDATE_N(R)_RECEIVED
-  51	UPDATE_P_FLAG
-  52	DATA_FLAG:=2
-  53	DATA_FLAG:=0
-  54	DATA_FLAG:=1
-  55	IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1
-  56	P_FLAG:=0
-  57	P_FLAG:=P
-  58	REMOTE_BUSY:=0
-  59	RETRY_COUNT:=0
-  60	RETRY_COUNT:=RETRY_COUNT+1
-  61	V(R):=0
-  62	V(R):=V(R)+1
-  63	V(S):=0
-  64	V(S):=N(R)
-  65	F_FLAG:=P
-  66	REPORT_STATUS(FRMR_RECEIVED)
-  67	REPORT_STATUS(FRMR_SENT)
-  68	REPORT_STATUS(REMOTE_BUSY)
-  69	REPORT_STATUS(REMOTE_NOT_BUSY)
-  70	RESET_INDICATION(LOCAL)
-  71	RESET_INDICATION(REMOTE)
diff -ruN linux-2.4.4/net/802/pseudo/opcodesnm.h linux/net/802/pseudo/opcodesnm.h
--- linux-2.4.4/net/802/pseudo/opcodesnm.h	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/opcodesnm.h	Wed Dec 31 16:00:00 1969
@@ -1,23 +0,0 @@
-static char *opcode_names[] = {
-"NOP", "CLEAR_REMOTE_BUSY", "CONNECT_INDICATION", "CONNECT_CONFIRM", "DATA_INDICATION",
-"DISCONNECT_INDICATION", "DUMMY_6", "RESET_CONFIRM", "DUMMY_8",
-"IF_F=1_CLEAR_REMOTE_BUSY", "IF_DATA_FLAG=2_STOP_REJ_TIMER", "SEND_DISC_CMD(P=X)",
-"SEND_DM_RSP(F=X)", "SEND_FRMR_RSP(F=X)", "RE-SEND_FRMR_RSP(F=0)",
-"RE-SEND_FRMR_RSP(F=P)", "SEND_I_CMD(P=1)", "RE-SEND_I_CMD(P=1)",
-"RE-SEND_I_CMD(P=1)_OR_SEND_RR", "SEND_I_XXX(X=0)", "RE-SEND_I_XXX(X=0)",
-"RE-SEND_I_XXX(X=0)_OR_SEND_RR", "RE-SEND_I_RSP(F=1)", "SEND_REJ_CMD(P=1)",
-"SEND_REJ_RSP(F=1)", "SEND_REJ_XXX(X=0)", "SEND_RNR_CMD(F=1)", "SEND_RNR_RSP(F=1)",
-"SEND_RNR_XXX(X=0)", "SET_REMOTE_BUSY", "OPTIONAL_SEND_RNR_XXX(X=0)",
-"SEND_RR_CMD(P=1)", "SEND_ACKNOWLEDGE_CMD(P=1)", "SEND_RR_RSP(F=1)",
-"SEND_ACKNOWLEDGE_RSP(F=1)", "SEND_RR_XXX(X=0)", "SEND_ACKNOWLEDGE_XXX(X=0)",
-"SEND_SABME_CMD(P=X)", "SEND_UA_RSP(F=X)", "S_FLAG:=0", "S_FLAG:=1", "START_P_TIMER",
-"START_ACK_TIMER", "START_REJ_TIMER", "START_ACK_TIMER_IF_NOT_RUNNING",
-"STOP_ACK_TIMER", "STOP_P_TIMER", "STOP_REJ_TIMER", "STOP_ALL_TIMERS",
-"STOP_OTHER_TIMERS", "UPDATE_N(R)_RECEIVED", "UPDATE_P_FLAG", "DATA_FLAG:=2",
-"DATA_FLAG:=0", "DATA_FLAG:=1", "IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1", "P_FLAG:=0",
-"P_FLAG:=P", "REMOTE_BUSY:=0", "RETRY_COUNT:=0", "RETRY_COUNT:=RETRY_COUNT+1",
-"V(R):=0", "V(R):=V(R)+1", "V(S):=0", "V(S):=N(R)", "F_FLAG:=P",
-"REPORT_STATUS(FRMR_RECEIVED)", "REPORT_STATUS(FRMR_SENT)",
-"REPORT_STATUS(REMOTE_BUSY)", "REPORT_STATUS(REMOTE_NOT_BUSY)",
-"RESET_INDICATION(LOCAL)", "RESET_INDICATION(REMOTE)"
-};
diff -ruN linux-2.4.4/net/802/pseudo/pseudocode linux/net/802/pseudo/pseudocode
--- linux-2.4.4/net/802/pseudo/pseudocode	Fri Apr  6 10:51:19 2001
+++ linux/net/802/pseudo/pseudocode	Wed Dec 31 16:00:00 1969
@@ -1,780 +0,0 @@
-;============================================================================
-;
-; translate this with 
-; 	cat pseudocode | sed -f act2num |  awk -f compile.awk >pseudocode.h
-;
-; actionname	pseudocode
-;
-;============================================================================
-ADM1		SEND_SABME_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=0
-		S_FLAG:=0
-;
-; instructions in ADM2 have been changed:
-; 1. 	P_FLAG:=P is probably wrong in doc...
-; 	I think it should be F_FLAG:=P the way it is in CONN3
-; 2.	CONNECT_RESPONSE has been wired in here,
-;	CONN1 is no longer referenced
-;
-ADM2		F_FLAG:=P
-		SEND_UA_RSP(F=X)
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		P_FLAG:=0
-		REMOTE_BUSY:=0
-		CONNECT_INDICATION
-ADM3		SEND_DM_RSP(F=X)
-ADM4		SEND_DM_RSP(F=X)
-ADM5		NOP
-;============================================================================
-;CONN1		SEND_UA_RSP(F=X)
-;		V(S):=0
-;		V(R):=0
-;		RETRY_COUNT:=0
-;		P_FLAG:=0
-;		REMOTE_BUSY:=0
-CONN2		SEND_DM_RSP(F=X)
-CONN3		F_FLAG:=P
-CONN4		DISCONNECT_INDICATION
-CONN5		NOP
-;============================================================================
-RESWAIT1	SEND_SABME_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=0
-RESWAIT2	SEND_UA_RSP(F=X)
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		P_FLAG:=0
-		REMOTE_BUSY:=0
-		RESET_CONFIRM
-RESWAIT3	SEND_DISC_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=0
-RESWAIT4	SEND_DM_RSP(F=X)		
-RESWAIT5	DISCONNECT_INDICATION
-RESWAIT6	S_FLAG:=1
-		F_FLAG:=P
-RESWAIT7	SEND_DM_RSP(F=X)
-		DISCONNECT_INDICATION
-RESWAIT8	NOP
-;============================================================================
-RESCHK1		SEND_UA_RSP(F=X)
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		P_FLAG:=0
-		REMOTE_BUSY:=0
-RESCHK2		SEND_DM_RSP(F=X)
-RESCHK3		DISCONNECT_INDICATION
-RESCHK4		F_FLAG:=P
-RESCHK5		SEND_DM_RSP(F=X)
-		DISCONNECT_INDICATION
-RESCHK6		NOP
-;============================================================================
-SETUP1		SEND_UA_RSP(F=X)
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		S_FLAG:=1
-SETUP2		STOP_ACK_TIMER
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		UPDATE_P_FLAG
-		CONNECT_CONFIRM
-		REMOTE_BUSY:=0
-SETUP3		P_FLAG:=0
-		CONNECT_CONFIRM
-		REMOTE_BUSY:=0
-SETUP4		SEND_DM_RSP(F=X)
-		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-SETUP5		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-SETUP6		NOP
-SETUP7		SEND_SABME_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-SETUP8		DISCONNECT_INDICATION
-;============================================================================
-RESET1		SEND_UA_RSP(F=X)
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		S_FLAG:=1
-RESET2		STOP_ACK_TIMER
-		V(S):=0
-		V(R):=0
-		RETRY_COUNT:=0
-		UPDATE_P_FLAG
-		RESET_CONFIRM
-		REMOTE_BUSY:=0
-RESET3		P_FLAG:=0
-		RESET_CONFIRM
-		REMOTE_BUSY:=0
-RESET4		SEND_DM_RSP(F=X)
-		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-RESET5		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-RESET6		NOP
-RESET7		SEND_SABME_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-RESET8		DISCONNECT_INDICATION
-;============================================================================
-D_CONN1		SEND_DM_RSP(F=X)
-		STOP_ACK_TIMER
-D_CONN2		STOP_ACK_TIMER
-D_CONN3		SEND_UA_RSP(F=X)
-D_CONN4		STOP_ACK_TIMER
-D_CONN5		NOP
-D_CONN6		SEND_DISC_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-D_CONN7		NOP
-;============================================================================
-ERR1		RESET_INDICATION(REMOTE)
-		STOP_ACK_TIMER
-		F_FLAG:=P
-ERR2		SEND_UA_RSP(F=X)
-		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-ERR3		DISCONNECT_INDICATION
-		STOP_ACK_TIMER
-ERR4		RESET_INDICATION(LOCAL)
-		STOP_ACK_TIMER
-		REPORT_STATUS(FRMR_RECEIVED)
-		S_FLAG:=0
-ERR5		RE-SEND_FRMR_RSP(F=P)
-		START_ACK_TIMER
-ERR6		NOP
-ERR7		RE-SEND_FRMR_RSP(F=0)
-		START_ACK_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-ERR8		S_FLAG:=0
-		RESET_INDICATION(LOCAL)
-;============================================================================
-; the shared actions are common to states NORMAL, BUSY, REJECT,
-; AWAIT, AWAIT_BUSY and AWAIT_REJECT.
-;============================================================================
-SH1		SEND_DISC_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-SH2		SEND_SABME_CMD(P=X)
-		P_FLAG:=P
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-		S_FLAG:=0
-SH3		RESET_INDICATION(REMOTE)
-		F_FLAG:=P
-		STOP_ALL_TIMERS
-SH4		SEND_UA_RSP(F=X)
-		DISCONNECT_INDICATION
-		STOP_ALL_TIMERS
-SH5		STOP_ALL_TIMERS
-		RESET_INDICATION(LOCAL)
-		REPORT_STATUS(FRMR_RECEIVED)
-		S_FLAG:=0
-SH6		DISCONNECT_INDICATION
-		STOP_ALL_TIMERS
-SH7		SEND_FRMR_RSP(F=X)
-		REPORT_STATUS(FRMR_SENT)
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-SH8		SEND_FRMR_RSP(F=0)
-		REPORT_STATUS(FRMR_SENT)
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-SH9		SEND_FRMR_RSP(F=0)
-		REPORT_STATUS(FRMR_SENT)
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-SH10		SEND_FRMR_RSP(F=X)
-		REPORT_STATUS(FRMR_SENT)
-		START_ACK_TIMER
-		STOP_OTHER_TIMERS
-		RETRY_COUNT:=0
-SH11		STOP_ALL_TIMERS
-		RESET_INDICATION(LOCAL)
-		S_FLAG:=0
-;============================================================================
-NORMAL1		SEND_I_CMD(P=1)
-		START_P_TIMER
-		START_ACK_TIMER_IF_NOT_RUNNING
-;		SEND_I_XXX(X=0)
-;		START_ACK_TIMER_IF_NOT_RUNNING
-NORMAL2		SEND_I_XXX(X=0)
-		START_ACK_TIMER_IF_NOT_RUNNING
-NORMAL3		SEND_RNR_CMD(F=1)
-		START_P_TIMER
-		DATA_FLAG:=0
-;		SEND_RNR_XXX(X=0)
-;		DATA_FLAG:=0
-NORMAL4		SEND_RNR_XXX(X=0)
-		DATA_FLAG:=0
-NORMAL5		SEND_REJ_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		UPDATE_P_FLAG
-		START_REJ_TIMER
-		IF_F=1_CLEAR_REMOTE_BUSY
-;		SEND_REJ_CMD(P=1)
-;		UPDATE_N(R)_RECEIVED
-;		START_P_TIMER
-;		START_REJ_TIMER
-;		IF_F=1_CLEAR_REMOTE_BUSY
-NORMAL6		SEND_REJ_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		START_REJ_TIMER
-NORMAL7		SEND_REJ_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		START_REJ_TIMER
-;
-; the order of opcodes in NORMAL8 is changed.
-; the transition table will execute NORMAL8A for incoming pdus
-; with p/f 1, pdus with pf 0 are treated in NORMAL8B.
-;   
-NORMAL8A	V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_CMD(P=1)
-		START_P_TIMER
-		UPDATE_N(R)_RECEIVED
-		IF_F=1_CLEAR_REMOTE_BUSY
-		DATA_INDICATION
-;
-NORMAL8B	V(R):=V(R)+1
-		UPDATE_P_FLAG
-		SEND_ACKNOWLEDGE_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		IF_F=1_CLEAR_REMOTE_BUSY
-		DATA_INDICATION
-;
-; the order of opcodes in NORMAL9 is changed 
-NORMAL9		V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-;
-; the order of opcodes in NORMAL10 is changed 
-NORMAL10	V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-NORMAL11	UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-NORMAL12	SEND_ACKNOWLEDGE_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-NORMAL13	UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-NORMAL14	SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-NORMAL15	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		UPDATE_P_FLAG
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		V(S):=N(R)
-;		UPDATE_N(R)_RECEIVED
-;		START_P_TIMER
-;		RE-SEND_I_CMD(P=1)
-;		CLEAR_REMOTE_BUSY
-NORMAL16	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-NORMAL17	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		RE-SEND_I_RSP(F=1)
-		CLEAR_REMOTE_BUSY
-NORMAL18	SEND_RR_CMD(P=1)
-		START_P_TIMER
-NORMAL19	P_FLAG:=0
-;		SEND_RR_CMD(P=1)
-;		START_P_TIMER
-;		RETRY_COUNT:=RETRY_COUNT+1
-NORMAL20	SEND_RR_CMD(P=1)
-		START_P_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-;============================================================================
-BUSY1		SEND_I_CMD(P=1)
-		START_P_TIMER
-		START_ACK_TIMER_IF_NOT_RUNNING
-;		SEND_I_XXX(X=0)
-;		START_ACK_TIMER_IF_NOT_RUNNING
-BUSY2		SEND_I_XXX(X=0)
-		START_ACK_TIMER_IF_NOT_RUNNING
-BUSY3		SEND_REJ_CMD(P=1)
-		START_REJ_TIMER
-		START_P_TIMER
-;		SEND_REJ_XXX(X=0)
-;		START_REJ_TIMER
-BUSY4		SEND_REJ_XXX(X=0)
-		START_REJ_TIMER
-BUSY5		SEND_RR_CMD(P=1)
-		START_P_TIMER
-		SEND_RR_XXX(X=0)
-BUSY6		SEND_RR_XXX(X=0)
-BUSY7		SEND_RR_CMD(P=1)
-		START_P_TIMER
-		SEND_RR_XXX(X=0)
-BUSY8		SEND_RR_XXX(X=0)
-BUSY9		OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1
-		IF_F=1_CLEAR_REMOTE_BUSY
-;		SEND_RNR_CMD(P=1)
-;		START_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1
-;		IF_F=1_CLEAR_REMOTE_BUSY
-BUSY10		OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1
-BUSY11		SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG_=0_THEN_DATA_FLAG:=1
-BUSY12		SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG=2_STOP_REJ_TIMER
-		DATA_FLAG:=1
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		SEND_RNR_RSP(F=1)
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG=2_STOP_REJ_TIMER
-;		DATA_FLAG:=0
-BUSY13		OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG=2_STOP_REJ_TIMER
-		DATA_FLAG:=1
-		IF_F=1_CLEAR_REMOTE_BUSY
-;		SEND_RNR_CMD(F=1)
-;		START_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG=2_STOP_REJ_TIMER
-;		DATA_FLAG:=1
-;		IF_F=1_CLEAR_REMOTE_BUSY
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		SEND_RNR_CMD(F=1)
-;		START_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG=2_STOP_REJ_TIMER
-;		DATA_FLAG:=0
-;		IF_F=1_CLEAR_REMOTE_BUSY
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		UPDATE_P_FLAG
-;		OPTIONAL_SEND_RNR_XXX(X=0)
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG=2_STOP_REJ_TIMER
-;		DATA_FLAG:=0
-;		IF_F=1_CLEAR_REMOTE_BUSY
-BUSY14		OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		IF_DATA_FLAG=2_STOP_REJ_TIMER
-		DATA_FLAG:=1
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		OPTIONAL_SEND_RNR_XXX(X=0)
-;		UPDATE_N(R)_RECEIVED
-;		IF_DATA_FLAG=2_STOP_REJ_TIMER
-;		DATA_FLAG:=0
-BUSY15		UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-BUSY16		SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-BUSY17		UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-BUSY18		SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-BUSY19		V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		UPDATE_P_FLAG
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		V(S):=N(R)
-;		UPDATE_N(R)_RECEIVED
-;		RE-SEND_I_CMD(P=1)
-;		CLEAR_REMOTE_BUSY
-BUSY20		V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-BUSY21		V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		SEND_RNR_RSP(F=1)
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-BUSY22		SEND_RNR_CMD(F=1)
-		START_P_TIMER
-BUSY23		P_FLAG:=0
-;		SEND_RNR_CMD(F=1)
-;		START_P_TIMER
-;		RETRY_COUNT:=RETRY_COUNT+1
-BUSY24		SEND_RNR_CMD(F=1)
-		START_P_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-BUSY25		DATA_FLAG:=1
-;		SEND_RNR_CMD(F=1)
-;		START_P_TIMER
-;		RETRY_COUNT:=RETRY_COUNT+1
-;		DATA_FLAG:=1
-BUSY26		DATA_FLAG:=1
-;============================================================================
-REJECT1		SEND_I_CMD(P=1)
-		START_P_TIMER
-		START_ACK_TIMER_IF_NOT_RUNNING
-;		SEND_I_XXX(X=0)
-;		START_ACK_TIMER_IF_NOT_RUNNING
-REJECT2		SEND_I_XXX(X=0)
-		START_ACK_TIMER_IF_NOT_RUNNING
-REJECT3		SEND_RNR_CMD(F=1)
-		START_P_TIMER
-		DATA_FLAG:=2
-;		SEND_RNR_XXX(X=0)
-;		DATA_FLAG:=2
-REJECT4		SEND_RNR_XXX(X=0)
-		DATA_FLAG:=2
-REJECT5		UPDATE_N(R)_RECEIVED
-		UPDATE_P_FLAG
-		IF_F=1_CLEAR_REMOTE_BUSY
-REJECT6		SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-;
-; order of opcodes in REJECT7 is changed 
-REJECT7		V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_CMD(P=1)
-		START_P_TIMER
-		UPDATE_N(R)_RECEIVED
-		IF_F=1_CLEAR_REMOTE_BUSY
-		STOP_REJ_TIMER
-		DATA_INDICATION
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		UPDATE_P_FLAG
-;		SEND_ACKNOWLEDGE_XXX(X=0)
-;		UPDATE_N(R)_RECEIVED
-;		IF_F=1_CLEAR_REMOTE_BUSY
-;		STOP_REJ_TIMER
-;
-; order of opcodes in REJECT8 is changed 
-REJECT8		V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		STOP_REJ_TIMER
-		DATA_INDICATION
-;
-; order of opcodes in REJECT9 is changed 
-REJECT9		V(R):=V(R)+1
-		SEND_ACKNOWLEDGE_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		STOP_REJ_TIMER
-		DATA_INDICATION
-REJECT10	UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-REJECT11	SEND_ACKNOWLEDGE_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-REJECT12	UPDATE_P_FLAG
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-REJECT13	SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-REJECT14	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		UPDATE_P_FLAG
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		V(S):=N(R)
-;		UPDATE_N(R)_RECEIVED
-;		RE-SEND_I_CMD(P=1)
-;		START_P_TIMER
-;		CLEAR_REMOTE_BUSY
-REJECT15	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-REJECT16	V(S):=N(R)
-		UPDATE_N(R)_RECEIVED
-		RE-SEND_I_RSP(F=1)
-		CLEAR_REMOTE_BUSY
-REJECT17	SEND_RR_CMD(P=1)
-		START_P_TIMER
-REJECT18	SEND_REJ_CMD(P=1)
-		START_P_TIMER
-		START_REJ_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-REJECT19	P_FLAG:=0
-;		SEND_RR_CMD(P=1)
-;		START_P_TIMER
-;		START_REJ_TIMER
-;		RETRY_COUNT:=RETRY_COUNT+1
-REJECT20	SEND_RR_CMD(P=1)
-		START_P_TIMER
-		START_REJ_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-;============================================================================
-AWAIT1		SEND_RNR_XXX(X=0)
-		DATA_FLAG:=0
-AWAIT2		SEND_REJ_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		RE-SEND_I_XXX(X=0)
-		START_REJ_TIMER
-		CLEAR_REMOTE_BUSY
-;		SEND_REJ_CMD(P=1)
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_XXX(X=0)
-;		START_P_TIMER
-;		START_REJ_TIMER
-;		CLEAR_REMOTE_BUSY
-AWAIT3		SEND_REJ_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		START_REJ_TIMER
-AWAIT4		SEND_REJ_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		START_REJ_TIMER
-;
-; order of opcode in AWAIT5 changed
-AWAIT5		V(R):=V(R)+1
-		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		RE-SEND_I_CMD(P=1)_OR_SEND_RR
-		START_P_TIMER
-		CLEAR_REMOTE_BUSY
-		DATA_INDICATION
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		STOP_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_XXX(X=0)_OR_SEND_RR
-;		CLEAR_REMOTE_BUSY
-;
-; order of opcode in AWAIT6 changed
-AWAIT6		V(R):=V(R)+1
-		SEND_RR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-;
-; order of opcode in AWAIT7 changed
-AWAIT7		V(R):=V(R)+1
-		SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-AWAIT8		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_CMD(P=1)
-;		START_P_TIMER
-;		CLEAR_REMOTE_BUSY
-AWAIT9		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT10		SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT11		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		SET_REMOTE_BUSY
-AWAIT12		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT13		SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT14		SEND_RR_CMD(P=1)
-		START_P_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-;============================================================================
-AWAIT_BUSY1	SEND_REJ_XXX(X=0)
-		START_REJ_TIMER		
-AWAIT_BUSY2	SEND_RR_XXX(X=0)
-AWAIT_BUSY3	SEND_RR_XXX(X=0)
-AWAIT_BUSY4	OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		DATA_FLAG:=1
-		CLEAR_REMOTE_BUSY
-		RE-SEND_I_XXX(X=0)
-;		SEND_RNR_CMD(F=1)
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		START_P_TIMER
-;		DATA_FLAG:=1
-;		CLEAR_REMOTE_BUSY
-;		RE-SEND_I_XXX(X=0)
-AWAIT_BUSY5	OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		DATA_FLAG:=1
-AWAIT_BUSY6	SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		DATA_FLAG:=1
-AWAIT_BUSY7	OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		DATA_FLAG:=1
-		STOP_P_TIMER
-		CLEAR_REMOTE_BUSY
-		RE-SEND_I_XXX(X=0)
-;		SEND_RNR_CMD(F=1)
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		START_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		DATA_FLAG:=0
-;		CLEAR_REMOTE_BUSY
-;		RE-SEND_I_XXX(X=0)
-;		OPTIONAL_SEND_RNR_XXX(X=0)
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		STOP_P_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		DATA_FLAG:=0
-;		CLEAR_REMOTE_BUSY
-;		RE-SEND_I_XXX(X=0)
-AWAIT_BUSY8	OPTIONAL_SEND_RNR_XXX(X=0)
-		UPDATE_N(R)_RECEIVED
-		DATA_FLAG:=1
-;		OPTIONAL_SEND_RNR_XXX(X=0)
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		UPDATE_N(R)_RECEIVED
-;		DATA_FLAG:=0
-AWAIT_BUSY9	SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		DATA_FLAG:=1
-;		SEND_RNR_RSP(F=1)
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		UPDATE_N(R)_RECEIVED
-;		DATA_FLAG:=0
-AWAIT_BUSY10	UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_CMD(P=1)
-;		START_P_TIMER
-;		CLEAR_REMOTE_BUSY
-AWAIT_BUSY11	UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT_BUSY12	SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT_BUSY13	UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		SET_REMOTE_BUSY
-AWAIT_BUSY14	UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT_BUSY15	SEND_RNR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT_BUSY16	SEND_RNR_CMD(F=1)
-		START_P_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-;============================================================================
-AWAIT_REJECT1	SEND_RNR_XXX(X=0)
-		DATA_FLAG:=2
-AWAIT_REJECT2	UPDATE_N(R)_RECEIVED
-AWAIT_REJECT3	SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-;
-; order of opcodes in AWAIT_REJECT4 changed
-AWAIT_REJECT4	V(R):=V(R)+1
-		UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		RE-SEND_I_CMD(P=1)_OR_SEND_RR
-		START_P_TIMER
-		STOP_REJ_TIMER
-		CLEAR_REMOTE_BUSY
-		DATA_INDICATION
-;		V(R):=V(R)+1
-;		DATA_INDICATION
-;		STOP_P_TIMER
-;		STOP_REJ_TIMER
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_CMD(P=1)_OR_SEND_RR
-;		CLEAR_REMOTE_BUSY
-;
-; order of opcodes in AWAIT_REJECT5 changed
-AWAIT_REJECT5	V(R):=V(R)+1
-		SEND_RR_XXX(X=0)
-		STOP_REJ_TIMER
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-;
-; order of opcodes in AWAIT_REJECT6 changed
-AWAIT_REJECT6	V(R):=V(R)+1
-		SEND_RR_RSP(F=1)
-		STOP_REJ_TIMER
-		UPDATE_N(R)_RECEIVED
-		DATA_INDICATION
-AWAIT_REJECT7	UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		RE-SEND_I_XXX(X=0)
-		CLEAR_REMOTE_BUSY
-;		UPDATE_N(R)_RECEIVED
-;		V(S):=N(R)
-;		RE-SEND_I_CMD(P=1)
-;		START_P_TIMER
-;		CLEAR_REMOTE_BUSY
-AWAIT_REJECT8	UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT_REJECT9	SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		CLEAR_REMOTE_BUSY
-AWAIT_REJECT10	UPDATE_N(R)_RECEIVED
-		V(S):=N(R)
-		STOP_P_TIMER
-		SET_REMOTE_BUSY
-AWAIT_REJECT11	UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT_REJECT12	SEND_RR_RSP(F=1)
-		UPDATE_N(R)_RECEIVED
-		SET_REMOTE_BUSY
-AWAIT_REJECT13	SEND_REJ_CMD(P=1)
-		START_P_TIMER
-		RETRY_COUNT:=RETRY_COUNT+1
-;============================================================================
-
diff -ruN linux-2.4.4/net/802/pseudo/pseudocode.h linux/net/802/pseudo/pseudocode.h
--- linux-2.4.4/net/802/pseudo/pseudocode.h	Thu Dec 12 06:54:22 1996
+++ linux/net/802/pseudo/pseudocode.h	Wed Dec 31 16:00:00 1969
@@ -1,287 +0,0 @@
-
-/* this file generated on Thu Oct 24 11:42:35 GMT 1996  */
-
-static char pseudo_code [ ] = { 
-	   0,	  37,	  57,	  42,	  59,	  39,	   0,	  65,	  38,
-	  63,	  61,	  59,	  56,	  58,	   2,	   0,	  12,	   0,
-	  12,	   0,	   0,	   0,	  12,	   0,	  65,	   0,	   5,
-	   0,	   0,	   0,	  37,	  57,	  42,	  59,	   0,	  38,
-	  63,	  61,	  59,	  56,	  58,	   7,	   0,	  11,	  57,
-	  42,	  59,	   0,	  12,	   0,	   5,	   0,	  40,	  65,
-	   0,	  12,	   5,	   0,	   0,	   0,	  38,	  63,	  61,
-	  59,	  56,	  58,	   0,	  12,	   0,	   5,	   0,	  65,
-	   0,	  12,	   5,	   0,	   0,	   0,	  38,	  63,	  61,
-	  59,	  40,	   0,	  45,	  63,	  61,	  59,	  51,	   3,
-	  58,	   0,	  56,	   3,	  58,	   0,	  12,	   5,	  45,
-	   0,	   5,	  45,	   0,	   0,	   0,	  37,	  57,	  42,
-	  60,	   0,	   5,	   0,	  38,	  63,	  61,	  59,	  40,
-	   0,	  45,	  63,	  61,	  59,	  51,	   7,	  58,	   0,
-	  56,	   7,	  58,	   0,	  12,	   5,	  45,	   0,	   5,
-	  45,	   0,	   0,	   0,	  37,	  57,	  42,	  60,	   0,
-	   5,	   0,	  12,	  45,	   0,	  45,	   0,	  38,	   0,
-	  45,	   0,	   0,	   0,	  11,	  57,	  42,	  60,	   0,
-	   0,	   0,	  71,	  45,	  65,	   0,	  38,	   5,	  45,
-	   0,	   5,	  45,	   0,	  70,	  45,	  66,	  39,	   0,
-	  15,	  42,	   0,	   0,	   0,	  14,	  42,	  60,	   0,
-	  39,	  70,	   0,	  11,	  57,	  42,	  49,	  59,	   0,
-	  37,	  57,	  42,	  49,	  59,	  39,	   0,	  71,	  65,
-	  48,	   0,	  38,	   5,	  48,	   0,	  48,	  70,	  66,
-	  39,	   0,	   5,	  48,	   0,	  13,	  67,	  42,	  49,
-	  59,	   0,	   0,	  67,	  42,	  49,	  59,	   0,	   0,
-	  67,	  42,	  49,	  59,	   0,	  13,	  67,	  42,	  49,
-	  59,	   0,	  48,	  70,	  39,	   0,	  16,	  41,	  44,
-	   0,	  19,	  44,	   0,	  26,	  41,	  53,	   0,	  28,
-	  53,	   0,	  25,	  50,	  51,	  43,	   9,	   0,	  25,
-	  50,	  43,	   0,	  24,	  50,	  43,	   0,	  62,	  32,
-	  41,	  50,	   9,	   4,	   0,	  62,	  51,	  36,	  50,
-	   9,	   4,	   0,	  62,	  36,	  50,	   4,	   0,	  62,
-	  34,	  50,	   4,	   0,	  51,	  50,	   1,	   0,	  34,
-	  50,	   1,	   0,	  51,	  50,	  29,	   0,	  33,	  50,
-	  29,	   0,	  64,	  50,	  51,	  20,	   1,	   0,	  64,
-	  50,	  20,	   1,	   0,	  64,	  50,	  22,	   1,	   0,
-	  31,	  41,	   0,	  56,	   0,	  31,	  41,	  60,	   0,
-	  16,	  41,	  44,	   0,	  19,	  44,	   0,	  23,	  43,
-	  41,	   0,	  25,	  43,	   0,	  31,	  41,	  35,	   0,
-	  35,	   0,	  31,	  41,	  35,	   0,	  35,	   0,	  30,
-	  51,	  50,	  55,	   9,	   0,	  30,	  50,	  55,	   0,
-	  27,	  50,	  55,	   0,	  27,	  50,	  10,	  54,	   0,
-	  30,	  51,	  50,	  10,	  54,	   9,	   0,	  30,	  50,
-	  10,	  54,	   0,	  51,	  50,	   1,	   0,	  27,	  50,
-	   1,	   0,	  51,	  50,	  29,	   0,	  27,	  50,	  29,
-	   0,	  64,	  50,	  51,	  20,	   1,	   0,	  64,	  50,
-	  20,	   1,	   0,	  64,	  50,	  27,	  20,	   1,	   0,
-	  26,	  41,	   0,	  56,	   0,	  26,	  41,	  60,	   0,
-	  54,	   0,	  54,	   0,	  16,	  41,	  44,	   0,	  19,
-	  44,	   0,	  26,	  41,	  52,	   0,	  28,	  52,	   0,
-	  50,	  51,	   9,	   0,	  33,	  50,	   0,	  62,	  32,
-	  41,	  50,	   9,	  47,	   4,	   0,	  62,	  36,	  50,
-	  47,	   4,	   0,	  62,	  34,	  50,	  47,	   4,	   0,
-	  51,	  50,	   1,	   0,	  34,	  50,	   1,	   0,	  51,
-	  50,	  29,	   0,	  33,	  50,	  29,	   0,	  64,	  50,
-	  51,	  20,	   1,	   0,	  64,	  50,	  20,	   1,	   0,
-	  64,	  50,	  22,	   1,	   0,	  31,	  41,	   0,	  23,
-	  41,	  43,	  60,	   0,	  56,	   0,	  31,	  41,	  43,
-	  60,	   0,	  28,	  53,	   0,	  25,	  50,	  64,	  46,
-	  20,	  43,	   1,	   0,	  25,	  50,	  43,	   0,	  24,
-	  50,	  43,	   0,	  62,	  50,	  64,	  18,	  41,	   1,
-	   4,	   0,	  62,	  35,	  50,	   4,	   0,	  62,	  33,
-	  50,	   4,	   0,	  50,	  64,	  46,	  20,	   1,	   0,
-	  50,	   1,	   0,	  33,	  50,	   1,	   0,	  50,	  64,
-	  46,	  29,	   0,	  50,	  29,	   0,	  33,	  50,	  29,
-	   0,	  31,	  41,	  60,	   0,	  25,	  43,	   0,	  35,
-	   0,	  35,	   0,	  30,	  50,	  64,	  46,	  54,	   1,
-	  20,	   0,	  30,	  50,	  54,	   0,	  27,	  50,	  54,
-	   0,	  30,	  50,	  64,	  54,	  46,	   1,	  20,	   0,
-	  30,	  50,	  54,	   0,	  27,	  50,	  54,	   0,	  50,
-	  64,	  46,	  20,	   1,	   0,	  50,	   1,	   0,	  27,
-	  50,	   1,	   0,	  50,	  64,	  46,	  29,	   0,	  50,
-	  29,	   0,	  27,	  50,	  29,	   0,	  26,	  41,	  60,
-	   0,	  28,	  52,	   0,	  50,	   0,	  33,	  50,	   0,
-	  62,	  50,	  64,	  18,	  41,	  47,	   1,	   4,	   0,
-	  62,	  35,	  47,	  50,	   4,	   0,	  62,	  33,	  47,
-	  50,	   4,	   0,	  50,	  64,	  46,	  20,	   1,	   0,
-	  50,	   1,	   0,	  33,	  50,	   1,	   0,	  50,	  64,
-	  46,	  29,	   0,	  50,	  29,	   0,	  33,	  50,	  29,
-	   0,	  23,	  41,	  60,	  0
-};
-
-static short int pseudo_code_idx [ ] ={
-	   0,	   1,	   7,	  16,	  18,	  20,	  22,	  24,	  26,
-	  28,	  30,	  35,	  43,	  48,	  50,	  52,	  55,	  58,
-	  60,	  67,	  69,	  71,	  73,	  76,	  78,	  84,	  92,
-	  96,	 100,	 103,	 105,	 110,	 112,	 118,	 126,	 130,
-	 134,	 137,	 139,	 144,	 146,	 149,	 151,	 153,	 155,
-	 157,	 162,	 164,	 168,	 172,	 175,	 180,	 183,	 185,
-	 189,	 192,	 198,	 205,	 209,	 213,	 218,	 221,	 227,
-	 233,	 239,	 245,	 249,	 253,	 256,	 260,	 263,	 269,
-	 273,	 277,	 284,	 291,	 296,	 301,	 305,	 309,	 313,
-	 317,	 323,	 328,	 333,	 336,	 338,	 342,	 346,	 349,
-	 353,	 356,	 360,	 362,	 366,	 368,	 374,	 378,	 382,
-	 387,	 394,	 399,	 403,	 407,	 411,	 415,	 421,	 426,
-	 432,	 435,	 437,	 441,	 443,	 445,	 449,	 452,	 456,
-	 459,	 463,	 466,	 474,	 480,	 486,	 490,	 494,	 498,
-	 502,	 508,	 513,	 518,	 521,	 526,	 528,	 533,	 536,
-	 544,	 548,	 552,	 560,	 565,	 570,	 576,	 579,	 583,
-	 588,	 591,	 595,	 599,	 602,	 604,	 606,	 614,	 618,
-	 622,	 630,	 634,	 638,	 644,	 647,	 651,	 656,	 659,
-	 663,	 667,	 670,	 672,	 675,	 684,	 690,	 696,	 702,
-	 705,	 709,	 714,	 717,	 721,	  0
-};
-
-#define NOP        	   0 
-#define ADM1       	   1 
-#define ADM2       	   2 
-#define ADM3       	   3 
-#define ADM4       	   4 
-#define ADM5       	   5 
-#define CONN2      	   6 
-#define CONN3      	   7 
-#define CONN4      	   8 
-#define CONN5      	   9 
-#define RESWAIT1   	  10 
-#define RESWAIT2   	  11 
-#define RESWAIT3   	  12 
-#define RESWAIT4   	  13 
-#define RESWAIT5   	  14 
-#define RESWAIT6   	  15 
-#define RESWAIT7   	  16 
-#define RESWAIT8   	  17 
-#define RESCHK1    	  18 
-#define RESCHK2    	  19 
-#define RESCHK3    	  20 
-#define RESCHK4    	  21 
-#define RESCHK5    	  22 
-#define RESCHK6    	  23 
-#define SETUP1     	  24 
-#define SETUP2     	  25 
-#define SETUP3     	  26 
-#define SETUP4     	  27 
-#define SETUP5     	  28 
-#define SETUP6     	  29 
-#define SETUP7     	  30 
-#define SETUP8     	  31 
-#define RESET1     	  32 
-#define RESET2     	  33 
-#define RESET3     	  34 
-#define RESET4     	  35 
-#define RESET5     	  36 
-#define RESET6     	  37 
-#define RESET7     	  38 
-#define RESET8     	  39 
-#define D_CONN1    	  40 
-#define D_CONN2    	  41 
-#define D_CONN3    	  42 
-#define D_CONN4    	  43 
-#define D_CONN5    	  44 
-#define D_CONN6    	  45 
-#define D_CONN7    	  46 
-#define ERR1       	  47 
-#define ERR2       	  48 
-#define ERR3       	  49 
-#define ERR4       	  50 
-#define ERR5       	  51 
-#define ERR6       	  52 
-#define ERR7       	  53 
-#define ERR8       	  54 
-#define SH1        	  55 
-#define SH2        	  56 
-#define SH3        	  57 
-#define SH4        	  58 
-#define SH5        	  59 
-#define SH6        	  60 
-#define SH7        	  61 
-#define SH8        	  62 
-#define SH9        	  63 
-#define SH10       	  64 
-#define SH11       	  65 
-#define NORMAL1    	  66 
-#define NORMAL2    	  67 
-#define NORMAL3    	  68 
-#define NORMAL4    	  69 
-#define NORMAL5    	  70 
-#define NORMAL6    	  71 
-#define NORMAL7    	  72 
-#define NORMAL8A   	  73 
-#define NORMAL8B   	  74 
-#define NORMAL9    	  75 
-#define NORMAL10   	  76 
-#define NORMAL11   	  77 
-#define NORMAL12   	  78 
-#define NORMAL13   	  79 
-#define NORMAL14   	  80 
-#define NORMAL15   	  81 
-#define NORMAL16   	  82 
-#define NORMAL17   	  83 
-#define NORMAL18   	  84 
-#define NORMAL19   	  85 
-#define NORMAL20   	  86 
-#define BUSY1      	  87 
-#define BUSY2      	  88 
-#define BUSY3      	  89 
-#define BUSY4      	  90 
-#define BUSY5      	  91 
-#define BUSY6      	  92 
-#define BUSY7      	  93 
-#define BUSY8      	  94 
-#define BUSY9      	  95 
-#define BUSY10     	  96 
-#define BUSY11     	  97 
-#define BUSY12     	  98 
-#define BUSY13     	  99 
-#define BUSY14     	 100 
-#define BUSY15     	 101 
-#define BUSY16     	 102 
-#define BUSY17     	 103 
-#define BUSY18     	 104 
-#define BUSY19     	 105 
-#define BUSY20     	 106 
-#define BUSY21     	 107 
-#define BUSY22     	 108 
-#define BUSY23     	 109 
-#define BUSY24     	 110 
-#define BUSY25     	 111 
-#define BUSY26     	 112 
-#define REJECT1    	 113 
-#define REJECT2    	 114 
-#define REJECT3    	 115 
-#define REJECT4    	 116 
-#define REJECT5    	 117 
-#define REJECT6    	 118 
-#define REJECT7    	 119 
-#define REJECT8    	 120 
-#define REJECT9    	 121 
-#define REJECT10   	 122 
-#define REJECT11   	 123 
-#define REJECT12   	 124 
-#define REJECT13   	 125 
-#define REJECT14   	 126 
-#define REJECT15   	 127 
-#define REJECT16   	 128 
-#define REJECT17   	 129 
-#define REJECT18   	 130 
-#define REJECT19   	 131 
-#define REJECT20   	 132 
-#define AWAIT1     	 133 
-#define AWAIT2     	 134 
-#define AWAIT3     	 135 
-#define AWAIT4     	 136 
-#define AWAIT5     	 137 
-#define AWAIT6     	 138 
-#define AWAIT7     	 139 
-#define AWAIT8     	 140 
-#define AWAIT9     	 141 
-#define AWAIT10    	 142 
-#define AWAIT11    	 143 
-#define AWAIT12    	 144 
-#define AWAIT13    	 145 
-#define AWAIT14    	 146 
-#define AWAIT_BUSY1 	 147 
-#define AWAIT_BUSY2 	 148 
-#define AWAIT_BUSY3 	 149 
-#define AWAIT_BUSY4 	 150 
-#define AWAIT_BUSY5 	 151 
-#define AWAIT_BUSY6 	 152 
-#define AWAIT_BUSY7 	 153 
-#define AWAIT_BUSY8 	 154 
-#define AWAIT_BUSY9 	 155 
-#define AWAIT_BUSY10 	 156 
-#define AWAIT_BUSY11 	 157 
-#define AWAIT_BUSY12 	 158 
-#define AWAIT_BUSY13 	 159 
-#define AWAIT_BUSY14 	 160 
-#define AWAIT_BUSY15 	 161 
-#define AWAIT_BUSY16 	 162 
-#define AWAIT_REJECT1 	 163 
-#define AWAIT_REJECT2 	 164 
-#define AWAIT_REJECT3 	 165 
-#define AWAIT_REJECT4 	 166 
-#define AWAIT_REJECT5 	 167 
-#define AWAIT_REJECT6 	 168 
-#define AWAIT_REJECT7 	 169 
-#define AWAIT_REJECT8 	 170 
-#define AWAIT_REJECT9 	 171 
-#define AWAIT_REJECT10 	 172 
-#define AWAIT_REJECT11 	 173 
-#define AWAIT_REJECT12 	 174 
-#define AWAIT_REJECT13 	 175 
-
diff -ruN linux-2.4.4/net/802/psnap.c linux/net/802/psnap.c
--- linux-2.4.4/net/802/psnap.c	Mon Oct 16 12:42:53 2000
+++ linux/net/802/psnap.c	Wed Dec 31 16:00:00 1969
@@ -1,154 +0,0 @@
-/*
- *	SNAP data link layer. Derived from 802.2
- *
- *		Alan Cox <Alan.Cox@linux.org>, from the 802.2 layer by Greg Page.
- *		Merged in additions from Greg Page's psnap.c.
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/skbuff.h>
-#include <net/datalink.h>
-#include <net/p8022.h>
-#include <net/psnap.h>
-#include <linux/mm.h>
-#include <linux/in.h>
-#include <linux/init.h>
-
-static struct datalink_proto *snap_list = NULL;
-static struct datalink_proto *snap_dl = NULL;		/* 802.2 DL for SNAP */
-
-/*
- *	Find a snap client by matching the 5 bytes.
- */
-
-static struct datalink_proto *find_snap_client(unsigned char *desc)
-{
-	struct datalink_proto	*proto;
-
-	for (proto = snap_list; proto != NULL && memcmp(proto->type, desc, 5) ; proto = proto->next);
-	return proto;
-}
-
-/*
- *	A SNAP packet has arrived
- */
-
-int snap_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)
-{
-	static struct packet_type psnap_packet_type =
-	{
-		0,
-		NULL,		/* All Devices */
-		snap_rcv,
-		NULL,
-		NULL,
-	};
-
-	struct datalink_proto	*proto;
-
-	proto = find_snap_client(skb->h.raw);
-	if (proto != NULL)
-	{
-		/*
-		 *	Pass the frame on.
-		 */
-
-		skb->h.raw += 5;
-		skb->nh.raw += 5;
-		skb_pull(skb,5);
-		if (psnap_packet_type.type == 0)
-			psnap_packet_type.type=htons(ETH_P_SNAP);
-
-		return proto->rcvfunc(skb, dev, &psnap_packet_type);
-	}
-	skb->sk = NULL;
-	kfree_skb(skb);
-	return 0;
-}
-
-/*
- *	Put a SNAP header on a frame and pass to 802.2
- */
-
-static void snap_datalink_header(struct datalink_proto *dl, struct sk_buff *skb, unsigned char *dest_node)
-{
-	memcpy(skb_push(skb,5),dl->type,5);
-	snap_dl->datalink_header(snap_dl, skb, dest_node);
-}
-
-/*
- *	Set up the SNAP layer
- */
-
-EXPORT_SYMBOL(register_snap_client);
-EXPORT_SYMBOL(unregister_snap_client);
-
-static int __init snap_init(void)
-{
-	snap_dl=register_8022_client(0xAA, snap_rcv);
-	if(snap_dl==NULL)
-		printk("SNAP - unable to register with 802.2\n");
-	return 0;
-}
-module_init(snap_init);
-
-/*
- *	Register SNAP clients. We don't yet use this for IP.
- */
-
-struct datalink_proto *register_snap_client(unsigned char *desc, int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *))
-{
-	struct datalink_proto	*proto;
-
-	if (find_snap_client(desc) != NULL)
-		return NULL;
-
-	proto = (struct datalink_proto *) kmalloc(sizeof(*proto), GFP_ATOMIC);
-	if (proto != NULL)
-	{
-		memcpy(proto->type, desc,5);
-		proto->type_len = 5;
-		proto->rcvfunc = rcvfunc;
-		proto->header_length = 5+snap_dl->header_length;
-		proto->datalink_header = snap_datalink_header;
-		proto->string_name = "SNAP";
-		proto->next = snap_list;
-		snap_list = proto;
-	}
-
-	return proto;
-}
-
-/*
- *	Unregister SNAP clients. Protocols no longer want to play with us ...
- */
-
-void unregister_snap_client(unsigned char *desc)
-{
-	struct datalink_proto **clients = &snap_list;
-	struct datalink_proto *tmp;
-	unsigned long flags;
-
-	save_flags(flags);
-	cli();
-
-	while ((tmp = *clients) != NULL)
-	{
-		if (memcmp(tmp->type,desc,5) == 0)
-		{
-			*clients = tmp->next;
-			kfree(tmp);
-			break;
-		}
-		else
-			clients = &tmp->next;
-	}
-
-	restore_flags(flags);
-}
diff -ruN linux-2.4.4/net/802/transit/Makefile linux/net/802/transit/Makefile
--- linux-2.4.4/net/802/transit/Makefile	Fri Dec 29 14:07:24 2000
+++ linux/net/802/transit/Makefile	Wed Dec 31 16:00:00 1969
@@ -1,13 +0,0 @@
-include $(TOPDIR)/Rules.make
-
-all:	pdutr.h timertr.h
-
-pdutr.h: pdutr.pre compile.awk			
-	awk -f ./compile.awk pdutr.pre > pdutr.h
-
-timertr.h: timertr.pre compile.awk
-	awk -f ./compile.awk timertr.pre > timertr.h
-
-clean:
-	touch pdutr.h timertr.h
-	rm pdutr.h timertr.h
diff -ruN linux-2.4.4/net/802/transit/compile.awk linux/net/802/transit/compile.awk
--- linux-2.4.4/net/802/transit/compile.awk	Thu Dec 12 06:54:22 1996
+++ linux/net/802/transit/compile.awk	Wed Dec 31 16:00:00 1969
@@ -1,81 +0,0 @@
-# to run: awk -f transit.awk transit.p0
-#
-BEGIN { "date" | getline
-	enable_index = 1
-	today = $0
-	printf("\n/* this file was generated on %s  */\n", today )
-	not_firstone = 0	# flag to avoid empty entry in 1st table
-	fpe = 0			# entry tbl array fill pointer
-	fpeo = 0		# entry tbl offset list fill pointer
-	fpdef = 0 		# define list fill pointer
-}
-
-### /^;/ { }			# line starting with a semicolon is comment 
-
-/^[A-Z]/ {			# table name
-	if ( $1 == "TABLE" ) {
-	   tbl = $2		# get table name
-	   newtbl( tbl )
-	}
-	else if ( $1 == "COMPILE" ) {
-	   array_name = $2
-	   if ( $3 == "NOINDEX" ) { enable_index = 0 }
-	}
-	else {			# table entry
-	   ec = ec +1
-	   n = split( $0, fld, " " )
-	   action = fld[ n-1 ]
-	   newstate = fld[ n ]
-	   store( action, newstate )
-	   ecct = ecct +1
-	}
-}
-
-END {	store( action, newstate )
-
-	if ( enable_index ) {
-	    printf( "\n/* index name #defines: */\n\n",
-		 ec, ecct )
-
-	    for( ii = 1; ii <= fpeo; ii++ ){
-	       printf( "#define %-12s %3d\n", define[ ii ], ii -1 )
-	    }
-	}
-
-	printf( "\n\n/* size of transition table is %d bytes */\n",
-		 fpe )
-
-	if ( enable_index ) {
-	    printf( "\nstatic short int %s_offset [ ] ={", array_name )
-	    for( ii = 1; ii <= fpeo; ii++ ){
-	        if ( (ii % 10) == 1 ) printf("\n  ")
-	        printf( " %4d", entry_offset[ ii ] )
-	        if ( ii < fpeo ) printf( "," )
-	    }
-	    printf(" };\n")
-	}
-
-	printf( "\nstatic char %s_entry [ ] = {", array_name )
-	for( ii = 1; ii <= fpe; ii++ ){
-	    if ( (ii % 6) == 1 ) printf("\n  ")
-	    printf( " %-14s", entry[ ii ] )
-	    if ( ii < fpe ) printf( "," )
-	}
-	printf(" };\n")
-
-}
-
-function store(  act, ns ){
-#	printf( "%s %s\n",  act, ns )
-	entry[ ++fpe ] = act
-	entry[ ++fpe ] = ns 
-}
-
-function newtbl( tbl ){
-	   if ( not_firstone ) {
-		store( action, newstate )
-	   }
-	   not_firstone = 1
-	   entry_offset[ ++fpeo ] = fpe		# entry tbl offset list
-	   define[ ++fpdef ] = tbl	# state name to define
-}
diff -ruN linux-2.4.4/net/802/transit/pdutr.h linux/net/802/transit/pdutr.h
--- linux-2.4.4/net/802/transit/pdutr.h	Mon Jan 12 14:46:27 1998
+++ linux/net/802/transit/pdutr.h	Wed Dec 31 16:00:00 1969
@@ -1,309 +0,0 @@
-
-/* this file was generated on Thu Jan  8 00:21:19 GMT 1998  */
-
-/* index name #defines: */
-
-#define ADM            0
-#define CONN           1
-#define RESET_WAIT     2
-#define RESET_CHECK    3
-#define SETUP          4
-#define RESET          5
-#define D_CONN         6
-#define ERROR          7
-#define NORMAL         8
-#define BUSY           9
-#define REJECT        10
-#define AWAIT         11
-#define AWAIT_BUSY    12
-#define AWAIT_REJECT  13
-
-
-/* size of transition table is 1684 bytes */
-
-static short int pdutr_offset [ ] ={
-      0,   54,   82,  110,  138,  192,  246,  300,  328,  554,
-    780, 1006, 1232, 1458 };
-
-static char pdutr_entry [ ] = {
-   ADM5          , ADM           , ADM4          , ADM           , ADM5          , ADM           ,
-   ADM4          , ADM           , ADM5          , ADM           , ADM4          , ADM           ,
-   ADM5          , ADM           , ADM4          , ADM           , ADM3          , ADM           ,
-   ADM3          , ADM           , ADM2          , CONN          , ADM2          , CONN          ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   ADM5          , ADM           , ADM5          , ADM           , ADM5          , ADM           ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN5         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN3         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN5         , CONN          ,
-   CONN5         , CONN          , CONN5         , CONN          , CONN4         , ADM           ,
-   CONN5         , CONN          , CONN5         , CONN          , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT7      , RESET_WAIT    , RESWAIT6      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESWAIT5      , ADM           , RESWAIT8      , RESET_WAIT    ,
-   RESWAIT8      , RESET_WAIT    , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK5       , ADM           ,
-   RESCHK4       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   RESCHK3       , ADM           , RESCHK6       , RESET_CHECK   , RESCHK6       , RESET_CHECK   ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP4        , ADM           ,
-   SETUP4        , ADM           , SETUP1        , SETUP         , SETUP1        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   SETUP2        , NORMAL        , SETUP5        , ADM           , SETUP5        , ADM           ,
-   SETUP6        , SETUP         , SETUP6        , SETUP         , SETUP6        , SETUP         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET4        , ADM           ,
-   RESET4        , ADM           , RESET1        , RESET         , RESET1        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   RESET2        , NORMAL        , RESET5        , ADM           , RESET5        , ADM           ,
-   RESET6        , RESET         , RESET6        , RESET         , RESET6        , RESET         ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN3       , D_CONN        ,
-   D_CONN3       , D_CONN        , D_CONN1       , ADM           , D_CONN1       , ADM           ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   D_CONN4       , ADM           , D_CONN4       , ADM           , D_CONN5       , ADM           ,
-   D_CONN5       , D_CONN        , D_CONN5       , D_CONN        , D_CONN5       , D_CONN        ,
-   ERR5          , ERROR         , ERR5          , ERROR         , ERR5          , ERROR         ,
-   ERR5          , ERROR         , ERR2          , ADM           , ERR1          , RESET_CHECK   ,
-   ERR6          , ERROR         , ERR6          , ERROR         , ERR6          , ERROR         ,
-   ERR6          , ERROR         , ERR6          , ERROR         , ERR3          , ADM           ,
-   ERR4          , RESET_WAIT    , ERR4          , RESET_WAIT    , NORMAL8B      , NORMAL        ,
-   NORMAL9       , NORMAL        , NORMAL10      , NORMAL        , NORMAL10      , NORMAL        ,
-   NORMAL5       , REJECT        , NORMAL6       , REJECT        , NORMAL7       , REJECT        ,
-   NORMAL7       , REJECT        , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL12      , NORMAL        , NORMAL12      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL11      , NORMAL        , NORMAL12      , NORMAL        , NORMAL12      , NORMAL        ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , NORMAL14      , NORMAL        ,
-   NORMAL14      , NORMAL        , NORMAL13      , NORMAL        , NORMAL13      , NORMAL        ,
-   NORMAL14      , NORMAL        , NORMAL14      , NORMAL        , NORMAL15      , NORMAL        ,
-   NORMAL16      , NORMAL        , NORMAL17      , NORMAL        , NORMAL17      , NORMAL        ,
-   NORMAL15      , NORMAL        , NORMAL16      , NORMAL        , NORMAL17      , NORMAL        ,
-   NORMAL17      , NORMAL        , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , NORMAL8B      , NORMAL        ,
-   NORMAL9       , NORMAL        , SH10          , ERROR         , NORMAL8A      , NORMAL        ,
-   NORMAL5       , REJECT        , NORMAL6       , REJECT        , SH10          , ERROR         ,
-   NORMAL5       , REJECT        , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   SH10          , ERROR         , NORMAL11      , NORMAL        , NORMAL11      , NORMAL        ,
-   NORMAL11      , NORMAL        , SH10          , ERROR         , NORMAL11      , NORMAL        ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , SH10          , ERROR         ,
-   NORMAL13      , NORMAL        , NORMAL13      , NORMAL        , NORMAL13      , NORMAL        ,
-   SH10          , ERROR         , NORMAL13      , NORMAL        , NORMAL15      , NORMAL        ,
-   NORMAL16      , NORMAL        , SH10          , ERROR         , NORMAL15      , NORMAL        ,
-   NORMAL15      , NORMAL        , NORMAL16      , NORMAL        , SH10          , ERROR         ,
-   NORMAL15      , NORMAL        , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , BUSY13        , BUSY          , BUSY14        , BUSY          ,
-   BUSY12        , BUSY          , BUSY12        , BUSY          , BUSY9         , BUSY          ,
-   BUSY10        , BUSY          , BUSY11        , BUSY          , BUSY11        , BUSY          ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , BUSY16        , BUSY          ,
-   BUSY16        , BUSY          , BUSY15        , BUSY          , BUSY15        , BUSY          ,
-   BUSY16        , BUSY          , BUSY16        , BUSY          , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , BUSY18        , BUSY          , BUSY18        , BUSY          ,
-   BUSY17        , BUSY          , BUSY17        , BUSY          , BUSY18        , BUSY          ,
-   BUSY18        , BUSY          , BUSY19        , BUSY          , BUSY20        , BUSY          ,
-   BUSY21        , BUSY          , BUSY21        , BUSY          , BUSY19        , BUSY          ,
-   BUSY20        , BUSY          , BUSY21        , BUSY          , BUSY21        , BUSY          ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , BUSY13        , BUSY          , BUSY14        , BUSY          ,
-   SH10          , ERROR         , BUSY13        , BUSY          , BUSY9         , BUSY          ,
-   BUSY10        , BUSY          , SH10          , ERROR         , BUSY9         , BUSY          ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , SH10          , ERROR         ,
-   BUSY15        , BUSY          , BUSY15        , BUSY          , BUSY15        , BUSY          ,
-   SH10          , ERROR         , BUSY15        , BUSY          , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , SH10          , ERROR         , BUSY17        , BUSY          ,
-   BUSY17        , BUSY          , BUSY17        , BUSY          , SH10          , ERROR         ,
-   BUSY17        , BUSY          , BUSY19        , BUSY          , BUSY20        , BUSY          ,
-   SH10          , ERROR         , BUSY19        , BUSY          , BUSY19        , BUSY          ,
-   BUSY20        , BUSY          , SH10          , ERROR         , BUSY19        , BUSY          ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   REJECT7       , REJECT        , REJECT8       , REJECT        , REJECT9       , REJECT        ,
-   REJECT9       , REJECT        , REJECT5       , REJECT        , REJECT5       , REJECT        ,
-   REJECT6       , REJECT        , REJECT6       , REJECT        , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , REJECT11      , REJECT        , REJECT11      , REJECT        ,
-   REJECT10      , REJECT        , REJECT10      , REJECT        , REJECT11      , REJECT        ,
-   REJECT11      , REJECT        , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   REJECT13      , REJECT        , REJECT13      , REJECT        , REJECT12      , REJECT        ,
-   REJECT12      , REJECT        , REJECT13      , REJECT        , REJECT13      , REJECT        ,
-   REJECT14      , REJECT        , REJECT15      , REJECT        , REJECT16      , REJECT        ,
-   REJECT16      , REJECT        , REJECT14      , REJECT        , REJECT15      , REJECT        ,
-   REJECT16      , REJECT        , REJECT16      , REJECT        , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   REJECT7       , REJECT        , REJECT8       , REJECT        , SH10          , ERROR         ,
-   REJECT7       , REJECT        , REJECT5       , REJECT        , REJECT5       , REJECT        ,
-   SH10          , ERROR         , REJECT5       , REJECT        , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , SH10          , ERROR         , REJECT10      , REJECT        ,
-   REJECT10      , REJECT        , REJECT10      , REJECT        , SH10          , ERROR         ,
-   REJECT10      , REJECT        , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   SH10          , ERROR         , REJECT12      , REJECT        , REJECT12      , REJECT        ,
-   REJECT12      , REJECT        , SH10          , ERROR         , REJECT12      , REJECT        ,
-   REJECT14      , REJECT        , REJECT15      , REJECT        , SH10          , ERROR         ,
-   REJECT14      , REJECT        , REJECT14      , REJECT        , REJECT15      , REJECT        ,
-   SH10          , ERROR         , REJECT14      , REJECT        , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , AWAIT6        , AWAIT         ,
-   AWAIT6        , AWAIT         , AWAIT7        , AWAIT         , AWAIT7        , AWAIT         ,
-   AWAIT3        , AWAIT_REJECT  , AWAIT3        , AWAIT_REJECT  , AWAIT4        , AWAIT_REJECT  ,
-   AWAIT4        , AWAIT_REJECT  , AWAIT9        , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT10       , AWAIT         , AWAIT10       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT10       , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT12       , AWAIT         , AWAIT12       , AWAIT         , AWAIT13       , AWAIT         ,
-   AWAIT13       , AWAIT         , AWAIT12       , AWAIT         , AWAIT12       , AWAIT         ,
-   AWAIT13       , AWAIT         , AWAIT13       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT10       , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT9        , AWAIT         , AWAIT10       , AWAIT         ,
-   AWAIT10       , AWAIT         , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , AWAIT6        , AWAIT         ,
-   AWAIT6        , AWAIT         , SH10          , ERROR         , AWAIT5        , NORMAL        ,
-   AWAIT3        , AWAIT_REJECT  , AWAIT3        , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT2        , REJECT        , AWAIT9        , AWAIT         , AWAIT9        , AWAIT         ,
-   SH10          , ERROR         , AWAIT8        , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , SH10          , ERROR         , AWAIT8        , AWAIT         ,
-   AWAIT12       , AWAIT         , AWAIT12       , AWAIT         , SH10          , ERROR         ,
-   AWAIT11       , AWAIT         , AWAIT12       , AWAIT         , AWAIT12       , AWAIT         ,
-   SH10          , ERROR         , AWAIT11       , AWAIT         , AWAIT9        , AWAIT         ,
-   AWAIT9        , AWAIT         , SH10          , ERROR         , AWAIT8        , AWAIT         ,
-   AWAIT9        , AWAIT         , AWAIT9        , AWAIT         , SH10          , ERROR         ,
-   AWAIT8        , AWAIT         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , AWAIT_BUSY8   , AWAIT_BUSY    , AWAIT_BUSY8   , AWAIT_BUSY    ,
-   AWAIT_BUSY9   , AWAIT_BUSY    , AWAIT_BUSY9   , AWAIT_BUSY    , AWAIT_BUSY5   , AWAIT_BUSY    ,
-   AWAIT_BUSY5   , AWAIT_BUSY    , AWAIT_BUSY6   , AWAIT_BUSY    , AWAIT_BUSY6   , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY15  , AWAIT_BUSY    ,
-   AWAIT_BUSY15  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    , AWAIT_BUSY12  , AWAIT_BUSY    ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , AWAIT_BUSY8   , AWAIT_BUSY    , AWAIT_BUSY8   , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY7   , BUSY          , AWAIT_BUSY5   , AWAIT_BUSY    ,
-   AWAIT_BUSY5   , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY4   , BUSY          ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    , SH10          , ERROR         ,
-   AWAIT_BUSY10  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY10  , BUSY          , AWAIT_BUSY14  , AWAIT_BUSY    ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY13  , BUSY          ,
-   AWAIT_BUSY14  , AWAIT_BUSY    , AWAIT_BUSY14  , AWAIT_BUSY    , SH10          , ERROR         ,
-   AWAIT_BUSY13  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   SH10          , ERROR         , AWAIT_BUSY10  , BUSY          , AWAIT_BUSY11  , AWAIT_BUSY    ,
-   AWAIT_BUSY11  , AWAIT_BUSY    , SH10          , ERROR         , AWAIT_BUSY10  , BUSY          ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT6 , AWAIT         ,
-   AWAIT_REJECT6 , AWAIT         , AWAIT_REJECT2 , AWAIT_REJECT  , AWAIT_REJECT2 , AWAIT_REJECT  ,
-   AWAIT_REJECT3 , AWAIT_REJECT  , AWAIT_REJECT3 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  , AWAIT_REJECT12, AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT9 , AWAIT_REJECT  , AWAIT_REJECT9 , AWAIT_REJECT  , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH4           , ADM           , SH4           , ADM           ,
-   SH4           , ADM           , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   SH3           , RESET_CHECK   , SH3           , RESET_CHECK   , SH3           , RESET_CHECK   ,
-   AWAIT_REJECT5 , AWAIT         , AWAIT_REJECT5 , AWAIT         , SH10          , ERROR         ,
-   AWAIT_REJECT4 , NORMAL        , AWAIT_REJECT2 , AWAIT_REJECT  , AWAIT_REJECT2 , AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT4 , NORMAL        , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         , AWAIT_REJECT7 , REJECT        ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT_REJECT7 , REJECT        , AWAIT_REJECT11, AWAIT_REJECT  , AWAIT_REJECT11, AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT10, REJECT        , AWAIT_REJECT11, AWAIT_REJECT  ,
-   AWAIT_REJECT11, AWAIT_REJECT  , SH10          , ERROR         , AWAIT_REJECT10, REJECT        ,
-   AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  , SH10          , ERROR         ,
-   AWAIT_REJECT7 , REJECT        , AWAIT_REJECT8 , AWAIT_REJECT  , AWAIT_REJECT8 , AWAIT_REJECT  ,
-   SH10          , ERROR         , AWAIT_REJECT7 , REJECT        , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH9           , ERROR         , SH9           , ERROR         ,
-   SH9           , ERROR         , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH6           , ADM           , SH6           , ADM           , SH6           , ADM           ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH5           , RESET_WAIT    ,
-   SH5           , RESET_WAIT    , SH5           , RESET_WAIT    , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR         , SH7           , ERROR         ,
-   SH7           , ERROR         , SH7           , ERROR          };
diff -ruN linux-2.4.4/net/802/transit/pdutr.pre linux/net/802/transit/pdutr.pre
--- linux-2.4.4/net/802/transit/pdutr.pre	Fri Apr  6 10:51:19 2001
+++ linux/net/802/transit/pdutr.pre	Wed Dec 31 16:00:00 1969
@@ -1,1121 +0,0 @@
-COMPILE pdutr INDEX
-;
-; Transition tables for incoming pdu events.
-; translate this thing into C with
-;  	awk -f ./compile.awk pdu.trans > pdutr.h
-;
-TABLE ADM
-;Transition table for the ADM state:
-;
-;frame type   p bit     action    newstate
-;received     in frame
-;
-I_CMD         0         ADM5      ADM
-I_CMD         1         ADM4      ADM
-RR_CMD        0         ADM5      ADM
-RR_CMD        1         ADM4      ADM
-RNR_CMD       0         ADM5      ADM
-RNR_CMD       1         ADM4      ADM
-REJ_CMD       0         ADM5      ADM
-REJ_CMD       1         ADM4      ADM
-DISC_CMD      0         ADM3      ADM
-DISC_CMD      1         ADM3      ADM
-SABME_CMD     0         ADM2      CONN  
-SABME_CMD     1         ADM2      CONN  
-I_RSP         0         ADM5      ADM
-I_RSP         1         ADM5      ADM
-RR_RSP        0         ADM5      ADM
-RR_RSP        1         ADM5      ADM
-RNR_RSP       0         ADM5      ADM
-RNR_RSP       1         ADM5      ADM
-REJ_RSP       0         ADM5      ADM
-REJ_RSP       1         ADM5      ADM
-UA_RSP        0         ADM5      ADM
-UA_RSP        1         ADM5      ADM
-DM_RSP        0         ADM5      ADM
-DM_RSP        1         ADM5      ADM
-FRMR_RSP      0         ADM5      ADM
-FRMR_RSP      1         ADM5      ADM
-;
-TABLE CONN
-;
-;Transition table for the CONN state:
-;
-;frame type   action    newstate
-;received     
-;
-I_CMD         CONN5     CONN
-RR_CMD        CONN5     CONN
-RNR_CMD       CONN5     CONN
-REJ_CMD       CONN5     CONN
-DISC_CMD      CONN5     CONN
-SABME_CMD     CONN3     CONN  
-I_RSP         CONN5     CONN
-RR_RSP        CONN5     CONN
-RNR_RSP       CONN5     CONN
-REJ_RSP       CONN5     CONN
-UA_RSP        CONN5     CONN
-DM_RSP        CONN4     ADM
-FRMR_RSP      CONN5     CONN
-;
-TABLE RESET_WAIT
-;Transition table for the RESET_WAIT
-;
-;frame type   action    newstate
-;received     
-;
-I_CMD         RESWAIT8  RESET_WAIT
-RR_CMD        RESWAIT8  RESET_WAIT
-RNR_CMD       RESWAIT8  RESET_WAIT
-REJ_CMD       RESWAIT8  RESET_WAIT
-DISC_CMD      RESWAIT7  RESET_WAIT
-SABME_CMD     RESWAIT6  RESET_WAIT
-I_RSP         RESWAIT8  RESET_WAIT
-RR_RSP        RESWAIT8  RESET_WAIT
-RNR_RSP       RESWAIT8  RESET_WAIT
-REJ_RSP       RESWAIT8  RESET_WAIT
-UA_RSP        RESWAIT8  RESET_WAIT
-DM_RSP        RESWAIT5  ADM
-FRMR_RSP      RESWAIT8  RESET_WAIT
-;
-;
-TABLE RESET_CHECK
-;Transition table for the RESET_CHECK state
-;
-;frame type   action    newstate
-;received     
-;
-I_CMD         RESCHK6  RESET_CHECK
-RR_CMD        RESCHK6  RESET_CHECK
-RNR_CMD       RESCHK6  RESET_CHECK
-REJ_CMD       RESCHK6  RESET_CHECK
-DISC_CMD      RESCHK5  ADM
-SABME_CMD     RESCHK4  RESET_CHECK
-I_RSP         RESCHK6  RESET_CHECK
-RR_RSP        RESCHK6  RESET_CHECK
-RNR_RSP       RESCHK6  RESET_CHECK
-REJ_RSP       RESCHK6  RESET_CHECK
-UA_RSP        RESCHK6  RESET_CHECK
-DM_RSP        RESCHK3  ADM
-FRMR_RSP      RESCHK6  RESET_CHECK
-;
-;
-TABLE SETUP
-;Transition table for the SETUP state
-;
-;frame type   p flag    action    newstate
-;received     = f
-;
-I_CMD         0         SETUP6      SETUP
-I_CMD         1         SETUP6      SETUP
-RR_CMD        0         SETUP6      SETUP
-RR_CMD        1         SETUP6      SETUP
-RNR_CMD       0         SETUP6      SETUP
-RNR_CMD       1         SETUP6      SETUP
-REJ_CMD       0         SETUP6      SETUP
-REJ_CMD       1         SETUP6      SETUP
-DISC_CMD      0         SETUP4      ADM
-DISC_CMD      1         SETUP4      ADM  
-SABME_CMD     0         SETUP1      SETUP 
-SABME_CMD     1         SETUP1      SETUP 
-I_RSP         0         SETUP6      SETUP
-I_RSP         1         SETUP6      SETUP
-RR_RSP        0         SETUP6      SETUP
-RR_RSP        1         SETUP6      SETUP
-RNR_RSP       0         SETUP6      SETUP
-RNR_RSP       1         SETUP6      SETUP
-REJ_RSP       0         SETUP6      SETUP
-REJ_RSP       1         SETUP6      SETUP
-UA_RSP        0         SETUP6      SETUP
-UA_RSP        1         SETUP2      NORMAL
-DM_RSP        0         SETUP5      ADM  
-DM_RSP        1         SETUP5      ADM  
-FRMR_RSP      0         SETUP6      SETUP
-FRMR_RSP      1         SETUP6      SETUP
-;
-;
-TABLE RESET
-;Transition table for the RESET state:
-;
-;frame type   p flag    action    newstate
-;received     = f
-;
-I_CMD         0         RESET6      RESET
-I_CMD         1         RESET6      RESET
-RR_CMD        0         RESET6      RESET
-RR_CMD        1         RESET6      RESET
-RNR_CMD       0         RESET6      RESET
-RNR_CMD       1         RESET6      RESET
-REJ_CMD       0         RESET6      RESET
-REJ_CMD       1         RESET6      RESET
-DISC_CMD      0         RESET4      ADM
-DISC_CMD      1         RESET4      ADM  
-SABME_CMD     0         RESET1      RESET 
-SABME_CMD     1         RESET1      RESET 
-I_RSP         0         RESET6      RESET
-I_RSP         1         RESET6      RESET
-RR_RSP        0         RESET6      RESET
-RR_RSP        1         RESET6      RESET
-RNR_RSP       0         RESET6      RESET
-RNR_RSP       1         RESET6      RESET
-REJ_RSP       0         RESET6      RESET
-REJ_RSP       1         RESET6      RESET
-UA_RSP        0         RESET6      RESET
-UA_RSP        1         RESET2      NORMAL
-DM_RSP        0         RESET5      ADM  
-DM_RSP        1         RESET5      ADM  
-FRMR_RSP      0         RESET6      RESET
-FRMR_RSP      1         RESET6      RESET
-;
-;
-TABLE D_CONN
-;Transition table for the D_CONN state:
-;
-;frame type   p bit     action    newstate
-;received     in frame  
-I_CMD         0         D_CONN5      D_CONN
-I_CMD         1         D_CONN5      D_CONN
-RR_CMD        0         D_CONN5      D_CONN
-RR_CMD        1         D_CONN5      D_CONN
-RNR_CMD       0         D_CONN5      D_CONN
-RNR_CMD       1         D_CONN5      D_CONN
-REJ_CMD       0         D_CONN5      D_CONN
-REJ_CMD       1         D_CONN5      D_CONN
-DISC_CMD      0         D_CONN3      D_CONN
-DISC_CMD      1         D_CONN3      D_CONN
-SABME_CMD     0         D_CONN1      ADM  
-SABME_CMD     1         D_CONN1      ADM    
-I_RSP         0         D_CONN5      D_CONN
-I_RSP         1         D_CONN5      D_CONN
-RR_RSP        0         D_CONN5      D_CONN
-RR_RSP        1         D_CONN5      D_CONN
-RNR_RSP       0         D_CONN5      D_CONN
-RNR_RSP       1         D_CONN5      D_CONN
-REJ_RSP       0         D_CONN5      D_CONN
-REJ_RSP       1         D_CONN5      D_CONN
-UA_RSP        0         D_CONN5      D_CONN
-UA_RSP        1         D_CONN4      ADM   
-DM_RSP        0         D_CONN4      ADM  
-DM_RSP        1         D_CONN5      ADM  
-FRMR_RSP      0         D_CONN5      D_CONN
-FRMR_RSP      1         D_CONN5      D_CONN
-;
-;
-TABLE ERROR
-;Transition table for the ERROR state:
-;
-;frame type   action    newstate
-;received     
-;
-I_CMD         ERR5      ERROR
-RR_CMD        ERR5      ERROR
-RNR_CMD       ERR5      ERROR
-REJ_CMD       ERR5      ERROR
-DISC_CMD      ERR2      ADM
-SABME_CMD     ERR1      RESET_CHECK
-I_RSP         ERR6      ERROR
-RR_RSP        ERR6      ERROR
-RNR_RSP       ERR6      ERROR
-REJ_RSP       ERR6      ERROR
-UA_RSP        ERR6      ERROR
-DM_RSP        ERR3      ADM
-FRMR_RSP      ERR4      RESET_WAIT
-;
-TABLE NORMAL
-;Transition table for the NORMAL state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	NORMAL8B	NORMAL
-I_CMD          	0	0	1	NORMAL9		NORMAL
-I_CMD          	0	1	0	NORMAL10	NORMAL
-I_CMD          	0	1	1	NORMAL10	NORMAL
-I_CMD          	1	0	0	NORMAL5		REJECT
-I_CMD          	1	0	1	NORMAL6		REJECT
-I_CMD          	1	1	0	NORMAL7		REJECT
-I_CMD          	1	1	1	NORMAL7		REJECT
-RR_CMD         	0	0	0	NORMAL11	NORMAL
-RR_CMD         	0	0	1	NORMAL11	NORMAL
-RR_CMD         	0	1	0	NORMAL12	NORMAL
-RR_CMD         	0	1	1	NORMAL12	NORMAL
-RR_CMD         	1	0	0	NORMAL11	NORMAL
-RR_CMD         	1	0	1	NORMAL11	NORMAL
-RR_CMD         	1	1	0	NORMAL12	NORMAL
-RR_CMD         	1	1	1	NORMAL12	NORMAL
-RNR_CMD        	0	0	0	NORMAL13	NORMAL
-RNR_CMD        	0	0	1	NORMAL13	NORMAL
-RNR_CMD        	0	1	0	NORMAL14	NORMAL
-RNR_CMD        	0	1	1	NORMAL14	NORMAL
-RNR_CMD        	1	0	0	NORMAL13	NORMAL
-RNR_CMD        	1	0	1	NORMAL13	NORMAL
-RNR_CMD        	1	1	0	NORMAL14	NORMAL
-RNR_CMD        	1	1	1	NORMAL14	NORMAL
-REJ_CMD        	0	0	0	NORMAL15	NORMAL
-REJ_CMD        	0	0	1	NORMAL16	NORMAL
-REJ_CMD        	0	1	0	NORMAL17	NORMAL 
-REJ_CMD        	0	1	1	NORMAL17	NORMAL 
-REJ_CMD        	1	0	0	NORMAL15	NORMAL
-REJ_CMD        	1	0	1	NORMAL16	NORMAL
-REJ_CMD        	1	1	0	NORMAL17	NORMAL 
-REJ_CMD        	1	1	1	NORMAL17	NORMAL 
-DISC_CMD       	0	0	0	SH4		ADM
-DISC_CMD       	0	0	1	SH4		ADM
-DISC_CMD       	0	1	0	SH4		ADM
-DISC_CMD       	0	1	1	SH4		ADM
-DISC_CMD       	1	0	0	SH4		ADM
-DISC_CMD       	1	0	1	SH4		ADM
-DISC_CMD       	1	1	0	SH4		ADM
-DISC_CMD       	1	1	1	SH4		ADM
-SABME_CMD      	0	0	0	SH3		RESET_CHECK
-SABME_CMD      	0	0	1	SH3		RESET_CHECK
-SABME_CMD      	0	1	0	SH3		RESET_CHECK
-SABME_CMD      	0	1	1	SH3		RESET_CHECK
-SABME_CMD      	1	0	0	SH3		RESET_CHECK
-SABME_CMD      	1	0	1	SH3		RESET_CHECK
-SABME_CMD      	1	1	0	SH3		RESET_CHECK
-SABME_CMD      	1	1	1	SH3		RESET_CHECK
-I_RSP          	0	0	0	NORMAL8B	NORMAL
-I_RSP          	0	0	1	NORMAL9		NORMAL
-I_RSP          	0	1	0	SH10		ERROR
-I_RSP          	0	1	1	NORMAL8A	NORMAL
-I_RSP          	1	0	0	NORMAL5		REJECT
-I_RSP          	1	0	1	NORMAL6		REJECT
-I_RSP          	1	1	0	SH10		ERROR
-I_RSP          	1	1	1	NORMAL5		REJECT
-RR_RSP         	0	0	0	NORMAL11	NORMAL
-RR_RSP         	0	0	1	NORMAL11	NORMAL
-RR_RSP         	0	1	0	SH10		ERROR
-RR_RSP         	0	1	1	NORMAL11	NORMAL
-RR_RSP         	1	0	0	NORMAL11	NORMAL
-RR_RSP         	1	0	1	NORMAL11	NORMAL
-RR_RSP         	1	1	0	SH10		ERROR
-RR_RSP         	1	1	1	NORMAL11	NORMAL
-RNR_RSP        	0	0	0	NORMAL13	NORMAL
-RNR_RSP        	0	0	1	NORMAL13	NORMAL
-RNR_RSP        	0	1	0	SH10		ERROR
-RNR_RSP        	0	1	1	NORMAL13	NORMAL
-RNR_RSP        	1	0	0	NORMAL13	NORMAL
-RNR_RSP        	1	0	1	NORMAL13	NORMAL
-RNR_RSP        	1	1	0	SH10		ERROR
-RNR_RSP        	1	1	1	NORMAL13	NORMAL
-REJ_RSP        	0	0	0	NORMAL15	NORMAL
-REJ_RSP        	0	0	1	NORMAL16	NORMAL
-REJ_RSP        	0	1	0	SH10		ERROR
-REJ_RSP        	0	1	1	NORMAL15	NORMAL
-REJ_RSP        	1	0	0	NORMAL15	NORMAL
-REJ_RSP        	1	0	1	NORMAL16	NORMAL
-REJ_RSP        	1	1	0	SH10		ERROR
-REJ_RSP        	1	1	1	NORMAL15	NORMAL
-UA_RSP         	0	0	0	SH9		ERROR
-UA_RSP         	0	0	1	SH9		ERROR
-UA_RSP         	0	1	0	SH9		ERROR
-UA_RSP         	0	1	1	SH9		ERROR
-UA_RSP         	1	0	0	SH9		ERROR
-UA_RSP         	1	0	1	SH9		ERROR
-UA_RSP         	1	1	0	SH9		ERROR
-UA_RSP         	1	1	1	SH9		ERROR
-DM_RSP         	0	0	0	SH6		ADM
-DM_RSP         	0	0	1	SH6		ADM
-DM_RSP         	0	1	0	SH6		ADM
-DM_RSP         	0	1	1	SH6		ADM
-DM_RSP         	1	0	0	SH6		ADM
-DM_RSP         	1	0	1	SH6		ADM
-DM_RSP         	1	1	0	SH6		ADM
-DM_RSP         	1	1	1	SH6		ADM
-FRMR_RSP       	0	0	0	SH5		RESET_WAIT
-FRMR_RSP       	0	0	1	SH5		RESET_WAIT
-FRMR_RSP       	0	1	0	SH5		RESET_WAIT
-FRMR_RSP       	0	1	1	SH5		RESET_WAIT
-FRMR_RSP       	1	0	0	SH5		RESET_WAIT
-FRMR_RSP       	1	0	1	SH5		RESET_WAIT
-FRMR_RSP       	1	1	0	SH5		RESET_WAIT
-FRMR_RSP       	1	1	1	SH5		RESET_WAIT
-BAD_FRAME      	0	0	0	SH7		ERROR
-BAD_FRAME      	0	0	1	SH7		ERROR
-BAD_FRAME      	0	1	0	SH7		ERROR
-BAD_FRAME      	0	1	1	SH7		ERROR
-BAD_FRAME      	1	0	0	SH7		ERROR
-BAD_FRAME      	1	0	1	SH7		ERROR
-BAD_FRAME      	1	1	0	SH7		ERROR
-BAD_FRAME      	1	1	1	SH7		ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 1 modified by tredit4 I_CMD 1 0 0 NORMAL5 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP 1 0 0 NORMAL5 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP 1 1 1 NORMAL5 REJECT
-;112 entries in table, 1 modified by tredit4 I_CMD 1 0 1 NORMAL6 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP 1 0 1 NORMAL6 REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x NORMAL7 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP x 1 1 NORMAL8A NORMAL
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 0 NORMAL8B NORMAL
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 0 NORMAL8B NORMAL
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 1 NORMAL9 NORMAL
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 1 NORMAL9 NORMAL
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x NORMAL10 NORMAL
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x NORMAL11 NORMAL
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x NORMAL11 NORMAL
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 1 NORMAL11 NORMAL
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x NORMAL12 NORMAL
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x NORMAL13 NORMAL
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x NORMAL13 NORMAL
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 1 NORMAL13 NORMAL
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x NORMAL14 NORMAL
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 0 NORMAL15 NORMAL
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 1 NORMAL15 NORMAL
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 0 NORMAL15 NORMAL
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 1 NORMAL16 NORMAL
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 1 NORMAL16 NORMAL
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x NORMAL17 NORMAL
-;
-TABLE BUSY
-;Transition table for the BUSY state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	BUSY13	BUSY
-I_CMD          	0	0	1	BUSY14	BUSY
-I_CMD          	0	1	0	BUSY12	BUSY
-I_CMD          	0	1	1	BUSY12	BUSY
-I_CMD          	1	0	0	BUSY9	BUSY
-I_CMD          	1	0	1	BUSY10	BUSY
-I_CMD          	1	1	0	BUSY11	BUSY
-I_CMD          	1	1	1	BUSY11	BUSY
-RR_CMD         	0	0	0	BUSY15	BUSY
-RR_CMD         	0	0	1	BUSY15	BUSY
-RR_CMD         	0	1	0	BUSY16	BUSY
-RR_CMD         	0	1	1	BUSY16	BUSY
-RR_CMD         	1	0	0	BUSY15	BUSY
-RR_CMD         	1	0	1	BUSY15	BUSY
-RR_CMD         	1	1	0	BUSY16	BUSY
-RR_CMD         	1	1	1	BUSY16	BUSY
-RNR_CMD        	0	0	0	BUSY17	BUSY
-RNR_CMD        	0	0	1	BUSY17	BUSY
-RNR_CMD        	0	1	0	BUSY18	BUSY
-RNR_CMD        	0	1	1	BUSY18	BUSY
-RNR_CMD        	1	0	0	BUSY17	BUSY
-RNR_CMD        	1	0	1	BUSY17	BUSY
-RNR_CMD        	1	1	0	BUSY18	BUSY
-RNR_CMD        	1	1	1	BUSY18	BUSY
-REJ_CMD        	0	0	0	BUSY19	BUSY
-REJ_CMD        	0	0	1	BUSY20	BUSY
-REJ_CMD        	0	1	0	BUSY21	BUSY 
-REJ_CMD        	0	1	1	BUSY21	BUSY 
-REJ_CMD        	1	0	0	BUSY19	BUSY
-REJ_CMD        	1	0	1	BUSY20	BUSY
-REJ_CMD        	1	1	0	BUSY21	BUSY 
-REJ_CMD        	1	1	1	BUSY21	BUSY 
-DISC_CMD       	0	0	0	SH4	ADM
-DISC_CMD       	0	0	1	SH4	ADM
-DISC_CMD       	0	1	0	SH4	ADM
-DISC_CMD       	0	1	1	SH4	ADM
-DISC_CMD       	1	0	0	SH4	ADM
-DISC_CMD       	1	0	1	SH4	ADM
-DISC_CMD       	1	1	0	SH4	ADM
-DISC_CMD       	1	1	1	SH4	ADM
-SABME_CMD      	0	0	0	SH3	RESET_CHECK
-SABME_CMD      	0	0	1	SH3	RESET_CHECK
-SABME_CMD      	0	1	0	SH3	RESET_CHECK
-SABME_CMD      	0	1	1	SH3	RESET_CHECK
-SABME_CMD      	1	0	0	SH3	RESET_CHECK
-SABME_CMD      	1	0	1	SH3	RESET_CHECK
-SABME_CMD      	1	1	0	SH3	RESET_CHECK
-SABME_CMD      	1	1	1	SH3	RESET_CHECK
-I_RSP          	0	0	0	BUSY13	BUSY
-I_RSP          	0	0	1	BUSY14	BUSY
-I_RSP          	0	1	0	SH10	ERROR
-I_RSP          	0	1	1	BUSY13	BUSY
-I_RSP          	1	0	0	BUSY9	BUSY
-I_RSP          	1	0	1	BUSY10	BUSY
-I_RSP          	1	1	0	SH10	ERROR
-I_RSP          	1	1	1	BUSY9	BUSY
-RR_RSP         	0	0	0	BUSY15	BUSY
-RR_RSP         	0	0	1	BUSY15	BUSY
-RR_RSP         	0	1	0	SH10	ERROR
-RR_RSP         	0	1	1	BUSY15	BUSY
-RR_RSP         	1	0	0	BUSY15	BUSY
-RR_RSP         	1	0	1	BUSY15	BUSY
-RR_RSP         	1	1	0	SH10	ERROR
-RR_RSP         	1	1	1	BUSY15	BUSY
-RNR_RSP        	0	0	0	BUSY17	BUSY
-RNR_RSP        	0	0	1	BUSY17	BUSY
-RNR_RSP        	0	1	0	SH10	ERROR
-RNR_RSP        	0	1	1	BUSY17	BUSY
-RNR_RSP        	1	0	0	BUSY17	BUSY
-RNR_RSP        	1	0	1	BUSY17	BUSY
-RNR_RSP        	1	1	0	SH10	ERROR
-RNR_RSP        	1	1	1	BUSY17	BUSY
-REJ_RSP        	0	0	0	BUSY19	BUSY
-REJ_RSP        	0	0	1	BUSY20	BUSY
-REJ_RSP        	0	1	0	SH10	ERROR
-REJ_RSP        	0	1	1	BUSY19	BUSY
-REJ_RSP        	1	0	0	BUSY19	BUSY
-REJ_RSP        	1	0	1	BUSY20	BUSY
-REJ_RSP        	1	1	0	SH10	ERROR
-REJ_RSP        	1	1	1	BUSY19	BUSY
-UA_RSP         	0	0	0	SH9	ERROR
-UA_RSP         	0	0	1	SH9	ERROR
-UA_RSP         	0	1	0	SH9	ERROR
-UA_RSP         	0	1	1	SH9	ERROR
-UA_RSP         	1	0	0	SH9	ERROR
-UA_RSP         	1	0	1	SH9	ERROR
-UA_RSP         	1	1	0	SH9	ERROR
-UA_RSP         	1	1	1	SH9	ERROR
-DM_RSP         	0	0	0	SH6	ADM
-DM_RSP         	0	0	1	SH6	ADM
-DM_RSP         	0	1	0	SH6	ADM
-DM_RSP         	0	1	1	SH6	ADM
-DM_RSP         	1	0	0	SH6	ADM
-DM_RSP         	1	0	1	SH6	ADM
-DM_RSP         	1	1	0	SH6	ADM
-DM_RSP         	1	1	1	SH6	ADM
-FRMR_RSP       	0	0	0	SH5	RESET_WAIT
-FRMR_RSP       	0	0	1	SH5	RESET_WAIT
-FRMR_RSP       	0	1	0	SH5	RESET_WAIT
-FRMR_RSP       	0	1	1	SH5	RESET_WAIT
-FRMR_RSP       	1	0	0	SH5	RESET_WAIT
-FRMR_RSP       	1	0	1	SH5	RESET_WAIT
-FRMR_RSP       	1	1	0	SH5	RESET_WAIT
-FRMR_RSP       	1	1	1	SH5	RESET_WAIT
-BAD_FRAME      	0	0	0	SH7	ERROR
-BAD_FRAME      	0	0	1	SH7	ERROR
-BAD_FRAME      	0	1	0	SH7	ERROR
-BAD_FRAME      	0	1	1	SH7	ERROR
-BAD_FRAME      	1	0	0	SH7	ERROR
-BAD_FRAME      	1	0	1	SH7	ERROR
-BAD_FRAME      	1	1	0	SH7	ERROR
-BAD_FRAME      	1	1	1	SH7	ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 1 modified by tredit4 I_RSP 1 0 0 BUSY9 BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP 1 1 1 BUSY9 BUSY
-;112 entries in table, 1 modified by tredit4 I_CMD 1 0 0 BUSY9 BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP 1 0 1 BUSY10 BUSY
-;112 entries in table, 1 modified by tredit4 I_CMD 1 0 1 BUSY10 BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x BUSY11 BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x BUSY12 BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 0 BUSY13 BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP x 1 1 BUSY13 BUSY
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 0 BUSY13 BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 1 BUSY14 BUSY
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 1 BUSY14 BUSY
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x BUSY15 BUSY
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x BUSY15 BUSY
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 1 BUSY15 BUSY
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x BUSY16 BUSY
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x BUSY17 BUSY
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x BUSY17 BUSY
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 1 BUSY17 BUSY
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x BUSY18 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 0 BUSY19 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 0 BUSY19 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 1 BUSY19 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 1 BUSY20 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 1 BUSY20 BUSY
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x BUSY21 BUSY
-;
-TABLE REJECT
-;Transition table for the REJECT state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	REJECT7		REJECT
-I_CMD          	0	0	1	REJECT8		REJECT
-I_CMD          	0	1	0	REJECT9		REJECT
-I_CMD          	0	1	1	REJECT9		REJECT
-I_CMD          	1	0	0	REJECT5		REJECT
-I_CMD          	1	0	1	REJECT5		REJECT
-I_CMD          	1	1	0	REJECT6		REJECT
-I_CMD          	1	1	1	REJECT6		REJECT
-RR_CMD         	0	0	0	REJECT10	REJECT
-RR_CMD         	0	0	1	REJECT10	REJECT
-RR_CMD         	0	1	0	REJECT11	REJECT
-RR_CMD         	0	1	1	REJECT11	REJECT
-RR_CMD         	1	0	0	REJECT10	REJECT
-RR_CMD         	1	0	1	REJECT10	REJECT
-RR_CMD         	1	1	0	REJECT11	REJECT
-RR_CMD         	1	1	1	REJECT11	REJECT
-RNR_CMD        	0	0	0	REJECT12	REJECT
-RNR_CMD        	0	0	1	REJECT12	REJECT
-RNR_CMD        	0	1	0	REJECT13	REJECT
-RNR_CMD        	0	1	1	REJECT13	REJECT
-RNR_CMD        	1	0	0	REJECT12	REJECT
-RNR_CMD        	1	0	1	REJECT12	REJECT
-RNR_CMD        	1	1	0	REJECT13	REJECT
-RNR_CMD        	1	1	1	REJECT13	REJECT
-REJ_CMD        	0	0	0	REJECT14	REJECT
-REJ_CMD        	0	0	1	REJECT15	REJECT
-REJ_CMD        	0	1	0	REJECT16	REJECT 
-REJ_CMD        	0	1	1	REJECT16	REJECT 
-REJ_CMD        	1	0	0	REJECT14	REJECT
-REJ_CMD        	1	0	1	REJECT15	REJECT
-REJ_CMD        	1	1	0	REJECT16	REJECT 
-REJ_CMD        	1	1	1	REJECT16	REJECT 
-DISC_CMD       	0	0	0	SH4		ADM
-DISC_CMD       	0	0	1	SH4		ADM
-DISC_CMD       	0	1	0	SH4		ADM
-DISC_CMD       	0	1	1	SH4		ADM
-DISC_CMD       	1	0	0	SH4		ADM
-DISC_CMD       	1	0	1	SH4		ADM
-DISC_CMD       	1	1	0	SH4		ADM
-DISC_CMD       	1	1	1	SH4		ADM
-SABME_CMD      	0	0	0	SH3		RESET_CHECK
-SABME_CMD      	0	0	1	SH3		RESET_CHECK
-SABME_CMD      	0	1	0	SH3		RESET_CHECK
-SABME_CMD      	0	1	1	SH3		RESET_CHECK
-SABME_CMD      	1	0	0	SH3		RESET_CHECK
-SABME_CMD      	1	0	1	SH3		RESET_CHECK
-SABME_CMD      	1	1	0	SH3		RESET_CHECK
-SABME_CMD      	1	1	1	SH3		RESET_CHECK
-I_RSP          	0	0	0	REJECT7		REJECT
-I_RSP          	0	0	1	REJECT8		REJECT
-I_RSP          	0	1	0	SH10		ERROR
-I_RSP          	0	1	1	REJECT7		REJECT
-I_RSP          	1	0	0	REJECT5		REJECT
-I_RSP          	1	0	1	REJECT5		REJECT
-I_RSP          	1	1	0	SH10		ERROR
-I_RSP          	1	1	1	REJECT5		REJECT
-RR_RSP         	0	0	0	REJECT10	REJECT
-RR_RSP         	0	0	1	REJECT10	REJECT
-RR_RSP         	0	1	0	SH10		ERROR
-RR_RSP         	0	1	1	REJECT10	REJECT
-RR_RSP         	1	0	0	REJECT10	REJECT
-RR_RSP         	1	0	1	REJECT10	REJECT
-RR_RSP         	1	1	0	SH10		ERROR
-RR_RSP         	1	1	1	REJECT10	REJECT
-RNR_RSP        	0	0	0	REJECT12	REJECT
-RNR_RSP        	0	0	1	REJECT12	REJECT
-RNR_RSP        	0	1	0	SH10		ERROR
-RNR_RSP        	0	1	1	REJECT12	REJECT
-RNR_RSP        	1	0	0	REJECT12	REJECT
-RNR_RSP        	1	0	1	REJECT12	REJECT
-RNR_RSP        	1	1	0	SH10		ERROR
-RNR_RSP        	1	1	1	REJECT12	REJECT
-REJ_RSP        	0	0	0	REJECT14	REJECT
-REJ_RSP        	0	0	1	REJECT15	REJECT
-REJ_RSP        	0	1	0	SH10		ERROR
-REJ_RSP        	0	1	1	REJECT14	REJECT
-REJ_RSP        	1	0	0	REJECT14	REJECT
-REJ_RSP        	1	0	1	REJECT15	REJECT
-REJ_RSP        	1	1	0	SH10		ERROR
-REJ_RSP        	1	1	1	REJECT14	REJECT
-UA_RSP         	0	0	0	SH9		ERROR
-UA_RSP         	0	0	1	SH9		ERROR
-UA_RSP         	0	1	0	SH9		ERROR
-UA_RSP         	0	1	1	SH9		ERROR
-UA_RSP         	1	0	0	SH9		ERROR
-UA_RSP         	1	0	1	SH9		ERROR
-UA_RSP         	1	1	0	SH9		ERROR
-UA_RSP         	1	1	1	SH9		ERROR
-DM_RSP         	0	0	0	SH6		ADM
-DM_RSP         	0	0	1	SH6		ADM
-DM_RSP         	0	1	0	SH6		ADM
-DM_RSP         	0	1	1	SH6		ADM
-DM_RSP         	1	0	0	SH6		ADM
-DM_RSP         	1	0	1	SH6		ADM
-DM_RSP         	1	1	0	SH6		ADM
-DM_RSP         	1	1	1	SH6		ADM
-FRMR_RSP       	0	0	0	SH5		RESET_WAIT
-FRMR_RSP       	0	0	1	SH5		RESET_WAIT
-FRMR_RSP       	0	1	0	SH5		RESET_WAIT
-FRMR_RSP       	0	1	1	SH5		RESET_WAIT
-FRMR_RSP       	1	0	0	SH5		RESET_WAIT
-FRMR_RSP       	1	0	1	SH5		RESET_WAIT
-FRMR_RSP       	1	1	0	SH5		RESET_WAIT
-FRMR_RSP       	1	1	1	SH5		RESET_WAIT
-BAD_FRAME      	0	0	0	SH7		ERROR
-BAD_FRAME      	0	0	1	SH7		ERROR
-BAD_FRAME      	0	1	0	SH7		ERROR
-BAD_FRAME      	0	1	1	SH7		ERROR
-BAD_FRAME      	1	0	0	SH7		ERROR
-BAD_FRAME      	1	0	1	SH7		ERROR
-BAD_FRAME      	1	1	0	SH7		ERROR
-BAD_FRAME      	1	1	1	SH7		ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 2 modified by tredit4 I_CMD 1 0 x REJECT5 REJECT
-;112 entries in table, 2 modified by tredit4 I_RSP 1 0 x REJECT5 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP 1 1 1 REJECT5 REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x REJECT6 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP x 1 1 REJECT7 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 0 REJECT7 REJECT
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 0 REJECT7 REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP x 0 1 REJECT8 REJECT
-;112 entries in table, 1 modified by tredit4 I_CMD x 0 1 REJECT8 REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x REJECT9 REJECT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x REJECT10 REJECT
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x REJECT10 REJECT
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 1 REJECT10 REJECT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x REJECT11 REJECT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x REJECT12 REJECT
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x REJECT12 REJECT
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 1 REJECT12 REJECT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x REJECT13 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 0 REJECT14 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 0 REJECT14 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 1 REJECT14 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_CMD x 0 1 REJECT15 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 0 1 REJECT15 REJECT
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x REJECT16 REJECT
-;
-TABLE AWAIT
-;Transition table for the AWAIT state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	AWAIT6	AWAIT
-I_CMD          	0	0	1	AWAIT6	AWAIT
-I_CMD          	0	1	0	AWAIT7	AWAIT
-I_CMD          	0	1	1	AWAIT7	AWAIT
-I_CMD          	1	0	0	AWAIT3	AWAIT_REJECT
-I_CMD          	1	0	1	AWAIT3	AWAIT_REJECT
-I_CMD          	1	1	0	AWAIT4	AWAIT_REJECT
-I_CMD          	1	1	1	AWAIT4	AWAIT_REJECT
-RR_CMD         	0	0	0	AWAIT9	AWAIT
-RR_CMD         	0	0	1	AWAIT9	AWAIT
-RR_CMD         	0	1	0	AWAIT10	AWAIT
-RR_CMD         	0	1	1	AWAIT10	AWAIT
-RR_CMD         	1	0	0	AWAIT9	AWAIT
-RR_CMD         	1	0	1	AWAIT9	AWAIT
-RR_CMD         	1	1	0	AWAIT10	AWAIT
-RR_CMD         	1	1	1	AWAIT10	AWAIT
-RNR_CMD        	0	0	0	AWAIT12	AWAIT
-RNR_CMD        	0	0	1	AWAIT12	AWAIT
-RNR_CMD        	0	1	0	AWAIT13	AWAIT 
-RNR_CMD        	0	1	1	AWAIT13	AWAIT 
-RNR_CMD        	1	0	0	AWAIT12	AWAIT
-RNR_CMD        	1	0	1	AWAIT12	AWAIT
-RNR_CMD        	1	1	0	AWAIT13	AWAIT 
-RNR_CMD        	1	1	1	AWAIT13	AWAIT 
-REJ_CMD        	0	0	0	AWAIT9	AWAIT
-REJ_CMD        	0	0	1	AWAIT9	AWAIT
-REJ_CMD        	0	1	0	AWAIT10	AWAIT
-REJ_CMD        	0	1	1	AWAIT10	AWAIT
-REJ_CMD        	1	0	0	AWAIT9	AWAIT
-REJ_CMD        	1	0	1	AWAIT9	AWAIT
-REJ_CMD        	1	1	0	AWAIT10	AWAIT
-REJ_CMD        	1	1	1	AWAIT10	AWAIT
-DISC_CMD       	0	0	0	SH4	ADM
-DISC_CMD       	0	0	1	SH4	ADM
-DISC_CMD       	0	1	0	SH4	ADM
-DISC_CMD       	0	1	1	SH4	ADM
-DISC_CMD       	1	0	0	SH4	ADM
-DISC_CMD       	1	0	1	SH4	ADM
-DISC_CMD       	1	1	0	SH4	ADM
-DISC_CMD       	1	1	1	SH4	ADM
-SABME_CMD      	0	0	0	SH3	RESET_CHECK
-SABME_CMD      	0	0	1	SH3	RESET_CHECK
-SABME_CMD      	0	1	0	SH3	RESET_CHECK
-SABME_CMD      	0	1	1	SH3	RESET_CHECK
-SABME_CMD      	1	0	0	SH3	RESET_CHECK
-SABME_CMD      	1	0	1	SH3	RESET_CHECK
-SABME_CMD      	1	1	0	SH3	RESET_CHECK
-SABME_CMD      	1	1	1	SH3	RESET_CHECK
-I_RSP          	0	0	0	AWAIT6	AWAIT
-I_RSP          	0	0	1	AWAIT6	AWAIT
-I_RSP          	0	1	0	SH10	ERROR
-I_RSP          	0	1	1	AWAIT5	NORMAL
-I_RSP          	1	0	0	AWAIT3	AWAIT_REJECT
-I_RSP          	1	0	1	AWAIT3	AWAIT_REJECT
-I_RSP          	1	1	0	SH10	ERROR
-I_RSP          	1	1	1	AWAIT2	REJECT
-RR_RSP         	0	0	0	AWAIT9	AWAIT
-RR_RSP         	0	0	1	AWAIT9	AWAIT
-RR_RSP         	0	1	0	SH10	ERROR
-RR_RSP         	0	1	1	AWAIT8	AWAIT
-RR_RSP         	1	0	0	AWAIT9	AWAIT
-RR_RSP         	1	0	1	AWAIT9	AWAIT
-RR_RSP         	1	1	0	SH10	ERROR
-RR_RSP         	1	1	1	AWAIT8	AWAIT
-RNR_RSP        	0	0	0	AWAIT12	AWAIT
-RNR_RSP        	0	0	1	AWAIT12	AWAIT
-RNR_RSP        	0	1	0	SH10	ERROR
-RNR_RSP        	0	1	1	AWAIT11	AWAIT
-RNR_RSP        	1	0	0	AWAIT12	AWAIT
-RNR_RSP        	1	0	1	AWAIT12	AWAIT
-RNR_RSP        	1	1	0	SH10	ERROR
-RNR_RSP        	1	1	1	AWAIT11	AWAIT
-REJ_RSP        	0	0	0	AWAIT9	AWAIT
-REJ_RSP        	0	0	1	AWAIT9	AWAIT
-REJ_RSP        	0	1	0	SH10	ERROR
-REJ_RSP        	0	1	1	AWAIT8	AWAIT
-REJ_RSP        	1	0	0	AWAIT9	AWAIT
-REJ_RSP        	1	0	1	AWAIT9	AWAIT
-REJ_RSP        	1	1	0	SH10	ERROR
-REJ_RSP        	1	1	1	AWAIT8	AWAIT
-UA_RSP         	0	0	0	SH9	ERROR
-UA_RSP         	0	0	1	SH9	ERROR
-UA_RSP         	0	1	0	SH9	ERROR
-UA_RSP         	0	1	1	SH9	ERROR
-UA_RSP         	1	0	0	SH9	ERROR
-UA_RSP         	1	0	1	SH9	ERROR
-UA_RSP         	1	1	0	SH9	ERROR
-UA_RSP         	1	1	1	SH9	ERROR
-DM_RSP         	0	0	0	SH6	ADM
-DM_RSP         	0	0	1	SH6	ADM
-DM_RSP         	0	1	0	SH6	ADM
-DM_RSP         	0	1	1	SH6	ADM
-DM_RSP         	1	0	0	SH6	ADM
-DM_RSP         	1	0	1	SH6	ADM
-DM_RSP         	1	1	0	SH6	ADM
-DM_RSP         	1	1	1	SH6	ADM
-FRMR_RSP       	0	0	0	SH5	RESET_WAIT
-FRMR_RSP       	0	0	1	SH5	RESET_WAIT
-FRMR_RSP       	0	1	0	SH5	RESET_WAIT
-FRMR_RSP       	0	1	1	SH5	RESET_WAIT
-FRMR_RSP       	1	0	0	SH5	RESET_WAIT
-FRMR_RSP       	1	0	1	SH5	RESET_WAIT
-FRMR_RSP       	1	1	0	SH5	RESET_WAIT
-FRMR_RSP       	1	1	1	SH5	RESET_WAIT
-BAD_FRAME      	0	0	0	SH7	ERROR
-BAD_FRAME      	0	0	1	SH7	ERROR
-BAD_FRAME      	0	1	0	SH7	ERROR
-BAD_FRAME      	0	1	1	SH7	ERROR
-BAD_FRAME      	1	0	0	SH7	ERROR
-BAD_FRAME      	1	0	1	SH7	ERROR
-BAD_FRAME      	1	1	0	SH7	ERROR
-BAD_FRAME      	1	1	1	SH7	ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 1 modified by tredit4 I_RSP 1 1 x AWAIT2 REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD 1 0 x AWAIT3 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 I_RSP 1 0 x AWAIT3 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x AWAIT4 AWAIT_REJECT
-;112 entries in table, 1 modified by tredit4 I_RSP x 1 x AWAIT5 NORMAL
-;112 entries in table, 2 modified by tredit4 I_RSP x 0 x AWAIT6 AWAIT
-;112 entries in table, 2 modified by tredit4 I_CMD x 0 x AWAIT6 AWAIT
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x AWAIT7 AWAIT
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 x AWAIT8 AWAIT
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 x AWAIT8 AWAIT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x AWAIT9 AWAIT
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x AWAIT9 AWAIT
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 0 x AWAIT9 AWAIT
-;112 entries in table, 4 modified by tredit4 REJ_RSP x 0 x AWAIT9 AWAIT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x AWAIT10 AWAIT
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x AWAIT10 AWAIT
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 x AWAIT11 AWAIT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x AWAIT12 AWAIT
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x AWAIT12 AWAIT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x AWAIT13 AWAIT
-;
-TABLE AWAIT_BUSY
-;Transition table for the AWAIT_BUSY state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	AWAIT_BUSY8	AWAIT_BUSY
-I_CMD          	0	0	1	AWAIT_BUSY8	AWAIT_BUSY
-I_CMD          	0	1	0	AWAIT_BUSY9	AWAIT_BUSY
-I_CMD          	0	1	1	AWAIT_BUSY9	AWAIT_BUSY
-I_CMD          	1	0	0	AWAIT_BUSY5	AWAIT_BUSY
-I_CMD          	1	0	1	AWAIT_BUSY5	AWAIT_BUSY
-I_CMD          	1	1	0	AWAIT_BUSY6	AWAIT_BUSY
-I_CMD          	1	1	1	AWAIT_BUSY6	AWAIT_BUSY
-RR_CMD         	0	0	0	AWAIT_BUSY11	AWAIT_BUSY
-RR_CMD         	0	0	1	AWAIT_BUSY11	AWAIT_BUSY
-RR_CMD         	0	1	0	AWAIT_BUSY12	AWAIT_BUSY
-RR_CMD         	0	1	1	AWAIT_BUSY12	AWAIT_BUSY
-RR_CMD         	1	0	0	AWAIT_BUSY11	AWAIT_BUSY
-RR_CMD         	1	0	1	AWAIT_BUSY11	AWAIT_BUSY
-RR_CMD         	1	1	0	AWAIT_BUSY12	AWAIT_BUSY
-RR_CMD         	1	1	1	AWAIT_BUSY12	AWAIT_BUSY
-RNR_CMD        	0	0	0	AWAIT_BUSY14	AWAIT_BUSY
-RNR_CMD        	0	0	1	AWAIT_BUSY14	AWAIT_BUSY
-RNR_CMD        	0	1	0	AWAIT_BUSY15	AWAIT_BUSY 
-RNR_CMD        	0	1	1	AWAIT_BUSY15	AWAIT_BUSY 
-RNR_CMD        	1	0	0	AWAIT_BUSY14	AWAIT_BUSY
-RNR_CMD        	1	0	1	AWAIT_BUSY14	AWAIT_BUSY
-RNR_CMD        	1	1	0	AWAIT_BUSY15	AWAIT_BUSY 
-RNR_CMD        	1	1	1	AWAIT_BUSY15	AWAIT_BUSY 
-REJ_CMD        	0	0	0	AWAIT_BUSY11	AWAIT_BUSY
-REJ_CMD        	0	0	1	AWAIT_BUSY11	AWAIT_BUSY
-REJ_CMD        	0	1	0	AWAIT_BUSY12	AWAIT_BUSY
-REJ_CMD        	0	1	1	AWAIT_BUSY12	AWAIT_BUSY
-REJ_CMD        	1	0	0	AWAIT_BUSY11	AWAIT_BUSY
-REJ_CMD        	1	0	1	AWAIT_BUSY11	AWAIT_BUSY
-REJ_CMD        	1	1	0	AWAIT_BUSY12	AWAIT_BUSY
-REJ_CMD        	1	1	1	AWAIT_BUSY12	AWAIT_BUSY
-DISC_CMD       	0	0	0	SH4		ADM
-DISC_CMD       	0	0	1	SH4		ADM
-DISC_CMD       	0	1	0	SH4		ADM
-DISC_CMD       	0	1	1	SH4		ADM
-DISC_CMD       	1	0	0	SH4		ADM
-DISC_CMD       	1	0	1	SH4		ADM
-DISC_CMD       	1	1	0	SH4		ADM
-DISC_CMD       	1	1	1	SH4		ADM
-SABME_CMD      	0	0	0	SH3		RESET_CHECK
-SABME_CMD      	0	0	1	SH3		RESET_CHECK
-SABME_CMD      	0	1	0	SH3		RESET_CHECK
-SABME_CMD      	0	1	1	SH3		RESET_CHECK
-SABME_CMD      	1	0	0	SH3		RESET_CHECK
-SABME_CMD      	1	0	1	SH3		RESET_CHECK
-SABME_CMD      	1	1	0	SH3		RESET_CHECK
-SABME_CMD      	1	1	1	SH3		RESET_CHECK
-I_RSP          	0	0	0	AWAIT_BUSY8	AWAIT_BUSY
-I_RSP          	0	0	1	AWAIT_BUSY8	AWAIT_BUSY
-I_RSP          	0	1	0	SH10		ERROR
-I_RSP          	0	1	1	AWAIT_BUSY7	BUSY
-I_RSP          	1	0	0	AWAIT_BUSY5	AWAIT_BUSY
-I_RSP          	1	0	1	AWAIT_BUSY5	AWAIT_BUSY
-I_RSP          	1	1	0	SH10		ERROR
-I_RSP          	1	1	1	AWAIT_BUSY4	BUSY
-RR_RSP         	0	0	0	AWAIT_BUSY11	AWAIT_BUSY
-RR_RSP         	0	0	1	AWAIT_BUSY11	AWAIT_BUSY
-RR_RSP         	0	1	0	SH10		ERROR
-RR_RSP         	0	1	1	AWAIT_BUSY10	BUSY
-RR_RSP         	1	0	0	AWAIT_BUSY11	AWAIT_BUSY
-RR_RSP         	1	0	1	AWAIT_BUSY11	AWAIT_BUSY
-RR_RSP         	1	1	0	SH10		ERROR
-RR_RSP         	1	1	1	AWAIT_BUSY10	BUSY
-RNR_RSP        	0	0	0	AWAIT_BUSY14	AWAIT_BUSY
-RNR_RSP        	0	0	1	AWAIT_BUSY14	AWAIT_BUSY
-RNR_RSP        	0	1	0	SH10		ERROR
-RNR_RSP        	0	1	1	AWAIT_BUSY13	BUSY
-RNR_RSP        	1	0	0	AWAIT_BUSY14	AWAIT_BUSY
-RNR_RSP        	1	0	1	AWAIT_BUSY14	AWAIT_BUSY
-RNR_RSP        	1	1	0	SH10		ERROR
-RNR_RSP        	1	1	1	AWAIT_BUSY13	BUSY
-REJ_RSP        	0	0	0	AWAIT_BUSY11	AWAIT_BUSY
-REJ_RSP        	0	0	1	AWAIT_BUSY11	AWAIT_BUSY
-REJ_RSP        	0	1	0	SH10		ERROR
-REJ_RSP        	0	1	1	AWAIT_BUSY10	BUSY
-REJ_RSP        	1	0	0	AWAIT_BUSY11	AWAIT_BUSY
-REJ_RSP        	1	0	1	AWAIT_BUSY11	AWAIT_BUSY
-REJ_RSP        	1	1	0	SH10		ERROR
-REJ_RSP        	1	1	1	AWAIT_BUSY10	BUSY
-UA_RSP         	0	0	0	SH9		ERROR
-UA_RSP         	0	0	1	SH9		ERROR
-UA_RSP         	0	1	0	SH9		ERROR
-UA_RSP         	0	1	1	SH9		ERROR
-UA_RSP         	1	0	0	SH9		ERROR
-UA_RSP         	1	0	1	SH9		ERROR
-UA_RSP         	1	1	0	SH9		ERROR
-UA_RSP         	1	1	1	SH9		ERROR
-DM_RSP         	0	0	0	SH6		ADM
-DM_RSP         	0	0	1	SH6		ADM
-DM_RSP         	0	1	0	SH6		ADM
-DM_RSP         	0	1	1	SH6		ADM
-DM_RSP         	1	0	0	SH6		ADM
-DM_RSP         	1	0	1	SH6		ADM
-DM_RSP         	1	1	0	SH6		ADM
-DM_RSP         	1	1	1	SH6		ADM
-FRMR_RSP       	0	0	0	SH5		RESET_WAIT
-FRMR_RSP       	0	0	1	SH5		RESET_WAIT
-FRMR_RSP       	0	1	0	SH5		RESET_WAIT
-FRMR_RSP       	0	1	1	SH5		RESET_WAIT
-FRMR_RSP       	1	0	0	SH5		RESET_WAIT
-FRMR_RSP       	1	0	1	SH5		RESET_WAIT
-FRMR_RSP       	1	1	0	SH5		RESET_WAIT
-FRMR_RSP       	1	1	1	SH5		RESET_WAIT
-BAD_FRAME      	0	0	0	SH7		ERROR
-BAD_FRAME      	0	0	1	SH7		ERROR
-BAD_FRAME      	0	1	0	SH7		ERROR
-BAD_FRAME      	0	1	1	SH7		ERROR
-BAD_FRAME      	1	0	0	SH7		ERROR
-BAD_FRAME      	1	0	1	SH7		ERROR
-BAD_FRAME      	1	1	0	SH7		ERROR
-BAD_FRAME      	1	1	1	SH7		ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 1 modified by tredit4 I_RSP 1 1 x AWAIT_BUSY4 BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD 1 0 x AWAIT_BUSY5 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 I_RSP 1 0 x AWAIT_BUSY5 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x AWAIT_BUSY6 AWAIT_BUSY
-;112 entries in table, 1 modified by tredit4 I_RSP x 1 x AWAIT_BUSY7 BUSY
-;112 entries in table, 2 modified by tredit4 I_RSP x 0 x AWAIT_BUSY8 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD x 0 x AWAIT_BUSY8 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x AWAIT_BUSY9 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 x AWAIT_BUSY10 BUSY
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 x AWAIT_BUSY10 BUSY
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x AWAIT_BUSY11 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x AWAIT_BUSY11 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 0 x AWAIT_BUSY11 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 REJ_RSP x 0 x AWAIT_BUSY11 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x AWAIT_BUSY12 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x AWAIT_BUSY12 AWAIT_BUSY
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 x AWAIT_BUSY13 BUSY
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x AWAIT_BUSY14 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x AWAIT_BUSY14 AWAIT_BUSY
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x AWAIT_BUSY15 AWAIT_BUSY
-;
-TABLE AWAIT_REJECT
-;Transition table for the AWAIT_REJECT state:
-;
-;frame type   uexpect   p bit     p_flag    
-;received     N(S)      in frame            
-;
-I_CMD          	0	0	0	AWAIT_REJECT5	AWAIT
-I_CMD          	0	0	1	AWAIT_REJECT5	AWAIT
-I_CMD          	0	1	0	AWAIT_REJECT6	AWAIT
-I_CMD          	0	1	1	AWAIT_REJECT6	AWAIT
-I_CMD          	1	0	0	AWAIT_REJECT2	AWAIT_REJECT
-I_CMD          	1	0	1	AWAIT_REJECT2	AWAIT_REJECT
-I_CMD          	1	1	0	AWAIT_REJECT3	AWAIT_REJECT
-I_CMD          	1	1	1	AWAIT_REJECT3	AWAIT_REJECT
-RR_CMD         	0	0	0	AWAIT_REJECT8	AWAIT_REJECT
-RR_CMD         	0	0	1	AWAIT_REJECT8	AWAIT_REJECT
-RR_CMD         	0	1	0	AWAIT_REJECT9	AWAIT_REJECT
-RR_CMD         	0	1	1	AWAIT_REJECT9	AWAIT_REJECT
-RR_CMD         	1	0	0	AWAIT_REJECT8	AWAIT_REJECT
-RR_CMD         	1	0	1	AWAIT_REJECT8	AWAIT_REJECT
-RR_CMD         	1	1	0	AWAIT_REJECT9	AWAIT_REJECT
-RR_CMD         	1	1	1	AWAIT_REJECT9	AWAIT_REJECT
-RNR_CMD        	0	0	0	AWAIT_REJECT11	AWAIT_REJECT
-RNR_CMD        	0	0	1	AWAIT_REJECT11	AWAIT_REJECT
-RNR_CMD        	0	1	0	AWAIT_REJECT12	AWAIT_REJECT
-RNR_CMD        	0	1	1	AWAIT_REJECT12	AWAIT_REJECT
-RNR_CMD        	1	0	0	AWAIT_REJECT11	AWAIT_REJECT
-RNR_CMD        	1	0	1	AWAIT_REJECT11	AWAIT_REJECT
-RNR_CMD        	1	1	0	AWAIT_REJECT12	AWAIT_REJECT
-RNR_CMD        	1	1	1	AWAIT_REJECT12	AWAIT_REJECT
-REJ_CMD        	0	0	0	AWAIT_REJECT8	AWAIT_REJECT
-REJ_CMD        	0	0	1	AWAIT_REJECT8	AWAIT_REJECT
-REJ_CMD        	0	1	0	AWAIT_REJECT9	AWAIT_REJECT
-REJ_CMD        	0	1	1	AWAIT_REJECT9	AWAIT_REJECT
-REJ_CMD        	1	0	0	AWAIT_REJECT8	AWAIT_REJECT
-REJ_CMD        	1	0	1	AWAIT_REJECT8	AWAIT_REJECT
-REJ_CMD        	1	1	0	AWAIT_REJECT9	AWAIT_REJECT
-REJ_CMD        	1	1	1	AWAIT_REJECT9	AWAIT_REJECT
-DISC_CMD       	0	0	0	SH4	ADM
-DISC_CMD       	0	0	1	SH4	ADM
-DISC_CMD       	0	1	0	SH4	ADM
-DISC_CMD       	0	1	1	SH4	ADM
-DISC_CMD       	1	0	0	SH4	ADM
-DISC_CMD       	1	0	1	SH4	ADM
-DISC_CMD       	1	1	0	SH4	ADM
-DISC_CMD       	1	1	1	SH4	ADM
-SABME_CMD      	0	0	0	SH3	RESET_CHECK
-SABME_CMD      	0	0	1	SH3	RESET_CHECK
-SABME_CMD      	0	1	0	SH3	RESET_CHECK
-SABME_CMD      	0	1	1	SH3	RESET_CHECK
-SABME_CMD      	1	0	0	SH3	RESET_CHECK
-SABME_CMD      	1	0	1	SH3	RESET_CHECK
-SABME_CMD      	1	1	0	SH3	RESET_CHECK
-SABME_CMD      	1	1	1	SH3	RESET_CHECK
-I_RSP          	0	0	0	AWAIT_REJECT5	AWAIT
-I_RSP          	0	0	1	AWAIT_REJECT5	AWAIT
-I_RSP          	0	1	0	SH10	ERROR
-I_RSP          	0	1	1	AWAIT_REJECT4	NORMAL
-I_RSP          	1	0	0	AWAIT_REJECT2	AWAIT_REJECT
-I_RSP          	1	0	1	AWAIT_REJECT2	AWAIT_REJECT
-I_RSP          	1	1	0	SH10	ERROR
-I_RSP          	1	1	1	AWAIT_REJECT4	NORMAL
-RR_RSP         	0	0	0	AWAIT_REJECT8	AWAIT_REJECT
-RR_RSP         	0	0	1	AWAIT_REJECT8	AWAIT_REJECT
-RR_RSP         	0	1	0	SH10	ERROR
-RR_RSP         	0	1	1	AWAIT_REJECT7	REJECT
-RR_RSP         	1	0	0	AWAIT_REJECT8	AWAIT_REJECT
-RR_RSP         	1	0	1	AWAIT_REJECT8	AWAIT_REJECT
-RR_RSP         	1	1	0	SH10	ERROR
-RR_RSP         	1	1	1	AWAIT_REJECT7	REJECT
-RNR_RSP        	0	0	0	AWAIT_REJECT11	AWAIT_REJECT
-RNR_RSP        	0	0	1	AWAIT_REJECT11	AWAIT_REJECT
-RNR_RSP        	0	1	0	SH10	ERROR
-RNR_RSP        	0	1	1	AWAIT_REJECT10	REJECT
-RNR_RSP        	1	0	0	AWAIT_REJECT11	AWAIT_REJECT
-RNR_RSP        	1	0	1	AWAIT_REJECT11	AWAIT_REJECT
-RNR_RSP        	1	1	0	SH10	ERROR
-RNR_RSP        	1	1	1	AWAIT_REJECT10	REJECT
-REJ_RSP        	0	0	0	AWAIT_REJECT8	AWAIT_REJECT
-REJ_RSP        	0	0	1	AWAIT_REJECT8	AWAIT_REJECT
-REJ_RSP        	0	1	0	SH10	ERROR
-REJ_RSP        	0	1	1	AWAIT_REJECT7	REJECT
-REJ_RSP        	1	0	0	AWAIT_REJECT8	AWAIT_REJECT
-REJ_RSP        	1	0	1	AWAIT_REJECT8	AWAIT_REJECT
-REJ_RSP        	1	1	0	SH10	ERROR
-REJ_RSP        	1	1	1	AWAIT_REJECT7	REJECT
-UA_RSP         	0	0	0	SH9	ERROR
-UA_RSP         	0	0	1	SH9	ERROR
-UA_RSP         	0	1	0	SH9	ERROR
-UA_RSP         	0	1	1	SH9	ERROR
-UA_RSP         	1	0	0	SH9	ERROR
-UA_RSP         	1	0	1	SH9	ERROR
-UA_RSP         	1	1	0	SH9	ERROR
-UA_RSP         	1	1	1	SH9	ERROR
-DM_RSP         	0	0	0	SH6	ADM
-DM_RSP         	0	0	1	SH6	ADM
-DM_RSP         	0	1	0	SH6	ADM
-DM_RSP         	0	1	1	SH6	ADM
-DM_RSP         	1	0	0	SH6	ADM
-DM_RSP         	1	0	1	SH6	ADM
-DM_RSP         	1	1	0	SH6	ADM
-DM_RSP         	1	1	1	SH6	ADM
-FRMR_RSP       	0	0	0	SH5	RESET_WAIT
-FRMR_RSP       	0	0	1	SH5	RESET_WAIT
-FRMR_RSP       	0	1	0	SH5	RESET_WAIT
-FRMR_RSP       	0	1	1	SH5	RESET_WAIT
-FRMR_RSP       	1	0	0	SH5	RESET_WAIT
-FRMR_RSP       	1	0	1	SH5	RESET_WAIT
-FRMR_RSP       	1	1	0	SH5	RESET_WAIT
-FRMR_RSP       	1	1	1	SH5	RESET_WAIT
-BAD_FRAME      	0	0	0	SH7	ERROR
-BAD_FRAME      	0	0	1	SH7	ERROR
-BAD_FRAME      	0	1	0	SH7	ERROR
-BAD_FRAME      	0	1	1	SH7	ERROR
-BAD_FRAME      	1	0	0	SH7	ERROR
-BAD_FRAME      	1	0	1	SH7	ERROR
-BAD_FRAME      	1	1	0	SH7	ERROR
-BAD_FRAME      	1	1	1	SH7	ERROR
-;
-;112 entries in table, 8 modified by tredit4 SABME_CMD x x x SH3 RESET_CHECK
-;112 entries in table, 8 modified by tredit4 DISC_CMD x x x SH4 ADM
-;112 entries in table, 8 modified by tredit4 FRMR_RSP x x x SH5 RESET_WAIT
-;112 entries in table, 8 modified by tredit4 DM_RSP x x x SH6 ADM
-;112 entries in table, 8 modified by tredit4 BAD_FRAME x x x SH7 ERROR
-;112 entries in table, 8 modified by tredit4 UA_RSP x x x SH9 ERROR
-;112 entries in table, 8 modified by tredit4 anyrsp x 1 0 SH10 ERROR
-;112 entries in table, 2 modified by tredit4 I_CMD 1 0 x AWAIT_REJECT2 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 I_RSP 1 0 x AWAIT_REJECT2 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 I_CMD 1 1 x AWAIT_REJECT3 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 I_RSP x 1 x AWAIT_REJECT4 NORMAL
-;112 entries in table, 2 modified by tredit4 I_RSP x 0 x AWAIT_REJECT5 AWAIT
-;112 entries in table, 2 modified by tredit4 I_CMD x 0 x AWAIT_REJECT5 AWAIT
-;112 entries in table, 2 modified by tredit4 I_CMD x 1 x AWAIT_REJECT6 AWAIT
-;112 entries in table, 2 modified by tredit4 RR_RSP x 1 x AWAIT_REJECT7 REJECT
-;112 entries in table, 2 modified by tredit4 REJ_RSP x 1 x AWAIT_REJECT7 REJECT
-;112 entries in table, 0 modified by tredit4 I_RSP 1 1 x AWAIT_REJECT7 REJECT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 0 x AWAIT_REJECT8 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 RR_RSP x 0 x AWAIT_REJECT8 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 0 x AWAIT_REJECT8 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 REJ_RSP x 0 x AWAIT_REJECT8 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 RR_CMD x 1 x AWAIT_REJECT9 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 REJ_CMD x 1 x AWAIT_REJECT9 AWAIT_REJECT
-;112 entries in table, 2 modified by tredit4 RNR_RSP x 1 x AWAIT_REJECT10 REJECT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 0 x AWAIT_REJECT11 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 RNR_RSP x 0 x AWAIT_REJECT11 AWAIT_REJECT
-;112 entries in table, 4 modified by tredit4 RNR_CMD x 1 x AWAIT_REJECT12 AWAIT_REJECT
-;112 entries in table, 0 modified by tredit4 RNR_CMD x 1 x AWAIT_REJECT15 AWAIT_BUSY
diff -ruN linux-2.4.4/net/802/transit/timertr.h linux/net/802/transit/timertr.h
--- linux-2.4.4/net/802/transit/timertr.h	Mon Jan 12 14:46:27 1998
+++ linux/net/802/transit/timertr.h	Wed Dec 31 16:00:00 1969
@@ -1,157 +0,0 @@
-
-/* this file was generated on Thu Jan  8 00:21:21 GMT 1998  */
-
-
-/* size of transition table is 898 bytes */
-
-static char timertr_entry [ ] = {
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , ADM           ,
-   NOP           , ADM           , NOP           , ADM           , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , CONN          , NOP           , CONN          ,
-   NOP           , CONN          , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_WAIT    , NOP           , RESET_WAIT    , NOP           , RESET_WAIT    ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , NOP           , RESET_CHECK   ,
-   NOP           , RESET_CHECK   , NOP           , RESET_CHECK   , SETUP7        , SETUP         ,
-   SETUP7        , SETUP         , SETUP3        , NORMAL        , SETUP3        , NORMAL        ,
-   SETUP8        , ADM           , SETUP8        , ADM           , SETUP3        , NORMAL        ,
-   SETUP3        , NORMAL        , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , NOP           , SETUP         , NOP           , SETUP         ,
-   NOP           , SETUP         , RESET7        , RESET         , RESET7        , RESET         ,
-   RESET3        , NORMAL        , RESET3        , NORMAL        , RESET8        , ADM           ,
-   RESET8        , ADM           , RESET3        , NORMAL        , RESET3        , NORMAL        ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   NOP           , RESET         , NOP           , RESET         , NOP           , RESET         ,
-   D_CONN6       , D_CONN        , D_CONN6       , D_CONN        , D_CONN6       , D_CONN        ,
-   D_CONN6       , D_CONN        , D_CONN7       , ADM           , D_CONN7       , ADM           ,
-   D_CONN7       , ADM           , D_CONN7       , ADM           , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , NOP           , D_CONN        ,
-   NOP           , D_CONN        , NOP           , D_CONN        , ERR7          , ERROR         ,
-   ERR7          , ERROR         , ERR7          , ERROR         , ERR7          , ERROR         ,
-   ERR8          , RESET_WAIT    , ERR8          , RESET_WAIT    , ERR8          , RESET_WAIT    ,
-   ERR8          , RESET_WAIT    , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NOP           , ERROR         , NOP           , ERROR         ,
-   NOP           , ERROR         , NORMAL20      , AWAIT         , NOP           , NORMAL        ,
-   NORMAL20      , AWAIT         , NOP           , NORMAL        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NORMAL19      , NORMAL        , NORMAL19      , NORMAL        , NORMAL19      , NORMAL        ,
-   NORMAL19      , NORMAL        , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , NORMAL        ,
-   NOP           , NORMAL        , NOP           , NORMAL        , NOP           , NORMAL        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NORMAL20      , AWAIT         , NOP           , NORMAL        ,
-   NORMAL20      , AWAIT         , NOP           , NORMAL        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   BUSY24        , AWAIT_BUSY    , NOP           , BUSY          , BUSY24        , AWAIT_BUSY    ,
-   NOP           , BUSY          , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , BUSY23        , BUSY          ,
-   BUSY23        , BUSY          , BUSY23        , BUSY          , BUSY23        , BUSY          ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , BUSY25        , BUSY          , BUSY26        , BUSY          ,
-   BUSY25        , BUSY          , BUSY26        , BUSY          , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , BUSY          , NOP           , BUSY          , NOP           , BUSY          ,
-   NOP           , BUSY          , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , REJECT        , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   NOP           , REJECT        , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , REJECT        ,
-   NOP           , REJECT        , NOP           , REJECT        , NOP           , REJECT        ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT         , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , NOP           , AWAIT         ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT         , NOP           , AWAIT         ,
-   NOP           , AWAIT         , NOP           , AWAIT         , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    , NOP           , AWAIT_BUSY    ,
-   NOP           , AWAIT_BUSY    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , NOP           , AWAIT_REJECT  ,
-   NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  , NOP           , AWAIT_REJECT  ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT    , SH11          , RESET_WAIT    ,
-   SH11          , RESET_WAIT    , SH11          , RESET_WAIT     };
diff -ruN linux-2.4.4/net/802/transit/timertr.pre linux/net/802/transit/timertr.pre
--- linux-2.4.4/net/802/transit/timertr.pre	Thu Dec 12 06:54:22 1996
+++ linux/net/802/transit/timertr.pre	Wed Dec 31 16:00:00 1969
@@ -1,527 +0,0 @@
-COMPILE timertr NOINDEX 
-TABLE XXX
-;
-;Transition table for expiring timers:
-;
-;llc state 	timer   	retry_c	s_flag 	p_flag	action	newstate
-;		expired    	>= N2  
-;				
-ADM		ACK_TIMER	0	0      	0	NOP	ADM	
-ADM		ACK_TIMER	0	0      	1	NOP	ADM
-ADM		ACK_TIMER	0	1      	0	NOP	ADM
-ADM		ACK_TIMER	0	1      	1	NOP	ADM
-ADM		ACK_TIMER	1	0      	0	NOP	ADM
-ADM		ACK_TIMER	1	0      	1	NOP	ADM
-ADM		ACK_TIMER	1	1       0	NOP	ADM
-ADM		ACK_TIMER	1	1	1	NOP	ADM
-;;
-ADM		P_TIMER		0	0	0	NOP	ADM
-ADM		P_TIMER		0	0	1	NOP	ADM
-ADM		P_TIMER		0	1	0	NOP	ADM
-ADM		P_TIMER		0	1	1	NOP	ADM
-ADM		P_TIMER		1	0	0	NOP	ADM
-ADM		P_TIMER		1	0	1	NOP	ADM
-ADM		P_TIMER		1	1	0	NOP	ADM
-ADM		P_TIMER		1	1	1	NOP	ADM
-;;			
-ADM		REJ_TIMER 	0	0	0	NOP	ADM
-ADM		REJ_TIMER 	0	0	1	NOP	ADM
-ADM		REJ_TIMER 	0	1	0	NOP	ADM
-ADM		REJ_TIMER 	0	1	1	NOP	ADM
-ADM		REJ_TIMER 	1	0	0	NOP	ADM
-ADM		REJ_TIMER 	1	0	1	NOP	ADM
-ADM		REJ_TIMER 	1	1	0	NOP	ADM
-ADM		REJ_TIMER 	1	1	1	NOP	ADM
-;;			
-ADM		BUSY_TIMER 	0	0	0	NOP	ADM
-ADM		BUSY_TIMER 	0	0	1	NOP	ADM
-ADM		BUSY_TIMER 	0	1	0	NOP	ADM
-ADM		BUSY_TIMER 	0	1	1	NOP	ADM
-ADM		BUSY_TIMER 	1	0	0	NOP	ADM
-ADM		BUSY_TIMER 	1	0	1	NOP	ADM
-ADM		BUSY_TIMER 	1	1	0	NOP	ADM
-ADM		BUSY_TIMER 	1	1	1	NOP	ADM
-;;
-;;
-CONN		ACK_TIMER	0	0      	0	NOP	CONN	
-CONN		ACK_TIMER	0	0      	1	NOP	CONN
-CONN		ACK_TIMER	0	1      	0	NOP	CONN
-CONN		ACK_TIMER	0	1      	1	NOP	CONN
-CONN		ACK_TIMER	1	0      	0	NOP	CONN
-CONN		ACK_TIMER	1	0      	1	NOP	CONN
-CONN		ACK_TIMER	1	1       0	NOP	CONN
-CONN		ACK_TIMER	1	1	1	NOP	CONN
-;;
-CONN		P_TIMER		0	0	0	NOP	CONN
-CONN		P_TIMER		0	0	1	NOP	CONN
-CONN		P_TIMER		0	1	0	NOP	CONN
-CONN		P_TIMER		0	1	1	NOP	CONN
-CONN		P_TIMER		1	0	0	NOP	CONN
-CONN		P_TIMER		1	0	1	NOP	CONN
-CONN		P_TIMER		1	1	0	NOP	CONN
-CONN		P_TIMER		1	1	1	NOP	CONN
-;;			
-CONN		REJ_TIMER 	0	0	0	NOP	CONN
-CONN		REJ_TIMER 	0	0	1	NOP	CONN
-CONN		REJ_TIMER 	0	1	0	NOP	CONN
-CONN		REJ_TIMER 	0	1	1	NOP	CONN
-CONN		REJ_TIMER 	1	0	0	NOP	CONN
-CONN		REJ_TIMER 	1	0	1	NOP	CONN
-CONN		REJ_TIMER 	1	1	0	NOP	CONN
-CONN		REJ_TIMER 	1	1	1	NOP	CONN
-;;			
-CONN		BUSY_TIMER 	0	0	0	NOP	CONN
-CONN		BUSY_TIMER 	0	0	1	NOP	CONN
-CONN		BUSY_TIMER 	0	1	0	NOP	CONN
-CONN		BUSY_TIMER 	0	1	1	NOP	CONN
-CONN		BUSY_TIMER 	1	0	0	NOP	CONN
-CONN		BUSY_TIMER 	1	0	1	NOP	CONN
-CONN		BUSY_TIMER 	1	1	0	NOP	CONN
-CONN		BUSY_TIMER 	1	1	1	NOP	CONN
-;;
-;;
-RESET_WAIT	ACK_TIMER	0	0      	0	NOP	RESET_WAIT	
-RESET_WAIT	ACK_TIMER	0	0      	1	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	0	1      	0	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	0	1      	1	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	1	0      	0	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	1	0      	1	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	1	1       0	NOP	RESET_WAIT
-RESET_WAIT	ACK_TIMER	1	1	1	NOP	RESET_WAIT
-;;
-RESET_WAIT	P_TIMER		0	0	0	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		0	0	1	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		0	1	0	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		0	1	1	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		1	0	0	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		1	0	1	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		1	1	0	NOP	RESET_WAIT
-RESET_WAIT	P_TIMER		1	1	1	NOP	RESET_WAIT
-;;			
-RESET_WAIT	REJ_TIMER 	0	0	0	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	0	0	1	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	0	1	0	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	0	1	1	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	1	0	0	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	1	0	1	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	1	1	0	NOP	RESET_WAIT
-RESET_WAIT	REJ_TIMER 	1	1	1	NOP	RESET_WAIT
-;;			
-RESET_WAIT	BUSY_TIMER 	0	0	0	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	0	0	1	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	0	1	0	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	0	1	1	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	1	0	0	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	1	0	1	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	1	1	0	NOP	RESET_WAIT
-RESET_WAIT	BUSY_TIMER 	1	1	1	NOP	RESET_WAIT
-;;
-;;
-RESET_CHECK	ACK_TIMER	0	0      	0	NOP	RESET_CHECK	
-RESET_CHECK	ACK_TIMER	0	0      	1	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	0	1      	0	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	0	1      	1	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	1	0      	0	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	1	0      	1	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	1	1       0	NOP	RESET_CHECK
-RESET_CHECK	ACK_TIMER	1	1	1	NOP	RESET_CHECK
-;;
-RESET_CHECK	P_TIMER		0	0	0	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		0	0	1	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		0	1	0	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		0	1	1	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		1	0	0	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		1	0	1	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		1	1	0	NOP	RESET_CHECK
-RESET_CHECK	P_TIMER		1	1	1	NOP	RESET_CHECK
-;;			
-RESET_CHECK	REJ_TIMER 	0	0	0	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	0	0	1	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	0	1	0	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	0	1	1	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	1	0	0	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	1	0	1	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	1	1	0	NOP	RESET_CHECK
-RESET_CHECK	REJ_TIMER 	1	1	1	NOP	RESET_CHECK
-;;			
-RESET_CHECK	BUSY_TIMER 	0	0	0	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	0	0	1	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	0	1	0	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	0	1	1	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	1	0	0	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	1	0	1	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	1	1	0	NOP	RESET_CHECK
-RESET_CHECK	BUSY_TIMER 	1	1	1	NOP	RESET_CHECK
-;;
-;;
-;;
-SETUP		ACK_TIMER	0	0      	0	SETUP7  SETUP	
-SETUP		ACK_TIMER	0	0      	1	SETUP7  SETUP
-SETUP		ACK_TIMER	0	1      	0	SETUP3  NORMAL
-SETUP		ACK_TIMER	0	1      	1	SETUP3  NORMAL
-SETUP		ACK_TIMER	1	0      	0	SETUP8  ADM
-SETUP		ACK_TIMER	1	0      	1	SETUP8  ADM
-SETUP		ACK_TIMER	1	1       0	SETUP3  NORMAL
-SETUP		ACK_TIMER	1	1	1	SETUP3  NORMAL
-;;
-SETUP		P_TIMER		0	0	0	NOP	SETUP
-SETUP		P_TIMER		0	0	1	NOP	SETUP
-SETUP		P_TIMER		0	1	0	NOP	SETUP
-SETUP		P_TIMER		0	1	1	NOP	SETUP
-SETUP		P_TIMER		1	0	0	NOP	SETUP
-SETUP		P_TIMER		1	0	1	NOP	SETUP
-SETUP		P_TIMER		1	1	0	NOP	SETUP
-SETUP		P_TIMER		1	1	1	NOP	SETUP
-;;			
-SETUP		REJ_TIMER 	0	0	0	NOP	SETUP
-SETUP		REJ_TIMER 	0	0	1	NOP	SETUP
-SETUP		REJ_TIMER 	0	1	0	NOP	SETUP
-SETUP		REJ_TIMER 	0	1	1	NOP	SETUP
-SETUP		REJ_TIMER 	1	0	0	NOP	SETUP
-SETUP		REJ_TIMER 	1	0	1	NOP	SETUP
-SETUP		REJ_TIMER 	1	1	0	NOP	SETUP
-SETUP		REJ_TIMER 	1	1	1	NOP	SETUP
-;;			
-SETUP		BUSY_TIMER 	0	0	0	NOP	SETUP
-SETUP		BUSY_TIMER 	0	0	1	NOP	SETUP
-SETUP		BUSY_TIMER 	0	1	0	NOP	SETUP
-SETUP		BUSY_TIMER 	0	1	1	NOP	SETUP
-SETUP		BUSY_TIMER 	1	0	0	NOP	SETUP
-SETUP		BUSY_TIMER 	1	0	1	NOP	SETUP
-SETUP		BUSY_TIMER 	1	1	0	NOP	SETUP
-SETUP		BUSY_TIMER 	1	1	1	NOP	SETUP
-;;
-;;
-;;
-RESET		ACK_TIMER	0	0      	0	RESET7  RESET	
-RESET		ACK_TIMER	0	0      	1	RESET7  RESET
-RESET		ACK_TIMER	0	1      	0	RESET3  NORMAL
-RESET		ACK_TIMER	0	1      	1	RESET3  NORMAL
-RESET		ACK_TIMER	1	0      	0	RESET8  ADM
-RESET		ACK_TIMER	1	0      	1	RESET8  ADM
-RESET		ACK_TIMER	1	1       0	RESET3  NORMAL
-RESET		ACK_TIMER	1	1	1	RESET3  NORMAL
-;;
-RESET		P_TIMER		0	0	0	NOP	RESET
-RESET		P_TIMER		0	0	1	NOP	RESET
-RESET		P_TIMER		0	1	0	NOP	RESET
-RESET		P_TIMER		0	1	1	NOP	RESET
-RESET		P_TIMER		1	0	0	NOP	RESET
-RESET		P_TIMER		1	0	1	NOP	RESET
-RESET		P_TIMER		1	1	0	NOP	RESET
-RESET		P_TIMER		1	1	1	NOP	RESET
-;;			
-RESET		REJ_TIMER 	0	0	0	NOP	RESET
-RESET		REJ_TIMER 	0	0	1	NOP	RESET
-RESET		REJ_TIMER 	0	1	0	NOP	RESET
-RESET		REJ_TIMER 	0	1	1	NOP	RESET
-RESET		REJ_TIMER 	1	0	0	NOP	RESET
-RESET		REJ_TIMER 	1	0	1	NOP	RESET
-RESET		REJ_TIMER 	1	1	0	NOP	RESET
-RESET		REJ_TIMER 	1	1	1	NOP	RESET
-;;			
-RESET		BUSY_TIMER 	0	0	0	NOP	RESET
-RESET		BUSY_TIMER 	0	0	1	NOP	RESET
-RESET		BUSY_TIMER 	0	1	0	NOP	RESET
-RESET		BUSY_TIMER 	0	1	1	NOP	RESET
-RESET		BUSY_TIMER 	1	0	0	NOP	RESET
-RESET		BUSY_TIMER 	1	0	1	NOP	RESET
-RESET		BUSY_TIMER 	1	1	0	NOP	RESET
-RESET		BUSY_TIMER 	1	1	1	NOP	RESET
-;;
-;;
-D_CONN		ACK_TIMER	0	0      	0	D_CONN6 D_CONN	
-D_CONN		ACK_TIMER	0	0      	1	D_CONN6 D_CONN
-D_CONN		ACK_TIMER	0	1      	0	D_CONN6 D_CONN
-D_CONN		ACK_TIMER	0	1      	1	D_CONN6 D_CONN
-D_CONN		ACK_TIMER	1	0      	0	D_CONN7 ADM
-D_CONN		ACK_TIMER	1	0      	1	D_CONN7 ADM
-D_CONN		ACK_TIMER	1	1       0	D_CONN7 ADM
-D_CONN		ACK_TIMER	1	1	1	D_CONN7 ADM
-;;
-D_CONN		P_TIMER		0	0	0	NOP	D_CONN
-D_CONN		P_TIMER		0	0	1	NOP	D_CONN
-D_CONN		P_TIMER		0	1	0	NOP	D_CONN
-D_CONN		P_TIMER		0	1	1	NOP	D_CONN
-D_CONN		P_TIMER		1	0	0	NOP	D_CONN
-D_CONN		P_TIMER		1	0	1	NOP	D_CONN
-D_CONN		P_TIMER		1	1	0	NOP	D_CONN
-D_CONN		P_TIMER		1	1	1	NOP	D_CONN
-;;			
-D_CONN		REJ_TIMER 	0	0	0	NOP	D_CONN
-D_CONN		REJ_TIMER 	0	0	1	NOP	D_CONN
-D_CONN		REJ_TIMER 	0	1	0	NOP	D_CONN
-D_CONN		REJ_TIMER 	0	1	1	NOP	D_CONN
-D_CONN		REJ_TIMER 	1	0	0	NOP	D_CONN
-D_CONN		REJ_TIMER 	1	0	1	NOP	D_CONN
-D_CONN		REJ_TIMER 	1	1	0	NOP	D_CONN
-D_CONN		REJ_TIMER 	1	1	1	NOP	D_CONN
-;;			
-D_CONN		BUSY_TIMER 	0	0	0	NOP	D_CONN
-D_CONN		BUSY_TIMER 	0	0	1	NOP	D_CONN
-D_CONN		BUSY_TIMER 	0	1	0	NOP	D_CONN
-D_CONN		BUSY_TIMER 	0	1	1	NOP	D_CONN
-D_CONN		BUSY_TIMER 	1	0	0	NOP	D_CONN
-D_CONN		BUSY_TIMER 	1	0	1	NOP	D_CONN
-D_CONN		BUSY_TIMER 	1	1	0	NOP	D_CONN
-D_CONN		BUSY_TIMER 	1	1	1	NOP	D_CONN
-;;
-;;
-ERROR		ACK_TIMER	0	0      	0	ERR7    ERROR	
-ERROR		ACK_TIMER	0	0      	1	ERR7    ERROR
-ERROR		ACK_TIMER	0	1      	0	ERR7    ERROR
-ERROR		ACK_TIMER	0	1      	1	ERR7    ERROR
-ERROR		ACK_TIMER	1	0      	0	ERR8    RESET_WAIT
-ERROR		ACK_TIMER	1	0      	1	ERR8    RESET_WAIT
-ERROR		ACK_TIMER	1	1       0       ERR8    RESET_WAIT
-ERROR		ACK_TIMER	1	1	1	ERR8    RESET_WAIT
-;;
-ERROR		P_TIMER		0	0	0	NOP	ERROR
-ERROR		P_TIMER		0	0	1	NOP	ERROR
-ERROR		P_TIMER		0	1	0	NOP	ERROR
-ERROR		P_TIMER		0	1	1	NOP	ERROR
-ERROR		P_TIMER		1	0	0	NOP	ERROR
-ERROR		P_TIMER		1	0	1	NOP	ERROR
-ERROR		P_TIMER		1	1	0	NOP	ERROR
-ERROR		P_TIMER		1	1	1	NOP	ERROR
-;;			
-ERROR		REJ_TIMER 	0	0	0	NOP	ERROR
-ERROR		REJ_TIMER 	0	0	1	NOP	ERROR
-ERROR		REJ_TIMER 	0	1	0	NOP	ERROR
-ERROR		REJ_TIMER 	0	1	1	NOP	ERROR
-ERROR		REJ_TIMER 	1	0	0	NOP	ERROR
-ERROR		REJ_TIMER 	1	0	1	NOP	ERROR
-ERROR		REJ_TIMER 	1	1	0	NOP	ERROR
-ERROR		REJ_TIMER 	1	1	1	NOP	ERROR
-;;			
-ERROR		BUSY_TIMER 	0	0	0	NOP	ERROR
-ERROR		BUSY_TIMER 	0	0	1	NOP	ERROR
-ERROR		BUSY_TIMER 	0	1	0	NOP	ERROR
-ERROR		BUSY_TIMER 	0	1	1	NOP	ERROR
-ERROR		BUSY_TIMER 	1	0	0	NOP	ERROR
-ERROR		BUSY_TIMER 	1	0	1	NOP	ERROR
-ERROR		BUSY_TIMER 	1	1	0	NOP	ERROR
-ERROR		BUSY_TIMER 	1	1	1	NOP	ERROR
-;;
-;;
-NORMAL		ACK_TIMER	0	0      	0	NORMAL20 AWAIT	
-NORMAL		ACK_TIMER	0	0      	1	NOP	NORMAL
-NORMAL		ACK_TIMER	0	1      	0	NORMAL20 AWAIT
-NORMAL		ACK_TIMER	0	1      	1	NOP	NORMAL
-NORMAL		ACK_TIMER	1	0      	0	SH11    RESET_WAIT
-NORMAL		ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-NORMAL		ACK_TIMER	1	1       0	SH11    RESET_WAIT
-NORMAL		ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;
-NORMAL		P_TIMER		0	0	0	NORMAL19 NORMAL
-NORMAL		P_TIMER		0	0	1	NORMAL19 NORMAL
-NORMAL		P_TIMER		0	1	0	NORMAL19 NORMAL
-NORMAL		P_TIMER		0	1	1	NORMAL19 NORMAL
-NORMAL		P_TIMER		1	0	0	SH11    RESET_WAIT
-NORMAL		P_TIMER		1	0	1	SH11    RESET_WAIT
-NORMAL		P_TIMER		1	1	0	SH11    RESET_WAIT
-NORMAL		P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-NORMAL		REJ_TIMER 	0	0	0	NOP	NORMAL
-NORMAL		REJ_TIMER 	0	0	1	NOP	NORMAL
-NORMAL		REJ_TIMER 	0	1	0	NOP	NORMAL
-NORMAL		REJ_TIMER 	0	1	1	NOP	NORMAL
-NORMAL		REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-NORMAL		REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-NORMAL		REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-NORMAL		REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-NORMAL		BUSY_TIMER 	0	0	0	NORMAL20 AWAIT
-NORMAL		BUSY_TIMER 	0	0	1	NOP	NORMAL
-NORMAL		BUSY_TIMER 	0	1	0	NORMAL20 AWAIT
-NORMAL		BUSY_TIMER 	0	1	1	NOP	NORMAL
-NORMAL		BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-NORMAL		BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-NORMAL		BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-NORMAL		BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
-;;
-BUSY		ACK_TIMER	0	0      	0	BUSY24  AWAIT_BUSY
-BUSY		ACK_TIMER	0	0      	1	NOP	BUSY
-BUSY		ACK_TIMER	0	1      	0	BUSY24  AWAIT_BUSY
-BUSY		ACK_TIMER	0	1      	1	NOP	BUSY
-BUSY		ACK_TIMER	1	0      	0	SH11    RESET_WAIT	
-BUSY		ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-BUSY		ACK_TIMER	1	1       0	SH11    RESET_WAIT
-BUSY		ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;
-BUSY		P_TIMER		0	0	0	BUSY23  BUSY
-BUSY		P_TIMER		0	0	1	BUSY23  BUSY
-BUSY		P_TIMER		0	1	0	BUSY23  BUSY
-BUSY		P_TIMER		0	1	1	BUSY23  BUSY
-BUSY		P_TIMER		1	0	0	SH11    RESET_WAIT
-BUSY		P_TIMER		1	0	1	SH11    RESET_WAIT
-BUSY		P_TIMER		1	1	0	SH11    RESET_WAIT
-BUSY		P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-BUSY		REJ_TIMER 	0	0	0	BUSY25  BUSY
-BUSY		REJ_TIMER 	0	0	1	BUSY26  BUSY
-BUSY		REJ_TIMER 	0	1	0	BUSY25  BUSY
-BUSY		REJ_TIMER 	0	1	1	BUSY26  BUSY
-BUSY		REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-BUSY		REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-BUSY		REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-BUSY		REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-BUSY		BUSY_TIMER 	0	0	0	NOP	BUSY
-BUSY		BUSY_TIMER 	0	0	1	NOP	BUSY
-BUSY		BUSY_TIMER 	0	1	0	NOP	BUSY
-BUSY		BUSY_TIMER 	0	1	1	NOP	BUSY
-BUSY		BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-BUSY		BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-BUSY		BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-BUSY		BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
-;;
-REJECT		ACK_TIMER	0	0      	0	NOP	REJECT	
-REJECT		ACK_TIMER	0	0      	1	NOP	REJECT
-REJECT		ACK_TIMER	0	1      	0	NOP	REJECT
-REJECT		ACK_TIMER	0	1      	1	NOP	REJECT
-REJECT		ACK_TIMER	1	0      	0	SH11    RESET_WAIT
-REJECT		ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-REJECT		ACK_TIMER	1	1       0	SH11    RESET_WAIT
-REJECT		ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;
-REJECT		P_TIMER		0	0	0	NOP	REJECT
-REJECT		P_TIMER		0	0	1	NOP	REJECT
-REJECT		P_TIMER		0	1	0	NOP	REJECT
-REJECT		P_TIMER		0	1	1	NOP	REJECT
-REJECT		P_TIMER		1	0	0	SH11    RESET_WAIT
-REJECT		P_TIMER		1	0	1	SH11    RESET_WAIT
-REJECT		P_TIMER		1	1	0	SH11    RESET_WAIT
-REJECT		P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-REJECT		REJ_TIMER 	0	0	0	NOP	REJECT
-REJECT		REJ_TIMER 	0	0	1	NOP	REJECT
-REJECT		REJ_TIMER 	0	1	0	NOP	REJECT
-REJECT		REJ_TIMER 	0	1	1	NOP	REJECT
-REJECT		REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-REJECT		REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-REJECT		REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-REJECT		REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-REJECT		BUSY_TIMER 	0	0	0	NOP	REJECT
-REJECT		BUSY_TIMER 	0	0	1	NOP	REJECT
-REJECT		BUSY_TIMER 	0	1	0	NOP	REJECT
-REJECT		BUSY_TIMER 	0	1	1	NOP	REJECT
-REJECT		BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-REJECT		BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-REJECT		BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-REJECT		BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
-;;
-AWAIT		ACK_TIMER	0	0      	0	NOP	AWAIT	
-AWAIT		ACK_TIMER	0	0      	1	NOP	AWAIT
-AWAIT		ACK_TIMER	0	1      	0	NOP	AWAIT
-AWAIT		ACK_TIMER	0	1      	1	NOP	AWAIT
-AWAIT		ACK_TIMER	1	0      	0	SH11    RESET_WAIT
-AWAIT		ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-AWAIT		ACK_TIMER	1	1       0	SH11    RESET_WAIT
-AWAIT		ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;
-AWAIT		P_TIMER		0	0	0	NOP	AWAIT
-AWAIT		P_TIMER		0	0	1	NOP	AWAIT
-AWAIT		P_TIMER		0	1	0	NOP	AWAIT
-AWAIT		P_TIMER		0	1	1	NOP	AWAIT
-AWAIT		P_TIMER		1	0	0	SH11    RESET_WAIT
-AWAIT		P_TIMER		1	0	1	SH11    RESET_WAIT
-AWAIT		P_TIMER		1	1	0	SH11    RESET_WAIT
-AWAIT		P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT		REJ_TIMER 	0	0	0	NOP	AWAIT
-AWAIT		REJ_TIMER 	0	0	1	NOP	AWAIT
-AWAIT		REJ_TIMER 	0	1	0	NOP	AWAIT
-AWAIT		REJ_TIMER 	0	1	1	NOP	AWAIT
-AWAIT		REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT		REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT		REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT		REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT		BUSY_TIMER 	0	0	0	NOP	AWAIT
-AWAIT		BUSY_TIMER 	0	0	1	NOP	AWAIT
-AWAIT		BUSY_TIMER 	0	1	0	NOP	AWAIT
-AWAIT		BUSY_TIMER 	0	1	1	NOP	AWAIT
-AWAIT		BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT		BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT		BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT		BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
-;;
-AWAIT_BUSY	ACK_TIMER	0	0      	0	NOP	AWAIT_BUSY	
-AWAIT_BUSY	ACK_TIMER	0	0      	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	ACK_TIMER	0	1      	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	ACK_TIMER	0	1      	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	ACK_TIMER	1	0      	0	SH11    RESET_WAIT
-AWAIT_BUSY	ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-AWAIT_BUSY	ACK_TIMER	1	1       0	SH11    RESET_WAIT
-AWAIT_BUSY	ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;
-AWAIT_BUSY	P_TIMER		0	0	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	P_TIMER		0	0	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	P_TIMER		0	1	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	P_TIMER		0	1	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	P_TIMER		1	0	0	SH11    RESET_WAIT
-AWAIT_BUSY	P_TIMER		1	0	1	SH11    RESET_WAIT
-AWAIT_BUSY	P_TIMER		1	1	0	SH11    RESET_WAIT
-AWAIT_BUSY	P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT_BUSY	REJ_TIMER 	0	0	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	REJ_TIMER 	0	0	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	REJ_TIMER 	0	1	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	REJ_TIMER 	0	1	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT_BUSY	REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT_BUSY	REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT_BUSY	REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT_BUSY	BUSY_TIMER 	0	0	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	BUSY_TIMER 	0	0	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	BUSY_TIMER 	0	1	0	NOP	AWAIT_BUSY
-AWAIT_BUSY	BUSY_TIMER 	0	1	1	NOP	AWAIT_BUSY
-AWAIT_BUSY	BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT_BUSY	BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT_BUSY	BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT_BUSY	BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
-;;
-AWAIT_REJECT	ACK_TIMER	0	0      	0	NOP	AWAIT_REJECT	
-AWAIT_REJECT	ACK_TIMER	0	0      	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	ACK_TIMER	0	1      	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	ACK_TIMER	0	1      	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	ACK_TIMER	1	0      	0	SH11    RESET_WAIT
-AWAIT_REJECT	ACK_TIMER	1	0      	1	SH11    RESET_WAIT
-AWAIT_REJECT	ACK_TIMER	1	1       0	SH11    RESET_WAIT
-AWAIT_REJECT	ACK_TIMER	1	1	1	SH11    RESET_WAIT
-;;							
-AWAIT_REJECT	P_TIMER		0	0	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	P_TIMER		0	0	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	P_TIMER		0	1	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	P_TIMER		0	1	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	P_TIMER		1	0	0	SH11    RESET_WAIT
-AWAIT_REJECT	P_TIMER		1	0	1	SH11    RESET_WAIT
-AWAIT_REJECT	P_TIMER		1	1	0	SH11    RESET_WAIT
-AWAIT_REJECT	P_TIMER		1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT_REJECT	REJ_TIMER 	0	0	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	REJ_TIMER 	0	0	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	REJ_TIMER 	0	1	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	REJ_TIMER 	0	1	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	REJ_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT_REJECT	REJ_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT_REJECT	REJ_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT_REJECT	REJ_TIMER 	1	1	1	SH11    RESET_WAIT
-;;			
-AWAIT_REJECT	BUSY_TIMER 	0	0	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	BUSY_TIMER 	0	0	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	BUSY_TIMER 	0	1	0	NOP	AWAIT_REJECT
-AWAIT_REJECT	BUSY_TIMER 	0	1	1	NOP	AWAIT_REJECT
-AWAIT_REJECT	BUSY_TIMER 	1	0	0	SH11    RESET_WAIT
-AWAIT_REJECT	BUSY_TIMER 	1	0	1	SH11    RESET_WAIT
-AWAIT_REJECT	BUSY_TIMER 	1	1	0	SH11    RESET_WAIT
-AWAIT_REJECT	BUSY_TIMER 	1	1	1	SH11    RESET_WAIT
-;;
diff -ruN linux-2.4.4/net/Config.in linux/net/Config.in
--- linux-2.4.4/net/Config.in	Tue Mar  6 22:44:15 2001
+++ linux/net/Config.in	Mon May 14 19:28:22 2001
@@ -3,6 +3,14 @@
 #
 mainmenu_option next_comment
 comment 'Networking options'
+
+tristate 'ANSI/IEEE 802.2 Data link layer protocol' CONFIG_LLC
+if [ "$CONFIG_LLC" != "n" ]; then
+  dep_tristate '  ANSI/IEEE 802.2 Data link layer User Interface SAPs' CONFIG_LLC_UI
+fi
+bool 'ANSI/IEEE 802.[3,4,5] Physical layer protocols' CONFIG_DEVLINK
+tristate 'SNAP protocol layer' CONFIG_SNAP
+
 tristate 'Packet socket' CONFIG_PACKET
 if [ "$CONFIG_PACKET" != "n" ]; then
    bool '  Packet socket: mmapped IO' CONFIG_PACKET_MMAP
@@ -17,6 +25,9 @@
    bool '  Network packet filtering debugging' CONFIG_NETFILTER_DEBUG
 fi
 bool 'Socket Filtering'  CONFIG_FILTER
+bool 'Advanced Linux Network Buffers' CONFIG_ADV_SKB
+bool 'Common Programming Interface Communications (CPI-C)' CONFIG_CPIC
+bool 'Advanced Program-to-Program Communications (APPC)' CONFIG_APPC
 tristate 'Unix domain sockets' CONFIG_UNIX
 bool 'TCP/IP networking' CONFIG_INET
 if [ "$CONFIG_INET" = "y" ]; then
@@ -49,6 +60,11 @@
 fi
 
 comment ' '
+tristate 'SNA Networking' CONFIG_SNA
+if [ "$CONFIG_SNA" != "n" ]; then
+   source net/sna/Config.in
+fi
+comment ' '
 tristate 'The IPX protocol' CONFIG_IPX
 if [ "$CONFIG_IPX" != "n" ]; then
    source net/ipx/Config.in
@@ -62,7 +78,6 @@
 if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
    tristate 'CCITT X.25 Packet Layer (EXPERIMENTAL)' CONFIG_X25
    tristate 'LAPB Data Link Driver (EXPERIMENTAL)' CONFIG_LAPB
-   bool '802.2 LLC (EXPERIMENTAL)' CONFIG_LLC
    bool 'Frame Diverter (EXPERIMENTAL)' CONFIG_NET_DIVERT
 #   if [ "$CONFIG_LLC" = "y" ]; then
 #      bool '  Netbeui (EXPERIMENTAL)' CONFIG_NETBEUI
diff -ruN linux-2.4.4/net/Makefile linux/net/Makefile
--- linux-2.4.4/net/Makefile	Fri Dec 29 14:07:24 2000
+++ linux/net/Makefile	Mon May 14 19:33:32 2001
@@ -14,7 +14,7 @@
 subdir-m :=	ipv4 # hum?
 
 
-subdir-$(CONFIG_NET)		+= 802 sched
+subdir-$(CONFIG_NET)		+= sched
 subdir-$(CONFIG_INET)		+= ipv4
 subdir-$(CONFIG_NETFILTER)	+= ipv4/netfilter
 subdir-$(CONFIG_UNIX)		+= unix
@@ -44,9 +44,13 @@
 subdir-$(CONFIG_ATM)		+= atm
 subdir-$(CONFIG_DECNET)		+= decnet
 subdir-$(CONFIG_ECONET)		+= econet
+subdir-$(CONFIG_DEVLINK)        += devlink
+subdir-$(CONFIG_LLC)            += llc
+subdir-$(CONFIG_SNAP)           += snap
+subdir-$(CONFIG_SNA)            += sna
 
 
-obj-y	:= socket.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
+obj-y	:= socket.o cpic.o attach.o appc.o $(join $(subdir-y), $(patsubst %,/%.o,$(notdir $(subdir-y))))
 ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_MODULES)		+= netsyms.o
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
diff -ruN linux-2.4.4/net/README linux/net/README
--- linux-2.4.4/net/README	Thu Nov  9 15:57:53 2000
+++ linux/net/README	Mon May 14 19:32:22 2001
@@ -3,23 +3,24 @@
 
 Code Section		Bug Report Contact
 -------------------+-------------------------------------------
-802 [other	]	alan@lxorguk.ukuu.org.uk	
-    [token ring	]	p.norton@computer.org
-appletalk		jschlst@turbolinux.com
+appletalk		jschlst@samba.org
 ax25			g4klx@g4klx.demon.co.uk
 bridge			buytenh@gnu.org
 core			alan@lxorguk.ukuu.org.uk
 decnet			SteveW@ACM.org
+devlink [tokenring]	p.norton@computer.org
+	[fibrechannel]	vma@iol.unh.edu
+	[other]		alan@lxorguk.ukuu.org.uk
 ethernet		alan@lxorguk.ukuu.org.uk
 ipv4			davem@caip.rutgers.edu,Eric.Schenk@dna.lth.se
 ipv6			davem@caip.rutgers.edu,Eric.Schenk@dna.lth.se
-ipx/spx			jschlst@turbolinux.com
+ipx/spx			jschlst@samba.org
 irda                    dagb@cs.uit.no
 lapb			g4klx@g4klx.demon.co.uk
+llc			jschlst@samba.org
 netrom			g4klx@g4klx.demon.co.uk
 rose			g4klx@g4klx.demon.co.uk
+snap			jschlst@samba.org
 wanrouter		gene@compuserve.com, jaspreet@sangoma and dm@sangoma.com
 unix			alan@lxorguk.ukuu.org.uk
 x25			g4klx@g4klx.demon.co.uk
-
-
diff -ruN linux-2.4.4/net/appc.c linux/net/appc.c
--- linux-2.4.4/net/appc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/appc.c	Mon May 14 19:30:06 2001
@@ -0,0 +1,96 @@
+/* appc.c: Advanced Program-to-Program Communications.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+
+#include <linux/appc.h>
+
+static int appcs_in_use = 0;
+static struct appc_ops *appc_client_ops[NPROTO];
+
+#define MAX_APPC_ADDR   1024
+
+int appc_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_APPC_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int appc_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_APPC_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+		if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+asmlinkage void sys_appcall(unsigned short opcode, unsigned char opext,
+        unsigned short rcpri, unsigned long rcsec, void *uaddr)
+{
+	switch(opcode)
+	{
+
+	}
+}
+
+int appc_register(struct appc_ops *ops)
+{
+        int err;
+
+        if(ops->family >= NPROTO)
+        {
+                printk(KERN_CRIT "appc protocol %d >= NPROTO(%d)\n", ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+        err = -EEXIST;
+        if(appc_client_ops[ops->family] == NULL)
+        {
+                appc_client_ops[ops->family] = ops;
+                err = 0;
+        }
+
+        return (err);
+}
+
+int appc_unregister(int family)
+{
+        if(family < 0 || family >= NPROTO)
+                return (-1);
+        appc_client_ops[family] = NULL;
+        return (0);
+}
diff -ruN linux-2.4.4/net/appletalk/ddp.c linux/net/appletalk/ddp.c
--- linux-2.4.4/net/appletalk/ddp.c	Thu Apr 12 12:11:39 2001
+++ linux/net/appletalk/ddp.c	Mon May 14 20:00:55 2001
@@ -75,8 +75,8 @@
 #include <linux/skbuff.h>
 #include <linux/spinlock.h>
 #include <linux/termios.h>	/* For TIOCOUTQ/INQ */
+#include <linux/llc.h>
 #include <net/datalink.h>
-#include <net/p8022.h>
 #include <net/psnap.h>
 #include <net/sock.h>
 #include <linux/ip.h>
diff -ruN linux-2.4.4/net/attach.c linux/net/attach.c
--- linux-2.4.4/net/attach.c	Wed Dec 31 16:00:00 1969
+++ linux/net/attach.c	Mon May 14 19:30:06 2001
@@ -0,0 +1,430 @@
+/* attach.c: Linux-SNA Attach Manager Kernel Stub.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/cache.h>
+#include <linux/module.h>
+
+#include <linux/attach.h>
+
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} attach_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+
+static struct attach_ops *attach_client_ops[NPROTO];
+
+static struct vfsmount *attach_mnt;
+
+/* IDs for TPs connected to an attach manager */
+static unsigned long attach_tp_ids = 0;
+
+#define ATTACHFS_MAGIC 0x634F567B
+
+static int atfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type = ATTACHFS_MAGIC;
+        buf->f_bsize = 1024;
+        buf->f_namelen = 255;
+        return 0;
+}
+
+static struct super_operations atfs_ops = {
+        statfs:         atfs_statfs,
+};
+
+static struct super_block * atfs_read_super(struct super_block *sb, void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid = root->i_gid = 0;
+        root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize = 1024;
+        sb->s_blocksize_bits = 10;
+        sb->s_magic = ATTACHFS_MAGIC;
+        sb->s_op = &atfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "attach:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb = sb;
+        sb->s_root->d_parent = sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(attach_fs_type, "attachfs", atfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int atfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations atfs_dentry_operations = {
+        d_delete:       atfs_delete_dentry,
+};
+
+int attach_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return (-ENXIO);
+}
+
+int attach_close(struct inode *inode, struct file *flip);
+
+static struct file_operations attach_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		attach_no_open,         /* special open code to disallow open by proc */
+        release:	attach_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+extern __inline__ struct attach *ati_lookup(struct inode *inode)
+{
+        return &inode->u.attach_i;
+}
+
+int attach_map_fd(struct attach *at)
+{
+        int fd;
+	struct qstr this;
+	char name[32];
+
+        /*
+         *      Find a file descriptor suitable for return to the user.
+         */
+
+        fd = get_unused_fd();
+        if (fd >= 0) {
+                struct file *file = get_empty_filp();
+
+                if (!file) {
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", at->inode->i_ino);
+                this.name = name;
+                this.len = strlen(name);
+                this.hash = at->inode->i_ino;
+
+		file->f_dentry = d_alloc(attach_mnt->mnt_sb->s_root, &this);
+                if (!file->f_dentry) {
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+		file->f_dentry->d_op = &atfs_dentry_operations;
+                d_add(file->f_dentry, at->inode);
+                file->f_vfsmnt = mntget(attach_mnt);
+
+		at->file = file;
+                file->f_op = at->inode->i_fop = &attach_file_ops;
+                file->f_mode = 3;
+                file->f_flags = O_RDWR;
+                file->f_pos = 0;
+                fd_install(fd, file);
+        }
+
+out:
+        return fd;
+}
+
+struct attach *attachfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct attach *attach;
+
+        if(!(file = fget(fd)))
+        {
+                *err = -EBADF;
+                return NULL;
+        }
+
+        inode = file->f_dentry->d_inode;
+        if(!inode || !inode->i_attach || !(attach = ati_lookup(inode)))
+        {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+
+        if(attach->file != file)
+        {
+                printk(KERN_ERR "ati_lookup: attach file changed!\n");
+                attach->file = file;
+        }
+
+        return (attach);
+}
+
+struct attach *attach_alloc(void)
+{
+        struct inode *inode;
+        struct attach *at;
+
+        inode = get_empty_inode();
+        if(!inode)
+                return (NULL);
+
+        at = ati_lookup(inode);
+
+        inode->i_mode = S_IFSOCK|S_IRWXUGO;
+        inode->i_attach = 1;
+        inode->i_uid = current->fsuid;
+        inode->i_gid = current->fsgid;
+
+        init_waitqueue_head(&at->wait);
+        at->fasync_list = NULL;
+        at->inode     	= inode;
+        at->flags     	= 0;
+        at->ops       	= NULL;
+        at->file      	= NULL;
+
+	attach_in_use[smp_processor_id()].counter++;
+        return (at);
+}
+
+int attach_create(struct attach **a)
+{
+	struct attach *at;
+
+	if(!(at = attach_alloc()))
+		return (-ENOMEM);
+	at->ops	= attach_client_ops[PF_SNA];	/* Bad - I know */
+	*a 	= at;
+
+	return (0);
+}
+
+void attach_release(struct attach *at)
+{
+        attach_in_use[smp_processor_id()].counter--;
+        if(!at->file) {
+                iput(at->inode);
+                return;
+        }
+        at->file = NULL;
+}
+
+struct attach_tps *attach_find_tp(struct attach_tps *tps, char *name)
+{
+	struct attach_tps *t;
+	for(t = tps; t != NULL; t = t->next)
+		if(!strcmp(t->tp_name, name))
+			return (t);
+
+	return (NULL);
+}
+
+/* Returns TP fd, needs attch fd and tp_info */
+asmlinkage int sys_tp_register(int s, struct tp_info *tpi)
+{
+	int err;
+	struct attach *at;
+	struct tp_info tpii;
+	struct attach_tps *tp;
+
+	if((at = attachfd_lookup(s, &err)) == NULL)
+		return (-EBADF);
+
+	if(copy_from_user(&tpii, tpi, sizeof(struct tp_info)))
+                return (-EFAULT);
+
+	tp = attach_find_tp(at->tps, tpii.tp_name);
+	if(tp != NULL)
+		return (-EEXIST);
+
+	tp = (struct attach_tps *)kmalloc(sizeof(struct attach_tps),GFP_ATOMIC);
+	strncpy(tp->tp_name, tpii.tp_name, 64);
+	tp->state	= AT_INIT;
+	tp->flags	= 0;
+	tp->pid		= -1;
+	tp->id		= attach_tp_ids++;
+	tp->next	= at->tps;
+	at->tps		= tp;
+
+        return (err);
+}
+
+/* Needs attach fd, and tp fd to unregister */
+asmlinkage int sys_tp_unregister(int a, int b)
+{
+	struct attach_tps *tp, **clients;
+	struct attach *at;
+	int err;
+
+	if((at = attachfd_lookup(a, &err)) == NULL)
+                return (-EBADF);
+
+	clients = &at->tps;
+	while((tp = *clients) != NULL)
+	{
+		if(tp->id == b)
+		{
+			*clients = tp->next;
+			kfree(tp);
+			return (0);
+		}
+		clients = &tp->next;
+	}
+
+	return (-ENOENT);
+}
+
+/* Open an SNA Attach session, grab an unused FD and setup everything for
+ * the attach manager to start registering TPs.
+ */
+asmlinkage int sys_attach_open(void)
+{
+	int retval;
+	struct attach *a;
+
+	retval = attach_create(&a);
+	if(retval < 0)
+		goto out;
+
+	retval = attach_map_fd(a);
+	if(retval < 0)
+		goto out_release;
+
+out:
+	return (retval);
+
+out_release:
+	attach_release(a);
+	return (retval);
+}
+
+extern __inline__ void attachfd_put(struct attach *at)
+{
+        fput(at->file);
+}
+
+asmlinkage int sys_attach_listen(int s, void *ubuf, int len, unsigned int flags)
+{
+	struct attach *at;
+	int err;
+
+	at = attachfd_lookup(s, &err);
+	if(!at)
+		goto out;
+
+	err = at->ops->attach_listen(at, ubuf, len);
+	attachfd_put(at);
+
+out:
+	return (err);
+}
+
+asmlinkage int sys_tp_correlate(int s, pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+        struct attach *at;
+        int err;
+
+        printk("sys_tp_correlate %d %ld\n", pid, tcb_id);
+
+        at = attachfd_lookup(s, &err);
+        if(!at)
+                goto out;
+
+        err = at->ops->tp_correlate(pid, tcb_id, tp_name);
+
+out:
+        return (err);
+}
+
+asmlinkage int sys_attach_close(int s)
+{
+	struct attach *at;
+	int err;
+
+	if((at = attachfd_lookup(s, &err)) != NULL)
+		attach_release(at);
+        return (err);
+}
+
+int attach_close(struct inode *inode, struct file *flip)
+{
+        if(!inode)
+        {
+                printk(KERN_DEBUG "attach_close: NULL inode\n");
+                return (0);
+        }
+        unlock_kernel();
+//        cpic_fasync(-1, filp, 0);
+        attach_release(ati_lookup(inode));
+        lock_kernel();
+
+        return (0);
+}
+
+int attach_register(struct attach_ops *ops)
+{
+        int err;
+
+        if(ops->family >= NPROTO)
+        {
+                printk(KERN_CRIT "attach %d >= NPROTO(%d)\n", 
+			ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+        err = -EEXIST;
+        if(attach_client_ops[ops->family] == NULL)
+        {
+                attach_client_ops[ops->family] = ops;
+                err = 0;
+        }
+
+	register_filesystem(&attach_fs_type);
+        attach_mnt = kern_mount(&attach_fs_type);
+
+        return (err);
+}
+
+int attach_unregister(int family)
+{
+        if(family < 0 || family >= NPROTO)
+                return (-1);
+        attach_client_ops[family] = NULL;
+        return (0);
+}
diff -ruN linux-2.4.4/net/cpic.c linux/net/cpic.c
--- linux-2.4.4/net/cpic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/cpic.c	Mon May 14 19:30:06 2001
@@ -0,0 +1,1068 @@
+/* cpic.c: Common Programming Interface Communications, v2.1 compliant.
+ *  - Protocol independent CPI-C functions. This file does all the
+ *    high-level work for a net layer using CPI-C, and condences the CPI-C
+ *    functions into a few protocol specific parts. Basicly that breaking
+ *    down into cpic.c doing error checking on the call and user-kernel
+ *    data structure transfers.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@turbolinux.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/socket.h>
+#include <linux/file.h>
+#include <linux/net.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/wanrouter.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <linux/errno.h>
+#include <linux/sna.h>
+#include <linux/module.h>
+
+#include <linux/ctype.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static union {
+        int     counter;
+        char    __pad[SMP_CACHE_BYTES];
+} cpics_in_use[NR_CPUS] __cacheline_aligned = {{0}};
+static struct cpic_ops *cpic_client_ops[NPROTO];
+
+#define MAX_CPIC_ADDR   1024
+
+static struct vfsmount *cpic_mnt;
+
+static int cpic_map_fd(struct cpic *cpic);
+
+#define CPICFS_MAGIC 0x634D128F
+
+static int cpicfs_statfs(struct super_block *sb, struct statfs *buf)
+{
+        buf->f_type = CPICFS_MAGIC;
+        buf->f_bsize = 1024;
+        buf->f_namelen = 255;
+        return 0;
+}
+
+static struct super_operations cpicfs_ops = {
+        statfs:         cpicfs_statfs,
+};
+
+static struct super_block * cpicfs_read_super(struct super_block *sb, 
+	void *data, int silent)
+{
+        struct inode *root = new_inode(sb);
+        if (!root)
+                return NULL;
+        root->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;
+        root->i_uid = root->i_gid = 0;
+        root->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;
+        sb->s_blocksize = 1024;
+        sb->s_blocksize_bits = 10;
+        sb->s_magic = CPICFS_MAGIC;
+        sb->s_op = &cpicfs_ops;
+        sb->s_root = d_alloc(NULL, &(const struct qstr) { "cpic:", 7, 0 });
+        if (!sb->s_root) {
+                iput(root);
+                return NULL;
+        }
+        sb->s_root->d_sb = sb;
+        sb->s_root->d_parent = sb->s_root;
+        d_instantiate(sb->s_root, root);
+        return sb;
+}
+
+static DECLARE_FSTYPE(cpic_fs_type, "cpicfs", cpicfs_read_super,
+        FS_NOMOUNT|FS_SINGLE);
+
+static int cpicfs_delete_dentry(struct dentry *dentry)
+{
+        return 1;
+}
+
+static struct dentry_operations cpicfs_dentry_operations = {
+        d_delete:       cpicfs_delete_dentry,
+};
+
+int cpic_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_CPIC_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int cpic_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_CPIC_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+                if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+int cpic_error(void *uaddr, __u32 return_code)
+{
+        return(cpic_ktou(&return_code, sizeof(return_code), uaddr));
+}
+
+int cpic_get_cvid(unsigned char CM_PTR conversation_id)
+{
+        __u32 cvid = 0;
+
+        copy_from_user(&cvid, conversation_id, sizeof(__u32));
+
+        return ((int)cvid);
+}
+
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare);
+int cpic_close(struct inode *inode, struct file *flip);
+
+static struct file_operations cpic_file_ops = {
+        llseek:		NULL,
+        read:		NULL,
+        write:		NULL,
+        poll:		NULL,                   /* readdir */
+        ioctl:		NULL,
+        mmap:		NULL,
+        open:		cpic_no_open,           /* special open code to disallow open via /proc
+*/
+        release:	cpic_close,
+        fasync:		NULL,                   /* no fsync */
+        readv:		NULL,
+	writev:		NULL
+};
+
+void cpic_release(struct cpic *cpic)
+{
+	if(cpic->ops)
+		cpic->ops->release(cpic);
+	cpics_in_use[smp_processor_id()].counter--;
+}
+
+static int cpic_no_open(struct inode *irrelevant, struct file *dontcare)
+{
+        return (-ENXIO);
+}
+
+extern __inline__ struct cpic *cpici_lookup(struct inode *inode)
+{
+        return &inode->u.cpic_i;
+}
+
+extern struct cpic *cpicfd_lookup(int fd, int *err)
+{
+        struct file *file;
+        struct inode *inode;
+        struct cpic *cpic;
+
+        if(!(file = fget(fd)))
+        {
+                *err = -EBADF;
+                return NULL;
+        }
+
+        inode = file->f_dentry->d_inode;
+        if(!inode || !inode->i_cpic || !(cpic = cpici_lookup(inode)))
+        {
+                *err = -ENOTSOCK;
+                fput(file);
+                return NULL;
+        }
+
+        if(cpic->file != file)
+	{
+                printk(KERN_ERR "cpici_lookup: cpic file changed!\n");
+                cpic->file = file;
+        }
+
+	return (cpic);
+}
+
+/* Side information.
+ */
+
+static unsigned long cpic_side_id = 0;
+static struct cpic_side_info *cpic_side_list = NULL;
+
+struct cpic_side_info *cpic_find_side_info(unsigned char *name)
+{
+        struct cpic_side_info *cpic;
+
+        for(cpic = cpic_side_list; cpic != NULL; cpic = cpic->next)
+	{
+		printk("com -%s- -%s-\n", name, cpic->sym_dest_name);
+                if(!strncmp(cpic->sym_dest_name, name, 8))
+                        return (cpic);
+	}
+        return (NULL);
+}
+
+int cpic_unregister_side_info(struct cpic_delete_side_info *side)
+{
+        struct cpic_side_info *cs, **clients;
+
+        clients = &cpic_side_list;
+        while((cs = *clients) != NULL)
+        {
+                if(!strncmp(cs->sym_dest_name, side->sym_dest_name, 8))
+                {
+                        *clients = cs->next;
+                        kfree(cs);
+                        return (0);
+                }
+                clients = &cs->next;
+        }
+
+        return (-ENOENT);
+}
+
+struct netid *char_to_netid(unsigned char *b)
+{
+        struct netid *n;
+        unsigned char c[40];
+        int i;
+
+        strcpy(c, b);   /* always use protection */
+        n = (struct netid *)kmalloc(sizeof(struct netid), GFP_KERNEL);
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for(i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for(i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for(i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+        for(i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return (n);
+}
+
+char *pr_netid(struct netid *n)
+{
+        struct netid p;
+        char *buff;
+        int i;
+
+        buff = (char *)kmalloc(20, GFP_ATOMIC);
+        memcpy(&p, n, sizeof(struct netid));
+        for(i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for(i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+
+        return (buff);
+}
+
+int cpic_register_side_info(struct cpic_define_side_info *side)
+{
+        struct cpic_side_info *cs;
+	int i;
+
+        cs = cpic_find_side_info(side->sym_dest_name);
+        if(cs != NULL)
+                return (-EEXIST);
+        cs = (struct cpic_side_info *)kmalloc(sizeof(struct cpic_side_info),
+                GFP_ATOMIC);
+	memset(cs, '\0', sizeof(struct cpic_side_info));
+	memcpy(&cs->netid, char_to_netid(side->netid), sizeof(struct netid));
+	memcpy(&cs->netid_plu, char_to_netid(side->netid_plu), 
+		sizeof(struct netid));
+        strncpy(cs->sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+	for(i = strlen(cs->sym_dest_name); i < 8; i++)
+		cs->sym_dest_name[i] = 0x20;
+        strncpy(cs->mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cs->tp_name, side->tp_name, 65);
+        cs->service_tp 		= side->service_tp;
+        cs->security_level 	= side->security_level;
+        strncpy(cs->username, side->username, 11);
+        strncpy(cs->password, side->password, 11);
+        cs->proc_id             = cpic_side_id++;
+
+        /* Add to list */
+        cs->next                = cpic_side_list;
+        cpic_side_list      	= cs;
+
+        return (0);
+}
+
+int cpic_ginfo(struct cpic_side_info *side, char *buf, int len)
+{
+        struct cpicsreq cr;
+        int done = 0;
+
+        if(!buf)
+        {
+                done += sizeof(cr);
+                return (done);
+        }
+        if(len < (int)sizeof(cr))
+                return done;
+        memset(&cr, '\0', sizeof(struct cpicsreq));
+
+        /* Move the data here */
+	sprintf(cr.netid, "%s", pr_netid(&side->netid));
+	sprintf(cr.netid_plu, "%s", pr_netid(&side->netid_plu));
+        strncpy(cr.sym_dest_name, side->sym_dest_name, RESOURCE_NAME_LEN);
+        strncpy(cr.mode_name, side->mode_name, RESOURCE_NAME_LEN);
+        strncpy(cr.tp_name, side->tp_name, 65);
+        strncpy(cr.username, side->username, 11);
+        strncpy(cr.password, side->password, 11);
+        cr.service_tp     = side->service_tp;
+        cr.security_level = side->security_level;
+        cr.proc_id        = side->proc_id;
+
+        if(copy_to_user(buf, &cr, sizeof(struct cpicsreq)))
+                return (-EFAULT);
+        buf += sizeof(struct cpicsreq);
+        len -= sizeof(struct cpicsreq);
+        done += sizeof(struct cpicsreq);
+
+        return (done);
+}
+
+int cpic_query_side_info(char *arg)
+{
+        struct cpicsconf cc;
+        struct cpic_side_info *side;
+        char *pos;
+        int len, total;
+
+        if(copy_from_user(&cc, arg, sizeof(cc)))
+                return (-EFAULT);
+
+        pos = cc.cpicsc_buf;
+        len = cc.cpics_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(side = cpic_side_list; side != NULL; side = side->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = cpic_ginfo(side, NULL, 0);
+                else
+                        done = cpic_ginfo(side, pos+total, len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        cc.cpics_len = total;
+        if(copy_to_user(arg, &cc, sizeof(cc)))
+                return (-EFAULT);
+        return (0);
+}
+
+/* CPI-C functions
+ */
+
+int cpic_close(struct inode *inode, struct file *flip)
+{
+	if(!inode)
+        {
+                printk(KERN_DEBUG "cpic_close: NULL inode\n");
+                return (0);
+        }
+        unlock_kernel();
+//        cpic_fasync(-1, filp, 0);
+        cpic_release(cpici_lookup(inode));
+        lock_kernel();
+
+        return (0);
+}
+
+struct cpic *cpic_alloc(void)
+{
+	struct inode *inode;
+	struct cpic *cpic;
+
+	inode = get_empty_inode();
+        if(!inode)
+                return (NULL);
+
+	cpic = cpici_lookup(inode);
+
+	inode->i_mode = S_IFSOCK|S_IRWXUGO;
+        inode->i_cpic = 1;
+        inode->i_uid = current->fsuid;
+        inode->i_gid = current->fsgid;
+
+        init_waitqueue_head(&cpic->wait);
+	cpic->fasync_list = NULL;
+	cpic->inode     = inode;
+	cpic->state	= CM_INIT;
+	cpic->flags	= 0;
+	cpic->side	= NULL;
+	cpic->file	= NULL;
+	cpic->pid	= 0;
+
+	cpic->ops = cpic_client_ops[PF_SNA];
+
+	cpics_in_use[smp_processor_id()].counter++;
+	return (cpic);
+}
+
+int cpic_create(struct cpic_side_info *side, struct cpic **cpic)
+{
+	struct cpic *c;
+
+	if(!(c = cpic_alloc()))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	c->side	= side;
+	*cpic 	= c;
+
+	if(side != NULL)
+		c->ops->create(c, 1);
+
+	return (CM_OK);
+}
+
+unsigned long cpic_cmaccp(unsigned char CM_PTR conversation_id, pid_t *p)
+{
+        struct cpic *cpic;
+	struct sna_tcb *tcb;
+	int fd;
+	__u32 rc;
+
+        /* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(NULL, &cpic);
+        if(rc != CM_OK)
+                goto out;
+
+	/* Now this is a local (server) tp being launched.
+	 * So we need to located the already allocated tcb and link
+	 * it to this cpic session. We do this by using the pid
+	 * provided by the user.
+	 */
+	cpic_utok(p, sizeof(pid_t), &cpic->pid);
+	tcb = cpic->vi.sna;
+	tcb = cpic->ops->find_tcb_by_pid(cpic->pid);
+	if(!tcb)
+	{
+		printk("No TCB found by PID %d\n", cpic->pid);
+		rc = CM_PRODUCT_SPECIFIC_ERROR;
+		goto out_release;
+	}
+
+	cpic->vi.sna = tcb;
+
+        fd = cpic_map_fd(cpic);
+        if(fd < 0)
+                goto out_release;
+        else
+                cpic_ktou(&fd, sizeof(int), conversation_id);
+
+	tcb->state = CM_INIT_INCOMING;
+
+out:
+        return (rc);
+
+out_release:
+        cpic_release(cpic);
+        return (rc);
+}
+
+unsigned long cpic_cmcnvi(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return (CM_OK);
+}
+
+unsigned long cpic_cmcnvo(unsigned char CM_PTR buffer,
+	CM_INT32 CM_PTR buffer_length)
+{
+	return (CM_OK);
+}
+
+static int cpic_map_fd(struct cpic *cpic)
+{
+	int fd;
+	struct qstr this;
+        char name[32];
+
+	/* Find a file descriptor suitable for return to the user. */
+        fd = get_unused_fd();
+        if(fd >= 0) 
+	{
+                struct file *file = get_empty_filp();
+
+                if(!file) 
+		{
+                        put_unused_fd(fd);
+                        fd = -ENFILE;
+                        goto out;
+                }
+
+		sprintf(name, "[%lu]", cpic->inode->i_ino);
+                this.name = name;
+                this.len = strlen(name);
+                this.hash = cpic->inode->i_ino;
+
+                file->f_dentry = d_alloc(cpic_mnt->mnt_sb->s_root, &this);
+                if(!file->f_dentry)
+		{
+                        put_filp(file);
+                        put_unused_fd(fd);
+                        fd = -ENOMEM;
+                        goto out;
+                }
+
+		file->f_dentry->d_op = &cpicfs_dentry_operations;
+                d_add(file->f_dentry, cpic->inode);
+                file->f_vfsmnt = mntget(cpic_mnt);
+
+		cpic->file = file;
+                file->f_op = cpic->inode->i_fop = &cpic_file_ops;
+                file->f_mode = 3;
+                file->f_flags = O_RDWR;
+                file->f_pos = 0;
+                fd_install(fd, file);
+        }
+
+out:
+        return (fd);
+}
+
+unsigned long cpic_cminit(unsigned char CM_PTR conversation_id,
+	unsigned char CM_PTR sym_dest_name)
+{
+	struct cpic_side_info *side;
+	struct cpic *cpic;
+	unsigned char sdn[9];
+	__u32 rc;
+	int fd, err;
+
+	/* Locate the side information entry */
+	err = cpic_utok(sym_dest_name, sizeof(sdn), &sdn);
+	if(err < 0)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	side = cpic_find_side_info(sdn);
+	if(side == NULL)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	/* Create all of local structures for CPIC to exist. */
+        rc = cpic_create(side, &cpic);
+        if(rc != CM_OK)
+		goto out;
+
+	fd = cpic_map_fd(cpic);
+	if(fd < 0)
+		goto out_release;
+	else
+		cpic_ktou(&fd, sizeof(int), conversation_id);
+
+out:
+	return (rc);
+
+out_release:
+        cpic_release(cpic);
+	return (rc);
+}
+
+CM_ENTRY sys_cmrltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	ops->cmrltp(tp_name, tp_name_length, return_code);
+}
+
+CM_ENTRY sys_cmsltp(unsigned char CM_PTR tp_name,
+	CM_INT32 CM_PTR tp_name_length,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+//	cpic_client_ops[PF_SNA]->cmsltp(tp_name, tp_name_length, return_code);
+}
+
+CM_ENTRY sys_cmwcmp(unsigned char CM_PTR ooid_list,
+	CM_INT32 CM_PTR ooid_list_count,
+	CM_INT32 CM_PTR timeout,
+	unsigned char CM_PTR completed_op_index_list,
+	CM_INT32 CM_PTR completed_op_count,
+	unsigned char CM_PTR user_field_list,
+	CM_RETURN_CODE CM_PTR return_code)
+{
+
+}
+
+unsigned long cpic_cmembs(__u32 *max_buffer_size)
+{
+	__u32 size = sizeof(__u32);
+        cpic_ktou(&size, sizeof(__u32), max_buffer_size);
+
+	return (CM_OK);
+}
+
+asmlinkage CM_ENTRY sys_cpicall(unsigned char CM_PTR conversation_id, 
+	unsigned short opcode, void *uaddr, CM_RETURN_CODE CM_PTR return_code) 
+{
+	struct cpic *cpic = NULL;
+	cpic_args *args = NULL;
+	unsigned long rc = CM_OK;
+	int err;
+
+	/* Copy call arguments from user space */
+	args = (cpic_args *)kmalloc(sizeof(cpic_args), GFP_ATOMIC);
+	cpic_utok(uaddr, sizeof(cpic_args), args);
+
+	/* Get the local cpic structure if available. */
+	if((opcode != CM_CMINIT && opcode != CM_CMCNVI && opcode != CM_CMCNVO
+		&& opcode != CM_CMEMBS && opcode != CM_CMRLTP
+		&& opcode != CM_CMSLTP && opcode != CM_CMWCMP
+		&& opcode != CM_CMACCP)
+		&& ((cpic = cpicfd_lookup(cpic_get_cvid(conversation_id), &err))
+		== NULL))
+	{
+		rc = CM_PROGRAM_PARAMETER_CHECK;
+		goto out;
+	} 
+
+	switch(opcode)
+	{
+		case (CM_CMACCI):
+			rc = cpic->ops->cmacci(cpic);
+			break;
+
+		case (CM_CMACCP):
+			rc = cpic_cmaccp(conversation_id, (pid_t *)args->a1);
+			break;
+
+		case (CM_CMALLC):
+			rc = cpic->ops->cmallc(cpic);
+			break;
+
+		case (CM_CMCANC):
+			rc = cpic->ops->cmcanc(cpic);
+			break;
+
+		case (CM_CMCFM):
+			rc = cpic->ops->cmcfm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMCFMD):
+			rc = cpic->ops->cmcfmd(cpic);
+			break;
+
+		case (CM_CMCNVI):	/* No Cvid */
+			rc = cpic_cmcnvi((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+
+		case (CM_CMCNVO):	/* No Cvid */
+			rc = cpic_cmcnvo((__u8 *)args->a1,(CM_INT32 *)args->a2);
+			break;
+
+		case (CM_CMDEAL):
+			rc = cpic->ops->cmdeal(cpic);
+			break;
+
+		case (CM_CMDFDE):
+			rc = cpic->ops->cmdfde(cpic);
+			break;
+
+		case (CM_CMEACN):
+			rc = cpic->ops->cmeacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEAEQ):
+			rc = cpic->ops->cmeaeq(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMEAPT):
+			rc = cpic->ops->cmeapt(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMECS):
+			rc = cpic->ops->cmecs(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMECT):
+			rc = cpic->ops->cmect(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMECTX):
+			rc = cpic->ops->cmectx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEID):
+			rc = cpic->ops->cmeid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMEMBS):	/* No Cvid */
+			rc = cpic_cmembs((__u32 *)args->a1);
+			break;
+
+		case (CM_CMEMN):
+			rc = cpic->ops->cmemn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMEPID):
+			rc = cpic->ops->cmepid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6, (__u32 *)args->a7);
+			break;
+
+		case (CM_CMEPLN):
+			rc = cpic->ops->cmepln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMESI):
+			rc = cpic->ops->cmesi(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMESL):
+			rc = cpic->ops->cmesl(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMESRM):
+			rc = cpic->ops->cmesrm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMESUI):
+			rc = cpic->ops->cmesui(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMETC):
+			rc = cpic->ops->cmetc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMETPN):
+			rc = cpic->ops->cmetpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMFLUS):
+			rc = cpic->ops->cmflus(cpic);
+			break;
+
+		case (CM_CMINCL):
+			rc = cpic->ops->cmincl(cpic);
+			break;
+
+		case (CM_CMINIC):
+			rc = cpic->ops->cminic(cpic);
+			break;
+
+		case (CM_CMINIT):	/* No Cvid */
+			rc = cpic_cminit(conversation_id, (__u8 *)args->a1);
+			break;
+
+		case (CM_CMPREP):
+			rc = cpic->ops->cmprep(cpic);
+			break;
+
+		case (CM_CMPTR):
+			rc = cpic->ops->cmptr(cpic);
+			break;
+
+		case (CM_CMRCV):
+			rc = cpic->ops->cmrcv(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5,
+				(__u32 *)args->a6);
+			break;
+
+		case (CM_CMRCVX):
+			rc = cpic->ops->cmrcvx(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5);
+			break;
+
+		case (CM_CMRLTP):	/* No Cvid */
+			break;
+
+		case (CM_CMRTS):
+			rc = cpic->ops->cmrts(cpic);
+			break;
+
+		case (CM_CMSAC):
+			rc = cpic->ops->cmsac(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSACN):
+			rc = cpic->ops->cmsacn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSAEQ):
+			rc = cpic->ops->cmsaeq(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSAPT):
+			rc = cpic->ops->cmsapt(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSBT):
+			rc = cpic->ops->cmsbt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCSP):
+			rc = cpic->ops->cmscsp(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSCST):
+			rc = cpic->ops->cmscst(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCSU):
+			rc = cpic->ops->cmscsu(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSCT):
+			rc = cpic->ops->cmsct(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSCU):
+			rc = cpic->ops->cmscu(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSDT):
+			rc = cpic->ops->cmsdt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSED):
+			rc = cpic->ops->cmsed(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSEND):
+			rc = cpic->ops->cmsend(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSERR):
+			rc = cpic->ops->cmserr(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSF):
+			rc = cpic->ops->cmsf(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSID):
+			rc = cpic->ops->cmsid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSLD):
+			rc = cpic->ops->cmsld(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSLTP):	/* No Cvid */
+			break;
+
+		case (CM_CMSMN):
+			rc = cpic->ops->cmsmn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSNDX):
+			rc = cpic->ops->cmsndx(cpic, (__u32 *)args->a1,
+				(__u32 *)args->a2, (__u32 *)args->a3);
+			break;
+
+		case (CM_CMSPDP):
+			rc = cpic->ops->cmspdp(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSPID):
+			rc = cpic->ops->cmspid(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4, (__u32 *)args->a5, 
+				(__u32 *)args->a6);
+			break;
+
+		case (CM_CMSPLN):
+			rc = cpic->ops->cmspln(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMSPM):
+			rc = cpic->ops->cmspm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSPTR):
+			rc = cpic->ops->cmsptr(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSQCF):
+			rc = cpic->ops->cmsqcf(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMSQPM):
+			rc = cpic->ops->cmsqpm(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2, (__u32 *)args->a3,
+				(__u32 *)args->a4);
+			break;
+
+		case (CM_CMSRC):
+			rc = cpic->ops->cmsrc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSRT):
+			rc = cpic->ops->cmsrt(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSSL):
+			rc = cpic->ops->cmssl(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSSRM):
+			rc = cpic->ops->cmssrm(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSST):
+			rc = cpic->ops->cmsst(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSTC):
+			rc = cpic->ops->cmstc(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMSTPN):
+			rc = cpic->ops->cmstpn(cpic, (__u32 *)args->a1, 
+				(__u32 *)args->a2);
+			break;
+
+		case (CM_CMTRTS):
+			rc = cpic->ops->cmtrts(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMWAIT):
+			rc = cpic->ops->cmwait(cpic, (__u32 *)args->a1);
+			break;
+
+		case (CM_CMWCMP):	/* No Cvid */
+			break;
+
+		default:
+			rc = CM_PROGRAM_PARAMETER_CHECK;
+			goto out;
+	}
+
+out:
+	cpic_error(return_code, rc);
+	return;
+}
+
+int cpic_register(struct cpic_ops *ops)
+{
+	int err;
+
+	if(ops->family >= NPROTO)
+	{
+		printk(KERN_CRIT "cpic protocol %d >= NPROTO(%d)\n", ops->family, NPROTO);
+                return (-ENOBUFS);
+        }
+
+	err = -EEXIST;
+	if(cpic_client_ops[ops->family] == NULL)
+	{
+		cpic_client_ops[ops->family] = ops;
+		err = 0;
+	} 
+
+	register_filesystem(&cpic_fs_type);
+        cpic_mnt = kern_mount(&cpic_fs_type);
+
+	return (err);
+}
+
+int cpic_unregister(int family)
+{
+	struct cpic_side_info *cpic;
+
+	if(family < 0 || family >= NPROTO)
+		return (-1);
+
+        for(cpic = cpic_side_list; cpic != NULL; cpic = cpic->next)
+		kfree(cpic);
+	cpic_side_list = NULL;
+
+	cpic_client_ops[family] = NULL;
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct cpic_side_info *side;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-18s%-18s%-9s%-10s%-s\n",
+                "netid.node", "netid.plu", "sym_name", "mode_name", "tp_name");
+
+        for(side = cpic_side_list; side != NULL; side = side->next)
+        {
+                len += sprintf(buffer + len, "%-18s", 
+			pr_netid((struct netid *)&side->netid));
+                len += sprintf(buffer + len, "%-18s",
+			pr_netid((struct netid *)&side->netid_plu));
+                len += sprintf(buffer + len, "%-9s", side->sym_dest_name);
+		len += sprintf(buffer + len, "%-10s", side->mode_name);
+		len += sprintf(buffer + len, "%-s\n", side->tp_name);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+#endif	/* CONFIG_PROC_FS */
diff -ruN linux-2.4.4/net/devlink/Makefile linux/net/devlink/Makefile
--- linux-2.4.4/net/devlink/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/Makefile	Mon May 14 19:29:21 2001
@@ -0,0 +1,24 @@
+#
+# Makefile for the Linux 802.[3,4,5] physical layer protocols.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := devlink.o
+
+obj-y := p8023.o
+obj-m := $(O_TARGET)
+
+obj-$(CONFIG_SYSCTL) += sysctl_net_devlink.o
+obj-$(CONFIG_TR) += tr.o
+obj-$(CONFIG_NET_FC) += fc.o
+obj-$(CONFIG_FDDI) += fddi.o
+obj-$(CONFIG_HIPPI) += hippi.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+	tar -cvf /dev/f1 .
diff -ruN linux-2.4.4/net/devlink/fc.c linux/net/devlink/fc.c
--- linux-2.4.4/net/devlink/fc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/fc.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,98 @@
+/*
+ * NET3:	Fibre Channel device handling subroutines
+ * 
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *		Vineet Abraham <vma@iol.unh.edu>
+ *		v 1.0 03/22/99
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/fcdevice.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/net.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <net/arp.h>
+
+/*
+ *	Put the headers on a Fibre Channel packet. 
+ */
+ 
+int fc_header(struct sk_buff *skb, struct net_device *dev, unsigned short type,
+              void *daddr, void *saddr, unsigned len) 
+{
+	struct fch_hdr *fch;
+	int hdr_len;
+
+	/* 
+	 * Add the 802.2 SNAP header if IP as the IPv4 code calls  
+	 * dev->hard_header directly.
+	 */
+	if (type == ETH_P_IP || type == ETH_P_ARP)
+	{
+		struct fcllc *fcllc=(struct fcllc *)(fch+1);
+
+		hdr_len = sizeof(struct fch_hdr) + sizeof(struct fcllc);
+		fch = (struct fch_hdr *)skb_push(skb, hdr_len);
+		fcllc = (struct fcllc *)(fch+1);
+		fcllc->dsap = fcllc->ssap = EXTENDED_SAP;
+		fcllc->llc = UI_CMD;
+		fcllc->protid[0] = fcllc->protid[1] = fcllc->protid[2] = 0x00;
+		fcllc->ethertype = htons(type);
+	}
+	else
+	{
+		hdr_len = sizeof(struct fch_hdr);
+		fch = (struct fch_hdr *)skb_push(skb, hdr_len);	
+	}
+
+	if(saddr)
+		memcpy(fch->saddr,saddr,dev->addr_len);
+	else
+		memcpy(fch->saddr,dev->dev_addr,dev->addr_len);
+
+	if(daddr) 
+	{
+		memcpy(fch->daddr,daddr,dev->addr_len);
+		return(hdr_len);
+	}
+	return -hdr_len;
+}
+	
+/*
+ *	A neighbour discovery of some species (eg arp) has completed. We
+ *	can now send the packet.
+ */
+ 
+int fc_rebuild_header(struct sk_buff *skb) 
+{
+	struct fch_hdr *fch=(struct fch_hdr *)skb->data;
+	struct fcllc *fcllc=(struct fcllc *)(skb->data+sizeof(struct fch_hdr));
+	if(fcllc->ethertype != htons(ETH_P_IP)) {
+		printk("fc_rebuild_header: Don't know how to resolve type %04X addresses ?\n",(unsigned int)htons(fcllc->ethertype));
+		return 0;
+	}
+#ifdef CONFIG_INET
+	return arp_find(fch->daddr, skb);
+#else
+	return 0;
+#endif
+}
+	
diff -ruN linux-2.4.4/net/devlink/fddi.c linux/net/devlink/fddi.c
--- linux-2.4.4/net/devlink/fddi.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/fddi.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,166 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		FDDI-type device handling.
+ *
+ * Version:	@(#)fddi.c	1.0.0	08/12/96
+ *
+ * Authors:	Lawrence V. Stefani, <stefani@lkg.dec.com>
+ *
+ *		fddi.c is based on previous eth.c and tr.c work by
+ *			Ross Biro, <bir7@leland.Stanford.Edu>
+ *			Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *			Mark Evans, <evansmp@uhura.aston.ac.uk>
+ *			Florian La Roche, <rzsfl@rz.uni-sb.de>
+ *			Alan Cox, <gw4pts@gw4pts.ampr.org>
+ * 
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ *	Changes
+ *		Alan Cox		:	New arp/rebuild header
+ *		Maciej W. Rozycki	:	IPv6 support
+ */
+ 
+#include <linux/config.h>
+#include <asm/segment.h>
+#include <asm/system.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/fddidevice.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <net/arp.h>
+#include <net/sock.h>
+
+/*
+ * Create the FDDI MAC header for an arbitrary protocol layer
+ *
+ * saddr=NULL	means use device source address
+ * daddr=NULL	means leave destination address (eg unresolved arp)
+ */
+
+int fddi_header(struct sk_buff	*skb, struct net_device *dev, unsigned short type,
+		void *daddr, void *saddr, unsigned len)
+{
+	int hl = FDDI_K_SNAP_HLEN;
+	struct fddihdr *fddi;
+	
+	if(type != ETH_P_IP && type != ETH_P_IPV6 && type != ETH_P_ARP)
+		hl=FDDI_K_8022_HLEN-3;
+	fddi = (struct fddihdr *)skb_push(skb, hl);
+	fddi->fc			 = FDDI_FC_K_ASYNC_LLC_DEF;
+	if(type == ETH_P_IP || type == ETH_P_IPV6 || type == ETH_P_ARP)
+	{
+		fddi->hdr.llc_snap.dsap		 = FDDI_EXTENDED_SAP;
+		fddi->hdr.llc_snap.ssap		 = FDDI_EXTENDED_SAP;
+		fddi->hdr.llc_snap.ctrl		 = FDDI_UI_CMD;
+		fddi->hdr.llc_snap.oui[0]	 = 0x00;
+		fddi->hdr.llc_snap.oui[1]	 = 0x00;
+		fddi->hdr.llc_snap.oui[2]	 = 0x00;
+		fddi->hdr.llc_snap.ethertype	 = htons(type);
+	}
+
+	/* Set the source and destination hardware addresses */
+	 
+	if (saddr != NULL)
+		memcpy(fddi->saddr, saddr, dev->addr_len);
+	else
+		memcpy(fddi->saddr, dev->dev_addr, dev->addr_len);
+
+	if (daddr != NULL)
+	{
+		memcpy(fddi->daddr, daddr, dev->addr_len);
+		return(hl);
+	}
+
+	return(-hl);
+}
+
+
+/*
+ * Rebuild the FDDI MAC header. This is called after an ARP
+ * (or in future other address resolution) has completed on
+ * this sk_buff.  We now let ARP fill in the other fields.
+ */
+ 
+int fddi_rebuild_header(struct sk_buff	*skb)
+{
+	struct fddihdr *fddi = (struct fddihdr *)skb->data;
+
+#ifdef CONFIG_INET
+	if (fddi->hdr.llc_snap.ethertype == __constant_htons(ETH_P_IP))
+		/* Try to get ARP to resolve the header and fill destination address */
+		return arp_find(fddi->daddr, skb);
+	else
+#endif	
+	{
+		printk("%s: Don't know how to resolve type %02X addresses.\n",
+		       skb->dev->name, htons(fddi->hdr.llc_snap.ethertype));
+		return(0);
+	}
+}
+
+
+/*
+ * Determine the packet's protocol ID and fill in skb fields.
+ * This routine is called before an incoming packet is passed
+ * up.  It's used to fill in specific skb fields and to set
+ * the proper pointer to the start of packet data (skb->data).
+ */
+ 
+unsigned short fddi_type_trans(struct sk_buff *skb, struct net_device *dev)
+{
+	struct fddihdr *fddi = (struct fddihdr *)skb->data;
+	unsigned short type;
+	
+	/*
+	 * Set mac.raw field to point to FC byte, set data field to point
+	 * to start of packet data.  Assume 802.2 SNAP frames for now.
+	 */
+
+	skb->mac.raw = skb->data;	/* point to frame control (FC) */
+	
+	if(fddi->hdr.llc_8022_1.dsap==0xe0)
+	{
+		skb_pull(skb, FDDI_K_8022_HLEN-3);
+		type = __constant_htons(ETH_P_802_2);
+	}
+	else
+	{
+		skb_pull(skb, FDDI_K_SNAP_HLEN);		/* adjust for 21 byte header */
+		type=fddi->hdr.llc_snap.ethertype;
+	}
+	
+	/* Set packet type based on destination address and flag settings */
+			
+	if (*fddi->daddr & 0x01)
+	{
+		if (memcmp(fddi->daddr, dev->broadcast, FDDI_K_ALEN) == 0)
+			skb->pkt_type = PACKET_BROADCAST;
+		else
+			skb->pkt_type = PACKET_MULTICAST;
+	}
+	
+	else if (dev->flags & IFF_PROMISC)
+	{
+		if (memcmp(fddi->daddr, dev->dev_addr, FDDI_K_ALEN))
+			skb->pkt_type = PACKET_OTHERHOST;
+	}
+
+	/* Assume 802.2 SNAP frames, for now */
+
+	return(type);
+}
diff -ruN linux-2.4.4/net/devlink/hippi.c linux/net/devlink/hippi.c
--- linux-2.4.4/net/devlink/hippi.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/hippi.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,154 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		HIPPI-type device handling.
+ *
+ * Version:	@(#)hippi.c	1.0.0	05/29/97
+ *
+ * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Mark Evans, <evansmp@uhura.aston.ac.uk>
+ *		Florian  La Roche, <rzsfl@rz.uni-sb.de>
+ *		Alan Cox, <gw4pts@gw4pts.ampr.org>
+ *		Jes Sorensen, <Jes.Sorensen@cern.ch>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/hippidevice.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <net/arp.h>
+#include <net/sock.h>
+#include <asm/uaccess.h>
+#include <asm/checksum.h>
+#include <asm/segment.h>
+#include <asm/system.h>
+
+/*
+ * hippi_net_init()
+ *
+ * Do nothing, this is just to pursuade the stupid linker to behave.
+ */
+
+void hippi_net_init(void)
+{
+	return;
+}
+
+/*
+ * Create the HIPPI MAC header for an arbitrary protocol layer 
+ *
+ * saddr=NULL	means use device source address
+ * daddr=NULL	means leave destination address (eg unresolved arp)
+ */
+
+int hippi_header(struct sk_buff *skb, struct net_device *dev,
+		 unsigned short type, void *daddr, void *saddr,
+		 unsigned len)
+{
+	struct hippi_hdr *hip = (struct hippi_hdr *)skb_push(skb, HIPPI_HLEN);
+
+	if (!len){
+		len = skb->len - HIPPI_HLEN;
+		printk("hippi_header(): length not supplied\n");
+	}
+
+	/*
+	 * Due to the stupidity of the little endian byte-order we
+	 * have to set the fp field this way.
+	 */
+	hip->fp.fixed		= __constant_htonl(0x04800018);
+	hip->fp.d2_size		= htonl(len + 8);
+	hip->le.fc		= 0;
+	hip->le.double_wide	= 0;	/* only HIPPI 800 for the time being */
+	hip->le.message_type	= 0;	/* Data PDU */
+
+	hip->le.dest_addr_type	= 2;	/* 12 bit SC address */
+	hip->le.src_addr_type	= 2;	/* 12 bit SC address */
+
+	memcpy(hip->le.src_switch_addr, dev->dev_addr + 3, 3);
+	memset(&hip->le.reserved, 0, 16);
+
+	hip->snap.dsap		= HIPPI_EXTENDED_SAP;
+	hip->snap.ssap		= HIPPI_EXTENDED_SAP;
+	hip->snap.ctrl		= HIPPI_UI_CMD;
+	hip->snap.oui[0]	= 0x00;
+	hip->snap.oui[1]	= 0x00;
+	hip->snap.oui[2]	= 0x00;
+	hip->snap.ethertype	= htons(type);
+
+	if (daddr)
+	{
+		memcpy(hip->le.dest_switch_addr, daddr + 3, 3);
+		memcpy(&skb->private.ifield, daddr + 2, 4);
+		return HIPPI_HLEN;
+	}
+	return -HIPPI_HLEN;
+}
+
+
+/*
+ * Rebuild the HIPPI MAC header. This is called after an ARP has
+ * completed on this sk_buff. We now let ARP fill in the other fields.
+ */
+
+int hippi_rebuild_header(struct sk_buff *skb)
+{
+	struct hippi_hdr *hip = (struct hippi_hdr *)skb->data;
+
+	/*
+	 * Only IP is currently supported
+	 */
+	 
+	if(hip->snap.ethertype != __constant_htons(ETH_P_IP)) 
+	{
+		printk(KERN_DEBUG "%s: unable to resolve type %X addresses.\n",skb->dev->name,ntohs(hip->snap.ethertype));
+		return 0;
+	}
+
+	/*
+	 * We don't support dynamic ARP on HIPPI, but we use the ARP
+	 * static ARP tables to hold the I-FIELDs.
+	 */
+	return arp_find(hip->le.daddr, skb);
+}
+
+
+/*
+ *	Determine the packet's protocol ID.
+ */
+ 
+unsigned short hippi_type_trans(struct sk_buff *skb, struct net_device *dev)
+{
+	struct hippi_hdr *hip;
+	
+	hip = (struct hippi_hdr *) skb->data;
+
+	/*
+	 * This is actually wrong ... question is if we really should
+	 * set the raw address here.
+	 */
+	 skb->mac.raw = skb->data;
+	 skb_pull(skb, HIPPI_HLEN);
+
+	/*
+	 * No fancy promisc stuff here now.
+	 */
+
+	return hip->snap.ethertype;
+}
diff -ruN linux-2.4.4/net/devlink/p8023.c linux/net/devlink/p8023.c
--- linux-2.4.4/net/devlink/p8023.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/p8023.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,62 @@
+/*
+ *	NET3:	802.3 data link hooks used for IPX 802.3
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	802.3 isn't really a protocol data link layer. Some old IPX stuff
+ *	uses it however. Note that there is only one 802.3 protocol layer
+ *	in the system. We don't currently support different protocols
+ *	running raw 802.3 on different devices. Thankfully nobody else
+ *	has done anything like the old IPX.
+ */
+ 
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <linux/mm.h>
+#include <linux/in.h>
+
+/*
+ *	Place an 802.3 header on a packet. The driver will do the mac
+ *	addresses, we just need to give it the buffer length.
+ */
+ 
+static void p8023_datalink_header(struct datalink_proto *dl, 
+		struct sk_buff *skb, unsigned char *dest_node)
+{
+	struct net_device	*dev = skb->dev;
+	dev->hard_header(skb, dev, ETH_P_802_3, dest_node, NULL, skb->len);
+}
+
+/*
+ *	Create an 802.3 client. Note there can be only one 802.3 client
+ */
+ 
+struct datalink_proto *make_8023_client(void)
+{
+	struct datalink_proto	*proto;
+
+	proto = (struct datalink_proto *) kmalloc(sizeof(*proto), GFP_ATOMIC);
+	if (proto != NULL) 
+	{
+		proto->type_len = 0;
+		proto->header_length = 0;
+		proto->datalink_header = p8023_datalink_header;
+		proto->string_name = "802.3";
+	}
+	return proto;
+}
+
+/*
+ *	Destroy the 802.3 client.
+ */
+ 
+void destroy_8023_client(struct datalink_proto *dl)
+{
+	if (dl)
+		kfree(dl);
+}
+
diff -ruN linux-2.4.4/net/devlink/sysctl_net_devlink.c linux/net/devlink/sysctl_net_devlink.c
--- linux-2.4.4/net/devlink/sysctl_net_devlink.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/sysctl_net_devlink.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,59 @@
+/* -*- linux-c -*-
+ *	sysctl_net_devlink.c: sysctl interface to 802.[3,4,5] subsystem.
+ *
+ *	Begun April 1, 1996, Mike Shaver.
+ *	Added /proc/sys/net/devlink directory entry (empty =) ). [MS]
+ * 
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+#include <linux/config.h>
+
+#if defined(CONFIG_TR) || defined(CONFIG_TR_MODULE)
+#ifdef CONFIG_SYSCTL
+extern int sysctl_tr_rif_timeout;
+ctl_table tr_table[] = {
+	{NET_TR_RIF_TIMEOUT, "rif_timeout", &sysctl_tr_rif_timeout, sizeof(int),
+	 0644, NULL, &proc_dointvec},
+	{0}
+};
+
+static ctl_table tr_dir_table[] = {
+        {NET_LLC, "token-ring", NULL, 0, 0555, tr_table},
+        {0}
+};
+
+static ctl_table tr_root_table[] = {
+        {CTL_NET, "net", NULL, 0, 0555, tr_dir_table},
+        {0}
+};
+
+static struct ctl_table_header *tr_table_header;
+
+void tr_register_sysctl(void)
+{
+        tr_table_header = register_sysctl_table(tr_root_table, 1);
+}
+
+void tr_unregister_sysctl(void)
+{
+        unregister_sysctl_table(tr_table_header);
+}
+
+#else
+
+void tr_register_sysctl(void)
+{
+}
+
+void tr_unregister_sysctl(void)
+{
+}
+
+#endif /* CONFIG_SYSCTL */
+#endif /* CONFIG_TR || CONFIG_TR_MODULE */
diff -ruN linux-2.4.4/net/devlink/tr.c linux/net/devlink/tr.c
--- linux-2.4.4/net/devlink/tr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/devlink/tr.c	Mon May 14 19:29:21 2001
@@ -0,0 +1,555 @@
+/*
+ * NET3:	Token ring device handling subroutines
+ * 
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Fixes:       3 Feb 97 Paul Norton <pnorton@cts.com> Minor routing fixes.
+ *              Added rif table to /proc/net/tr_rif and rif timeout to
+ *              /proc/sys/net/token-ring/rif_timeout.
+ *              22 Jun 98 Paul Norton <p.norton@computer.org> Rearranged
+ *              tr_header and tr_type_trans to handle passing IPX SNAP and
+ *              802.2 through the correct layers. Eliminated tr_reformat.
+ *        
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/in.h>
+#include <linux/inet.h>
+#include <linux/netdevice.h>
+#include <linux/trdevice.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/net.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <net/arp.h>
+
+static void tr_source_route(struct sk_buff *skb, struct trh_hdr *trh, struct net_device *dev);
+static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev);
+static void rif_check_expire(unsigned long dummy);
+
+#define TR_SR_DEBUG 0
+
+typedef struct rif_cache_s *rif_cache;
+
+/*
+ *	Each RIF entry we learn is kept this way
+ */
+ 
+struct rif_cache_s {	
+	unsigned char addr[TR_ALEN];
+	int iface;
+	__u16 rcf;
+	__u16 rseg[8];
+	rif_cache next;
+	unsigned long last_used;
+	unsigned char local_ring;
+};
+
+#define RIF_TABLE_SIZE 32
+
+/*
+ *	We hash the RIF cache 32 ways. We do after all have to look it
+ *	up a lot.
+ */
+ 
+rif_cache rif_table[RIF_TABLE_SIZE]={ NULL, };
+
+static spinlock_t rif_lock = SPIN_LOCK_UNLOCKED;
+
+#define RIF_TIMEOUT 60*10*HZ
+#define RIF_CHECK_INTERVAL 60*HZ
+
+/*
+ *	Garbage disposal timer.
+ */
+ 
+static struct timer_list rif_timer;
+
+int sysctl_tr_rif_timeout = RIF_TIMEOUT;
+
+/*
+ *	Put the headers on a token ring packet. Token ring source routing
+ *	makes this a little more exciting than on ethernet.
+ */
+ 
+int tr_header(struct sk_buff *skb, struct net_device *dev, unsigned short type,
+              void *daddr, void *saddr, unsigned len) 
+{
+	struct trh_hdr *trh;
+	int hdr_len;
+
+	/* 
+	 * Add the 802.2 SNAP header if IP as the IPv4 code calls  
+	 * dev->hard_header directly.
+	 */
+	if (type == ETH_P_IP || type == ETH_P_ARP)
+	{
+		struct trllc *trllc=(struct trllc *)(trh+1);
+
+		hdr_len = sizeof(struct trh_hdr) + sizeof(struct trllc);
+		trh = (struct trh_hdr *)skb_push(skb, hdr_len);
+		trllc = (struct trllc *)(trh+1);
+		trllc->dsap = trllc->ssap = EXTENDED_SAP;
+		trllc->llc = UI_CMD;
+		trllc->protid[0] = trllc->protid[1] = trllc->protid[2] = 0x00;
+		trllc->ethertype = htons(type);
+	}
+	else
+	{
+		hdr_len = sizeof(struct trh_hdr);
+		trh = (struct trh_hdr *)skb_push(skb, hdr_len);	
+	}
+
+	trh->ac=AC;
+	trh->fc=LLC_FRAME;
+
+	if(saddr)
+		memcpy(trh->saddr,saddr,dev->addr_len);
+	else
+		memcpy(trh->saddr,dev->dev_addr,dev->addr_len);
+
+	/*
+	 *	Build the destination and then source route the frame
+	 */
+	 
+	if(daddr) 
+	{
+		memcpy(trh->daddr,daddr,dev->addr_len);
+		tr_source_route(skb,trh,dev);
+		return(hdr_len);
+	}
+
+	return -hdr_len;
+}
+	
+/*
+ *	A neighbour discovery of some species (eg arp) has completed. We
+ *	can now send the packet.
+ */
+ 
+int tr_rebuild_header(struct sk_buff *skb) 
+{
+	struct trh_hdr *trh=(struct trh_hdr *)skb->data;
+	struct trllc *trllc=(struct trllc *)(skb->data+sizeof(struct trh_hdr));
+	struct net_device *dev = skb->dev;
+
+	/*
+	 *	FIXME: We don't yet support IPv6 over token rings
+	 */
+	 
+	if(trllc->ethertype != htons(ETH_P_IP)) {
+		printk("tr_rebuild_header: Don't know how to resolve type %04X addresses ?\n",(unsigned int)htons(trllc->ethertype));
+		return 0;
+	}
+
+#ifdef CONFIG_INET
+	if(arp_find(trh->daddr, skb)) {
+			return 1;
+	}
+	else 
+#endif	
+	{	
+		tr_source_route(skb,trh,dev); 
+		return 0;
+	}
+}
+	
+/*
+ *	Some of this is a bit hackish. We intercept RIF information
+ *	used for source routing. We also grab IP directly and don't feed
+ *	it via SNAP.
+ */
+ 
+unsigned short tr_type_trans(struct sk_buff *skb, struct net_device *dev) 
+{
+
+	struct trh_hdr *trh=(struct trh_hdr *)skb->data;
+	struct trllc *trllc;
+	unsigned riflen=0;
+	
+	skb->mac.raw = skb->data;
+	
+       	if(trh->saddr[0] & TR_RII)
+		riflen = (ntohs(trh->rcf) & TR_RCF_LEN_MASK) >> 8;
+
+	trllc = (struct trllc *)(skb->data+sizeof(struct trh_hdr)-TR_MAXRIFLEN+riflen);
+
+	skb_pull(skb,sizeof(struct trh_hdr)-TR_MAXRIFLEN+riflen);
+
+	if(*trh->daddr & 0x80) 
+	{
+		if(!memcmp(trh->daddr,dev->broadcast,TR_ALEN)) 	
+			skb->pkt_type=PACKET_BROADCAST;
+		else
+			skb->pkt_type=PACKET_MULTICAST;
+	}
+	else if ( (trh->daddr[0] & 0x01) && (trh->daddr[1] & 0x00) && (trh->daddr[2] & 0x5E))
+	{
+		skb->pkt_type=PACKET_MULTICAST;
+	}
+	else if(dev->flags & IFF_PROMISC) 
+	{
+		if(memcmp(trh->daddr, dev->dev_addr, TR_ALEN))
+			skb->pkt_type=PACKET_OTHERHOST;
+	}
+
+	if ((skb->pkt_type != PACKET_BROADCAST) &&
+	    (skb->pkt_type != PACKET_MULTICAST))
+		tr_add_rif_info(trh,dev) ; 
+
+	/*
+	 * Strip the SNAP header from ARP packets since we don't 
+	 * pass them through to the 802.2/SNAP layers.
+	 */
+
+	if (trllc->dsap == EXTENDED_SAP &&
+	    (trllc->ethertype == ntohs(ETH_P_IP) ||
+	     trllc->ethertype == ntohs(ETH_P_ARP)))
+	{
+		skb_pull(skb, sizeof(struct trllc));
+		return trllc->ethertype;
+	}
+
+	return ntohs(ETH_P_802_2);
+}
+
+/*
+ *	We try to do source routing... 
+ */
+
+static void tr_source_route(struct sk_buff *skb,struct trh_hdr *trh,struct net_device *dev) 
+{
+	int i, slack;
+	unsigned int hash;
+	rif_cache entry;
+	unsigned char *olddata;
+	unsigned char mcast_func_addr[] = {0xC0,0x00,0x00,0x04,0x00,0x00};
+	unsigned long flags ; 
+	
+	spin_lock_irqsave(&rif_lock,flags);
+
+	/*
+	 *	Broadcasts are single route as stated in RFC 1042 
+	 */
+	if( (!memcmp(&(trh->daddr[0]),&(dev->broadcast[0]),TR_ALEN)) ||
+	    (!memcmp(&(trh->daddr[0]),&(mcast_func_addr[0]), TR_ALEN))  )
+	{
+		trh->rcf=htons((((sizeof(trh->rcf)) << 8) & TR_RCF_LEN_MASK)  
+			       | TR_RCF_FRAME2K | TR_RCF_LIMITED_BROADCAST);
+		trh->saddr[0]|=TR_RII;
+	}
+	else 
+	{
+		for(i=0,hash=0;i<TR_ALEN;hash+=trh->daddr[i++]);
+		hash&=RIF_TABLE_SIZE-1;
+		/*
+		 *	Walk the hash table and look for an entry
+		 */
+		for(entry=rif_table[hash];entry && memcmp(&(entry->addr[0]),&(trh->daddr[0]),TR_ALEN);entry=entry->next);
+
+		/*
+		 *	If we found an entry we can route the frame.
+		 */
+		if(entry) 
+		{
+#if TR_SR_DEBUG
+printk("source routing for %02X:%02X:%02X:%02X:%02X:%02X\n",trh->daddr[0],
+		  trh->daddr[1],trh->daddr[2],trh->daddr[3],trh->daddr[4],trh->daddr[5]);
+#endif
+			if(!entry->local_ring && (ntohs(entry->rcf) & TR_RCF_LEN_MASK) >> 8)
+			{
+				trh->rcf=entry->rcf;
+				memcpy(&trh->rseg[0],&entry->rseg[0],8*sizeof(unsigned short));
+				trh->rcf^=htons(TR_RCF_DIR_BIT);	
+				trh->rcf&=htons(0x1fff);	/* Issam Chehab <ichehab@madge1.demon.co.uk> */
+
+				trh->saddr[0]|=TR_RII;
+#if TR_SR_DEBUG
+				printk("entry found with rcf %04x\n", entry->rcf);
+			}
+			else
+			{
+				printk("entry found but without rcf length, local=%02x\n", entry->local_ring);
+#endif
+			}
+			entry->last_used=jiffies;
+		}
+		else 
+		{
+			/*
+			 *	Without the information we simply have to shout
+			 *	on the wire. The replies should rapidly clean this
+			 *	situation up.
+			 */
+			trh->rcf=htons((((sizeof(trh->rcf)) << 8) & TR_RCF_LEN_MASK)  
+				       | TR_RCF_FRAME2K | TR_RCF_LIMITED_BROADCAST);
+			trh->saddr[0]|=TR_RII;
+#if TR_SR_DEBUG
+			printk("no entry in rif table found - broadcasting frame\n");
+#endif
+		}
+	}
+
+	/* Compress the RIF here so we don't have to do it in the driver(s) */
+	if (!(trh->saddr[0] & 0x80))
+		slack = 18;
+	else 
+		slack = 18 - ((ntohs(trh->rcf) & TR_RCF_LEN_MASK)>>8);
+	olddata = skb->data;
+	spin_unlock_irqrestore(&rif_lock,flags);
+
+	skb_pull(skb, slack);
+	memmove(skb->data, olddata, sizeof(struct trh_hdr) - slack);
+}
+
+/*
+ *	We have learned some new RIF information for our source
+ *	routing.
+ */
+ 
+static void tr_add_rif_info(struct trh_hdr *trh, struct net_device *dev)
+{
+	int i;
+	unsigned int hash, rii_p = 0;
+	rif_cache entry;
+
+
+	spin_lock_bh(&rif_lock);
+	
+	/*
+	 *	Firstly see if the entry exists
+	 */
+
+       	if(trh->saddr[0] & TR_RII)
+	{
+		trh->saddr[0]&=0x7f;
+		if (((ntohs(trh->rcf) & TR_RCF_LEN_MASK) >> 8) > 2)
+		{
+			rii_p = 1;
+	        }
+	}
+
+	for(i=0,hash=0;i<TR_ALEN;hash+=trh->saddr[i++]);
+	hash&=RIF_TABLE_SIZE-1;
+	for(entry=rif_table[hash];entry && memcmp(&(entry->addr[0]),&(trh->saddr[0]),TR_ALEN);entry=entry->next);
+
+	if(entry==NULL) 
+	{
+#if TR_SR_DEBUG
+printk("adding rif_entry: addr:%02X:%02X:%02X:%02X:%02X:%02X rcf:%04X\n",
+		trh->saddr[0],trh->saddr[1],trh->saddr[2],
+       		trh->saddr[3],trh->saddr[4],trh->saddr[5],
+		ntohs(trh->rcf));
+#endif
+		/*
+		 *	Allocate our new entry. A failure to allocate loses
+		 *	use the information. This is harmless.
+		 *
+		 *	FIXME: We ought to keep some kind of cache size
+		 *	limiting and adjust the timers to suit.
+		 */
+		entry=kmalloc(sizeof(struct rif_cache_s),GFP_ATOMIC);
+
+		if(!entry) 
+		{
+			printk(KERN_DEBUG "tr.c: Couldn't malloc rif cache entry !\n");
+			spin_unlock_bh(&rif_lock);
+			return;
+		}
+
+		memcpy(&(entry->addr[0]),&(trh->saddr[0]),TR_ALEN);
+		entry->iface = dev->ifindex;
+		entry->next=rif_table[hash];
+		entry->last_used=jiffies;
+		rif_table[hash]=entry;
+
+		if (rii_p)
+		{
+			entry->rcf = trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK);
+			memcpy(&(entry->rseg[0]),&(trh->rseg[0]),8*sizeof(unsigned short));
+			entry->local_ring = 0;
+			trh->saddr[0]|=TR_RII; /* put the routing indicator back for tcpdump */
+		}
+		else
+		{
+			entry->local_ring = 1;
+		}
+	} 	
+	else	/* Y. Tahara added */
+	{ 
+		/*
+		 *	Update existing entries
+		 */
+		if (!entry->local_ring) 
+		    if (entry->rcf != (trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK)) &&
+			 !(trh->rcf & htons(TR_RCF_BROADCAST_MASK)))
+		    {
+#if TR_SR_DEBUG
+printk("updating rif_entry: addr:%02X:%02X:%02X:%02X:%02X:%02X rcf:%04X\n",
+		trh->saddr[0],trh->saddr[1],trh->saddr[2],
+		trh->saddr[3],trh->saddr[4],trh->saddr[5],
+		ntohs(trh->rcf));
+#endif
+			    entry->rcf = trh->rcf & htons((unsigned short)~TR_RCF_BROADCAST_MASK);
+        		    memcpy(&(entry->rseg[0]),&(trh->rseg[0]),8*sizeof(unsigned short));
+		    }                                         
+           	entry->last_used=jiffies;               
+	}
+	spin_unlock_bh(&rif_lock);
+}
+
+/*
+ *	Scan the cache with a timer and see what we need to throw out.
+ */
+
+static void rif_check_expire(unsigned long dummy) 
+{
+	int i;
+	unsigned long now=jiffies;
+	unsigned long flags ; 
+
+	spin_lock_irqsave(&rif_lock,flags);
+	
+	for(i=0; i < RIF_TABLE_SIZE;i++) 
+	{
+		rif_cache entry, *pentry=rif_table+i;	
+		while((entry=*pentry)) 
+		{
+			/*
+			 *	Out it goes
+			 */
+			if((now-entry->last_used) > sysctl_tr_rif_timeout) 
+			{
+				*pentry=entry->next;
+				kfree(entry);
+			}
+			else
+				pentry=&entry->next;
+		}
+	}
+	
+	spin_unlock_irqrestore(&rif_lock,flags);
+
+	/*
+	 *	Reset the timer
+	 */
+	 
+	mod_timer(&rif_timer, jiffies+sysctl_tr_rif_timeout);
+
+}
+
+/*
+ *	Generate the /proc/net information for the token ring RIF
+ *	routing.
+ */
+ 
+#ifndef CONFIG_PROC_FS
+static int rif_get_info(char *buffer,char **start, off_t offset, int length)  { return 0;}
+#else
+static int rif_get_info(char *buffer,char **start, off_t offset, int length) 
+{
+	int len=0;
+	off_t begin=0;
+	off_t pos=0;
+	int size,i,j,rcf_len,segment,brdgnmb;
+	unsigned long now=jiffies;
+
+	rif_cache entry;
+
+	size=sprintf(buffer,
+		     "if     TR address       TTL   rcf   routing segments\n");
+	pos+=size;
+	len+=size;
+
+	spin_lock_bh(&rif_lock);
+	for(i=0;i < RIF_TABLE_SIZE;i++) 
+	{
+		for(entry=rif_table[i];entry;entry=entry->next) {
+			struct net_device *dev = __dev_get_by_index(entry->iface);
+
+			size=sprintf(buffer+len,"%s %02X:%02X:%02X:%02X:%02X:%02X %7li ",
+				     dev?dev->name:"?",entry->addr[0],entry->addr[1],entry->addr[2],entry->addr[3],entry->addr[4],entry->addr[5],
+				     sysctl_tr_rif_timeout-(now-entry->last_used));
+			len+=size;
+			pos=begin+len;
+			if (entry->local_ring)
+			        size=sprintf(buffer+len,"local\n");
+			else {
+			        size=sprintf(buffer+len,"%04X", ntohs(entry->rcf));
+				rcf_len = ((ntohs(entry->rcf) & TR_RCF_LEN_MASK)>>8)-2; 
+				if (rcf_len)
+				        rcf_len >>= 1;
+				for(j = 1; j < rcf_len; j++) {
+					if(j==1) {
+						segment=ntohs(entry->rseg[j-1])>>4;
+						len+=size;
+						pos=begin+len;
+						size=sprintf(buffer+len,"  %03X",segment);
+					};
+					segment=ntohs(entry->rseg[j])>>4;
+					brdgnmb=ntohs(entry->rseg[j-1])&0x00f;
+					len+=size;
+					pos=begin+len;
+					size=sprintf(buffer+len,"-%01X-%03X",brdgnmb,segment);
+				}
+				len+=size;
+				pos=begin+len;
+			        size=sprintf(buffer+len,"\n");
+			}
+			len+=size;
+			pos=begin+len;
+
+			if(pos<offset) 
+			{
+				len=0;
+				begin=pos;
+			}
+			if(pos>offset+length)
+				break;
+	   	}
+		if(pos>offset+length)
+			break;
+	}
+	spin_unlock_bh(&rif_lock);
+
+	*start=buffer+(offset-begin); /* Start of wanted data */
+	len-=(offset-begin);    /* Start slop */
+	if(len>length)
+		len=length;    /* Ending slop */
+	if (len<0)
+		len=0;
+	return len;
+}
+#endif
+
+/*
+ *	Called during bootup.  We don't actually have to initialise
+ *	too much for this.
+ */
+
+static int __init rif_init(void)
+{
+	rif_timer.expires  = RIF_TIMEOUT;
+	rif_timer.data     = 0L;
+	rif_timer.function = rif_check_expire;
+	init_timer(&rif_timer);
+	add_timer(&rif_timer);
+
+	proc_net_create("tr_rif",0,rif_get_info);
+	return 0;
+}
+
+module_init(rif_init);
diff -ruN linux-2.4.4/net/ipx/af_ipx.c linux/net/ipx/af_ipx.c
--- linux-2.4.4/net/ipx/af_ipx.c	Thu Apr 12 12:11:39 2001
+++ linux/net/ipx/af_ipx.c	Mon May 14 20:02:32 2001
@@ -109,7 +109,8 @@
 #include <linux/mm.h>
 #include <linux/termios.h>	/* For TIOCOUTQ/INQ */
 #include <linux/interrupt.h>
-#include <net/p8022.h>
+#include <net/llc.h>
+#include <linux/llc.h>
 #include <net/psnap.h>
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
@@ -2579,7 +2580,7 @@
 	p8023_datalink = make_8023_client();
 	dev_add_pack(&ipx_8023_packet_type);
 
-	p8022_datalink = register_8022_client(ipx_8022_type,ipx_rcv);
+	p8022_datalink = register_8022_client(ipx_8022_type,ipx_rcv, NULL);
 	if (!p8022_datalink)
 		printk(KERN_CRIT "IPX: Unable to register with 802.2\n");
 
diff -ruN linux-2.4.4/net/llc/Makefile linux/net/llc/Makefile
--- linux-2.4.4/net/llc/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/net/llc/Makefile	Mon May 14 19:29:43 2001
@@ -0,0 +1,22 @@
+#
+# Makefile for the Linux 802.x protocol layers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := llc.o
+export-objs := dl_llc.o
+
+obj-y := dl_llc.o
+obj-m := $(O_TARGET)
+
+obj-$(CONFIG_LLC_UI) += af_llc.o
+obj-$(CONFIG_SYSCTL) += sysctl_net_llc.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+		tar -cvf /dev/f1 .
diff -ruN linux-2.4.4/net/llc/af_llc.c linux/net/llc/af_llc.c
--- linux-2.4.4/net/llc/af_llc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/llc/af_llc.c	Mon May 14 21:30:03 2001
@@ -0,0 +1,960 @@
+/* IEEE 802.2 LLC Class 1 and Class 2 user-space LLC interface.
+ * - Supports SOCK_DGRAM, and SOCK_STREAM.
+ *
+ * Author:
+ * Jay Schulist <jschlst@samba.org>
+ *
+ * Sources:
+ * - ANSI/IEEE Std 802.2-1989.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#if defined(CONFIG_LLC_UI) || defined(CONFIG_LLC_UI_MODULE)
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#include <linux/uio.h>
+#include <linux/unistd.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+
+#include <net/llc.h>
+#include <linux/llc.h>
+
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+
+#include <linux/ctype.h>        /* For hexdump() */
+
+#ifndef LLC_UI_DEBUG
+#define LLC_UI_DEBUG 0 
+#endif
+static unsigned int llc_ui_debug = LLC_UI_DEBUG;
+
+static struct sock *llc_ui_socket_list = NULL;
+static struct proto_ops llc_ui_ops;
+
+int llc_ui_rcv_msg(int rsp, struct sk_buff *skb);
+int llc_ui_rcv(struct sk_buff *skb, struct net_device *dev,
+        struct packet_type *pt);
+static int llc_ui_disconnect(struct sock *sk);
+static int llc_ui_shutdown(struct socket *sock, int how);
+
+static int llc_ui_sock_init(struct sock *sk)
+{
+        return (0);
+}
+
+static int llc_ui_create(struct socket *sock, int protocol)
+{
+        struct sock *sk;
+
+	if(llc_ui_debug > 5)
+        	printk("llc_ui_create\n");
+
+        sk = sk_alloc(PF_LLC, GFP_KERNEL, 1);
+        if(sk == NULL)
+                return (-ENOMEM);
+
+        switch(sock->type)
+        {
+                case (SOCK_STREAM):
+                case (SOCK_DGRAM):
+                        sock->ops = &llc_ui_ops;
+                        break;
+
+                default:
+                        sk_free(sk);
+                        return (-ESOCKTNOSUPPORT);
+        }
+
+        sock_init_data(sock, sk);
+        llc_ui_sock_init(sk);
+        sk->destruct    = NULL;
+        sk->zapped      = 1;
+        sk->no_check    = 1;
+        sk->sap         = 0;
+        sk->llc_proto   = NULL;
+
+#ifdef MODULE
+        MOD_INC_USE_COUNT;
+#endif
+
+        return (0);
+}
+
+static int llc_ui_destroy_socket(struct sock *sk)
+{
+	if(llc_ui_debug > 5)
+        	printk("llc_ui_destroy_socket %p\n", sk);
+
+        if(sk->llc_proto != NULL)
+        {
+                struct datalink_proto *dl = sk->llc_proto;
+                struct llc_pinfo *llc = dl->ll_pinfo.llc;
+
+		llc_ui_disconnect(sk);
+                unregister_8022_client(llc->ssap);
+        }
+
+        sklist_destroy_socket(&llc_ui_socket_list, sk);
+
+#ifdef MODULE
+        MOD_DEC_USE_COUNT;
+#endif
+
+        return (0);
+}
+
+inline void llc_ui_insert_socket(struct sock *sk)
+{
+	if(llc_ui_debug > 5)
+		printk("llc_ui_insert_socket\n");
+
+        sklist_insert_socket(&llc_ui_socket_list, sk);
+
+        return;
+}
+
+static int llc_ui_release(struct socket *sock)
+{
+        struct sock *sk = sock->sk;
+
+	if(llc_ui_debug > 5)
+		printk("llc_ui_release %p\n", sk);
+
+        if(sk == NULL)
+                return (0);
+
+        if(!sk->dead)
+                sk->state_change(sk);
+
+        sk->dead = 1;
+        sock->sk = NULL;
+        llc_ui_destroy_socket(sk);
+
+        return (0);
+}
+
+static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr,int addr_len)
+{
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+        struct datalink_proto *dl;
+        struct sock *sk;
+
+        sk = sock->sk;
+        if(sk->zapped == 0)
+                return (-EINVAL);
+        if(addr_len != sizeof(struct sockaddr_llc))
+                return (-EINVAL);
+        if(addr->sllc_family != AF_LLC)
+                return (-EAFNOSUPPORT);
+
+        dl = register_8022_client(addr->sllc_ssap, llc_ui_rcv, llc_ui_rcv_msg);
+	if(dl == NULL)
+		return (-EAGAIN);
+	sk->sap 	= addr->sllc_ssap;
+        sk->llc_proto 	= dl;
+        dl->sock 	= sk;
+
+        llc_ui_insert_socket(sk);
+        sk->zapped = 0;
+
+        return (0);
+}
+
+/* Establish a connection to a host on the network. */
+static int llc_ui_connect(struct socket *sock, struct sockaddr *uaddr,
+        int addr_len, int flags)
+{
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr;
+        struct sock *sk = sock->sk;
+        struct datalink_proto *dl = sk->llc_proto;
+        struct sk_buff *skb;
+        struct net_device *dev;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_connect %p\n", sk);
+
+        if(addr_len != sizeof(*addr))
+                return (-EINVAL);
+        if(addr->sllc_family != AF_LLC)
+                return (-EAFNOSUPPORT);
+
+        sock->state     = SS_CONNECTING;
+        sk->state       = TCP_SYN_SENT;
+	llc_ui_insert_socket(sk);
+
+        rtnl_lock();
+        dev = dev_getbyhwaddr(ARPHRD_ETHER, addr->sllc_smac);
+        rtnl_unlock();
+        if(dev == NULL)
+                return (-ENETUNREACH);
+
+	llc_connect(dl, dev, addr->sllc_dmac, addr->sllc_dsap, 0);
+
+        cli();
+        do {
+                skb = skb_dequeue(&sk->receive_queue);
+                if(skb == NULL)
+                {
+                        if(flags & O_NONBLOCK)
+                        {
+                                sti();
+                                return (-EWOULDBLOCK);
+                        }
+                        interruptible_sleep_on(sk->sleep);
+                        if(signal_pending(current))
+                        {
+                                sti();
+                                return (-ERESTARTSYS);
+                        }
+                }
+        } while (skb == NULL);
+
+        sock->state     = SS_CONNECTED;
+        sk->state       = TCP_ESTABLISHED;
+        kfree_skb(skb);
+        sti();
+
+        return (0);
+}
+
+static int llc_ui_listen(struct socket *sock, int backlog)
+{
+        struct sock *sk = sock->sk;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_listen\n");
+
+        if(sock->state != SS_UNCONNECTED)
+                return (-EINVAL);
+        if(sk->type != SOCK_STREAM && sk->type != SOCK_SEQPACKET)
+                return (-EOPNOTSUPP);
+        if(sk->zapped != 0)
+                return (-EAGAIN);
+
+        if((unsigned) backlog == 0)     /* BSDism */
+                backlog = 1;
+        if((unsigned) backlog > SOMAXCONN)
+                backlog = SOMAXCONN;
+        sk->max_ack_backlog = backlog;
+        if(sk->state != TCP_LISTEN)
+        {
+                sk->ack_backlog = 0;
+                sk->state = TCP_LISTEN;
+        }
+        sk->socket->flags |= __SO_ACCEPTCON;
+
+        return (0);
+}
+
+/* Allow a client to accept a connect. */
+static int llc_ui_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+        struct sock *sk, *newsk;
+        struct sk_buff *skb;
+	struct datalink_proto *dl;
+	struct llc_pinfo *llc;
+        llchdr *llc_hdr;
+        struct ethhdr *eth_hdr;
+        int err;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_accept %p\n", sock->sk);
+
+        if(sock->sk == NULL)
+                return (-EINVAL);
+        sk = sock->sk;
+
+        err = llc_ui_create(newsock, sk->protocol);
+        if(err)
+                return (err);
+        if((sock->state != SS_UNCONNECTED) || !(sock->flags & __SO_ACCEPTCON))
+                return (-EINVAL);
+        if(sk->type != SOCK_SEQPACKET && sk->type != SOCK_STREAM)
+                return (-EOPNOTSUPP);
+        if(sk->state != TCP_LISTEN)
+                return (-EINVAL);
+
+        cli();
+        do {
+                skb = skb_dequeue(&sk->receive_queue);
+                if(skb == NULL)
+                {
+                        if(flags & O_NONBLOCK)
+                        {
+                                sti();
+                                return (-EWOULDBLOCK);
+                        }
+                        interruptible_sleep_on(sk->sleep);
+                        if(signal_pending(current))
+                        {
+                                sti();
+                                return (-ERESTARTSYS);
+                        }
+                }
+        } while (skb == NULL);
+	sti();
+
+	/* Now attach up the new socket.
+	 *
+	 * XXX: A bit hackish here yet,
+	 * LLC can only have one listener per SAP and we don't want
+	 * to truely queue connections as Unix sockets would like us
+	 * to. Instead we create a new socket with all valid data for the
+	 * new connection and set the old socket as blank and it has no
+	 * more revalance to us in the LLC layer. It is simply tossed when
+	 * the socket is disconnected. 
+	 */
+        newsk           = newsock->sk;
+	newsock->sk     = newsk;
+	llc_ui_insert_socket(newsk);
+        newsk->pair     = NULL;
+        newsk->sap      = sk->sap;
+        newsk->llc_proto= sk->llc_proto;
+	newsk->socket	= sock;		/* Link Parent sock to new sock. */
+	sk->sap		= 0;
+        sk->llc_proto   = NULL;
+	sk->socket	= sock;		/* Ensure parent is linked to itself */
+        newsk->state    = TCP_ESTABLISHED;
+        newsock->state  = SS_CONNECTED;
+        sk->ack_backlog--;
+
+	/* Ack the Connect with a UA RSP. */
+	dl      = newsk->llc_proto;
+	dl->sock= newsk;
+        llc     = dl->ll_pinfo.llc;
+	eth_hdr = (struct ethhdr *)skb->mac.raw;
+        llc_hdr = (llchdr *)skb->h.raw;
+        llc->dsap = llc_hdr->ssap;
+	memcpy(llc->dmac, eth_hdr->h_source, 6);
+
+	/* Ack the connect. */
+	llc_connect(dl, skb->dev, eth_hdr->h_source, llc_hdr->ssap, 1);
+	skb->sk = NULL;
+        kfree_skb(skb);
+
+        return (0);
+}
+
+static struct sock *llc_ui_find_socket(int type)
+{
+	struct sock *s;
+
+        for(s = llc_ui_socket_list; s != NULL; s = s->next)
+        {
+		if(s->sap == type)
+			break;
+	}
+
+	return (s);
+}
+
+int llc_ui_rcv_msg(int rsp, struct sk_buff *skb)
+{
+        llchdr *llc_hdr;
+	struct sock *sk;
+        struct datalink_proto *dl;
+        struct llc_pinfo *llc;
+
+	if(llc_ui_debug > 5)
+        	printk("llc_ui_rcv_msg\n");
+
+	llc_hdr = (llchdr *)skb->h.raw;
+        sk = llc_ui_find_socket(llc_hdr->dsap);
+        if(sk == NULL)
+        {
+		skb->sk = NULL;
+                kfree_skb(skb);
+                return (0);
+        }
+
+	dl = sk->llc_proto;
+        llc = dl->ll_pinfo.llc;
+	skb->sk = sk;
+
+        switch(rsp)
+        {
+		case (LLC_STATE_REMOTE_RESET_INDICATION):
+			llc_reset(dl, skb->dev, llc->dmac, llc->dsap, 1);
+			break;
+
+                /* Set Asynchronous Balanced Mode Extended command. */
+                case (LLC_STATE_RECEIVE_SABME_CMD):
+                        skb_queue_tail(&sk->receive_queue, skb);
+                        wake_up_interruptible(dl->sock->sleep);
+                        break;
+
+		/* Tear down this socket and toss it, move LLC/SAP data back
+		 * to original socket so that we can accept another connection
+		 * on it. Better ways to do this are always accepted. JJS.
+		 */
+		case (LLC_STATE_RECEIVE_DISC_CMD):
+		{
+			struct socket *oldsock = sk->socket;
+			struct sock *oldsk = oldsock->sk;
+			oldsk->sap      = sk->sap;
+        		oldsk->llc_proto= sk->llc_proto;
+			sk->sap = 0;
+			sk->llc_proto = NULL;
+			dl = oldsk->llc_proto;
+        		dl->sock = oldsk;
+
+			/* Kill closed socket */
+			sk->shutdown = RCV_SHUTDOWN;
+			if(!sk->dead)
+                		sk->state_change(sk);
+        		sk->dead = 1;
+			/* Wake up any sleepers on this socket. */
+			wake_up_interruptible(sk->sleep);
+
+			skb->sk = NULL;
+			kfree_skb(skb);
+			break;
+		}
+
+                case (LLC_STATE_RECEIVE_UA_RSP):
+                        skb_queue_tail(&sk->receive_queue, skb);
+                        wake_up_interruptible(dl->sock->sleep);
+                        break;
+
+		/* Events this layer doesn't care about, get toss'd */
+		default:
+			skb->sk = NULL;
+                	kfree_skb(skb);
+                	return (-1);
+        }
+
+        return (0);
+}
+
+int llc_ui_rcv(struct sk_buff *skb, struct net_device *dev,
+        struct packet_type *pt)
+{
+        llchdr *llc_hdr = (llchdr *)skb->h.raw;
+	struct sock *sk;
+
+	if(llc_ui_debug > 5)
+		printk("llc_ui_rcv\n");
+
+        if(skb->len < sizeof(llchdr))
+        {
+                kfree_skb(skb);
+                return (0);
+        }
+
+	sk = llc_ui_find_socket(llc_hdr->dsap);
+        if(sk == NULL)
+        {
+                kfree_skb(skb);
+                return (0);
+        }
+
+        skb->sk = sk;
+	skb->dev = dev;
+	skb_queue_tail(&sk->receive_queue, skb);
+        wake_up_interruptible(sk->sleep);
+
+	return (0);
+}
+
+static int llc_ui_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+        int flags, struct scm_cookie *scm)
+{
+        struct sock *sk = sock->sk;
+	struct sockaddr_llc *uaddr = (struct sockaddr_llc *)msg->msg_name;
+	llchdr *llc_hdr;
+        struct sk_buff *skb;
+        int copied = 0, err = 0, pdu_type;
+	__u8 offset;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_recvmsg %p\n", sk);
+
+	skb = skb_recv_datagram(sk, (flags & ~MSG_DONTWAIT),
+                                (flags & MSG_DONTWAIT), &err);
+        if (skb == NULL)
+                return err;
+
+	llc_hdr = (llchdr *)skb->h.raw;
+        pdu_type = llc_decode_pdu(llc_hdr);
+        if(pdu_type == LLC_TEST_RSP || pdu_type == LLC_UI_CMD)
+	{
+		offset = LLC_TYPE1_SIZE;
+                copied = skb->len - LLC_TYPE1_SIZE;
+	}
+        else
+	{
+		offset = LLC_TYPE2_SIZE;
+                copied = skb->len - LLC_TYPE2_SIZE;
+	}
+
+        if(copied > size)
+        {
+                copied = size;
+                msg->msg_flags |= MSG_TRUNC;
+        }
+
+	err = skb_copy_datagram_iovec(skb, offset, 
+		msg->msg_iov, copied);
+
+	if(!err)
+	{
+		if(uaddr)
+		{
+			uaddr->sllc_family      = AF_LLC;
+                	uaddr->sllc_dsap        = llc_hdr->dsap;
+                	uaddr->sllc_ssap        = llc_hdr->ssap;
+		}
+		msg->msg_namelen = sizeof(*uaddr);
+	}
+
+	skb_free_datagram(sk, skb);     /* Free the datagram. */
+
+        return err ? err : copied;
+}
+
+/* Grab data from the user and toss it onto the wire. */
+static int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, int len,
+        struct scm_cookie *scm)
+{
+        struct sockaddr_llc *addr = (struct sockaddr_llc *)msg->msg_name;
+        int flags = msg->msg_flags;
+        struct sock *sk = sock->sk;
+	struct datalink_proto *dl = sk->llc_proto;
+        struct net_device *dev;
+        struct sk_buff *skb;
+        int err, size;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_sendmsg: processing data.\n");
+
+        if(flags & ~MSG_DONTWAIT)
+                return (-EINVAL);
+        if(!addr)
+                return (-EINVAL);
+        if(!msg->msg_namelen)
+                return (-EINVAL);
+        if(msg->msg_namelen < sizeof(struct sockaddr_llc))
+                return (-EINVAL);
+        if(addr->sllc_family != AF_LLC)
+                return (-EINVAL);
+
+        rtnl_lock();
+        dev = dev_getbyhwaddr(ARPHRD_ETHER, addr->sllc_smac);
+        rtnl_unlock();
+        if(dev == NULL)
+                return (-ENETUNREACH);
+
+	if(!addr->sllc_test && sk->type == SOCK_STREAM)
+        	size = dl->header_length + 1;
+	else
+		size = dl->header_length;
+        size += dev->hard_header_len + len;
+
+        skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &err);
+        if(skb == NULL)
+                return (err);
+
+	if(addr->sllc_test)
+	{
+		skb->llc_cmd = LLC_STATE_TEST_REQUEST;
+		skb_reserve(skb, dl->header_length);
+	}
+	else
+	{
+		if(sk->type == SOCK_STREAM)
+		{
+			skb->llc_cmd = LLC_STATE_DATA_REQUEST;
+			skb_reserve(skb, dl->header_length + 1);
+		}
+		else
+		{
+			skb->llc_cmd = LLC_STATE_UNITDATA_REQUEST;
+			skb_reserve(skb, dl->header_length);
+		}
+	}
+
+	skb->sk  = sk;
+        skb->dev = dev;
+	skb_reserve(skb, dev->hard_header_len);
+        err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	dl->datalink_header(dl, skb, &addr->sllc_dsap);
+        dev->hard_header(skb, dev, ETH_P_802_3, addr->sllc_dmac, NULL,skb->len);
+        if(err)
+        {
+                kfree_skb(skb);
+                return (-EFAULT);
+        }
+
+        llc_queue_xmit(skb);
+
+        return (len);
+}
+
+static int llc_ui_shutdown(struct socket *sock, int how)
+{
+	struct sock *sk = sock->sk;
+
+	return (llc_ui_disconnect(sk));
+}
+
+static int llc_ui_disconnect(struct sock *sk)
+{
+        struct datalink_proto *dl = sk->llc_proto;
+        struct llc_pinfo *llc = dl->ll_pinfo.llc;
+	struct net_device *dev;
+	struct sk_buff *skb;
+
+	if(llc_ui_debug > 5)
+		printk("llc_ui_disconnect %p\n", sk);
+
+	rtnl_lock();
+        dev = dev_getbyhwaddr(ARPHRD_ETHER, llc->dmac);
+        rtnl_unlock();
+        if(dev == NULL)
+               	return (-ENETUNREACH);
+
+	llc_disconnect(dl, dev, llc->dmac, llc->dsap, 0);
+        cli();
+        do {
+               	skb = skb_dequeue(&sk->receive_queue);
+                if(skb == NULL)
+                {
+                       	interruptible_sleep_on(sk->sleep);
+                        if(signal_pending(current))
+                        {
+                              	sti();
+                                return (-ERESTARTSYS);
+                        }
+		}
+	} while (skb == NULL);
+
+        /* Received disconnect indication, socket shutdown. */
+        skb->sk = NULL;
+        kfree_skb(skb);
+        return (0);
+}
+
+static int llc_ui_ioctl(struct socket *sock, unsigned int cmd,unsigned long arg)
+{
+        struct sock *sk = sock->sk;
+        struct datalink_proto *dl = sk->llc_proto;
+        struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        int val;
+
+	if(dl == NULL)
+		return (-EINVAL);
+
+        if(copy_from_user(&val, &arg, sizeof(int)))
+                return (-EFAULT);
+
+        switch(cmd)
+        {
+                case (LLC_IOCTL_RETRY):
+                        if(val > LLC_MAX_RETRY)
+                                return (-EINVAL);
+                        llc->max_retry = val;
+                        break;
+
+                case (LLC_IOCTL_SIZE):
+                        if(val > LLC_MAX_SIZE)
+                                return (-EINVAL);
+                        llc->max_size = val;
+                        break;
+
+                case (LLC_IOCTL_WINDOW):
+                        if(val > LLC_MAX_WINDOW)
+                                return (-EINVAL);
+                        llc->max_window = val;
+                        break;
+
+                case (LLC_IOCTL_ACK_TIMER_EXPIRE):
+                        if(val > LLC_MAX_ACK_TIMER_EXPIRE)
+                                return (-EINVAL);
+                        llc->ack_expire = val;
+                        break;
+
+                case (LLC_IOCTL_P_TIMER_EXPIRE):
+                        if(val > LLC_MAX_P_TIMER_EXPIRE)
+                                return (-EINVAL);
+                        llc->p_expire = val;
+                        break;
+
+                case (LLC_IOCTL_REJ_TIMER_EXPIRE):
+                        if(val > LLC_MAX_REJ_TIMER_EXPIRE)
+                                return (-EINVAL);
+                        llc->rej_expire = val;
+                        break;
+
+                case (LLC_IOCTL_BUSY_TIMER_EXPIRE):
+                        if(val > LLC_MAX_BUSY_TIMER_EXPIRE)
+                                return (-EINVAL);
+                        llc->busy_expire = val;
+                        break;
+
+                default:
+                        return (-EOPNOTSUPP);
+        }
+
+        return (0);
+}
+
+static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
+        int *uaddr_len, int peer)
+{
+	struct sockaddr_llc from;
+	struct sock *sk = sock->sk;
+	struct llc_pinfo *llc = sk->llc_proto->ll_pinfo.llc;
+
+	if(llc_ui_debug > 5)
+		printk("llc_ui_getname\n");
+
+        *uaddr_len = sizeof(struct sockaddr_llc);
+	from.sllc_family 	= AF_LLC;
+	from.sllc_ssap 		= llc->ssap;
+	from.sllc_dsap		= llc->dsap;
+	memcpy(from.sllc_dmac, llc->dmac, 14);
+        memcpy(uaddr, &from, sizeof(from));
+
+        return (0);
+}
+
+static int llc_ui_setsockopt(struct socket *sock, int level, int optname, 
+	char *optval, int optlen)
+{
+        struct datalink_proto *dl;
+        struct sock *sk;
+        int err, opt;
+
+        sk = sock->sk;
+
+        if(optlen != sizeof(int))
+                return (-EINVAL);
+
+        err = get_user(opt, (unsigned int *)optval);
+        if(err)
+                return (err);
+
+        dl = sk->llc_proto;
+        if(dl == NULL && optname != LLC_REG_SAP_CLIENT)
+                return (-EAGAIN);
+
+        switch(level)
+        {
+                case (SOL_LLC):
+                        switch(optname)
+                        {
+                                /* Register a LLC UI SAP client with LLC. */
+                                case (LLC_REG_SAP_CLIENT):
+                                        sk->sap = opt;
+                                        dl = register_8022_client(sk->sap,
+                                                llc_ui_rcv, llc_ui_rcv_msg);
+					if(dl == NULL)
+						return (-EAGAIN);
+                                        sk->llc_proto = dl;
+                                        dl->sock = sk;
+                                        break;
+
+                                case (LLC_QUE_MSG):
+                                        break;
+
+                                case (LLC_IOCTL_RETRY):
+                                        if(opt > LLC_MAX_RETRY)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->max_retry = opt;
+                                        break;
+
+                                case (LLC_IOCTL_SIZE):
+                                        if(opt > LLC_MAX_SIZE)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->max_size = opt;
+                                        break;
+
+                                case (LLC_IOCTL_WINDOW):
+                                        if(opt > LLC_MAX_WINDOW)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->max_window = opt;
+                                        break;
+
+                                case (LLC_IOCTL_ACK_TIMER_EXPIRE):
+                                        if(opt > LLC_MAX_ACK_TIMER_EXPIRE)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->ack_expire = opt;
+                                        break;
+
+                                case (LLC_IOCTL_P_TIMER_EXPIRE):
+                                        if(opt > LLC_MAX_P_TIMER_EXPIRE)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->p_expire = opt;
+                                        break;
+
+                                case (LLC_IOCTL_REJ_TIMER_EXPIRE):
+                                        if(opt > LLC_MAX_REJ_TIMER_EXPIRE)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->rej_expire = opt;
+                                        break;
+
+                                case (LLC_IOCTL_BUSY_TIMER_EXPIRE):
+                                        if(opt > LLC_MAX_BUSY_TIMER_EXPIRE)
+                                                return (-EINVAL);
+                                        dl->ll_pinfo.llc->busy_expire = opt;
+                                        break;
+
+                                default:
+                                        return (-ENOPROTOOPT);
+                        }
+                        break;
+
+                default:
+                        return (-ENOPROTOOPT);
+        }
+
+        return (0);
+}
+
+static int llc_ui_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+        struct sock *sk;
+        struct datalink_proto *dl;
+        struct llc_pinfo *llc;
+        int val = 0;
+        int len;
+
+        if(llc_ui_debug > 3)
+                printk("llc_ui_getsockopt\n");
+
+        sk = sock->sk;
+        if(sk->llc_proto == NULL)
+        {
+                printk("Need to register sap first\n");
+                return (-1);
+        }
+
+        dl = sk->llc_proto;
+        llc = dl->ll_pinfo.llc;
+
+        if(llc == NULL)
+                return (-EINVAL);
+
+        switch(level)
+        {
+                case (SOL_LLC):
+                        switch(optname)
+                        {
+                                case (LLC_IOCTL_SSAP):
+                                        val = llc->ssap;
+                                        break;
+
+                                case (LLC_IOCTL_RETRY):
+                                        val = llc->max_retry;
+                                        break;
+
+                                case (LLC_IOCTL_SIZE):
+                                        val = llc->max_size;
+                                        break;
+
+                                case (LLC_IOCTL_WINDOW):
+                                        val = llc->max_window;
+                                        break;
+
+                                case (LLC_IOCTL_ACK_TIMER_EXPIRE):
+                                        val = llc->ack_expire;
+                                        break;
+
+                                case (LLC_IOCTL_P_TIMER_EXPIRE):
+                                        val = llc->p_expire;
+                                        break;
+
+                                case (LLC_IOCTL_REJ_TIMER_EXPIRE):
+                                        val = llc->rej_expire;
+                                        break;
+
+                                case (LLC_IOCTL_BUSY_TIMER_EXPIRE):
+                                        val = llc->busy_expire;
+                                        break;
+                        }
+                        break;
+
+                default:
+                        return (-ENOPROTOOPT);
+        }
+
+        if(get_user(len, optlen))
+                return (-EFAULT);
+
+        len = min(len, sizeof(int));
+        if(put_user(len, optlen))
+                return (-EFAULT);
+
+        if(copy_to_user(optval, &val, len))
+                return (-EFAULT);
+
+        return (0);
+}
+
+static struct net_proto_family llc_ui_family_ops =
+{
+        PF_LLC,
+        llc_ui_create
+};
+
+static struct proto_ops llc_ui_ops =
+{
+        PF_LLC,
+        llc_ui_release,
+        llc_ui_bind,
+        llc_ui_connect,
+        sock_no_socketpair,
+        llc_ui_accept,
+        llc_ui_getname,
+        datagram_poll,
+        llc_ui_ioctl,
+        llc_ui_listen,
+        llc_ui_shutdown,
+        llc_ui_setsockopt,
+        llc_ui_getsockopt,
+        llc_ui_sendmsg,
+        llc_ui_recvmsg,
+        sock_no_mmap
+};
+
+int __init llc_ui_init(void)
+{
+	(void)sock_register(&llc_ui_family_ops);
+
+	printk(KERN_INFO "ANSI/IEEE 802.2 User Interface SAPs for LLC v0.12\n");
+	return (0);
+}
+
+void __exit llc_ui_exit(void)
+{
+	sock_unregister(PF_LLC);
+	return;
+}
+
+module_init(llc_ui_init);
+module_exit(llc_ui_exit);
+
+#endif /* CONFIG_LLC_UI || CONFIG_LLC_UI_MODULE */
diff -ruN linux-2.4.4/net/llc/dl_llc.c linux/net/llc/dl_llc.c
--- linux-2.4.4/net/llc/dl_llc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/llc/dl_llc.c	Mon May 14 21:24:54 2001
@@ -0,0 +1,3275 @@
+/* IEEE 802.2 LLC Class 1 and Class 2 implementation for Linux.
+ *
+ * Author:
+ * Jay Schulist <jschlst@samba.org>
+ *
+ * Sources:
+ * - ANSI/IEEE Std 802.2-1989.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ *
+ * ToDo:
+ * - Enable linux to do duplicate address checking upon bringing
+ *   an interface to the IFF_UP state.
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+#include <linux/uio.h>
+#include <linux/unistd.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+
+#include <net/llc.h>
+#include <linux/llc.h>
+
+#include <linux/rtnetlink.h>
+#include <linux/notifier.h>
+#include <linux/if_arp.h>
+
+#include <linux/ctype.h>        /* For hexdump() */
+
+#ifdef CONFIG_SYSCTL
+extern inline void llc_register_sysctl(void);
+extern inline void llc_unregister_sysctl(void);
+#endif /* CONFIG_SYSCTL */
+
+int sysctl_max_retry            = LLC_RETRY;
+int sysctl_max_size             = LLC_SIZE;
+int sysctl_max_window           = LLC_WINDOW;
+int sysctl_ack_timer_expire     = LLC_ACK_TIMER_EXPIRE;
+int sysctl_p_timer_expire       = LLC_P_TIMER_EXPIRE;
+int sysctl_rej_timer_expire     = LLC_REJ_TIMER_EXPIRE;
+int sysctl_busy_timer_expire    = LLC_BUSY_TIMER_EXPIRE;
+int llc_debug			= 0;
+
+static struct llc_sc_info *llc_sc_list = NULL;
+
+static struct llc_pinfo *llc_sc = NULL;
+static struct datalink_proto *llc_client_list 	= NULL;
+
+static int llc_strip_8022(struct sk_buff *skb, int size);
+int llc_rcv(struct sk_buff *skb, struct net_device *dev,struct packet_type *pt);
+static int llc_demux_pdu(int action, struct sk_buff *skb,
+        struct datalink_proto *proto);
+static int llc_process_pdu_type2(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt);
+static void llc_datalink_header(struct datalink_proto *dl,
+        struct sk_buff *skb, unsigned char *dsap);
+static int llc_build_pdu(struct sk_buff *skb, struct llc_pinfo *llc, 
+	unsigned char dsap);
+static int llc_start_ack_timer(struct llc_pinfo *llc);
+static int llc_stop_ack_timer(struct llc_pinfo *llc);
+static void llc_ack_expire(unsigned long data);
+static int llc_start_p_timer(struct llc_pinfo *llc);
+static int llc_stop_p_timer(struct llc_pinfo *llc);
+static void llc_p_expire(unsigned long data);
+static int llc_start_rej_timer(struct llc_pinfo *llc);
+static int llc_stop_rej_timer(struct llc_pinfo *llc);
+static void llc_rej_expire(unsigned long data);
+static int llc_start_busy_timer(struct llc_pinfo *llc);
+static int llc_stop_busy_timer(struct llc_pinfo *llc);
+static void llc_busy_expire(unsigned long data);
+static int llc_sap_init(struct llc_pinfo *llc);
+static int llc_purge_queues(struct llc_pinfo *llc);
+static int llc_destroy_client(struct llc_pinfo *llc);
+static struct datalink_proto *llc_find_client(__u8 type);
+void llc_proto_init(struct net_proto *proto);
+static int llc_process_pdu_type1_sc(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt);
+static int llc_process_pdu_type1_sap(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt);
+int llc_queue_rsp(int rsp, struct sk_buff *skb, struct datalink_proto *proto);
+static int llc_update_nr(struct llc_pinfo *llc, struct sk_buff *skb);
+int llc_decode_pdu(llchdr *llc);
+static int llc_stop_all_timers(struct llc_pinfo *llc);
+static void llc_update_pf(struct llc_pinfo *llc, struct sk_buff *skb,int fflag);
+
+static int hexdump(unsigned char *pkt_data, int pkt_len)
+{
+        int i;
+
+        while(pkt_len>0)
+        {
+                printk("  ");   /* Leading spaces. */
+
+                /* Print the HEX representation. */
+                for(i=0; i<8; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i] & 0xFF);
+                        else
+                                printk("  ");
+                }
+
+                printk(":");
+
+                for(i=8; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i]&0xFF);
+                        else
+                                printk("  ");
+                }
+
+                /* Print the ASCII representation. */
+                printk("  ");
+
+                for(i=0; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                        {
+                                if(isprint(pkt_data[i]))
+                                        printk("%c", pkt_data[i]);
+                                else
+                                        printk(".");
+                        }
+                }
+
+                printk("\n");
+                pkt_len -= 16;
+                pkt_data += 16;
+        }
+
+        printk("\n");
+
+        return (0);
+}
+
+int llc_data(__u8 ssap, __u8 dsap, __u8 *dmac,
+	struct sk_buff *skb, struct net_device *dev)
+{
+	struct datalink_proto *dl = llc_find_client(dsap);
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+
+	printk("WE ARE BUILDING A DATA REQ\n");
+        llc->build = LLC_STATE_SEND_I_CMD;
+	llc->dsap = dsap;
+        llc_build_pdu(skb, llc, dsap);
+        llc->state2 = LLC_STATE_NORMAL;
+
+	dev->hard_header(skb, dev, ETH_P_802_3, dmac, NULL, skb->len);
+        llc_queue_xmit(skb);
+        return (0);
+}
+
+int llc_test(__u8 ssap, __u8 dsap, __u8 *dmac,
+	struct sk_buff *skb, struct net_device *dev)
+{
+	struct datalink_proto *dl = llc_find_client(dsap);
+        struct llc_pinfo *llc = dl->ll_pinfo.llc;
+
+	printk("Sending LLC TEST from from %02X to %02X\n", ssap, dsap);
+
+	llc->build 	= LLC_STATE_SEND_TEST_C;
+	llc->dsap	= dsap;
+	llc_build_pdu(skb, llc, dsap);
+	llc->state2	= LLC_STATE_NORMAL;
+
+	dev->hard_header(skb, dev, ETH_P_802_3, dmac, NULL, skb->len);
+	hexdump(skb->data, skb->len);
+	llc_queue_xmit(skb);
+	return (0);	
+}
+
+int llc_connect(struct datalink_proto *dl, struct net_device *dev,
+	__u8 *dmac, __u8 dsap, int rsp)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+	struct sk_buff *skb;
+	llchdr *llc_hdr;
+	int size;
+
+	size = dl->header_length + 1;
+        size += dev->hard_header_len;
+
+        skb = alloc_skb(size, GFP_KERNEL);
+        if(skb == NULL)
+                return (-ENOMEM);
+        skb->dev = dev;
+        skb_reserve(skb, dl->header_length + 1);
+        skb_reserve(skb, dev->hard_header_len);
+
+	if(rsp)
+	{
+		if(llc->state2 != LLC_STATE_CONN)
+		{
+			kfree_skb(skb);
+			return (-EINVAL);
+		}
+
+		llc->build = LLC_STATE_SEND_UA_RSP;
+		llc_build_pdu(skb, llc, 0);
+		llc_hdr = (llchdr *)skb->data;
+		llc_hdr->ctrl.uctrl.pf = llc->p_flag;
+		llc->seq.vs = 0;
+		llc->seq.vr = 0;
+		llc->retry_count = 0;
+		llc->p_flag = 0;
+		llc->remote_busy = 0;
+		llc->state2 = LLC_STATE_NORMAL;
+	}
+	else
+	{
+		if(llc->state2 != LLC_STATE_ADM)
+		{
+			kfree_skb(skb);
+			return (-EINVAL);
+		}
+
+		llc->build = LLC_STATE_SEND_SABME_CMD;
+                llc_build_pdu(skb, llc, 0);
+                llc_start_ack_timer(llc);
+                llc->retry_count = 0;
+                llc->s_flag = 0;
+                llc->state2 = LLC_STATE_SETUP;
+	}
+
+
+	dev->hard_header(skb, dev, ETH_P_802_3, dmac, NULL, skb->len);
+        llc_queue_xmit(skb);
+	return (0);
+}
+
+int llc_reset(struct datalink_proto *dl, struct net_device *dev,
+        __u8 *dmac, __u8 dsap, int rsp)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct sk_buff *skb;
+        llchdr *llc_hdr;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+
+        skb = alloc_skb(size, GFP_KERNEL);
+        if(skb == NULL)
+                return (-ENOMEM);
+        skb->dev = dev;
+        skb_reserve(skb, dl->header_length + 1);
+        skb_reserve(skb, dev->hard_header_len);
+
+        if(rsp)
+        {
+		if(llc->state2 != LLC_STATE_RESET_CHECK)
+		{
+			kfree_skb(skb);
+			return (-EINVAL);
+		}
+
+		llc->build = LLC_STATE_SEND_UA_RSP;
+		llc_build_pdu(skb, llc, 0);
+		llc_hdr = (llchdr *)skb->data;
+		llc_hdr->ctrl.sctrl.pf = llc->f_flag;
+		llc->seq.vs = 0;
+		llc->seq.vr = 0;
+		llc->retry_count = 0;
+                llc->p_flag = 0;
+                llc->remote_busy = 0;
+                llc->state2 = LLC_STATE_NORMAL;
+	}
+	else
+	{
+		if(llc->state2 != LLC_STATE_NORMAL
+                        || llc->state2 != LLC_STATE_BUSY
+                        || llc->state2 != LLC_STATE_REJECT
+                        || llc->state2 != LLC_STATE_AWAIT
+                        || llc->state2 != LLC_STATE_AWAIT_BUSY
+                        || llc->state2 != LLC_STATE_AWAIT_REJECT
+			|| llc->state2 != LLC_STATE_RESET_WAIT)
+		{
+			kfree_skb(skb);
+			return (-EINVAL);
+		}
+
+		if(llc->state2 == LLC_STATE_RESET_WAIT)
+		{
+			if(!llc->s_flag)
+                        {
+                        	llc->build = LLC_STATE_SEND_SABME_CMD;
+                                llc_build_pdu(skb, llc, 0);
+                                llc_hdr = (llchdr *)skb->data;
+                                llc_update_pf(llc, skb, 0);
+                                llc_start_ack_timer(llc);
+                                llc->retry_count = 0;
+                                llc->state2 = LLC_STATE_RESET;
+                        }
+			else
+			{
+				kfree_skb(skb);
+				return (-EINVAL);
+			}
+		}
+		else
+		{
+			llc->build = LLC_STATE_SEND_SABME_CMD;
+                        llc_build_pdu(skb, llc, 0);
+                        llc_hdr = (llchdr *)skb->data;
+                        llc_update_pf(llc, skb, 0);
+                        llc_start_ack_timer(llc);
+                        llc_stop_p_timer(llc);
+                        llc_stop_busy_timer(llc);
+                        llc_stop_rej_timer(llc);
+                        llc->retry_count = 0;
+                        llc->s_flag = 0;
+                        llc->state2 = LLC_STATE_RESET;
+		}
+	}
+
+	dev->hard_header(skb, dev, ETH_P_802_3, dmac, NULL, skb->len);
+        llc_queue_xmit(skb);
+        return (0);
+}
+
+int llc_disconnect(struct datalink_proto *dl, struct net_device *dev,
+	__u8 *dmac, __u8 dsap, int rsp)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct sk_buff *skb;
+        llchdr *llc_hdr;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+
+        skb = alloc_skb(size, GFP_KERNEL);
+        if(skb == NULL)
+                return (-ENOMEM);
+        skb->dev = dev;
+        skb_reserve(skb, dl->header_length + 1);
+        skb_reserve(skb, dev->hard_header_len);
+
+        if(llc->state2 != LLC_STATE_NORMAL 
+		|| llc->state2 != LLC_STATE_BUSY
+                || llc->state2 != LLC_STATE_REJECT
+                || llc->state2 != LLC_STATE_AWAIT
+                || llc->state2 != LLC_STATE_AWAIT_BUSY
+                || llc->state2 != LLC_STATE_AWAIT_REJECT
+		|| llc->state2 != LLC_STATE_CONN
+		|| llc->state2 != LLC_STATE_RESET_WAIT
+		|| llc->state2 != LLC_STATE_RESET_CHECK
+		|| rsp)
+	{
+		kfree_skb(skb);
+		return (-EINVAL);
+	}
+
+	if(llc->state2 == LLC_STATE_CONN || llc->state2 == LLC_STATE_RESET_CHECK
+		|| (llc->state2 == LLC_STATE_RESET_WAIT && llc->s_flag))
+	{
+		llc->build = LLC_STATE_SEND_DM_RSP;
+                llc_build_pdu(skb, llc, 0);
+		llc_hdr = (llchdr *)skb->data;
+		llc_hdr->ctrl.sctrl.pf = llc->f_flag;
+		llc->state2 = LLC_STATE_ADM;
+	}
+	else
+	{
+		llc->build = LLC_STATE_SEND_DISC_CMD;
+		llc_build_pdu(skb, llc, 0);
+		llc_update_pf(llc, skb, 0);
+		llc_start_ack_timer(llc);
+		llc->retry_count = 0;
+		llc->state2 = LLC_STATE_D_CONN;
+	}
+
+	dev->hard_header(skb, dev, ETH_P_802_3, dmac, NULL, skb->len);
+        llc_queue_xmit(skb);
+        return (0);
+}
+
+/* Remove the 802.2 header of "size" length. */
+static int llc_strip_8022(struct sk_buff *skb, int size)
+{
+        skb->h.raw      += size;
+        skb->nh.raw     += size;
+        skb_pull(skb, size);
+
+        return (0);
+}
+
+/* LLC layer receive function: Here all 802.2 packets come in. */
+int llc_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt)
+{
+        struct datalink_proto *proto;
+        llchdr *llc_hdr = (llchdr *)skb->h.raw;
+	int pdu_action;
+
+	if(llc_debug > 10)
+	{
+                printk("llc_rcv\n");
+		hexdump(skb->data, skb->len);
+	}
+
+        /* If the requested client is not registered no sense in any further
+         * processing, we just toss the skb. Null DSAP is handled by the
+	 * Station Component.
+         */
+        proto = llc_find_client(llc_hdr->dsap);
+        if(proto == NULL)
+        {
+		skb->sk = NULL;
+		kfree_skb(skb);
+		return (0);
+        }
+
+	if(llc_debug > 5)
+	{
+		printk("Client found for LLC datagram %02X\n", llc_hdr->dsap);
+		hexdump(skb->h.raw, skb->len);
+	}
+
+        /* Discover what the command or response PDU is holding. */
+        if((pdu_action = llc_decode_pdu(llc_hdr)) < 0)
+	{
+		skb->sk = NULL;
+		kfree_skb(skb);
+		return (0);
+	}
+
+        skb->dev = dev;         /* Relink just to be safe. */
+        skb->pt  = pt;		/* Attach pt here. */
+
+	/* Proceed to processing the received pdu. */
+        return(llc_demux_pdu(pdu_action, skb, proto));
+}
+
+int llc_decode_pdu(llchdr *llc)
+{
+        llc_bits *bits = &llc->ctrl.bits;
+
+        /* Unnumbered command/response. Pdu_type = 11. */
+        if(bits->f1 && bits->f2)
+        {
+                switch(bits->f3 & 0x3B)
+                {
+                        case (0x00):
+                                return (LLC_UI_CMD);
+
+                        case (0x03):
+                                return (LLC_DM_RSP);
+
+                        case (0x10):
+                                return (LLC_DISC_CMD);
+
+                        case (0x18):
+                                return (LLC_UA_RSP);
+
+                        case (0x1B):
+                                return (LLC_SABME_CMD);
+
+                        case (0x21):
+                                return (LLC_FRMR_RSP);
+
+                        case (0x2B):
+                                if(llc->ssap & LLC_PDU_RSP)
+                                        return (LLC_XID_RSP);
+                                else
+                                        return (LLC_XID_CMD);
+
+                        case (0x38):
+                                if(llc->ssap & LLC_PDU_RSP)
+                                        return (LLC_TEST_RSP);
+                                else
+                                        return (LLC_TEST_CMD);
+
+                        default:
+                                        return (-1);
+                }
+        }
+
+        /* Supervisory command/response. Pdu_type = 10. */
+        if(bits->f1 && !bits->f2)
+        {
+                switch(bits->f3 & 0x3B)
+                {
+                        case (0x00):
+                                if(llc->ssap & LLC_PDU_RSP)
+                                        return (LLC_RR_RSP);
+                                else
+                                        return (LLC_RR_CMD);
+
+                        case (0x01):
+                                if(llc->ssap & LLC_PDU_RSP)
+                                        return (LLC_RNR_RSP);
+                                else
+                                        return (LLC_RNR_CMD);
+
+                        case (0x02):
+                                if(llc->ssap & LLC_PDU_RSP)
+                                        return (LLC_REJ_RSP);
+                                else
+                                        return (LLC_REJ_CMD);
+
+                        default:
+                                return (-1);
+                }
+        }
+
+        /* Information transfer command/response. Pdu_type = 0. */
+        if(!bits->f1)
+        {
+                if(llc->ssap & LLC_PDU_RSP)
+                        return (LLC_I_RSP);
+                else
+                        return (LLC_I_CMD);
+        }
+
+        /* Catch all, should never get here. */
+        return (-1);
+}
+
+/* Demux the PDU and continue processing on it. 
+ *
+ * This is where all the work is done.
+ */
+static int llc_demux_pdu(int event, struct sk_buff *skb,
+	struct datalink_proto *proto)
+{
+	llchdr *llc_hdr = (llchdr *)skb->h.raw;
+	struct llc_pinfo *llc = proto->ll_pinfo.llc;
+	struct net_device *dev = skb->dev;
+	struct packet_type *pt = skb->pt;
+
+        if(llc_debug > 10)
+                printk("llc_demux_pdu\n");
+
+        /* Preform the needed operations to complete the command or response. */
+	switch(event)
+        {
+		/* LLC Class One PDUs */
+                case (LLC_UI_CMD):
+			llc->event = LLC_STATE_RECEIVE_UI;
+                        llc_process_pdu_type1_sap(skb, proto, dev, pt);
+                        break;
+
+                case (LLC_XID_CMD):
+			if(!llc_hdr->dsap)
+			{
+                                llc->event = LLC_STATE_RECEIVE_NULL_DSAP_XID_C;
+				llc_process_pdu_type1_sc(skb, proto, dev, pt);
+			}
+                        else
+			{
+                                llc->event = LLC_STATE_RECEIVE_XID_C;
+                        	llc_process_pdu_type1_sap(skb, proto, dev, pt);
+			}
+                        break;
+
+                case (LLC_XID_RSP):
+			llc->event = LLC_STATE_RECEIVE_XID_R;
+                        llc_process_pdu_type1_sap(skb, proto, dev, pt);
+                        break;
+
+                case (LLC_TEST_CMD):
+			if(!llc_hdr->dsap)
+			{
+                                llc->event = LLC_STATE_RECEIVE_NULL_DSAP_TEST_C;
+				llc_process_pdu_type1_sc(skb, proto, dev, pt);
+			}
+                        else
+			{
+                                llc->event = LLC_STATE_RECEIVE_TEST_C;
+                        	llc_process_pdu_type1_sap(skb, proto, dev, pt);
+			}
+                        break;
+
+                case (LLC_TEST_RSP):
+			llc->event = LLC_STATE_RECEIVE_TEST_R;
+                        llc_process_pdu_type1_sap(skb, proto, dev, pt);
+                        break;
+
+		/* 
+		 * LLC Class Two PDUs 
+		 */
+		/* Unnumbered Acknowledgement response. */
+		case (LLC_UA_RSP):      /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_UA_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Disconnect command. */
+		case (LLC_DISC_CMD):    /* Type 2. */
+			llc->event = LLC_STATE_RECEIVE_DISC_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Disconnected Mode response. */
+                case (LLC_DM_RSP):      /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_DM_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Set Asynchronous Balanced Mode Extended command. */
+	        case (LLC_SABME_CMD):   /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_SABME_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Frame Reject response. (Connection reset request) */
+                case (LLC_FRMR_RSP):    /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_FRMR_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Receive Ready command/response. */
+                case (LLC_RR_CMD):      /* Type 2. */
+/* Good */      case (LLC_RR_RSP):      /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_RR_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Receive Not Ready command. */
+                case (LLC_RNR_CMD):     /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_RNR_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Receive Not Ready response. */
+                case (LLC_RNR_RSP):     /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_RNR_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Reject command. */
+                case (LLC_REJ_CMD):     /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_REJ_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Reject response. */
+                case (LLC_REJ_RSP):     /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_REJ_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Information command. */
+/* Good */      case (LLC_I_CMD):       /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_I_CMD;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+		/* Information response. */
+                case (LLC_I_RSP):       /* Type 2. */
+                        llc->event = LLC_STATE_RECEIVE_I_RSP;
+                        llc_process_pdu_type2(skb, proto, dev, pt);
+                        break;
+
+                default:
+                        skb->sk = NULL;
+                        kfree_skb(skb);
+                        break;
+        }
+
+        return (0);
+}
+
+static int llc_process_pdu_type1_sc(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt)
+{
+        struct llc_pinfo *llc = proto->ll_pinfo.llc;
+
+        if(llc_debug > 10)
+                printk("llc_process_pdu_type1_sc\n");
+
+        switch(llc->state)
+        {
+                case (LLC_STATE_DOWN):
+                        skb->sk = NULL;
+                        kfree_skb(skb);
+                        return (0);
+
+                case (LLC_STATE_UP):
+                        switch(llc->event)
+                        {
+                                case (LLC_STATE_RECEIVE_NULL_DSAP_XID_C):
+					llc->build = LLC_STATE_SEND_XID_R;
+					llc_build_pdu(skb, llc, 0);
+					llc_queue_xmit(skb);
+                                        llc->state = LLC_STATE_UP;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_NULL_DSAP_TEST_C):
+                                        llc->build = LLC_STATE_SEND_NULL_DSAP_TEST_R;
+                                        llc_build_pdu(skb, llc, 0);
+                                        llc_queue_xmit(skb);
+                                        llc->state = LLC_STATE_UP;
+                                        break;
+
+                                default:
+                                        skb->sk = NULL;
+                                        kfree_skb(skb);
+                                        return (-EINVAL);
+                        }
+                        break;
+
+		/* Not supporting at the moment */
+                case (LLC_STATE_DUPLICATE_ADDRESS_CHK):
+                        switch(llc->event)
+                        {
+                                case (LLC_STATE_RECEIVE_NULL_DSAP_XID_R):
+                                        if(!llc->xid_r_count)
+                                        {
+                                                llc->xid_r_count++;
+                                                llc->state = LLC_STATE_DUPLICATE_ADDRESS_CHK;
+                                                kfree_skb(skb);
+                                                break;
+                                        }
+                                        else    /* llc->xid_r_count == 1. */
+                                        {
+                                                llc->state = LLC_STATE_DOWN;
+                                                kfree_skb(skb);
+                                                break;
+                                        }
+
+                                case (LLC_STATE_RECEIVE_NULL_DSAP_XID_C):
+/*
+                                        new_skb = llc_create_skb(LLC_TYPE1_SIZE
+                                                + LLC_XID_SIZE, llc);
+                                        llc_build_ctrl(LLC_XID_RSP, llchdr2);
+                                        llchdr2->dsap = llchdr1->ssap;
+                                        llchdr2->ssap = llc->ssap & LLC_PDU_RSP;                                        kfree_skb(skb);
+                                        llc_queue_xmit(new_skb);
+*/
+                                        llc->state = LLC_STATE_DUPLICATE_ADDRESS_CHK;
+                                        break;
+
+                                case (LLC_STATE_ACK_TIMER_EXPIRED):
+                                        if(llc->retry_count < llc->max_retry)
+                                        {
+/*
+                                                new_skb = llc_create_skb(LLC_TYPE1_SIZE + LLC_XID_SIZE, llc);
+                                                llc_build_ctrl(LLC_XID_CMD,
+                                                        llchdr2);
+                                                llchdr2->dsap = 0;
+                                                llchdr2->ssap = llc->ssap;
+                                                kfree_skb(skb);
+                                                llc_queue_xmit(new_skb);
+                                                llc->retry_count++;
+                                                llc->xid_r_count = 0;
+*/
+                                                llc->state = LLC_STATE_DUPLICATE_ADDRESS_CHK;
+                                                break;
+                                        }
+                                        else    /* llc->retry_count == max. */
+                                        {
+                                                kfree_skb(skb);
+                                                llc->state = LLC_STATE_UP;
+                                                break;
+                                        }
+
+                                default:
+					skb->sk = NULL;
+                                        kfree_skb(skb);
+                                        return (-EINVAL);
+                        }
+                        break;
+
+                default:
+			skb->sk = NULL;
+			kfree_skb(skb);
+                        return (-EINVAL);
+        }
+
+        return (0);
+}
+
+/* LLC SAP Components. All processing is defered to the
+ * receiver. This is processing just for specific SAPs.
+ * Any NULL dsaps go to the SC. We just set the proper
+ * state and cmd/rsp indications.
+ */
+static int llc_process_pdu_type1_sap(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt)
+{
+        struct llc_pinfo *llc = proto->ll_pinfo.llc;
+
+        if(llc_debug > 10)
+                printk("llc_process_pdu_type1_sap\n");
+
+        switch(llc->state)
+        {
+                case (LLC_STATE_INACTIVE):
+                        skb->sk = NULL;
+                        kfree_skb(skb);
+                        return (0);
+
+                case (LLC_STATE_ACTIVE):
+                        switch(llc->event)
+                        {
+                                case (LLC_STATE_RECEIVE_UI):
+                                        llc_strip_8022(skb, LLC_TYPE1_SIZE);
+                                        proto->rcvfunc(skb, dev, pt);
+                                        llc->state = LLC_STATE_ACTIVE;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_XID_C):
+					skb->llc_cmd = LLC_R_XID_C_INDICATION;
+					proto->rcvfunc(skb, dev, pt);
+                                        llc->state = LLC_STATE_ACTIVE;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_XID_R):
+					skb->llc_cmd = LLC_R_XID_R_INDICATION;
+					proto->rcvfunc(skb, dev, pt);
+					llc->state = LLC_STATE_ACTIVE;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_TEST_C):
+					skb->llc_cmd = LLC_R_TEST_C_INDICATION;
+					proto->rcvfunc(skb, dev, pt);
+                                        llc->state = LLC_STATE_ACTIVE;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_TEST_R):
+					skb->llc_cmd = LLC_R_TEST_R_INDICATION;
+                                        proto->rcvfunc(skb, dev, pt);
+                                        llc->state = LLC_STATE_ACTIVE;
+                                        break;
+
+                                default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					return (-EINVAL);
+                        }
+                        break;
+
+                default:
+			skb->sk = NULL;
+			kfree_skb(skb);
+                        return (-EINVAL);
+        }
+
+        return (0);
+}
+
+/* Send RR Response */
+static int llc_send_rr_rsp(struct sk_buff *skb, struct net_device *dev,
+	struct datalink_proto *dl, __u8 dsap, __u8 pf)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        llchdr *llc_hdr;
+        struct sk_buff *newskb;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+        if(newskb == NULL)
+        	return (-ENOMEM);
+        newskb->sk      = NULL;
+        newskb->dev     = skb->dev;
+        newskb->llc_cmd = LLC_STATE_SEND_RR_RESPONSE;
+        skb_reserve(newskb, dl->header_length + 1);
+        skb_reserve(newskb, dev->hard_header_len);
+
+	/* Add RR header */
+        llc->build = LLC_STATE_SEND_RR_RSP;
+        llc_build_pdu(newskb, llc, 0);
+        llc_hdr = (llchdr *)newskb->data;
+        llc_hdr->ctrl.sctrl.pf = pf;
+        llc_hdr->dsap = dsap;
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+
+        llc_queue_xmit(newskb);
+
+	return (0);
+}
+
+/* Send REJ Response */
+static int llc_send_rej_rsp(struct sk_buff *skb, struct net_device *dev,
+        struct datalink_proto *dl, __u8 dsap, __u8 pf)
+{
+        struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        llchdr *llc_hdr;
+        struct sk_buff *newskb;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+        if(newskb == NULL)
+                return (-ENOMEM);
+        newskb->sk      = NULL;
+        newskb->dev     = skb->dev;
+        newskb->llc_cmd = LLC_STATE_SEND_RR_RESPONSE;
+        skb_reserve(newskb, dl->header_length + 1);
+        skb_reserve(newskb, dev->hard_header_len);
+
+        /* Add RR header */
+        llc->build = LLC_STATE_SEND_REJ_RSP;
+        llc_build_pdu(newskb, llc, 0);
+        llc_hdr = (llchdr *)newskb->data;
+        llc_hdr->ctrl.sctrl.pf = pf;
+        llc_hdr->dsap = dsap;
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+
+        llc_queue_xmit(newskb);
+
+        return (0);
+}
+
+/* Send DM Response */
+static int llc_send_dm_rsp(struct sk_buff *skb, struct net_device *dev,
+        struct datalink_proto *dl, __u8 dsap, __u8 pf)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+	llchdr *llc_hdr;
+        struct sk_buff *newskb;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+        if(newskb == NULL)
+                return (-ENOMEM);
+        newskb->sk      = NULL;
+        newskb->dev     = skb->dev;
+        skb_reserve(newskb, dl->header_length + 1);
+        skb_reserve(newskb, dev->hard_header_len);
+
+	/* Add DM header */
+	llc->build = LLC_STATE_SEND_DM_RSP;
+        llc_build_pdu(newskb, llc, 0);
+        llc_hdr = (llchdr *)newskb->data;
+        llc_hdr->ctrl.sctrl.pf = pf;
+        llc_hdr->dsap = dsap;
+
+	dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+        llc_queue_xmit(newskb);
+
+        return (0);
+}
+
+/* Send RNR Response */
+static int llc_send_rnr_rsp(struct sk_buff *skb, struct net_device *dev,
+        struct datalink_proto *dl, __u8 dsap, __u8 pf)
+{
+        struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        llchdr *llc_hdr;
+        struct sk_buff *newskb;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+        if(newskb == NULL)
+                return (-ENOMEM);
+        newskb->sk      = NULL;
+        newskb->dev     = skb->dev;
+        skb_reserve(newskb, dl->header_length + 1);
+        skb_reserve(newskb, dev->hard_header_len);
+
+        /* Add DM header */
+        llc->build = LLC_STATE_SEND_RNR_RSP;
+        llc_build_pdu(newskb, llc, 0);
+        llc_hdr = (llchdr *)newskb->data;
+	llc_hdr->ctrl.sctrl.pf = pf;
+        llc_hdr->dsap = dsap;
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+        llc_queue_xmit(newskb);
+
+        return (0);
+}
+
+/* Send UA Rsp */
+static int llc_send_ua_rsp(struct sk_buff *skb, struct net_device *dev,
+        struct datalink_proto *dl, __u8 dsap, __u8 pf)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+	llchdr *llc_hdr;
+        struct sk_buff *newskb;
+        int size;
+
+        size = dl->header_length + 1;
+        size += dev->hard_header_len;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+        if(newskb == NULL)
+                return (-ENOMEM);
+        newskb->sk      = NULL;
+        newskb->dev     = skb->dev;
+        newskb->llc_cmd = LLC_STATE_SEND_UA_RESPONSE;
+        skb_reserve(newskb, dl->header_length + 1);
+        skb_reserve(newskb, dev->hard_header_len);
+
+	/* Add UA header */
+        llc->build = LLC_STATE_SEND_UA_RSP;
+        llc_build_pdu(newskb, llc, 0);
+        llc_hdr = (llchdr *)newskb->data;
+        llc_hdr->ctrl.uctrl.pf = pf;
+        llc_hdr->dsap = dsap;
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+        llc_queue_xmit(newskb);
+
+        return (0);
+}
+
+/* Return 0 if sequence is ok.
+ * Return Positive if sequence is bad.
+ */
+static int llc_chk_seq(struct llc_pinfo *llc, struct sk_buff *skb)
+{
+	llchdr *llc_hdr = (llchdr *)skb->h.raw;
+
+	/* Old llc_hdr->ctrl.ictrl.ns != llc->seq.vr */
+	return (llc->seq.vr - llc_hdr->ctrl.ictrl.ns);
+}
+
+static void llc_update_pf(struct llc_pinfo *llc, struct sk_buff *skb, int fflag)
+{
+	llchdr *llc_hdr = (llchdr *)skb->h.raw;
+
+	if(fflag)
+		llc->f_flag = llc_hdr->ctrl.sctrl.pf;
+	else
+		llc->p_flag = llc_hdr->ctrl.sctrl.pf;
+}
+
+/* Process all the received 802.2 Class Two frames */
+static int llc_process_pdu_type2(struct sk_buff *skb,
+        struct datalink_proto *proto, struct net_device *dev,
+        struct packet_type *pt)
+{
+	struct llc_pinfo *llc = proto->ll_pinfo.llc;
+	llchdr *llc_hdr = (llchdr *)skb->h.raw;
+	int event = llc->event;
+
+	if(llc_debug > 3)
+                printk("llc_process_pdu_type2\n");
+
+	/* Good Don't Touch */
+	if(llc->state2 == LLC_STATE_NORMAL || llc->state2 == LLC_STATE_BUSY
+		|| llc->state2 == LLC_STATE_AWAIT 
+		|| llc->state2 == LLC_STATE_AWAIT_BUSY
+		|| llc->state2 == LLC_STATE_AWAIT_REJECT)
+	{
+		switch(event)
+                {
+                	case (LLC_STATE_RECEIVE_SABME_CMD):
+				llc_update_pf(llc, skb, 1);
+                        	llc_queue_rsp(LLC_STATE_REMOTE_RESET_INDICATION,
+					skb, proto);
+				llc_stop_all_timers(llc);
+				llc->state2 = LLC_STATE_NORMAL;
+              //                  llc->state2 = LLC_STATE_RESET_CHECK;
+                                goto pdu_done;
+
+			/* Good/Perfect/Tested */
+                        case (LLC_STATE_RECEIVE_DISC_CMD):
+				llc_stop_all_timers(llc);
+                                llc_send_ua_rsp(skb, dev, proto, llc->dsap,
+					llc_hdr->ctrl.sctrl.pf);
+                                llc_queue_rsp(event, skb, proto);
+				llc->state2 = LLC_STATE_ADM;
+                                goto pdu_done;
+
+                        case (LLC_STATE_RECEIVE_FRMR_RSP):
+				llc_stop_all_timers(llc);
+                                llc_queue_rsp(LLC_STATE_LOCAL_RESET_INDICATION, 
+					skb, proto);
+                                llc->s_flag = 0;
+                                llc->state2 = LLC_STATE_RESET_WAIT;
+                                goto pdu_done;
+
+                        case (LLC_STATE_RECEIVE_DM_RSP):
+                                llc_queue_rsp(event, skb, proto);
+				llc_stop_all_timers(llc);
+                                llc->state2 = LLC_STATE_ADM;
+                                goto pdu_done;
+        	}
+	}
+
+	switch(llc->state2)
+        {
+		/* Good Don't Touch */
+		case (LLC_STATE_NORMAL):
+			switch(event)
+                        {
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RR_CMD):
+					if(llc_debug > 3)
+						printk("LLC_STATE_RECEIVE_RR_CMD\n");
+					if(llc_hdr->ctrl.sctrl.pf)
+						llc_send_rr_rsp(skb,dev,proto,
+							llc_hdr->ssap, 1);
+					else
+						llc->p_flag = 0;
+					llc_update_nr(llc, skb);
+					llc->remote_busy = 0;
+					skb->sk = NULL;
+                                        kfree_skb(skb);
+					llc->state2 = LLC_STATE_NORMAL;
+					break;	
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RR_RSP):
+					if(!llc_hdr->ctrl.sctrl.pf
+						|| (llc_hdr->ctrl.sctrl.pf
+						&& llc->p_flag))
+					{
+						llc->p_flag = 0;
+						llc_update_nr(llc, skb);
+						llc->remote_busy = 0;
+                                                break;
+					}
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RNR_CMD):
+                                        if(llc_hdr->ctrl.sctrl.pf)
+                                        {
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+						llc_update_nr(llc, skb);
+						llc->remote_busy = 1;
+						skb->sk = NULL;
+						kfree_skb(skb);
+						llc->state2 = LLC_STATE_NORMAL;
+						break;
+					}
+					else
+					{
+						llc_update_pf(llc, skb, 0);
+						llc_update_nr(llc, skb);
+						llc->remote_busy = 1;
+                                                skb->sk = NULL;
+                                                kfree_skb(skb);
+                                                llc->state2 = LLC_STATE_NORMAL;
+                                                break;
+					}
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RNR_RSP):
+                                        if(!llc_hdr->ctrl.sctrl.pf
+                                                || (llc_hdr->ctrl.sctrl.pf
+                                                && llc->p_flag))
+                                        {
+						llc_update_pf(llc, skb, 0);
+						llc_update_nr(llc, skb);
+						llc->remote_busy = 1;
+                                                skb->sk = NULL;
+                                                kfree_skb(skb);
+                                                llc->state2 = LLC_STATE_NORMAL;
+                                                break;
+					}
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_REJ_CMD):
+					llc->seq.vs = llc_hdr->ctrl.sctrl.nr;
+					llc_update_nr(llc, skb);
+					if(!llc_hdr->ctrl.sctrl.pf
+						&& !llc->p_flag)
+						llc_update_pf(llc, skb, 0);
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						/* Resend I RSP PDU */
+					}
+					else
+					{
+						/*
+						 * Set Tx Queue Flag and start
+						 * retransmitting at vs.
+						 */
+					}
+					llc->remote_busy = 0;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_NORMAL;	
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_REJ_RSP):
+					llc_update_nr(llc, skb);
+					llc_update_pf(llc, skb, 0);
+
+					/*
+					 * Set Tx Queue Flag and start
+                                         * retransmitting at vs.
+                                         */
+
+					llc->remote_busy = 0;
+                                        skb->sk = NULL;
+                                        kfree_skb(skb);
+                                        llc->state2 = LLC_STATE_NORMAL;
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_I_RSP):
+				case (LLC_STATE_RECEIVE_I_CMD):
+				{
+					int rsp_pdu = (event
+						== LLC_STATE_RECEIVE_I_RSP);
+
+					if(llc_debug > 4)
+						printk("LLC GOT AN I PACKET\n");
+
+					llc_update_nr(llc, skb);
+					proto->rcvfunc(skb, dev, pt);
+                                        llc->state2 = LLC_STATE_NORMAL;
+
+#ifdef NOT
+					if(llc_chk_seq(llc, skb))
+					{
+						if(llc_hdr->ctrl.ictrl.pf
+							&& !rsp_pdu)
+						{
+							llc_send_rej_rsp(skb,
+								dev,proto,
+								llc->dsap,1);
+						}
+						else
+						{
+							llc_send_rej_rsp(skb,
+								dev, proto,
+								llc->dsap, 1);
+						}
+						llc_update_nr(llc, skb);
+						llc_start_rej_timer(llc);
+						if(!llc->p_flag || (rsp_pdu
+							&& llc->p_flag
+							&& llc_hdr->ctrl.ictrl.pf))
+							llc_update_pf(llc, skb, 0);
+                                                skb->sk = NULL;
+                                                kfree_skb(skb);
+						llc->state2 = LLC_STATE_REJECT;
+						break;
+					}
+
+					llc->seq.vr++;
+					if(llc_hdr->ctrl.ictrl.pf && !rsp_pdu)
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					else
+					{
+						if(!rsp_pdu & !llc->p_flag)
+						{
+							llc_send_rr_rsp(skb,dev,
+								proto,llc->dsap,
+								1);
+							llc_start_p_timer(llc);
+						}
+						else
+						{
+							/* Send Ack any way
+							 * possible.
+							 */
+							llc_send_rr_rsp(skb,dev,
+								proto,llc->dsap,
+								1);
+						}
+					}
+					llc_update_nr(llc, skb);
+					proto->rcvfunc(skb, dev, pt);
+					llc->state2 = LLC_STATE_NORMAL;
+#endif
+					break;
+				}
+
+				/* Good Don't Touch */
+#ifdef NOT
+				case (LLC_STATE_RECEIVE_RR_RSP):
+				case (LLC_STATE_RECEIVE_RR_CMD):
+					llc_update_nr(llc, skb);
+					llc->retry_count = 0;
+					llc_stop_ack_timer(llc);
+
+					/* Dequeue pkts on ReTx queue. 
+					 * Restart ack timer if unack'd pkts
+					 * exist.
+					 */
+					skb->sk = NULL;
+					kfree_skb(skb);
+					break;
+#endif
+			}
+                        break;
+
+		case (LLC_STATE_AWAIT):
+			switch(event)
+			{
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_I_RSP):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+						llc_send_rej_rsp(skb,dev,proto,
+							llc->dsap, 0);
+						llc_update_nr(llc, skb);
+						llc_start_rej_timer(llc);
+						if(llc_hdr->ctrl.ictrl.pf)
+						{
+							llc->seq.vs = llc_hdr->ctrl.ictrl.nr;
+							llc_stop_p_timer(llc);
+
+							/* Resend I PDUs
+							 * Any way possible.
+							 */
+							llc->remote_busy = 0;
+							llc->state2 = LLC_STATE_REJECT;
+						}
+						else
+							llc->state2 = LLC_STATE_AWAIT_REJECT;
+						skb->sk = NULL;
+						kfree_skb(skb);
+						break;
+					}
+
+					llc->seq.vr++;
+                                        if(llc_hdr->ctrl.ictrl.pf)
+                                        {
+						llc->seq.vs 
+							=llc_hdr->ctrl.ictrl.nr;
+						/*
+						 * Resend I CMD or send RR
+						 */
+						llc_start_p_timer(llc);
+						llc->remote_busy = 0;
+						llc->state2 = LLC_STATE_NORMAL;
+					}
+					else
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 0);
+						llc->state2 = LLC_STATE_AWAIT;
+					}
+					proto->rcvfunc(skb, dev, pt);
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_I_CMD):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+						llc_send_rej_rsp(skb,dev,proto,
+							llc->dsap, 
+							llc_hdr->ctrl.ictrl.pf);
+						llc_update_nr(llc, skb);
+                                                llc_start_rej_timer(llc);
+                                                skb->sk = NULL;
+                                                kfree_skb(skb);
+                                                llc->state2=LLC_STATE_AWAIT_REJECT;
+                                                break;
+					}
+
+					llc->seq.vr++;
+					proto->rcvfunc(skb, dev, pt);
+					if(llc_hdr->ctrl.ictrl.pf)
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					}
+					else
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 0);
+					}
+					llc->state2 = LLC_STATE_AWAIT;
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RR_RSP):
+				case (LLC_STATE_RECEIVE_REJ_RSP):
+					llc->seq.vr = llc_hdr->ctrl.sctrl.nr;
+					llc->remote_busy = 0;
+
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						llc->seq.vs
+							=llc_hdr->ctrl.sctrl.nr;
+						llc_stop_p_timer(llc);
+						/*
+						 * Resend I PDUs any way pos.
+						 */
+						llc->state2 = LLC_STATE_NORMAL;
+					}
+					else
+						llc->state2 = LLC_STATE_AWAIT;
+
+					skb->sk = NULL;
+					kfree_skb(skb);
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RR_CMD):
+				case (LLC_STATE_RECEIVE_REJ_CMD):
+					llc->seq.vr = llc_hdr->ctrl.sctrl.nr;
+					llc->remote_busy = 0;
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					}
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_AWAIT;
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RNR_RSP):
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						llc->seq.vs
+							=llc_hdr->ctrl.sctrl.nr;
+						llc_stop_p_timer(llc);
+						llc->state2 = LLC_STATE_NORMAL;
+					}
+					else
+						llc->state2 = LLC_STATE_AWAIT;
+
+					llc->remote_busy = 1;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					break;
+
+				/* Good Don't Touch */
+				case (LLC_STATE_RECEIVE_RNR_CMD):
+                                        if(llc_hdr->ctrl.sctrl.pf)
+                                        {
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					}
+
+					llc->state2 = LLC_STATE_AWAIT;
+					llc->remote_busy = 1;
+                                        skb->sk = NULL;
+                                        kfree_skb(skb);
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					break;
+			}
+			break;
+
+		case (LLC_STATE_AWAIT_BUSY):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_I_RSP):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+					break;
+
+				case (LLC_STATE_RECEIVE_I_CMD):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+					break;
+
+				case (LLC_STATE_RECEIVE_RR_RSP):
+					break;
+
+				case (LLC_STATE_RECEIVE_RR_CMD):
+					break;
+
+				case (LLC_STATE_RECEIVE_REJ_RSP):
+					break;
+
+				case (LLC_STATE_RECEIVE_REJ_CMD):
+					break;
+
+				case (LLC_STATE_RECEIVE_RNR_RSP):
+					break;
+
+				case (LLC_STATE_RECEIVE_RNR_CMD):
+					break;
+			}
+			break;
+
+		case (LLC_STATE_AWAIT_REJECT):
+			switch(event)
+                        {
+                                case (LLC_STATE_RECEIVE_I_RSP):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_I_CMD):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_RR_RSP):
+                                case (LLC_STATE_RECEIVE_RR_CMD):
+                                case (LLC_STATE_RECEIVE_REJ_RSP):
+                                case (LLC_STATE_RECEIVE_REJ_CMD):
+				{
+                                        int rsp_pdu = ((event == LLC_STATE_RECEIVE_REJ_RSP) || (event == LLC_STATE_RECEIVE_RR_RSP));
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						if(!rsp_pdu)
+						{
+							llc_send_rnr_rsp(skb,
+								dev,proto,
+								llc->dsap,llc_hdr->ctrl.sctrl.pf);
+							llc->state2 = LLC_STATE_AWAIT_BUSY;
+						}
+						else
+						{
+							llc->seq.vs=llc_hdr->ctrl.sctrl.nr;
+							llc_stop_p_timer(llc);
+
+							/*
+							 * Resend I Pdus
+							 * Anyway possible.
+							 */
+							llc->state2 = LLC_STATE_BUSY;
+						}
+					}
+					else
+						llc->state2 = LLC_STATE_AWAIT_BUSY;
+
+					llc->seq.vr = llc_hdr->ctrl.sctrl.nr;
+					llc->remote_busy = 0;
+					skb->sk = NULL;
+					kfree_skb(skb);
+                                        break;
+				}
+
+                                case (LLC_STATE_RECEIVE_RNR_RSP):
+                                case (LLC_STATE_RECEIVE_RNR_CMD):
+				{
+					int rsp_pdu = (event == LLC_STATE_RECEIVE_RNR_RSP);
+
+					if(!rsp_pdu)
+					{
+						if(llc_hdr->ctrl.sctrl.pf)
+						{
+							llc_send_rnr_rsp(skb,dev,proto, llc->dsap, llc_hdr->ctrl.sctrl.pf);
+						}
+						llc->state2 = LLC_STATE_AWAIT_BUSY;
+					}
+					else
+					{
+						if(llc_hdr->ctrl.ictrl.pf)
+                                                {
+							llc->seq.vs=llc_hdr->ctrl.sctrl.nr;
+							llc_stop_p_timer(llc);
+							llc->state2 = LLC_STATE_BUSY;
+						}
+						else
+							llc->state2 = LLC_STATE_AWAIT_BUSY;
+					}			
+
+					llc->seq.vr = llc_hdr->ctrl.sctrl.nr;
+					llc->remote_busy = 1;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					break;
+				}
+			}
+			break;
+
+		case (LLC_STATE_BUSY):
+			switch(event)
+                        {
+                                case (LLC_STATE_RECEIVE_I_RSP):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_I_CMD):
+				{
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+					}
+
+                                        break;
+				}
+
+                                case (LLC_STATE_RECEIVE_RR_RSP):
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_RR_CMD):
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_REJ_RSP):
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_REJ_CMD):
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_RNR_RSP):
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_RNR_CMD):
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_REJECT):
+			switch(event)
+                        {
+                                case (LLC_STATE_RECEIVE_I_RSP):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+						llc_update_nr(llc, skb);
+						llc_update_pf(llc, skb, 0);
+						if(llc->p_flag)
+							llc->remote_busy = 0;
+
+						skb->sk = NULL;
+						kfree_skb(skb);
+						llc->state2 = LLC_STATE_REJECT;
+						break;
+					}
+			
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_I_CMD):
+                                        if(llc_chk_seq(llc, skb))
+                                        {
+						if(llc_hdr->ctrl.ictrl.pf)
+						{
+							llc_send_rr_rsp(skb,dev,
+								proto,llc->dsap,
+								1);
+						}
+						else
+							llc_update_pf(llc, skb, 0);
+						llc_update_nr(llc, skb);
+						skb->sk = NULL;
+						kfree_skb(skb);
+						llc->state2 = LLC_STATE_REJECT;
+						break;
+					}
+
+					llc->seq.vr++;
+					/* Shit */
+					if(llc_hdr->ctrl.ictrl.pf)
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					}
+					else
+					{
+						if(!llc->p_flag)
+						{
+							llc_start_p_timer(llc);
+//							llc_send_rr_cmd(skb,
+//								dev,proto);
+						}
+
+					}
+					llc_update_nr(llc, skb);
+					proto->rcvfunc(skb, dev, pt);
+					llc_stop_rej_timer(llc);
+					llc->state2 = LLC_STATE_NORMAL;
+                                        break;
+
+				/* Good Dont' Touch */
+                                case (LLC_STATE_RECEIVE_RR_RSP):
+					llc_update_pf(llc, skb, 0);
+                                        llc->remote_busy = 0;
+                                        skb->sk = NULL;
+                                        kfree_skb(skb);
+                                        llc->state2 = LLC_STATE_REJECT;
+                                        break;
+
+				/* Good Don't Touch */
+                                case (LLC_STATE_RECEIVE_RR_CMD):
+                                        if(llc_hdr->ctrl.sctrl.pf)
+					{
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap, 1);
+					}
+					else
+						llc_update_pf(llc, skb, 0);
+					llc_update_nr(llc, skb);
+					llc->remote_busy = 0;
+                                        skb->sk = NULL;
+                                        kfree_skb(skb);
+                                        llc->state2 = LLC_STATE_REJECT;
+                                        break;
+
+                                case (LLC_STATE_RECEIVE_REJ_RSP):
+					llc->seq.vs = llc_hdr->ctrl.sctrl.nr;
+					if(!llc->p_flag 
+						&& !llc_hdr->ctrl.sctrl.pf)
+						llc->p_flag
+							=llc_hdr->ctrl.sctrl.pf;
+					/*
+					 * Resend I Pdu XXX
+					 */
+
+					llc->remote_busy = 0;
+					llc->state2 = LLC_STATE_REJECT;
+                                        break;
+
+				/* Good Don't Touch */
+                                case (LLC_STATE_RECEIVE_REJ_CMD):
+					llc->seq.vs = llc_hdr->ctrl.sctrl.nr;
+					llc_update_nr(llc, skb);
+					if(llc_hdr->ctrl.sctrl.pf)
+					{
+						/* resend I Rsp PDU */
+					}
+					else
+					{
+						if(!llc_hdr->ctrl.sctrl.pf
+							&& !llc->p_flag)
+							llc_update_pf(llc, skb, 0);
+						/* Resend I XXX Pdu */
+					}
+
+					llc->remote_busy = 0;
+					llc->state2 = LLC_STATE_REJECT;
+                                        break;
+
+				/* Good Don't Touch */
+                                case (LLC_STATE_RECEIVE_RNR_RSP):
+					llc_update_pf(llc, skb, 0);
+					llc_update_nr(llc, skb);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_REJECT;
+                                        break;
+
+				/* Good Don't Touch */
+                                case (LLC_STATE_RECEIVE_RNR_CMD):
+					if(llc_hdr->ctrl.sctrl.pf)
+						llc_update_pf(llc, skb, 0);
+					else
+						llc_send_rr_rsp(skb,dev,proto,
+							llc->dsap,1);
+					llc_update_nr(llc, skb);
+					llc->remote_busy = 1;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_REJECT;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_RESET_CHECK):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc_update_pf(llc, skb, 1);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET_CHECK;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+					llc_send_dm_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET_CHECK;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_RESET_WAIT):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc->s_flag = 1;
+					llc_update_pf(llc, skb, 1);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET_WAIT;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+					llc_send_dm_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET_WAIT;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_ERROR):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc_queue_rsp(LLC_STATE_REMOTE_RESET_INDICATION, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_RESET_CHECK;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+					llc_send_ua_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					llc_queue_rsp(event, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_FRMR_RSP):
+					llc_queue_rsp(LLC_STATE_LOCAL_RESET_INDICATION, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->s_flag = 0;
+					llc->state2 = LLC_STATE_RESET_WAIT;
+					break;
+
+				default:
+					if(!(llc_hdr->ssap & LLC_PDU_RSP))
+					{
+						/* Resend FRMR RSP */
+						llc_start_ack_timer(llc);
+					}
+
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_ERROR;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_D_CONN):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+                                        llc_send_dm_rsp(skb,dev,proto,llc->dsap,                                                llc_hdr->ctrl.sctrl.pf);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_UA_RSP):
+					llc_stop_ack_timer(llc);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+					llc_send_ua_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_D_CONN;
+					break;
+
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_stop_ack_timer(llc);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_D_CONN;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_SETUP):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc->seq.vs = 0;
+					llc->seq.vr = 0;
+					llc->retry_count = 0;
+					llc_send_ua_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					llc->s_flag = 1;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_SETUP;
+					break;
+
+				case (LLC_STATE_RECEIVE_UA_RSP):
+					llc_stop_ack_timer(llc);
+					llc->seq.vs = 0;
+					llc->seq.vr = 0;
+					llc->retry_count = 0;
+					llc->remote_busy = 0;
+					llc_update_pf(llc, skb, 0);
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_NORMAL;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+                                        llc_send_dm_rsp(skb,dev,proto,llc->dsap,                                                llc_hdr->ctrl.sctrl.pf);
+					llc_queue_rsp(event, skb, proto);
+                                        llc_stop_ack_timer(llc);
+                                        llc->state2 = LLC_STATE_ADM;
+                                        break;
+
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc_stop_ack_timer(llc);
+                                        llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_SETUP;
+					break;
+			}
+			break;
+
+		/* Good Don't Touch */
+                case (LLC_STATE_ADM):
+                        switch(event)
+                        {
+                                case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc_update_pf(llc, skb, 0);
+					llc_queue_rsp(event, skb, proto);
+				//	llc->state2 = LLC_STATE_CONN;
+					llc->state2 = LLC_STATE_NORMAL;
+					break;
+
+				/* Perfect/Tested/Good */
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+                                        llc_send_dm_rsp(skb,dev,proto,
+						llc_hdr->ssap,
+                                                llc_hdr->ctrl.sctrl.pf);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					if(!(llc_hdr->ssap & LLC_PDU_RSP)
+						&& llc_hdr->ctrl.sctrl.pf)
+					{
+                                        	llc_send_dm_rsp(skb,dev,proto,
+							llc_hdr->ssap,
+	                                                llc_hdr->ctrl.sctrl.pf);
+					}
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+                        }
+                        break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_RESET):
+			switch(event)
+			{
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc->seq.vs = 0;
+					llc->seq.vr = 0;
+					llc->retry_count = 0;
+					llc->s_flag = 1;
+					llc_send_ua_rsp(skb,dev,proto,llc->dsap,
+						llc_hdr->ctrl.sctrl.pf);
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET;
+					break;
+
+				case (LLC_STATE_RECEIVE_UA_RSP):
+					llc_stop_ack_timer(llc);
+					llc->seq.vs = 0;
+					llc->seq.vr = 0;
+					llc->retry_count = 0;
+					llc->remote_busy = 0;
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_NORMAL;
+					break;
+
+				case (LLC_STATE_RECEIVE_DISC_CMD):
+                                        llc_send_dm_rsp(skb,dev,proto,llc->dsap,                                                llc_hdr->ctrl.sctrl.pf);
+					llc_queue_rsp(event, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc_stop_ack_timer(llc);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_RESET;
+			}
+			break;
+
+		/* Good Don't Touch */
+		case (LLC_STATE_CONN):
+			switch(event)
+                        {
+				case (LLC_STATE_RECEIVE_DM_RSP):
+					llc_queue_rsp(event, skb, proto);
+					llc->state2 = LLC_STATE_ADM;
+					break;
+
+				case (LLC_STATE_RECEIVE_SABME_CMD):
+					llc_update_pf(llc, skb, 1);
+					/* Fall through */
+
+				default:
+					skb->sk = NULL;
+					kfree_skb(skb);
+					llc->state2 = LLC_STATE_CONN;
+					break;
+			}
+			break;
+
+		default:
+                        return (-EINVAL);
+        }
+
+pdu_done:
+	return (0);
+}
+
+/*
+ * LLC protocol layer transmit functions.
+ */
+
+/* Update the retransmit queue. Check to see if the packet acks any of our
+ * queued packets. Window aware.
+ */
+static int llc_update_nr(struct llc_pinfo *llc, struct sk_buff *skb)
+{
+	llchdr *llc_hdr = (llchdr *)skb->h.raw;
+	struct sk_buff *qskb;
+
+	if(llc_debug > 3)
+		printk("llc_update_nr\n");
+
+	while((qskb = skb_dequeue(&llc->retx_queue)) != NULL)
+	{
+		llchdr *qllc_hdr = (llchdr *)qskb->data;
+		if(qllc_hdr->ctrl.ictrl.nr < llc_hdr->ctrl.ictrl.nr)
+		{
+			qskb->sk = NULL;
+			kfree_skb(qskb);
+		}
+		else
+		{
+			skb_queue_head(&llc->retx_queue, qskb);
+			break;
+		}
+	}
+
+	llc->seq.vr = llc_hdr->ctrl.ictrl.nr;
+	llc->retry_count = 0;
+
+	if(qskb == NULL)
+		llc_stop_ack_timer(llc);
+	else
+		llc_start_ack_timer(llc);
+
+	return (0);
+}
+
+static int llc_build_pdu(struct sk_buff *skb, struct llc_pinfo *llc,
+	unsigned char dsap)
+{
+	llchdr *llc_hdr;
+
+	if(llc_debug > 3)
+		printk("llc_build_pdu()\n");
+
+	/* Decide which PDU to build. */
+	switch(llc->build)
+	{
+		case (LLC_STATE_SEND_XID_C):
+		{
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap   = llc->dsap;
+                        llc_hdr->ssap   = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_XID_CMD;
+			break;
+		}
+
+		case (LLC_STATE_SEND_XID_R):
+		{
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap   = llc->dsap;
+                        llc_hdr->ssap   = llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_XID_RSP;
+			break;
+		}
+
+		/* Build a Unnumbered Information Packet for Tx. */
+		case (LLC_STATE_SEND_UI):
+		{
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE1_SIZE);
+                        llc_hdr->dsap   = llc->ssap;
+                        llc_hdr->ssap   = llc->ssap;
+                        llc_hdr->ctrl.ctrl = LLC_CTRL_UI_CMD;
+			break;
+		}
+
+		/* Send a LLC Test command. */
+		case (LLC_STATE_SEND_TEST_C):
+		{
+			llc_hdr = (llchdr *)skb_push(skb,LLC_TYPE1_SIZE);
+			llc_hdr->dsap 	= dsap;
+                        llc_hdr->ssap 	= llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_TEST_CMD;
+			break;
+		}
+
+		case (LLC_STATE_SEND_NULL_DSAP_TEST_R):
+		{
+			struct ethhdr *eth_hdr = skb->mac.ethernet;
+			char dest[6], dsap;
+			memcpy(&dest, eth_hdr->h_source, 6);
+			llc_hdr = (llchdr *)skb->data;
+			dsap = llc_hdr->ssap;
+			memset(skb->data, 0, 3);
+			llc_hdr->dsap	= dsap;
+			llc_hdr->ssap	= dsap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_TEST_RSP;
+			skb->dev->hard_header(skb, skb->dev, ETH_P_802_3,
+                		dest, NULL, skb->len);
+			break;
+		}
+
+		/* Generic procedures to build an LLC Test response. */
+		case (LLC_STATE_SEND_TEST_R):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE1_SIZE);
+			llc_hdr->dsap 	= llc_hdr->ssap;
+                        llc_hdr->ssap 	= llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_TEST_RSP;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_DISC_CMD):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+			llc_hdr->dsap = llc->dsap;
+			llc_hdr->ssap = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_DISC_CMD;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_DM_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+			llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+                        llc_hdr->ctrl.ctrl = LLC_CTRL_DM_RSP;
+			break;
+
+		case (LLC_STATE_SEND_FRMR_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+			llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+                        llc_hdr->ctrl.ctrl = LLC_CTRL_FRMR_RSP;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_I_CMD):
+			llc_hdr = (llchdr *)skb_push(skb, LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap;
+                        llc_hdr->ctrl.ctrl = LLC_CTRL_I_CMD;
+			llc_hdr->ctrl.ictrl.ns = llc->seq.vs;
+			llc_hdr->ctrl.ictrl.nr = llc->seq.vr;
+			llc->seq.vs++;
+			break;
+
+		case (LLC_STATE_SEND_I_RSP):
+			llc_hdr = (llchdr *)skb_push(skb, LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap & LLC_PDU_RSP;
+                        llc_hdr->ctrl.ctrl = LLC_CTRL_I_RSP;
+			break;
+
+		case (LLC_STATE_SEND_REJ_CMD):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_REJ_CMD;
+			break;
+
+		case (LLC_STATE_SEND_REJ_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_REJ_RSP;
+			break;
+
+		case (LLC_STATE_SEND_RNR_CMD):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_RNR_CMD;
+			break;
+
+		case (LLC_STATE_SEND_RNR_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_RNR_RSP;
+			break;
+
+		case (LLC_STATE_SEND_RR_CMD):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_RR_CMD;
+			llc_hdr->ctrl.ictrl.ns = llc->seq.vs;
+			llc_hdr->ctrl.ictrl.nr = llc->seq.vr;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_RR_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_RR_RSP;
+                        llc_hdr->ctrl.sctrl.nr = llc->seq.vr;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_SABME_CMD):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_SABME_CMD;
+			break;
+
+		/* Good */
+		case (LLC_STATE_SEND_UA_RSP):
+			llc_hdr = (llchdr *)skb_put(skb,LLC_TYPE2_SIZE);
+                        llc_hdr->dsap = llc->dsap;
+                        llc_hdr->ssap = llc->ssap + LLC_PDU_RSP;
+			llc_hdr->ctrl.ctrl = LLC_CTRL_UA_RSP;
+			break;
+	}
+
+	return (0);
+}
+
+/* The end of the LLC transmission path.
+ * Ideally, any protocol that uses LLC will queue to this
+ * transmission path and let us handle the device queue passing.
+ *
+ * skb->dev must contain a valid device to xmit on.
+ * dev->hard_header must already be applied if needed.
+ */
+int llc_queue_xmit(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->dev;
+	struct llc_pinfo *llc = NULL;
+	struct sk_buff *skb2;
+
+	if(llc_debug > 10)
+	{
+		printk("llc_queue_xmit\n");
+		hexdump(skb->data, skb->len);
+	}
+
+#ifdef NOT
+	/* Check to see if we are currently retransmitting data or
+	 * if we have reached the window limit without receiving an ack,
+	 * then lets queue the data to the transmit queue.
+	 *
+	 * Note: Probably should only queue if Class 2 and I PDU.
+	 */
+	if(llc->retransmitting 
+		|| (skb_queue_len(&llc->retx_queue) >= llc->max_window))
+	{
+		skb_queue_tail(&llc->tx_queue, skb);
+		llc->tx_queue_depth++;
+		return (0);
+	}
+
+	/* It looks like we are actually going to Tx the data on the
+	 * wire so lets queue a copy in the ReTx queue, for use later.
+	 *
+	 * Note: Probably should only queue if Class 2 and I PDU.
+	 */
+        skb2 = skb_clone(skb, GFP_ATOMIC);
+        if(skb2 == NULL)
+                return (-ENOBUFS);
+        skb_queue_tail(&llc->retx_queue, skb2);
+        llc->retx_queue_depth++;
+#endif
+
+	/* Check to see if we need to loopback the packet. */
+        if(!memcmp(skb->data, dev->dev_addr, dev->addr_len))
+        {
+		skb_orphan(skb);
+		skb->mac.raw	= skb->data;
+		skb->h.raw	= skb->data + dev->hard_header_len;
+		skb_pull(skb, dev->hard_header_len);
+		llc_rcv(skb, dev, NULL);
+        }
+        else
+                dev_queue_xmit(skb);
+
+        return (0);
+}
+
+/* We have been called to throw a header on a existing sk_buff. The
+ * skb most likely already has data on it, so we just put the right
+ * LLC header on and toss it onward.
+ */
+void llc_datalink_header(struct datalink_proto *dl,
+        struct sk_buff *skb, unsigned char *dsap)
+{
+	struct llc_pinfo *llc = dl->ll_pinfo.llc;
+
+	if(llc_debug > 3)
+		printk("llc_datalink_header\n");
+
+        switch(skb->llc_cmd)
+        {
+                /* Type 1 commands/actions. No need to test the state
+		 * on class one commands as the only way to get here
+		 * is if the sap is already in an active state.
+		 */
+/* Good */	case (LLC_STATE_UNITDATA_REQUEST):
+			llc->build = LLC_STATE_SEND_UI;
+                        llc_build_pdu(skb, llc, *dsap);
+                        llc->state = LLC_STATE_ACTIVE;
+                        break;
+
+/* Good */	case (LLC_STATE_XID_REQUEST):
+			llc->build = LLC_STATE_SEND_XID_C;
+                        llc_build_pdu(skb, llc, *dsap);
+                        llc->state = LLC_STATE_ACTIVE;
+			break;
+
+/* Good */	case (LLC_STATE_TEST_REQUEST):
+			llc->build = LLC_STATE_SEND_TEST_C;
+                        llc_build_pdu(skb, llc, *dsap);
+			llc->state = LLC_STATE_ACTIVE;
+			break;
+
+                /* Type 2 commands/actions. */
+/* Good */	case (LLC_STATE_DATA_REQUEST):
+			if(llc->state2 == LLC_STATE_NORMAL)
+			{
+				printk("WE ARE BUILDING A DATA REQ\n");
+				llc->build = LLC_STATE_SEND_I_CMD;
+                                llc_build_pdu(skb, llc, *dsap);
+                               // if(!llc->p_flag)
+	                       //         llc_start_p_timer(llc);
+                               // llc_start_ack_timer(llc);
+                                llc->state2 = LLC_STATE_NORMAL;
+				break;
+			}
+
+			if(llc->state2 == LLC_STATE_REJECT)
+			{
+				if(!llc->p_flag)
+                                {
+                                	llc->build=LLC_STATE_SEND_I_CMD;                                                llc_build_pdu(skb, llc, *dsap);
+                                        llc_start_p_timer(llc);
+				}
+				else
+				{
+                                        llc->build=LLC_STATE_SEND_I_CMD;                                                llc_build_pdu(skb, llc, *dsap);
+				}
+                                llc_start_ack_timer(llc);
+                                llc->state2 = LLC_STATE_REJECT;
+				break;
+			}
+			break;
+
+		/* By default we put a LLC UI CMD header on the skb,
+		 * if no command is specified. This allows for backwards
+		 * compatability for networking layers which haven't been
+		 * updated yet or use the old (pre 01/01/00) linux llc specs.
+		 */
+                default:
+			llc->build = LLC_STATE_SEND_UI;
+                        llc_build_pdu(skb, llc, *dsap);
+                        llc->state = LLC_STATE_ACTIVE;
+                        break;
+        }
+
+	return;
+}
+
+/* 
+ * LLC protocol layer timer operations.
+ */
+static int llc_start_ack_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->ack_timer);
+        llc->ack_timer.expires = jiffies + sysctl_ack_timer_expire;
+        add_timer(&llc->ack_timer);
+
+        return (0);
+}
+
+static int llc_stop_ack_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->ack_timer);
+
+        return (0);
+}
+
+static void llc_ack_expire(unsigned long data)
+{
+        struct llc_pinfo *llc = (struct llc_pinfo *)data;
+	struct sk_buff *skb;
+
+	printk("llc_ack_expire\n");
+
+        llc->event = LLC_STATE_ACK_TIMER_EXPIRED;
+
+	switch(llc->state)
+	{
+		case (LLC_STATE_SETUP):
+		case (LLC_STATE_RESET):
+			if(llc->s_flag)
+			{
+                        	llc->p_flag = 0;
+                                llc->remote_busy = 0;
+				llc->state = LLC_STATE_NORMAL;
+				break;
+			}
+
+			if(llc->retry_count < llc->max_retry && !llc->s_flag)
+			{
+				skb = alloc_skb(4, GFP_ATOMIC);
+				llc->build = LLC_STATE_SEND_SABME_CMD;
+				llc_build_pdu(skb, llc, 0);
+				llc_start_ack_timer(llc);
+				llc->retry_count ++;
+				llc_queue_xmit(skb);
+				break;
+			}
+
+			if(llc->retry_count >= llc->max_retry && !llc->s_flag)
+			{
+				llc->state = LLC_STATE_ADM;
+				break;
+			}
+
+		case (LLC_STATE_D_CONN):
+			if(llc->retry_count < llc->max_retry)
+			{
+				skb = alloc_skb(4, GFP_ATOMIC);
+				llc->build = LLC_STATE_SEND_DISC_CMD;
+				llc_build_pdu(skb, llc, 0);
+				llc_start_ack_timer(llc);
+				llc->retry_count++;
+				llc_queue_xmit(skb);
+				llc->state = LLC_STATE_D_CONN;
+			}
+			else
+				llc->state = LLC_STATE_ADM;
+			break;
+
+		case (LLC_STATE_ERROR):
+			if(llc->retry_count < llc->max_retry)
+			{
+				// llc_resend_frmr();
+				llc_start_ack_timer(llc);
+				llc->retry_count++;
+				llc->state = LLC_STATE_ERROR;
+			}
+			else
+			{
+				llc->s_flag = 0;
+				llc->state = LLC_STATE_RESET_WAIT;
+			}
+			break;
+
+		case (LLC_STATE_NORMAL):
+		case (LLC_STATE_BUSY):
+		case (LLC_STATE_REJECT):
+			if(llc->retry_count < llc->max_retry && !llc->s_flag)
+			{
+				skb = alloc_skb(4, GFP_ATOMIC);
+				llc->build = LLC_STATE_SEND_RR_CMD;
+				llc_build_pdu(skb, llc, 0);
+				llc_start_p_timer(llc);
+				llc->retry_count++;
+				llc_queue_xmit(skb);
+
+				if(llc->state == LLC_STATE_NORMAL)
+					llc->state = LLC_STATE_AWAIT;
+				if(llc->state == LLC_STATE_BUSY)
+					llc->state = LLC_STATE_AWAIT_BUSY;
+				if(llc->state == LLC_STATE_REJECT)
+					llc->state = LLC_STATE_AWAIT_REJECT;
+			}
+			break;
+	}
+
+        return;
+}
+
+static int llc_start_p_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->p_timer);
+        llc->p_timer.expires = jiffies + sysctl_p_timer_expire;
+        add_timer(&llc->p_timer);
+
+        return (0);
+}
+
+static int llc_stop_p_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->p_timer);
+
+        return (0);
+}
+
+static void llc_p_expire(unsigned long data)
+{
+        struct llc_pinfo *llc = (struct llc_pinfo *)data;
+	struct sk_buff *skb;
+
+        llc->event = LLC_STATE_P_TIMER_EXPIRED;
+
+	if(llc->state != LLC_STATE_NORMAL 
+		|| llc->state != LLC_STATE_BUSY
+		|| llc->state != LLC_STATE_REJECT 
+		|| llc->state != LLC_STATE_AWAIT
+		|| llc->state != LLC_STATE_AWAIT_BUSY
+		|| (llc->state != LLC_STATE_AWAIT_REJECT
+		&& llc->retry_count > llc->max_retry))
+	{
+		return;
+	}
+
+	skb = alloc_skb(4, GFP_ATOMIC);
+	llc->build = LLC_STATE_SEND_RR_CMD;
+	llc_build_pdu(skb, llc, 0);
+	llc_start_p_timer(llc);
+        llc->retry_count++;
+	llc_queue_xmit(skb);
+
+	if(llc->state == LLC_STATE_BUSY)
+	{
+		llc->state = LLC_STATE_AWAIT_BUSY;
+		return;
+	}
+
+	if(llc->state == LLC_STATE_NORMAL)
+	{
+		llc->state = LLC_STATE_AWAIT;
+		return;
+	}
+
+	if(llc->state == LLC_STATE_REJECT)
+	{
+		llc_start_rej_timer(llc);
+		llc->state = LLC_STATE_AWAIT_REJECT;
+		return;
+	}
+
+        return;
+}
+
+static int llc_start_rej_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->rej_timer);
+        llc->rej_timer.expires = jiffies + sysctl_rej_timer_expire;
+        add_timer(&llc->rej_timer);
+
+        return (0);
+}
+
+static int llc_stop_rej_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->rej_timer);
+
+        return (0);
+}
+
+static void llc_rej_expire(unsigned long data)
+{
+        struct llc_pinfo *llc = (struct llc_pinfo *)data;
+	struct sk_buff *skb;
+
+        llc->event = LLC_STATE_REJ_TIMER_EXPIRED;
+
+	switch(llc->state)
+	{
+		case (LLC_STATE_BUSY):
+			if(!llc->p_flag && llc->retry_count < llc->max_retry)
+			{
+				skb = alloc_skb(4, GFP_ATOMIC);
+				llc->build = LLC_STATE_SEND_RNR_CMD;
+				llc_build_pdu(skb, llc, 0);
+				llc_start_p_timer(llc);
+				llc->retry_count++;
+                                llc->data_flag = 1;
+				llc_queue_xmit(skb);
+				llc->state = LLC_STATE_AWAIT_BUSY;
+				break;
+			}
+
+			if(llc->p_flag && llc->retry_count < llc->max_retry)
+			{
+				llc->data_flag = 1;
+				llc->state = LLC_STATE_BUSY;
+				break;
+			}
+
+			break;
+
+		case (LLC_STATE_REJECT):
+			if(!llc->p_flag && llc->retry_count < llc->max_retry)
+			{
+				skb = alloc_skb(4, GFP_ATOMIC);
+				llc->build = LLC_STATE_SEND_REJ_CMD;
+				llc_build_pdu(skb, llc, 0);
+				llc_start_p_timer(llc);
+                                llc_start_rej_timer(llc);
+                                llc->retry_count++;
+				llc_queue_xmit(skb);
+				llc->state = LLC_STATE_REJECT;
+				break;
+			}
+			break;
+	}
+
+        return;
+}
+
+static int llc_start_busy_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->busy_timer);
+        llc->busy_timer.expires = jiffies + sysctl_busy_timer_expire;
+        add_timer(&llc->busy_timer);
+
+        return (0);
+}
+
+static int llc_stop_busy_timer(struct llc_pinfo *llc)
+{
+        del_timer(&llc->busy_timer);
+
+        return (0);
+}
+
+static void llc_busy_expire(unsigned long data)
+{
+        struct llc_pinfo *llc = (struct llc_pinfo *)data;
+	struct sk_buff *skb;
+
+        llc->event = LLC_STATE_BUSY_TIMER_EXPIRED;
+
+	if(llc->state != LLC_STATE_NORMAL
+		|| llc->state != LLC_STATE_BUSY
+		|| (llc->state != LLC_STATE_REJECT
+//		&& llc->pflag != 0)
+		&& llc->retry_count > llc->max_retry))
+	{
+		return;
+	}
+
+	skb = alloc_skb(4, GFP_ATOMIC);
+	llc->build = LLC_STATE_SEND_RR_CMD;
+	llc_build_pdu(skb, llc, 0);
+	llc_start_p_timer(llc);
+	llc->retry_count++;
+	llc_queue_xmit(skb);
+
+	if(llc->state == LLC_STATE_NORMAL)
+		llc->state = LLC_STATE_AWAIT;
+
+	if(llc->state == LLC_STATE_BUSY)
+		llc->state = LLC_STATE_AWAIT_BUSY;
+
+	if(llc->state == LLC_STATE_REJECT)
+	{
+		llc->state = LLC_STATE_AWAIT_REJECT;
+		llc_start_rej_timer(llc);
+		return;
+	}
+	
+        return;
+}
+
+static int llc_stop_all_timers(struct llc_pinfo *llc)
+{
+	llc_stop_ack_timer(llc);
+        llc_stop_p_timer(llc);
+        llc_stop_rej_timer(llc);
+        llc_stop_busy_timer(llc);
+
+	return (0);
+}
+
+/* We send directly to the receiver.. we are still in the rx bh so we will
+ * should not steal anybodys time too much.
+ */
+int llc_queue_rsp(int rsp, struct sk_buff *skb, struct datalink_proto *proto)
+{
+	struct llc_pinfo *llc = proto->ll_pinfo.llc;
+
+	if(llc_debug > 3)
+                printk("llc_queue_rsp: adding rsp to train\n");
+
+	if(skb != NULL)
+                skb = skb_unshare(skb, GFP_ATOMIC);
+
+	llc->rcvfunc(rsp, skb);
+
+	return (0);
+}
+
+/* LLC SAP (Station Access Point) initilization. 
+ * - SAPs start in an INACTIVE state and default to LLC Class 1 conformance.
+ */
+static int llc_sap_init(struct llc_pinfo *llc)
+{
+	llc->class		= LLC_SAP_CLASS_1;
+        llc->event              = 0;
+        llc->state              = LLC_STATE_INACTIVE;
+	llc->state2		= LLC_STATE_ADM;
+	llc->build		= 0;
+	llc->build_pf		= 0;
+
+	llc->dsap		= 0;
+	llc->ssap		= 0;
+
+        llc->s_flag             = 0;
+        llc->p_flag             = 0;
+        llc->f_flag             = 0;
+        llc->data_flag          = 0;
+        llc->remote_busy        = 0;
+
+        llc->seq.vs             = 0;
+        llc->seq.vr             = 0;
+
+        llc->retry_count        = 0;
+	llc->window_count	= 0;
+	llc->xid_r_count	= 0;
+
+        llc->max_retry          = sysctl_max_retry;
+        llc->max_size           = sysctl_max_size;
+        llc->max_window         = sysctl_max_window;
+
+	memset(&llc->ack_timer, 0, sizeof(struct timer_list));
+        llc->ack_timer.function         = llc_ack_expire;
+        llc->ack_timer.data             = (unsigned long)llc;
+        llc->ack_expire                 = sysctl_ack_timer_expire;
+	memset(&llc->p_timer, 0, sizeof(struct timer_list));
+        llc->p_timer.function           = llc_p_expire;
+        llc->p_timer.data               = (unsigned long)&llc;
+        llc->p_expire                   = sysctl_p_timer_expire;
+	memset(&llc->rej_timer, 0, sizeof(struct timer_list));
+        llc->rej_timer.function         = llc_rej_expire;
+        llc->rej_timer.data             = (unsigned long)&llc;
+        llc->rej_expire                 = sysctl_rej_timer_expire;
+	memset(&llc->busy_timer, 0, sizeof(struct timer_list));
+        llc->busy_timer.function        = llc_busy_expire;
+        llc->busy_timer.data            = (unsigned long)&llc;
+        llc->busy_expire                = sysctl_busy_timer_expire;
+
+        skb_queue_head_init(&llc->rx_queue);
+        skb_queue_head_init(&llc->tx_queue);
+        skb_queue_head_init(&llc->retx_queue);
+
+        return (0);
+}
+
+static int llc_purge_queues(struct llc_pinfo *llc)
+{
+	struct sk_buff *skb;
+
+	while((skb = skb_dequeue(&llc->rx_queue)) != NULL)
+                kfree_skb(skb);
+        while((skb = skb_dequeue(&llc->tx_queue)) != NULL)
+                kfree_skb(skb);
+        while((skb = skb_dequeue(&llc->retx_queue)) != NULL)
+                kfree_skb(skb);
+
+	return (0);
+}
+
+/* Destroy a LLC client's data structure. */
+static int llc_destroy_client(struct llc_pinfo *llc)
+{
+	llc_purge_queues(llc);
+	llc_stop_all_timers(llc);
+        kfree(llc);
+
+        return (0);
+}
+
+static struct llc_sc_info *llc_find_sc(struct net_device *dev)
+{
+	struct llc_sc_info *sc;
+
+	for(sc = llc_sc_list; sc != NULL; sc = sc->next)
+        {
+                if(sc->dev->ifindex == dev->ifindex)
+                        return (sc);
+        }
+
+        return (NULL);
+}
+
+static struct datalink_proto *llc_find_client(__u8 type)
+{
+        struct datalink_proto *proto;
+
+        for(proto = llc_client_list; proto != NULL; proto = proto->next)
+        {
+                if(proto->ll_pinfo.llc->ssap == type)
+                        return (proto);
+        }
+
+        return (NULL);
+}
+
+/* Activate a SAP. (SAP_ACTIVATION_REQUEST)
+ * - SAPs are registered with every SC we have. I know this is
+ *   stupid, but the spec describes only how to handle 1 MAC, so lets
+ *   assume the user really wants to be on all MACs. JJS
+ */
+struct datalink_proto *register_8022_client(unsigned char type, 
+	int (*rcvfunc)(struct sk_buff*,struct net_device*,struct packet_type*),
+	int (*msgrcvfunc)(int rsp, struct sk_buff *))
+{
+        struct datalink_proto *proto;
+        struct llc_pinfo *llc;
+
+	if(llc_debug > 5)
+		printk("register_8022_client\n");
+
+	proto = llc_find_client(type);
+        if(proto != NULL)
+                return (NULL);
+        llc = (struct llc_pinfo *)kmalloc(sizeof(*llc), GFP_ATOMIC);
+        if(llc == NULL)
+                return (NULL);
+        proto = (struct datalink_proto *)kmalloc(sizeof(*proto), GFP_ATOMIC);
+        if(proto != NULL)
+        {
+                proto->ll_pinfo.llc = llc;
+                llc_sap_init(llc);
+		proto->type[0] 		= type;		/* XXX */
+                proto->type_len 	= 1;		/* XXX */
+                llc->ssap               = type;
+		llc->dl			= proto;
+		llc->rcvfunc 		= msgrcvfunc;
+                proto->rcvfunc          = rcvfunc;
+		proto->header_length 	= 3;	/* We default to 3. */
+                proto->datalink_header  = llc_datalink_header;
+                proto->string_name      = "802.2";
+
+                /* Add client to each SC sap list. */
+/*
+		for(sc = llc_sc_list; sc != NULL; sc = sc->next)
+		{
+			struct datalink_proto *dl_list = sc->llc_sap_list;
+                	proto->next    = dl_list;
+                	dl_list        = proto->next;
+		}
+*/
+		proto->next		= llc_client_list;
+		llc_client_list		= proto;
+
+        }
+
+	llc->state = LLC_STATE_ACTIVE;
+        MOD_INC_USE_COUNT;
+
+        return (proto);
+}
+
+/* Deactivate a SAP. (SAP_DEACTIVATION_REQUEST).
+ */
+void unregister_8022_client(unsigned char type)
+{
+        struct datalink_proto **clients = &llc_client_list;
+        struct datalink_proto *tmp;
+        struct llc_pinfo *llc;
+        unsigned long flags;
+
+        save_flags(flags);
+        cli();
+
+        while((tmp = *clients) != NULL)
+        {
+                llc = tmp->ll_pinfo.llc;
+                if(llc->ssap == type)
+                {
+                        *clients = tmp->next;
+                        llc_destroy_client(llc);
+                        kfree(tmp);
+			MOD_DEC_USE_COUNT;
+                        break;
+                }
+                else
+                        clients = &tmp->next;
+        }
+
+        restore_flags(flags);
+
+        return;
+}
+
+static struct packet_type p8022_packet_type =
+{
+        0,              /* Mutter.. ntohs(ETH_P_802_2). */
+        NULL,           /* NULL = All devices. */
+        llc_rcv,        /* Top level receive function. */
+        NULL,
+        NULL,
+};
+
+#ifdef CONFIG_PROC_FS
+static int llc_get_info_sc(char *buffer, char **start,
+        off_t offset, int length)
+{
+        off_t begin = 0;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+/*
+	len += sprintf(buffer, " ", ");
+
+	for(p = llc_sc_list; p != NULL; p = p->next)
+	{
+
+
+	}
+*/
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+static int llc_get_info_sap(char *buffer, char **start, 
+	off_t offset, int length)
+{
+	struct datalink_proto *p;
+	off_t pos = 0, begin = 0;
+        int len = 0;
+
+	/* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-5s%-5s%-6s%-6s%-6s%-7s%-9s%-8s%-8s%-10s\n", 
+		"dsap", "ssap", "class", "event", "state", "state2", "rmt_busy",
+		"rty_cnt", "win_cnt", "xid_r_cnt");
+
+	for(p = llc_client_list; p != NULL; p = p->next)
+	{
+		struct llc_pinfo *llc = p->ll_pinfo.llc;
+
+		len += sprintf(buffer + len, "%02X   %02X   %02X    %02X"
+			"    %02X    %02X     %-8d %-7d %-7d %-9d\n",
+			llc->dsap, llc->ssap, llc->class, llc->event, 
+			llc->state, llc->state2, llc->remote_busy, llc->retry_count,
+			llc->window_count, llc->xid_r_count);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif /* CONFIG_PROC_FS */
+
+static int llc_create_station_component(struct net_device *dev)
+{
+	struct llc_sc_info *sc;
+
+	/* IEEE 802.2 only supports Ethernet, TokenRing and FDDI. */
+        if(dev->type != ARPHRD_ETHER || dev->type != ARPHRD_IEEE802
+                || dev->type != ARPHRD_FDDI)
+        {
+                return (0);
+        }
+
+	sc = llc_find_sc(dev);
+	if(sc != NULL)
+		return (-EEXIST);
+
+	sc = (struct llc_sc_info *)kmalloc(sizeof(struct llc_sc_info),
+		GFP_ATOMIC);
+	if(sc == NULL)
+		return (-ENOMEM);
+
+	/* Initialize the SC */
+	sc->dev 	 = dev;
+	sc->llc_sap_list = NULL;
+	sc->state	 = LLC_STATE_DOWN;
+	sc->next 	 = llc_sc_list;
+	llc_sc_list 	 = sc->next;
+
+	return (0);
+}
+
+static int llc_destroy_station_component(struct net_device *dev)
+{
+	struct llc_sc_info **sc_clients = &llc_sc_list;
+        struct llc_sc_info *sc_tmp;
+	struct datalink_proto *sap_tmp;
+        unsigned long flags;
+
+        save_flags(flags);
+        cli();
+
+        while((sc_tmp = *sc_clients) != NULL)
+        {
+                if(sc_tmp->dev->ifindex == dev->ifindex)
+                {
+			/* Destroy All SAPs connected to this SC. */
+                        *sc_clients = sc_tmp->next;
+			for(sap_tmp = sc_tmp->llc_sap_list; sap_tmp != NULL; sap_tmp = sap_tmp->next)
+			{
+				struct llc_pinfo *llc = sap_tmp->ll_pinfo.llc;
+                        	llc_destroy_client(llc);
+				kfree(sap_tmp);
+			}
+
+                        kfree(sc_tmp);
+                        break;
+                }
+                else
+                        sc_clients = &sc_tmp->next;
+        }
+
+        restore_flags(flags);
+
+	return (0);
+}
+
+static int llc_sc_state(struct net_device *dev, int state)
+{
+	struct llc_sc_info *sc;
+
+	sc = llc_find_sc(dev);
+	if(sc == NULL)
+		return (-ENOENT);
+
+	sc->state = state;
+
+	return (0);
+}
+
+int llc_netdev_event(struct notifier_block *self, unsigned long event, 
+	void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+
+	/* IEEE 802.2 only supports Ethernet, TokenRing and FDDI. */
+	if(dev->type != ARPHRD_ETHER || dev->type != ARPHRD_IEEE802
+		|| dev->type != ARPHRD_FDDI)
+	{
+		return (NOTIFY_DONE);
+	}
+
+	if(event == NETDEV_REGISTER)
+	{
+		llc_create_station_component(dev);
+		llc_sc_state(dev, LLC_STATE_DOWN);
+	}
+	if(event == NETDEV_UNREGISTER)
+		llc_destroy_station_component(dev);
+	if(event == NETDEV_UP)
+		llc_sc_state(dev, LLC_STATE_UP);
+	if(event == NETDEV_DOWN)
+		llc_sc_state(dev, LLC_STATE_DOWN);
+
+	return (NOTIFY_DONE);
+}
+
+struct notifier_block nb_llc =
+{
+	llc_netdev_event,
+	NULL,
+	0
+};
+
+/* LLC protocol initialization. */
+void __init llc_init(void)
+{
+	struct llc_pinfo *llc;
+	struct datalink_proto *dl;
+	struct net_device *dev;
+
+        /* Receive all 802.2 packets on any device. */
+        p8022_packet_type.type = htons(ETH_P_802_2);
+        dev_add_pack(&p8022_packet_type);
+
+	/* Create LLC station component */
+	llc = (struct llc_pinfo *)kmalloc(sizeof(*llc), GFP_ATOMIC);
+        dl = (struct datalink_proto *)kmalloc(sizeof(*dl), GFP_ATOMIC);
+        dl->ll_pinfo.llc 	= llc;
+        llc_sap_init(llc);
+        dl->type[0]          	= 0x00;         /* XXX */
+        dl->type_len         	= 1;            /* XXX */
+        llc->ssap               = 0x00;
+        llc->dl                 = dl;
+        llc->rcvfunc            = NULL;
+        dl->rcvfunc          	= llc_rcv;
+        dl->header_length    	= 3;    	/* We default to 3. */
+        dl->datalink_header  	= llc_datalink_header;
+        dl->string_name      	= "802.2";
+	dl->next             	= llc_client_list;
+        llc_client_list         = dl;
+        llc->state = LLC_STATE_UP;
+
+	/* Scan all the existing interfaces for IEEE 802.2
+	 * compatible devices, add the device to our list if it
+	 * is available for llc transfers.
+	 */
+	rtnl_lock();
+	for(dev = dev_base; dev != NULL; dev = dev->next)
+	{
+		/* llc_create_station_component will toss the device
+		 * if it is not an 802.2 MAC device.
+		 */
+		if(dev->flags & IFF_UP)
+		{
+			llc_create_station_component(dev);
+			llc_sc_state(dev, LLC_STATE_UP);
+		}
+	}
+	rtnl_unlock();
+
+	/* Attach a device notifier so we can watch for devices
+	 * going up and down.
+	 */
+	register_netdevice_notifier(&nb_llc);
+
+#ifdef CONFIG_PROC_FS
+        proc_net_create("llc_sap", 0, llc_get_info_sap);
+#endif /* CONFIG_PROC_FS */
+
+#ifdef CONFIG_SYSCTL
+        llc_register_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+        printk(KERN_INFO "ANSI/IEEE 802.2 v0.12 for Linux NET4.0\n");
+
+        return;
+}
+
+void __exit llc_exit(void)
+{
+	struct llc_sc_info *sc;
+
+        /* Remove out notifier from the netdevice layer. */
+        unregister_netdevice_notifier(&nb_llc);
+
+        /* Destroy all the station components (SC),
+         * SAP clients are already disconnected and freed.
+         */
+        for(sc = llc_sc_list; sc != NULL; sc = sc->next)
+                kfree(sc);
+
+        /* Remove the dev latch for 802.2 packets. */
+        dev_remove_pack(&p8022_packet_type);
+
+#ifdef CONFIG_PROC_FS
+        proc_net_remove("llc");
+#endif /* CONFIG_PROC_FS */
+
+#ifdef CONFIG_SYSCTL
+        llc_unregister_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+        return;
+}
+
+EXPORT_SYMBOL(register_8022_client);
+EXPORT_SYMBOL(unregister_8022_client);
+EXPORT_SYMBOL(llc_queue_xmit);
+EXPORT_SYMBOL(llc_decode_pdu);
+EXPORT_SYMBOL(llc_connect);
+EXPORT_SYMBOL(llc_disconnect);
+EXPORT_SYMBOL(llc_reset);
+EXPORT_SYMBOL(llc_data);
+EXPORT_SYMBOL(llc_test);
+
+module_init(llc_init);
+module_exit(llc_exit);
diff -ruN linux-2.4.4/net/llc/sysctl_net_llc.c linux/net/llc/sysctl_net_llc.c
--- linux-2.4.4/net/llc/sysctl_net_llc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/llc/sysctl_net_llc.c	Mon May 14 19:29:43 2001
@@ -0,0 +1,79 @@
+/* -*- linux-c -*-
+ *	sysctl_net_llc.c: sysctl interface to net 802 subsystem.
+ * 
+ *	Begun April 1, 1996, Mike Shaver.
+ *	Added /proc/sys/net/llc directory entry (empty =) ). [MS]
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+#include <linux/config.h>
+
+extern int sysctl_max_retry;
+extern int sysctl_max_size;
+extern int sysctl_max_window;
+extern int sysctl_ack_timer_expire;
+extern int sysctl_p_timer_expire;
+extern int sysctl_rej_timer_expire;
+extern int sysctl_busy_timer_expire;
+extern int llc_debug;
+
+#ifdef CONFIG_SYSCTL
+static ctl_table llc_table[] = {
+        {NET_LLC_MAX_RETRY, "llc-max-retransmission",
+        &sysctl_max_retry, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_MAX_SIZE, "llc-max-pdu-size",
+        &sysctl_max_size, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_MAX_WINDOW, "llc-max-window-size",
+        &sysctl_max_window, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_ACK_TIMER_EXPIRE, "llc-ack-timer-expire",
+        &sysctl_ack_timer_expire, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_P_TIMER_EXPIRE, "llc-p-timer-expire",
+        &sysctl_p_timer_expire, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_REJ_TIMER_EXPIRE, "llc-reject-timer-expire",
+        &sysctl_rej_timer_expire, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_LLC_BUSY_TIMER_EXPIRE, "llc-busy-timer-expire",
+        &sysctl_busy_timer_expire, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_LLC_DEBUG, "debug-level",
+	&llc_debug, sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+        {0}
+};
+
+static ctl_table llc_dir_table[] = {
+	{NET_LLC, "llc", NULL, 0, 0555, llc_table},
+        {0}
+};
+
+static ctl_table llc_root_table[] = {
+        {CTL_NET, "net", NULL, 0, 0555, llc_dir_table},
+        {0}
+};
+
+static struct ctl_table_header *llc_table_header;
+
+void llc_register_sysctl(void)
+{
+        llc_table_header = register_sysctl_table(llc_root_table, 1);
+}
+
+void llc_unregister_sysctl(void)
+{
+        unregister_sysctl_table(llc_table_header);
+}
+
+#else
+
+void llc_register_sysctl(void)
+{
+}
+
+void llc_unregister_sysctl(void)
+{
+}
+
+#endif /* CONFIG_SYSCTL */
diff -ruN linux-2.4.4/net/netsyms.c linux/net/netsyms.c
--- linux-2.4.4/net/netsyms.c	Fri Apr 27 14:15:01 2001
+++ linux/net/netsyms.c	Mon May 14 20:26:06 2001
@@ -53,6 +53,12 @@
 #include <linux/mroute.h>
 #include <linux/igmp.h>
 
+#include <net/cpic.h>
+
+/* Attach */
+extern int attach_register(struct attach_ops *ops);
+extern int attach_unregister(int family);
+
 extern struct net_proto_family inet_family_ops;
 
 #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE) || defined (CONFIG_KHTTPD) || defined (CONFIG_KHTTPD_MODULE)
@@ -75,9 +81,7 @@
 
 #ifdef CONFIG_IPX_MODULE
 extern struct datalink_proto   *make_EII_client(void);
-extern struct datalink_proto   *make_8023_client(void);
 extern void destroy_EII_client(struct datalink_proto *);
-extern void destroy_8023_client(struct datalink_proto *);
 #endif
 
 #ifdef CONFIG_ATALK_MODULE
@@ -156,6 +160,15 @@
 EXPORT_SYMBOL(sock_kmalloc);
 EXPORT_SYMBOL(sock_kfree_s);
 
+EXPORT_SYMBOL(cpic_register_side_info);
+EXPORT_SYMBOL(cpic_unregister_side_info);
+EXPORT_SYMBOL(cpic_query_side_info);
+EXPORT_SYMBOL(cpic_get_info_side);
+EXPORT_SYMBOL(cpic_register);
+EXPORT_SYMBOL(cpic_unregister);
+EXPORT_SYMBOL(attach_register);
+EXPORT_SYMBOL(attach_unregister);
+
 #ifdef CONFIG_FILTER
 EXPORT_SYMBOL(sk_run_filter);
 EXPORT_SYMBOL(sk_chk_filter);
@@ -205,8 +218,6 @@
 EXPORT_SYMBOL(memcpy_toiovec);
 
 #ifdef CONFIG_IPX_MODULE
-EXPORT_SYMBOL(make_8023_client);
-EXPORT_SYMBOL(destroy_8023_client);
 EXPORT_SYMBOL(make_EII_client);
 EXPORT_SYMBOL(destroy_EII_client);
 #endif
@@ -460,6 +471,7 @@
 EXPORT_SYMBOL(__dev_get_by_index);
 EXPORT_SYMBOL(dev_get_by_name);
 EXPORT_SYMBOL(__dev_get_by_name);
+EXPORT_SYMBOL(dev_getbyhwaddr);
 EXPORT_SYMBOL(netdev_finish_unregister);
 EXPORT_SYMBOL(netdev_set_master);
 EXPORT_SYMBOL(eth_type_trans);
@@ -513,6 +525,13 @@
 #ifdef CONFIG_INET
 EXPORT_SYMBOL(sysctl_ip_default_ttl);
 #endif
+#endif
+
+#if defined(CONFIG_IPX) || defined(CONFIG_IPX_MODULE)
+extern struct datalink_proto *make_8023_client(void);
+extern void destroy_8023_client(struct datalink_proto *dl);
+EXPORT_SYMBOL(make_8023_client);
+EXPORT_SYMBOL(destroy_8023_client);
 #endif
 
 /* Packet scheduler modules want these. */
diff -ruN linux-2.4.4/net/sna/Config.in linux/net/sna/Config.in
--- linux-2.4.4/net/sna/Config.in	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/Config.in	Mon May 14 19:28:58 2001
@@ -0,0 +1,15 @@
+#
+# Linux-SNA Configuration
+#
+
+bool '  SNA: IEEE 802.2 device support' CONFIG_SNA_LLC
+if [ "$CONFIG_SNA_LLC" = "y" ]; then
+  bool '  SNA: LAN Address Resolution' CONFIG_SNA_LAR
+fi
+bool '  SNA: Loopback device support' CONFIG_SNA_LOOPBACK
+bool '  SNA: ATM device support (EXPERIMENTAL)' CONFIG_SNA_ATM
+bool '  SNA: IBM compliant channel device support (EXPERIMENTAL)' CONFIG_SNA_CHANNEL
+bool '  SNA: SDLC device support (EXPERIMENTAL)' CONFIG_SNA_SDLC
+bool '  SNA: X.25 device support (EXPERIMENTAL)' CONFIG_SNA_X25
+bool '  SNA: TwinAxial device support (EXPERIMENTAL)' CONFIG_SNA_TWINAX
+bool '  SNA: Coaxial device supprt (EXPERIMENTAL)' CONFIG_SNA_COAX
diff -ruN linux-2.4.4/net/sna/Makefile linux/net/sna/Makefile
--- linux-2.4.4/net/sna/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/Makefile	Mon May 14 19:28:58 2001
@@ -0,0 +1,27 @@
+#
+# Makefile for the Linux Systems Network Architecture layer.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := sna.o
+
+export-objs := af_sna.o 
+
+obj-y := af_sna.o sna_ebcdic.o sna_nof.o sna_cs.o sna_asm.o sna_cosm.o \
+	    sna_ds.o sna_isr.o sna_pc.o sna_rss.o sna_ss.o sna_tdm.o \
+	    sna_dlc.o sna_lar.o sna_trs.o sna_rm.o sna_sm.o \
+	    sna_hsr.o sna_tc.o sna_dfc.o sna_appc.o sna_attach.o \
+	    sna_cpic.o sna_ps_main.o sna_ps_conv.o sna_ps_copr.o sna_ps_mc.o \
+	    sna_ps_sync.o
+obj-m := $(O_TARGET)
+
+obj-$(CONFIG_SYSCTL) += sysctl_net_sna.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+		tar -cvf /dev/f1 .
diff -ruN linux-2.4.4/net/sna/af_sna.c linux/net/sna/af_sna.c
--- linux-2.4.4/net/sna/af_sna.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/af_sna.c	Mon May 14 21:30:45 2001
@@ -0,0 +1,731 @@
+/* af_sna.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#if defined(CONFIG_SNA) || defined(CONFIG_SNA_MODULE)
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/ctype.h>
+
+#include <linux/sna.h>
+#include <linux/cpic.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <linux/llc.h>
+#include <net/llc.h>
+#endif
+
+#ifdef CONFIG_SYSCTL
+extern inline void sna_register_sysctl(void);
+extern inline void sna_unregister_sysctl(void);
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_net_sna = NULL;
+#endif
+
+static struct proto_ops sna_ops;
+
+char sna_version[] = "1.00pre14";
+char sna_maintainer[] = "Jay Schulist <jschlst@samba.org>";
+char sna_product_id[] = "WiskClean";
+char sna_product_name[] = "Linux-SNA";
+
+__u32	sysctl_max_link_stations_cnt;
+__u32	sysctl_max_lu_cnt;
+__u32	sysctl_max_mode_cnt;
+__u32	sysctl_max_inbound_activations;
+__u32	sysctl_max_outbound_activations;
+__u32	sysctl_max_retry_limit;
+__u32	sysctl_max_btu_size;
+__u32	sysctl_max_tx_ru_size;
+__u32	sysctl_max_rx_ru_size;
+__u32	sysctl_max_auto_activation_limit;
+__u32	sysctl_bind_pacing_cnt;
+__u32	sna_debug_level = 0;
+
+#define MAX_SNA_ADDR		1024
+
+#ifdef CONFIG_SNA_LLC
+/* Display an Ethernet address in readable format. */
+char *sna_pr_ether(unsigned char *ptr)
+{
+  	static char buff[64];
+
+  	sprintf(buff, "%02X%02X%02X%02X%02X%02X",
+        	(ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+        	(ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377));
+  	return(buff);
+}
+#endif
+
+char *sna_pr_nodeid(struct sna_nodeid *n)
+{
+        static char buff[20];
+
+        sprintf(buff, "%03X%05X", n->block_id, n->pu_id);
+
+        return (buff);
+}
+
+/* display a padded netid correctly */
+char *sna_pr_netid(struct sna_netid *n)
+{
+        struct sna_netid p;
+	char *buff;
+        int i;
+
+	buff = (char *)kmalloc(20, GFP_ATOMIC);
+        memcpy(&p, n, sizeof(struct sna_netid));
+        for(i = 0; p.net[i] != 0x20; i++); p.net[i] = 0;
+        for(i = 0; p.name[i] != 0x20; i++); p.name[i] = 0;
+        sprintf(buff, "%s.%s", p.net, p.name);
+
+        return (buff);
+}
+
+int sna_utok(void *uaddr, int ulen, void *kaddr)
+{
+        if(ulen < 0|| ulen > MAX_SNA_ADDR)
+                return (-EINVAL);
+        if(ulen == 0)
+                return (0);
+        if(copy_from_user(kaddr,uaddr,ulen))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_ktou(void *kaddr, int klen, void *uaddr)
+{
+        if(klen < 0 || klen > MAX_SNA_ADDR)
+                return (-EINVAL);
+        if(klen)
+        {
+                if(copy_to_user(uaddr,kaddr,klen))
+                        return (-EFAULT);
+        }
+        return (0);
+}
+
+struct sna_netid *sna_char_to_netid(unsigned char *b)
+{
+        struct sna_netid *n;
+	unsigned char c[40];
+        int i;
+
+	sna_debug(5, "sna_char_to_netid %s\n", b);
+	strcpy(c, b);	/* always use protection */
+        n = (struct sna_netid *)kmalloc(sizeof(struct sna_netid), GFP_KERNEL);
+        strcpy(n->name, strpbrk(c, ".")+1);
+        for(i = 0; i < 8; i++)
+                n->name[i] = toupper(n->name[i]);
+        for(i = strlen(n->name); i < 8; i++)
+                n->name[i] = 0x20;
+        strcpy(n->net, strtok(c, "."));
+        for(i = 0; i < 8; i++)
+                n->net[i] = toupper(n->net[i]);
+	for(i = strlen(n->net); i < 8; i++)
+                n->net[i] = 0x20;
+        return (n);
+} 
+
+int sna_netid_to_char(struct sna_netid *n, unsigned char *c)
+{
+	int len = 0, i;
+
+	sna_debug(5, "sna_netid_to_char %s.%s\n", n->net, n->name);
+	for(i = 0; i < 8 && (n->net[i] != 0x20); i++)
+		/* Nothing */ ;
+	len = i;
+	strncpy(c, n->net, i);
+	len = i + 1;
+	strncpy(c + i, ".", 1);
+	for(i = 0; i < 8 && (n->name[i] != 0x20); i++)
+		/* Nothing */ ;
+	strncpy(c + len, n->name, i);
+	len += i;
+	strncpy(c + len, "\0", 1);
+	sna_debug(5, "finished string is (%s) length is (%d) (%d)\n",
+		c, strlen(c), len);
+
+	return (len);
+}
+
+/* Temporary HexDump function. */
+int hexdump(unsigned char *pkt_data, int pkt_len)
+{
+        int i;
+
+        while(pkt_len>0)
+        {
+                printk("  ");   /* Leading spaces. */
+
+                /* Print the HEX representation. */
+                for(i=0; i<8; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i] & 0xFF);
+                        else
+                                printk("  ");
+                }
+
+                printk(":");
+
+                for(i=8; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                                printk("%2.2X ", pkt_data[i]&0xFF);
+                        else
+                                printk("  ");
+                }
+
+                /* Print the ASCII representation. */
+                printk("  ");
+
+                for(i=0; i<16; ++i)
+                {
+                        if(pkt_len - (long)i>0)
+                        {
+                                if(isprint(pkt_data[i]))
+                                        printk("%c", pkt_data[i]);
+                                else
+                                        printk(".");
+                        }
+                }
+
+                printk("\n");
+                pkt_len -= 16;
+                pkt_data += 16;
+        }
+
+        printk("\n");
+
+	return (0);
+}
+
+/* Create a SNA socket. */
+static int sna_create(struct socket *sock, int protocol)
+{
+	struct sock *sk = sock->sk;
+
+	sna_debug(5, "sna_create\n");
+	sk = sk_alloc(PF_SNA, GFP_KERNEL, 1);
+	if(sk == NULL)
+		return (-ENOMEM);
+
+	switch(sock->type)
+	{
+		case (SOCK_STREAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_DGRAM):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_RAW):
+			sock->ops = &sna_ops;
+			break;
+
+		case (SOCK_SEQPACKET):
+			sock->ops = &sna_ops;
+			break;
+
+		default:
+			sk_free((void *)sk);
+			return (-ESOCKTNOSUPPORT);
+	}
+
+	MOD_INC_USE_COUNT;
+
+	sock_init_data(sock, sk);
+
+	sk->destruct = NULL;
+        sk->zapped = 1;
+
+        return (0);
+}
+
+static int sna_destroy_socket(struct sock *sk)
+{
+	sna_debug(5, "sna_destroy_socket\n");
+
+	MOD_DEC_USE_COUNT;
+
+	return (0);
+}
+
+static int sna_release(struct socket *sock)
+{
+	struct sock *sk=sock->sk;
+
+	sna_debug(5, "sna_release\n");
+
+        if(sk == NULL)
+                return (0);
+
+        if(!sk->dead)
+                sk->state_change(sk);
+
+        sk->dead = 1;
+        sock->sk = NULL;
+	sna_destroy_socket(sk);
+
+	return (0);
+}
+
+static int sna_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	return (0);
+}
+
+static int sna_connect(struct socket *sock, struct sockaddr *uaddr,
+	int addr_len, int flags)
+{
+	return (0);
+}
+
+static int sna_accept(struct socket *sock, struct socket *newsock, int flags)
+{
+	return (0);
+}
+
+static unsigned int sna_poll(struct file * file, struct socket *sock,
+	poll_table *pt)
+{
+	return (0);
+}
+
+static int sna_getname(struct socket *sock, struct sockaddr *uaddr,
+	int *uaddr_len, int peer)
+{
+	return (0);
+}
+
+static int sna_transmit(struct sock *sk, struct sk_buff *skb, int size)
+{
+	sna_debug(5,"SNA tx'd packet!/n");
+
+	kfree_skb(skb);
+
+	return (0);
+}
+
+/* This is the Linux frontend to the SNA transmit code.
+ * For now this is just a fake sendmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */ 
+static int sna_sendmsg(struct socket *sock, struct msghdr *msg, int size,
+	struct scm_cookie *scm)
+{
+	struct sock *sk = sock->sk;
+        int flags = msg->msg_flags;
+        struct sk_buff *skb;
+	int err;
+
+	if(size > 10000)	/* Fake max. */
+		return (-EMSGSIZE);
+	if(flags&~MSG_DONTWAIT)
+                return (-EINVAL);
+
+	cli();
+        skb = sock_alloc_send_skb(sk, size, flags&MSG_DONTWAIT, &err);
+        if(skb == NULL)
+                return (err);
+        sti();
+
+        skb->sk = sk;
+
+	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+        if(err)
+        {
+                kfree_skb(skb);
+                return (-EFAULT);
+        }
+
+	err = sna_transmit(sk, skb, size);
+	if(err)
+		return (-EAGAIN);
+
+	return (size);
+}
+
+#ifdef NOT
+static int sna_rcv(struct sk_buff *skb, struct net_device *dev, 
+	struct packet_type *pt)
+{
+	sna_debug(5, "SNA rx'd packet!\n");
+
+	kfree_skb(skb);
+
+	return (0);
+}
+#endif
+
+/* This function is the Linux frontend to the SNA receive code.
+ * For now this is just a fake recvmsg routine to allow packet transfers,
+ * this will change as soon as the SNA backend is hooked up.
+ */
+static int sna_recvmsg(struct socket *sock, struct msghdr *msg, int size,
+	int flags, struct scm_cookie *scm)
+{
+	return (-EINVAL);
+	return (0);
+}
+
+static int sna_shutdown(struct socket *sk, int how)
+{
+	return (-EOPNOTSUPP);
+}
+
+/* SNA ioctl calls. */
+static int sna_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd)
+	{
+		case (SIOCGNODE):
+		case (SIOCGDLC):
+		case (SIOCGPORT):
+		case (SIOCGLS):
+		case (SIOCGMODE):
+		case (SIOCGLU):
+		case (SIOCGPLU):
+		case (SIOCGCOS):
+			return (sna_nof_ioctl(cmd, (void *)arg));
+
+		case (SIOCGLAR):		/* LAR Search/Find */
+			return (sna_lar_ioctl(cmd, (void *)arg));
+
+		case (SIOCGCPICS):
+			return (sna_cpic_ioctl(cmd, (void *)arg));
+
+#ifdef NOT
+		case (SIOPS):
+			return (sna_ps_ioctl(cmd, (void *)arg));
+#endif
+
+		default:
+			return (-EOPNOTSUPP);
+	}
+
+	return (0);
+}
+
+static int sna_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+	sna_debug(5, "sna_setsockopt\n");
+
+        switch(level)
+        {
+		case (SOL_SNA_NOF):
+			err = sna_nof_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef CONFIG_SNA_LAR
+		case (SOL_SNA_LAR):
+			err = sna_lar_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+#ifdef NOT
+		case (SOL_SNA_PS):
+			err = sna_ps_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		case (SOL_SNA_CPIC):
+			err = sna_cpic_setsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+		default:
+			return (-ENOPROTOOPT);
+	}
+
+	return (err);
+}
+
+static int sna_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+	int err;
+
+	sna_debug(5, "sna_getsockopt\n");
+
+        switch(level)
+        {
+		case (SOL_SNA_NOF):
+			err = sna_nof_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+
+#ifdef CONFIG_SNA_LAR
+		case (SOL_SNA_LAR):
+			err = sna_lar_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+#ifdef NOT
+		case (SOL_SNA_PS):
+			err = sna_ps_getsockopt(sock, level, optname,
+				optval, optlen);
+			break;
+#endif
+
+		default:
+			return (-ENOPROTOOPT);
+        }
+
+	return (err);
+}
+
+void sna_mod_inc_use_count(void)
+{
+	MOD_INC_USE_COUNT;
+}
+
+void sna_mod_dec_use_count(void)
+{
+	MOD_DEC_USE_COUNT;
+}
+
+static struct net_proto_family sna_family_ops =
+{
+	PF_SNA,
+	sna_create
+};
+
+static struct proto_ops sna_ops =
+{
+	PF_SNA,
+	sna_release,
+	sna_bind,
+	sna_connect,
+	sock_no_socketpair,
+	sna_accept,
+	sna_getname,
+	sna_poll,
+	sna_ioctl,
+	sock_no_listen,
+	sna_shutdown,
+	sna_setsockopt,		/* Okay. */
+	sna_getsockopt,		/* Okay. */
+	sna_sendmsg,
+	sna_recvmsg,
+	sock_no_mmap
+};
+
+#ifdef CONFIG_PROC_FS
+static void sna_proc_init(void)
+{
+        if(!proc_net_sna)
+        {
+                struct proc_dir_entry *ent;
+                ent = proc_mkdir("net/sna", 0);
+                if(ent)
+                {
+                        ent->owner = THIS_MODULE;
+                        proc_net_sna = ent;
+                }
+        }
+}
+
+static void sna_proc_cleanup(void)
+{
+        if(proc_net_sna)
+        {
+                proc_net_sna = NULL;
+                remove_proc_entry("net/sna", 0);
+        }
+}
+
+inline struct proc_dir_entry *proc_sna_create(const char *name,
+        mode_t mode, get_info_t *get_info)
+{
+        return create_proc_info_entry(name,mode,proc_net_sna,get_info);
+}
+
+inline void proc_sna_remove(const char *name)
+{
+        remove_proc_entry(name,proc_net_sna);
+}
+#endif
+
+/* Watch the network devices to see if we need to add/delete/start/stop
+ * a data link control. (Device)
+ */
+int sna_netdev_event(struct notifier_block *self, unsigned long event,
+        void *data)
+{
+        struct net_device *dev = (struct net_device *)data;
+
+        if(event == NETDEV_UP)
+                sna_nof_define_dlc(dev);
+        if(event == NETDEV_DOWN)
+                sna_nof_delete_dlc(dev);
+
+        return (NOTIFY_DONE);
+}
+
+struct notifier_block nb_sna =
+{
+        sna_netdev_event,
+        NULL,
+        0
+};
+
+int __init sna_init(void)
+{
+	struct net_device *dev;
+
+	/* Scan all the existing interfaces for SNA
+         * compatible devices, add the device to our list if it
+         * is available for sna transfers.
+         */
+        rtnl_lock();
+        for(dev = dev_base; dev != NULL; dev = dev->next)
+        {
+                if(dev->flags & IFF_UP)
+                        sna_nof_define_dlc(dev);
+        }
+        rtnl_unlock();
+
+        /* Attach a device notifier so we can watch for devices
+         * going up and down.
+         */
+        register_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_PROC_FS
+        sna_proc_init();
+	proc_sna_create("virtual_nodes", 0, sna_nof_get_info);
+	proc_sna_create("devices", 0, sna_cs_get_info_dlc);
+	proc_sna_create("ports", 0, sna_cs_get_info_port);
+	proc_sna_create("link_stations", 0, sna_cs_get_info_ls);
+	proc_sna_create("modes", 0, sna_rm_get_info_mode);
+
+	proc_sna_create("local_lus", 0, sna_rm_get_info_local_lu);
+	proc_sna_create("remote_lus", 0, sna_rm_get_info_remote_lu);
+
+	proc_sna_create("cpic_side_information", 0, sna_cpic_get_info_side);
+	proc_sna_create("cpic_conversations", 0, sna_cpic_get_info);
+
+	proc_sna_create("cos_levels", 0, sna_cosm_get_info);
+	proc_sna_create("cos_tg_characteristics", 0, sna_cosm_get_info_tg);
+	proc_sna_create("cos_node_characteristics", 0, sna_cos_get_info_node);
+
+	proc_sna_create("node_map", 0, sna_tdm_get_info);
+	proc_sna_create("transmission_groups", 0, sna_tdm_get_info_tg);
+
+	proc_sna_create("path_controls", 0, sna_pc_get_info_tg);
+
+	proc_sna_create("asm_active_address_space", 0, sna_asm_get_info);
+	proc_sna_create("asm_active_lfsids", 0, sna_asm_get_active_lfsids);
+
+#ifdef CONFIG_SNA_LAR
+        proc_sna_create("lan_address_discovery", 0, sna_lar_get_info);
+#endif
+#endif
+
+#ifdef CONFIG_SNA_LAR
+	sna_lar_create();
+#endif
+
+        printk(KERN_INFO "Linux-SNA (System Network Architecture) "
+		"v%s for Linux NET4.0\n", sna_version);
+
+	(void) sock_register(&sna_family_ops);
+
+#ifdef CONFIG_SYSCTL
+        sna_register_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+        return (0);
+}
+
+void __exit sna_exit(void)
+{
+	/* Remove out notifier from the netdevice layer. */
+        unregister_netdevice_notifier(&nb_sna);
+
+#ifdef CONFIG_SNA_LAR
+	sna_lar_destroy();
+#endif
+
+#ifdef CONFIG_SYSCTL
+        sna_unregister_sysctl();
+#endif /* CONFIG_SYSCTL */
+
+#ifdef CONFIG_PROC_FS
+#ifdef CONFIG_SNA_LAR
+	proc_sna_remove("lan_address_discovery");
+#endif
+	proc_sna_remove("cpic_conversations");
+	proc_sna_remove("cpic_side_information");
+	proc_sna_remove("remote_lus");
+	proc_sna_remove("local_lus");
+	proc_sna_remove("modes");
+	proc_sna_remove("link_stations");
+	proc_sna_remove("ports");
+	proc_sna_remove("devices");
+	proc_sna_remove("virtual_nodes");
+        sna_proc_cleanup();
+#endif
+
+	sock_unregister(PF_SNA);
+
+        return;
+}
+
+EXPORT_SYMBOL(hexdump);
+EXPORT_SYMBOL(sna_utok);
+EXPORT_SYMBOL(sna_ktou);
+
+module_init(sna_init);
+module_exit(sna_exit);
+#endif /* CONFIG_SNA || CONFIG_SNA_MODULE */
diff -ruN linux-2.4.4/net/sna/sna_appc.c linux/net/sna/sna_appc.c
--- linux-2.4.4/net/sna/sna_appc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_appc.c	Mon May 14 21:07:55 2001
@@ -0,0 +1,41 @@
+/* sna_appc.c: Linux Systems Network Architecture implementation
+ * - SNA Advanced Program to Program Communications (APPC).
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
diff -ruN linux-2.4.4/net/sna/sna_asm.c linux/net/sna/sna_asm.c
--- linux-2.4.4/net/sna/sna_asm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_asm.c	Mon May 14 21:08:06 2001
@@ -0,0 +1,341 @@
+/* sna_asm.c: Linux Systems Network Architecture implementation
+ * - Linux-SNA Address Space Manager (Connect HS to PC).
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_asm_pinfo *asm_clients = NULL;
+
+/* Display a Path Control ID */
+char *sna_asm_pr_pcid(unsigned char *ptr)
+{
+        static char buff[64];
+
+        sprintf(buff, "%02X%02X%02X%02X%02X%02X%02X%02X",
+                (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+                (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377),
+                (ptr[6] & 0377), (ptr[7] & 0377));
+        return(buff);
+}
+
+struct sna_asm_pinfo *sna_asm_find_by_pcid(unsigned char *pc_id)
+{
+	struct sna_asm_pinfo *a;
+
+	sna_debug(5, "sna_asm_find_by_pcid\n");
+	for(a = asm_clients; a != NULL; a = a->next)
+		if(!memcmp(&a->pc_id, pc_id, 8))
+			return (a);
+
+	return (NULL);
+}
+
+struct sna_lfsid_block *sna_asm_find_lblk_by_lfsid(struct sna_lfsid *lfsid)
+{
+        struct sna_asm_pinfo *a;
+        struct sna_lfsid_block *l;
+	int i;
+
+	sna_debug(5, "sna_asm_find_lfsid_by_lfsid\n");
+        for(a = asm_clients; a != NULL; a = a->next)
+                for(l = a->l_blks; l != NULL; l = l->next)
+			for(i = 0; i < 256; i++)
+                        	if(!memcmp(lfsid, &l->l[i].lfsid, 
+					sizeof(struct sna_lfsid)))
+                                	return (l);
+        return (NULL);
+}
+
+int sna_asm_activate_as(struct sna_activate_as *as)
+{
+	struct sna_asm_pinfo *a;
+
+	sna_debug(5, "sna_asm_activate_asm\n");
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if(a)
+		return (-EEXIST);
+
+	a = (struct sna_asm_pinfo *)kmalloc
+		(sizeof(struct sna_asm_pinfo), GFP_ATOMIC);
+	memcpy(&a->pc_id, &as->pc_id, 8);
+	a->intranode			= as->intranode;
+	a->odai				= as->odai;
+	a->max_btu			= as->max_btu;
+	a->tx_rx_bind_pacing		= as->tx_rx_bind_pacing;
+	a->dependent_lulu		= as->dependent_lulu;
+	a->adp_bind_pacing_dep_lulu	= as->adp_bind_pacing_dep_lulu;
+	a->generalized_oadi		= as->generalized_oadi;
+	a->next				= asm_clients;
+	asm_clients			= a;
+	kfree(as);
+
+        return (0);
+}
+
+int sna_asm_deactivate_as(unsigned char *pc_id)
+{
+	struct sna_asm_pinfo *a, **clients = &asm_clients;
+
+	sna_debug(5, "sna_asm_deactivate_as\n");
+        while((a = *clients) != NULL)
+        {
+		if(!memcmp(&a->pc_id, pc_id, 8))
+                {
+                        *clients = a->next;
+                        kfree(a);
+                        return (0);
+                }
+                clients = &a->next;
+        }
+
+        return (-ENOENT);
+}
+
+/* Locate address space, look for a free lfsid, if not in any of the
+ * existing blocks, then allocate a new block, return a fresh lfsid.
+ */
+int sna_asm_assign_lfsid(struct sna_assign_lfsid *as)
+{
+	struct sna_asm_pinfo *a;
+	struct sna_lfsid_block *l;
+	int i, blk_num = 0;
+
+	sna_debug(5, "sna_asm_assign_lfsid (%s)\n", sna_asm_pr_pcid(as->pc_id));
+	a = sna_asm_find_by_pcid(as->pc_id);
+	if(!a)
+		return (-ENOENT);
+
+restart:
+	/* search for a free lfsid */
+	for(l = a->l_blks; l != NULL; l = l->next)
+	{
+		blk_num++;
+		for(i = 0; i < 256; i++)
+		{
+			if(l->l[i].active)	/* lfsid is in use */
+				continue;
+
+			/* found a non-active lfsid */
+			l->l[i].active 		= 1;
+			l->l[i].sm_id		= as->sm_id;
+
+			/* We dynamicly assign the lfsid on request */
+			l->l[i].lfsid.odai	= a->odai;
+			l->l[i].lfsid.sid.raw	= ((blk_num * 256) - 256) + i;
+			memcpy(&as->lfsid, &l->l[i].lfsid, 
+				sizeof(struct sna_lfsid));
+			return (0);
+		}
+	}
+
+	/* could not find any non-active lfsids in already alloc'd blocks */
+	l = (struct sna_lfsid_block *)kmalloc(sizeof(struct sna_lfsid_block),
+		GFP_ATOMIC);
+	if(!l)
+		return (-ENOMEM);
+	memset(&l, 0, sizeof(struct sna_lfsid_block));
+	l->next		= a->l_blks;
+	a->l_blks 	= l;
+	a->blk_count++;
+	goto restart;	/* just added 256 addresses, lets try it again */
+}
+
+int sna_asm_free_lfsid(struct sna_free_lfsid *f)
+{
+	struct sna_asm_pinfo *a;
+        struct sna_lfsid_block *l;
+        int i;
+
+	sna_debug(5, "sna_asm_free_lfsid (%s)\n", sna_asm_pr_pcid(f->pc_id));
+        a = sna_asm_find_by_pcid(f->pc_id);
+        if(!a)
+                return (-ENOENT);
+
+	/* locate the lfsid */
+        for(l = a->l_blks; l != NULL; l = l->next)
+        {
+		for(i = 0; i < 256; i ++)
+		{
+			if(l->l[i].active && (l->l[i].sm_id == f->sm_id)
+				&& (l->l[i].lfsid.odai == f->lfsid.odai)
+				&& (l->l[i].lfsid.sid.raw == f->lfsid.sid.raw))
+			{
+				l->l[i].active 	= 0;
+				l->l[i].sm_id	= 0;
+				memset(&l->l[i].lfsid, 0, 
+					sizeof(struct sna_lfsid));
+				return (0);
+			}
+		}
+	}
+
+	return (-ENOENT);
+}
+
+int sna_asm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_asm_create %s\n", start->netid.name);
+
+        return (0);
+}
+
+int sna_asm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_asm_pinfo *a;
+	struct sna_lfsid_block *l;
+
+	sna_debug(5, "sna_asm_destroy\n");
+	for(a = asm_clients; a != NULL; a = a->next)
+	{
+		for(l = a->l_blks; l != NULL; l = l->next)
+			kfree(l);
+		kfree(a);
+	}
+
+        return (0);
+}
+
+/* receive and process bind data */
+int sna_asm_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	struct sna_lfsid_block *l;
+
+	sna_debug(5, "sna_asm_rcv_bind\n");
+	l = sna_asm_find_lblk_by_lfsid(lfsid);
+	if(!l)
+	{
+		kfree(lfsid);
+		kfree_skb(skb);
+		return (-ENOENT);
+	}
+
+	/* for now we kinda cheat and just send to sm rightaway... */
+	sna_sm_process_mu(skb, l);
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_asm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_asm_pinfo *a;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-9s%-8s%-6s%-5s%-6s%-9s%-8s%-9s\n", 
+		"pc_id", "max_btu", "intra", "odai", "godai", 
+		"dep_lulu", "bpacing", "dbpacing");
+
+        for(a = asm_clients; a != NULL; a = a->next)
+        {
+                len += sprintf(buffer + len, "%9s%8d%6d%5d%6d%9d%8d%9d",
+			sna_asm_pr_pcid(a->pc_id), a->max_btu, a->intranode,
+			a->odai, a->generalized_oadi, a->dependent_lulu,
+			a->tx_rx_bind_pacing, a->adp_bind_pacing_dep_lulu);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_asm_get_active_lfsids(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_asm_pinfo *a;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%-6s%-6s%-5s%-6s%-5s\n", 
+		"pc_id", "intra", "sm_id", "odai", "sidh", "sidl");
+
+        for(a = asm_clients; a != NULL; a = a->next)
+        {
+		struct sna_lfsid_block *l;
+
+		for(l = a->l_blks; l != NULL; l = l->next)
+		{
+			int i;
+			for(i = 0; i < 256; i++)
+			{
+				if(l->l[i].active)
+				{
+                			len += sprintf(buffer + len, 
+						"%9s%6d%6d%5d%6d%5d\n",
+						sna_asm_pr_pcid(a->pc_id),
+						a->intranode,
+						l->l[i].sm_id,
+						l->l[i].lfsid.odai,
+						l->l[i].lfsid.sid.hl.sidh,
+						l->l[i].lfsid.sid.hl.sidl);
+				}
+			}
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.4/net/sna/sna_attach.c linux/net/sna/sna_attach.c
--- linux-2.4.4/net/sna/sna_attach.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_attach.c	Mon May 14 21:08:46 2001
@@ -0,0 +1,134 @@
+/* sna_attach.c: Linux Systems Network Architecture implementation
+ * - SNA Attach Manager Kernel Backend.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+struct sk_buff_head attach_queue;
+wait_queue_head_t attach_wait;
+
+int sna_attach_execute_tp(__u32 tcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_attach_execute_tp\n");
+	memcpy(&skb->cb, &tcb_id, sizeof(unsigned long));
+	skb_queue_head(&attach_queue, skb);
+	wake_up_interruptible(&attach_wait);
+
+	return (0);
+}
+
+int sna_attach_tp_correlate(pid_t pid, unsigned long tcb_id, char *tp_name)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_attach_tp_correlate %d %ld\n", pid, tcb_id);
+	tcb = sna_cpic_find_tcb_by_id(tcb_id);
+	if(!tcb)
+		return (-1);
+	tcb->pid = pid;
+
+	return (0);
+}
+
+/* Get an attach from the SNA stack, then pass it to a manager. */
+int sna_attach_listen(struct attach *at, void *buf, int len)
+{
+	struct sk_buff *skb;
+	struct fmhdr *fm;
+	struct tp_attach tp;
+	__u8 tp_len;
+	__u8 *ptr;
+
+	sna_debug(5, "sna_attach_listen\n");
+
+restart:
+        while(skb_queue_empty(&attach_queue))      /* No data */
+        {
+		/* handle signals */
+                if(signal_pending(current))
+			return (-ERESTARTSYS);
+
+                if(skb_peek(&attach_queue) == NULL)
+                        interruptible_sleep_on(&attach_wait);
+        }
+
+        skb = skb_dequeue(&attach_queue);
+        if(skb == NULL)
+                goto restart;
+
+	fm = skb->f.fm;
+	ptr = &fm->fm.f5.raw;
+	memcpy(&tp_len, ptr, sizeof(__u8));
+	printk("len of name is %d\n", tp_len);
+	printk("Hex is %02X\n", *ptr);
+	tp.tp_len = tp_len;
+	strncpy(tp.tp_name, ptr + 1, tp_len);
+	memcpy(&tp.tcb_id, &skb->cb, sizeof(unsigned long));
+	printk("TCB ID of the incomming attach id %ld\n", tp.tcb_id);
+
+	if(copy_to_user(buf, &tp, sizeof(tp)))
+		return (-EFAULT);
+
+	kfree_skb(skb);
+	return (sizeof(tp));
+}
+
+static struct attach_ops aops = {
+	PF_SNA,
+	sna_attach_tp_correlate,
+	sna_attach_listen,
+};
+
+int sna_attach_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_attach_create\n");
+        skb_queue_head_init(&attach_queue);
+	init_waitqueue_head(&attach_wait);
+	attach_register(&aops);
+
+	return (0);
+}
+
+int sna_attach_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "sna_attach_destroy\n");
+	attach_unregister(0);
+
+	return (0);
+};
diff -ruN linux-2.4.4/net/sna/sna_cosm.c linux/net/sna/sna_cosm.c
--- linux-2.4.4/net/sna/sna_cosm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cosm.c	Mon May 14 21:08:59 2001
@@ -0,0 +1,569 @@
+/* sna_cosm.c: Linux Systems Network Architecture implementation
+ * - Class-of-Service Manager
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Jay Please Look 00
+ *		  [==]
+ *
+ * o You probably are not handling the BLANK and NULL mode names properly.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <linux/proc_fs.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_cosm_cb *cosm_list = NULL;
+
+struct sna_cosm_cb *sna_cosm_find(unsigned char *name)
+{
+	struct sna_cosm_cb *c;
+
+	for(c = cosm_list; c != NULL; c = c->next)
+		if(!strncmp(c->name, name, SNA_RESOURCE_NAME_LEN))
+			return (c);
+
+	return (NULL);
+}
+
+struct sna_cosm_tg_cb *sna_cosm_find_tg_weight(struct sna_cosm_cb *c,
+	unsigned short rsn)
+{
+	struct sna_cosm_tg_cb *t;
+
+	for(t = c->tg; t != NULL; t = t->next)
+		if(t->rsn == rsn)
+			return (t);
+	return (NULL);
+}
+
+struct sna_cosm_node_cb *sna_cosm_find_node_weight(struct sna_cosm_cb *c,
+        unsigned short rsn)
+{
+        struct sna_cosm_node_cb *n;
+
+        for(n = c->node; n != NULL; n = n->next)
+                if(n->rsn == rsn)
+                        return (n);
+        return (NULL);
+}
+
+/* Add a COS definition to the table, this function will create a new
+ * entry or update and existing entry.
+ */
+int sna_cosm_define_cos(struct sna_define_cos *cos)
+{
+	struct sna_cosm_cb *c;
+	struct sna_cosm_node_cb *n;
+	struct sna_cosm_tg_cb *t;
+
+	sna_debug(5, "sna_cosm_define_cos %s\n", cos->name);
+	c = sna_cosm_find(cos->name);
+	if(!c)
+	{
+		c = (struct sna_cosm_cb *)kmalloc(sizeof(struct sna_cosm_cb), 
+			GFP_ATOMIC);
+		memset(c, 0, sizeof(struct sna_cosm_cb));
+		strncpy(c->name, cos->name, SNA_RESOURCE_NAME_LEN);
+		c->tg			= NULL;
+		c->node			= NULL;
+		c->prev			= NULL;
+		c->next			= cosm_list;
+		cosm_list		= c;
+	}
+	c->weight               = cos->weight;
+        c->tx_priority          = cos->tx_priority;
+        c->default_cos_invalid  = cos->default_cos_invalid;
+        c->default_cos_null     = cos->default_cos_null;
+
+	/* now append tg cos records */
+	t = sna_cosm_find_tg_weight(c, cos->tg_rsn);
+	if(!t)
+	{
+		t = (struct sna_cosm_tg_cb *)kmalloc(sizeof(struct sna_cosm_tg_cb), GFP_ATOMIC);
+		memset(t, 0, sizeof(struct sna_cosm_tg_cb));
+		t->prev = NULL;
+		t->next	= c->tg;
+		c->tg	= t;
+	}
+	t->rsn				= cos->tg_rsn;
+        t->min_cost_per_connect		= cos->min_cost_per_connect;
+        t->max_cost_per_connect		= cos->max_cost_per_connect;
+        t->min_cost_per_byte		= cos->min_cost_per_byte;
+        t->max_cost_per_byte		= cos->max_cost_per_byte;
+        t->min_security			= cos->min_security;
+        t->max_security			= cos->max_security;
+        t->min_propagation_delay	= cos->min_propagation_delay;
+        t->max_propagation_delay	= cos->max_propagation_delay;
+        t->min_effective_capacity	= cos->min_effective_capacity;
+        t->max_effective_capacity	= cos->max_effective_capacity;
+        t->min_user1			= cos->min_user1;
+        t->max_user1			= cos->max_user1;
+        t->min_user2			= cos->min_user2;
+        t->max_user2			= cos->max_user2;
+        t->min_user3			= cos->min_user3;
+        t->max_user3			= cos->max_user3;
+
+	/* now append node cos records */
+	n = sna_cosm_find_node_weight(c, cos->node_rsn);
+	if(!n)
+	{
+		n = (struct sna_cosm_node_cb *)kmalloc(sizeof(struct sna_cosm_node_cb), GFP_ATOMIC);
+		memset(n, 0, sizeof(struct sna_cosm_node_cb));
+		n->prev = NULL;
+		n->next	= c->node;
+		c->node	= n;
+	}
+	n->rsn				= cos->node_rsn;
+	n->route_resistance		= cos->max_route_resistance;
+	n->node_congested		= cos->max_node_congested;
+//	n->inter_routing_depleted	= cos->inter_routing_depleted;
+
+	return (0);
+}
+
+int sna_cosm_delete_cos(struct sna_delete_cos *cos)
+{
+	struct sna_cosm_cb *c, **clients;
+
+	sna_debug(5, "sna_cosm_delete_cos\n");
+	clients = &cosm_list;
+        while((c = *clients) != NULL)
+        {
+                if(!strcmp(c->name, cos->name))
+                {
+			struct sna_cosm_tg_cb *t;
+			struct sna_cosm_node_cb *n;
+
+                        *clients = c->next;
+			for(t = c->tg; t != NULL; t = t->next)
+				kfree(t);
+			for(n = c->node; n != NULL; n = n->next)
+				kfree(n);
+                        kfree(c);
+                        return (0);
+                }
+                clients = &c->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cosm_cos_tpf_vector(struct sna_cos_tpf_vector *cos)
+{
+	struct sna_cosm_cb *c;
+	int i;
+
+	sna_debug(5, "sna_cosm_cos_tpf_vector\n");
+	c = sna_cosm_find(cos->mode_name);
+	if(!c)
+		return (-ENOENT);
+	memset(&cos->v, 0, sizeof(struct sna_cos));
+	cos->v.type		= 0x2C;
+	cos->v.tx_priority	= c->tx_priority;
+	i = strlen(c->name);
+	memcpy(cos->v.cos_name, c->name, i);
+	for(i = strlen(cos->v.cos_name); i < 8; i++)
+		cos->v.cos_name[i] = 0x40;
+	cos->v.len = sizeof(struct sna_cos);
+
+	return (0);
+}
+
+/* Slick little way to initialize all of the default COS records. */
+struct sna_define_cos cos_defaults[] = {
+	{"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 120, 0, 0, 0, 0, 0x01, 0xFF,
+	0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 180, 0, 128, 0, 128, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CONNECT", 0, SNA_TP_MEDIUM   , 1, 1, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCH", 10, SNA_TP_LOW      , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCH", 10, SNA_TP_LOW      , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#INTER", 20, SNA_TP_HIGH     , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTER", 20, SNA_TP_HIGH     , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#BATCHSC", 30, SNA_TP_LOW    , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"#INTERSC", 40, SNA_TP_HIGH   , 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+        {"CPSVCMG", 50, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 30, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x4, 0x7, 0xF, 0, 255, 0, 255, 0, 255, 5, 0, 31, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 60, 0, 0, 0, 0, 0x01, 0xFF, 
+	0x0, 0x7, 0x4, 0xF, 0, 255, 0, 255, 0, 255, 10, 0, 63, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 90, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 20, 0, 95, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 120, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x7, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 40, 0, 127, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 150, 0, 0, 0, 0, 0x01, 0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 60, 0, 159, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 180, 0, 128, 0,128,0x01,0xFF,
+        0x0, 0x9, 0x3, 0xF, 0, 255, 0, 255, 0, 255, 80, 0, 191, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 210, 0, 196, 0,196,0x01,0xFF,
+        0x0, 0xF, 0x2, 0xF, 0, 255, 0, 255, 0, 255, 120, 0, 223, 0, 0},
+	{"SNASVCMG", 60, SNA_TP_NETWORK, 0, 0, 240, 0, 255, 0,255,0x01,0xFF,
+        0x0, 0xF, 0x0, 0xF, 0, 255, 0, 255, 0, 255, 160, 0, 255, 0, 1}
+};
+
+int sna_cosm_init_default_cos(void)
+{
+	struct sna_cosm_cb *c;
+	int i;
+
+	sna_debug(5, "sna_cosm_init_default_cos\n");
+	for(i = 0; i < 56; i++)
+		sna_cosm_define_cos(&cos_defaults[i]);
+	for(c = cosm_list; c != NULL; c = c->next)
+		sna_debug(5, "cos_name %s\n", c->name);
+
+	return (0);
+}
+
+int sna_cos_ginfo(struct sna_cosm_cb *cos, char *buf, int len)
+{
+	struct cosreq cr;
+	int done = 0;
+
+	sna_debug(10, "sna_cos_ginfo\n");
+	if(!buf)
+        {
+                done += sizeof(cr);
+                return (done);
+        }
+        if(len < (int)sizeof(cr))
+                return done;
+        memset(&cr, 0, sizeof(struct cosreq));
+
+        /* Move the data here */
+	strncpy(cr.name, cos->name, SNA_RESOURCE_NAME_LEN);
+	cr.weight		= cos->weight;
+	cr.tx_priority		= cos->tx_priority;
+	cr.default_cos_invalid	= cos->default_cos_invalid;
+	cr.default_cos_null	= cos->default_cos_null;
+
+	if(copy_to_user(buf, &cr, sizeof(struct cosreq)))
+                return (-EFAULT);
+        buf += sizeof(struct cosreq);
+        len -= sizeof(struct cosreq);
+        done += sizeof(struct cosreq);
+
+        return (done);
+}
+
+int sna_cosm_query_cos(char *arg)
+{
+	struct cosconf cc;
+	struct sna_cosm_cb *cos;
+	char *pos;
+	int len, total;
+
+	sna_debug(5, "sna_cosm_query_cos\n");
+	if(copy_from_user(&cc, arg, sizeof(cc)))
+                return (-EFAULT);
+
+        pos = cc.cosc_buf;
+        len = cc.cos_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(cos = cosm_list; cos != NULL; cos = cos->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = sna_cos_ginfo(cos, NULL, 0);
+                else
+                        done = sna_cos_ginfo(cos, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        cc.cos_len = total;
+	if(copy_to_user(arg, &cc, sizeof(cc)))
+                return (-EFAULT);
+        return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cosm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	/* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%5s%5s"
+                "%5s%5s%4s%4s%4s%4s%4s%4s%4s"
+                "%4s%4s%4s%5s%6s\n",
+                "name", "lcpc",
+                "hcpc", "lcpb",
+                "hcpb", "lpd",
+                "hpd", "lec",
+                "lec", "lu1", "hu1",
+                "lu2", "hu2", "lu3", "hu3",
+                "stat", "quisc");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		struct sna_cosm_tg_cb *t;
+
+		for(t = c->tg; t != NULL; t = t->next)
+		{
+			len += sprintf(buffer + len, "%-9s%5d%5d"
+                	"%5d%5d%4d%4d%4d%4d%4d%4d%4d"
+                	"%4d%4d%4d%5d%6d\n",
+			c->name, t->min_cost_per_connect, 
+			t->max_cost_per_connect, t->min_cost_per_byte,
+			t->max_cost_per_byte, t->min_propagation_delay,
+			t->max_propagation_delay, t->min_effective_capacity,
+			t->max_effective_capacity, t->min_user1, t->max_user1,
+			t->min_user2, t->max_user2, t->min_user3, t->max_user3,
+			t->operational, t->quiescing);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_cos_get_info_node(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%4s%4s%4s%7s%8s%10s\n",
+                "name", "rr", "nc",
+		"ird", "quiesc", "gateway",
+		"directory");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		struct sna_cosm_node_cb *n;
+
+		for(n = c->node; n != NULL; n = n->next)
+		{
+			len += sprintf(buffer + len, "%-9s%4d%4d%4d%7d%8d%10d\n",
+			c->name, n->route_resistance, n->node_congested,
+			n->inter_routing_depleted, n->quiescing, 
+			n->gateway_support, n->central_directory);
+		}
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_cosm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_cosm_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-9s%7s%12s%17s%20s\n",
+		"name", "weight", "tx_priority", "default_cos_null",
+		"default_cos_invalid");
+
+        for(c = cosm_list; c != NULL; c = c->next)
+        {
+		len += sprintf(buffer+len, "%-9s%7d%12d%17d%20d\n",
+		c->name, c->weight, c->tx_priority, c->default_cos_null,
+		c->default_cos_invalid);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+int sna_cosm_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_cosm_create\n");
+	sna_cosm_init_default_cos();
+
+	return (0);
+}
+
+int sna_cosm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_cosm_cb *c;
+
+	sna_debug(5, "sna_cosm_destroy\n");
+
+	for(c = cosm_list; c != NULL; c = c->next)
+	{
+		struct sna_cosm_tg_cb *t;
+                struct sna_cosm_node_cb *n;
+
+                for(t = c->tg; t != NULL; t = t->next)
+	                kfree(t);
+                for(n = c->node; n != NULL; n = n->next)
+                        kfree(n);
+		kfree(c);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_cpic.c linux/net/sna/sna_cpic.c
--- linux-2.4.4/net/sna/sna_cpic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cpic.c	Mon May 14 21:09:11 2001
@@ -0,0 +1,1152 @@
+/* sna_cpic.c: Linux Systems Network Architecture implementation
+ * - SNA CPI Communications (CPI-C) Pure processing backend.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static struct sna_tcb *sna_tcb_clients = NULL;
+static unsigned long tcb_ids = 0;
+
+#define MAX_CPIC_ADDR	1024
+
+struct sna_tcb *sna_cpic_find_tcb_by_id(unsigned long tcb_id)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_id\n");
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %ld\n", tcb->tcb_id, tcb_id);
+		if(tcb->tcb_id == tcb_id)
+			return (tcb);
+	}
+
+	return (NULL);
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_pid(pid_t pid)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_pid %d\n", pid);
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %d\n", tcb->pid, pid);
+		if(tcb->pid == pid)
+			return (tcb);
+	}
+	return (NULL);
+}
+
+struct sna_tcb *sna_cpic_find_tcb_by_daf(__u8 daf)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_find_tcb_by_daf %d\n", daf);
+	for(tcb = sna_tcb_clients; tcb != NULL; tcb = tcb->next)
+	{
+		sna_debug(5, "%d %d\n", tcb->oaf, daf);
+		if(tcb->oaf == daf)
+			return (tcb);
+	}
+	return (NULL);
+}
+
+struct sna_cpic *sna_cpic_find_client(unsigned long conversation_id)
+{
+	struct sna_cpic *cpic;
+
+	sna_debug(5, "sna_cpic_find_client\n");
+
+/*
+	for(cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next)
+		if(cpic->conversation_id == conversation_id)
+				return (cpic);
+*/
+
+	return (NULL);
+}
+
+int sna_cpic_release_session(struct cpic *cpic)
+{
+	struct sna_tcb *sc = cpic->vi.sna;
+
+	sna_debug(5, "sna_cpic_release_session\n");
+
+	if(sc == NULL)
+		return (0);
+
+	cpic->vi.sna = NULL;
+	kfree(sc);
+
+        return (0);
+}
+
+unsigned long sna_cpic_create_tcb(void)
+{
+	struct sna_tcb *tcb;
+
+	sna_debug(5, "sna_cpic_create_tcb\n");
+	tcb = (struct sna_tcb *)kmalloc(sizeof(struct sna_tcb), GFP_ATOMIC);
+	tcb->state 	= CM_INIT;
+	tcb->tcb_id	= tcb_ids++;
+	tcb->pid	= 0;
+	init_waitqueue_head(&tcb->sleep);
+	skb_queue_head_init(&tcb->receive_queue);
+	skb_queue_head_init(&tcb->transmit_queue);
+
+	/* Temporary hack to do without PC. */
+	tcb->oaf = 5;
+	tcb->daf = 4;
+
+        tcb->prev        = NULL;
+        tcb->next        = sna_tcb_clients;
+        sna_tcb_clients	 = tcb;
+
+	return (tcb->tcb_id);
+}
+
+int sna_cpic_create_session(struct cpic *cpic, int s)
+{
+	struct sna_tcb *sc;
+
+	sna_debug(5, "sna_cpic_create_session\n");
+	sc = (struct sna_tcb *)kmalloc(sizeof(struct sna_tcb), GFP_ATOMIC);
+	sc->state	= CM_INIT;
+	sc->tcb_id	= tcb_ids++;
+	init_waitqueue_head(&sc->sleep);
+	skb_queue_head_init(&sc->receive_queue);
+	skb_queue_head_init(&sc->transmit_queue);
+
+	if(s)	/* Client, copy TP name  */
+	{
+		sc->tp_name_length = strlen(cpic->side->tp_name);
+		if(sc->tp_name_length > 0)
+			strncpy(sc->tp_name, cpic->side->tp_name, sc->tp_name_length);
+		sc->partner_lu_name_length = sprintf(sc->partner_lu_name, "%s", 
+			sna_pr_netid((struct sna_netid *)&cpic->side->netid_plu));
+
+		sc->mode_name_length = strlen(cpic->side->mode_name);
+		if(sc->mode_name_length > 0)
+			strncpy(sc->mode_name, cpic->side->mode_name,
+				sc->mode_name_length);
+
+		sc->oaf	= 4;
+		sc->daf	= 5;
+	}
+	else
+	{
+		sc->oaf	= 5;
+		sc->daf	= 4;
+	}
+
+
+	cpic->vi.sna 	= sc;
+	sc->prev	= NULL;
+	sc->next	= sna_tcb_clients;
+	sna_tcb_clients	= sc;
+
+        return (0);
+}
+
+__u32 sna_cmsaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ae_len;
+	__u8 ae_title;
+
+	sna_debug(5, "sna_cmsaeq\n");
+	copy_from_user(&ae_len, ae_qualifier_length, sizeof(__u32));
+	copy_from_user(&ae_title, ap_title_format, sizeof(__u8));
+        if((ae_len < 0 || ae_len > 1024)
+		|| (ae_title != CM_DN ))
+//		&& ae_title != CM_INT_DIGITS))
+	{
+                return(CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+        if(copy_from_user(&tcb->ae_qualifier, ae_qualifier, ae_len))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+        tcb->ae_qualifier_length = ae_len;
+	tcb->ae_qualifier_format = ae_title;
+
+        return (CM_OK);
+}
+
+__u32 sna_cmsac(struct cpic *c, __u32 *allocate_confirm)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *tcb = c->vi.sna;
+	__u32 ap_context_len;
+
+        sna_debug(5, "sna_cmsacn\n");
+	copy_from_user(&ap_context_len,appl_context_name_length,sizeof(__u32));
+        if((ap_context_len < 1 || ap_context_len > 256))
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+        if(copy_from_user(&tcb->application_context_name, 
+		application_context_name, ap_context_len))
+	{
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	}
+        tcb->application_context_length = ap_context_len;
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsapt\n");
+	sna_utok(ap_title_length, sizeof(__u32), &cpic->ap_title_length);
+        sna_utok(ap_title_format, sizeof(__u8), &cpic->ap_title_format);
+	if((cpic->ap_title_length < 0 || cpic->ap_title_length > 1024)
+                || (cpic->ap_title_format != CM_DN
+                && cpic->ap_title_format != CM_OID))
+        {
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	if(sna_utok(ap_title, cpic->ap_title_length, cpic->ap_title))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsbt(struct cpic *c, __u32 *begin_transaction)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsbt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_utok(begin_transaction, sizeof(__u8), &cpic->begin_transaction);
+	return (CM_OK);
+}
+
+__u32 sna_cmscsp(struct cpic *c, __u32 *password, __u32 *password_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscst(struct cpic *c, __u32 *conv_security_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscsu(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsct(struct cpic *c, __u32 *conversation_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmscu(struct cpic *c, __u32 *confirmation_urgency)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsdt(struct cpic *c, __u32 *deallocate_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsdt\n");
+	if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do error checking on this later */
+	sna_utok(deallocate_type, sizeof(CM_DEALLOCATE_TYPE),
+		&cpic->deallocate_type);
+	switch(cpic->deallocate_type)
+	{
+		case (CM_DEALLOCATE_SYNC_LEVEL):
+			break;
+
+		case (CM_DEALLOCATE_FLUSH):
+			break;
+
+		case (CM_DEALLOCATE_CONFIRM):
+			break;
+
+		case (CM_DEALLOCATE_ABEND):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsed(struct cpic *c, __u32 *error_direction)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsend(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+	struct sk_buff *skb;
+	int err, slen;
+
+	sna_debug(5, "sna_cmsend\n");
+	sna_utok(send_length, sizeof(__u32), &slen);
+
+	skb = alloc_skb(slen + 250, GFP_ATOMIC);
+	skb_reserve(skb, sizeof(struct snarhdr));
+        skb_reserve(skb, sizeof(struct sna_fid2) + 8);
+	err = sna_utok(buffer, slen, skb_put(skb, slen));
+        if(err)
+        {
+                kfree_skb(skb);
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+        }
+
+	hexdump(skb->data, skb->len);
+
+	skb_queue_tail(&tcb->transmit_queue, skb);
+	sna_ps_verb_router(SEND_DATA, tcb);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmrcv(struct cpic *c, __u32 *buffer, __u32 *requested_length,
+	__u32 *data_received, __u32 *received_length, __u32 *status_received,
+	__u32 *control_information_received)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+        struct sk_buff *skb;
+        int err, copied, rlen;
+	__u32 wr, sr;
+
+	sna_debug(5, "sna_cmrcv\n");
+	sna_ps_verb_router(RECEIVE_AND_WAIT, cpic);
+        skb = skb_dequeue(&cpic->receive_queue);
+        if(skb == NULL)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	printk("got backed in cmrcv !!!!!!!!!\n");
+	hexdump(skb->data, skb->len);
+
+        sna_utok(requested_length, sizeof(__u32), &rlen);
+	wr = CM_DATA_RECEIVED;
+	sna_utok(data_received, sizeof(__u32), &wr);
+	sr = CM_SEND_RECEIVED;
+	sna_utok(status_received, sizeof(__u32), &sr);
+
+        copied  = skb->len;
+        if(copied > rlen)
+        {
+                copied = rlen;
+        }
+
+	err = sna_ktou(&skb->data[9], copied, buffer);
+	if(err)
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmserr(struct cpic *c, __u32 *control_information_recevied)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsf(struct cpic *c, __u32 *fill)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsf\n");
+	sna_utok(fill, sizeof(CM_FILL), &cpic->fill);
+	if(cpic->fill != CM_FILL_LL && cpic->fill != CM_FILL_BUFFER)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsid(struct cpic *c, __u32 *initialization_data, 
+	__u32 *init_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsid\n");
+	sna_utok(init_data_length, sizeof(CM_INT32), &cpic->init_data_length);
+	if(cpic->init_data_length < 0 || cpic->init_data_length > 10000)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT && cpic->state != CM_RCV 
+		&& cpic->state != CM_SEND_RCV)
+        {
+		return (CM_PROGRAM_STATE_CHECK);
+        }
+
+	if(sna_utok(initialization_data,cpic->init_data_length,cpic->init_data))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsld(struct cpic *c, __u32 *log_data, __u32 *log_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsld\n");
+	sna_utok(log_data_length, sizeof(CM_INT32), &cpic->log_data_length);
+ 	if(cpic->log_data_length < 0 || cpic->log_data_length > 512)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+
+	if(sna_utok(log_data, cpic->log_data_length, cpic->log_data))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsltp(__u32 *tp, __u32 *tp_name_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsmn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsmn\n");
+	sna_utok(mode_name_length, sizeof(CM_INT32), &cpic->mode_name_length);
+	if(cpic->mode_name_length < 0 || cpic->mode_name_length > 8)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(mode_name, cpic->mode_name_length, cpic->mode_name))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsndx(struct cpic *c, __u32 *buffer, __u32 *send_length,
+	__u32 *control_information_received)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspdp(struct cpic *c, __u32 *prepare_data_permitted)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *partner_id_length, __u32 *partner_id_scope, 
+	__u32 *directory_syntax, __u32 *directory_encoding)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmspln(struct cpic *c, __u32 *partner_lu_name, 
+	__u32 *partner_lu_name_length)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmspln\n");
+	sna_utok(partner_lu_name_length, sizeof(CM_INT32), 
+		&cpic->partner_lu_name_length);
+	if(cpic->partner_lu_name_length<1 || cpic->partner_lu_name_length>17)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(partner_lu_name, cpic->partner_lu_name_length,
+		cpic->partner_lu_name))
+	{
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmspm(struct cpic *c, __u32 *processing_mode)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsptr(struct cpic *c, __u32 *prepare_to_receive_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsptr\n");
+	if(cpic->state != CM_INIT_INCOMING)	/* Should be just CM_INIT_INCOMING */
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do error checking on this later. */
+	sna_utok(prepare_to_receive_type, sizeof(CM_PREPARE_TO_RECEIVE_TYPE),
+		&cpic->prepare_to_receive_type);
+	switch(cpic->prepare_to_receive_type)
+	{
+		case (CM_PREP_TO_RECEIVE_SYNC_LEVEL):
+			break;
+
+		case (CM_PREP_TO_RECEIVE_FLUSH):
+			break;
+
+		case (CM_PREP_TO_RECEIVE_CONFIRM):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsqcf(struct cpic *c, __u32 *conversation_queue, 
+	__u32 *callback_function, __u32 *callback_info, __u32 *user_field)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmcanc(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmprep(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsqpm(struct cpic *c, __u32 *conversation_queue,
+	__u32 *queue_processing_mode, __u32 *user_field, __u32 *ooid)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsrc(struct cpic *c, __u32 *return_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmsrt(struct cpic *c, __u32 *receive_type)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmsrt\n");
+	sna_utok(receive_type, sizeof(CM_RECEIVE_TYPE), &cpic->receive_type);
+	if(cpic->receive_type != CM_RECEIVE_AND_WAIT
+		&& cpic->receive_type != CM_RECEIVE_IMMEDIATE)
+        {
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+
+	return (CM_OK);
+}
+
+__u32 sna_cmssl(struct cpic *c, __u32 *sync_level)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmssl\n");
+	if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Preform some error checking on this later. */
+	sna_utok(sync_level, sizeof(__u32), &cpic->sync_level);
+	switch(cpic->sync_level)
+	{
+		case (CM_NONE):
+			break;
+/*
+		case (CM_CONFIRM):
+			break;
+
+		case (CM_SYNC_POINT):
+			break;
+*/
+		case (CM_SYNC_POINT_NO_CONFIRM):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmssrm(struct cpic *c, __u32 *send_receive_mode)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmssrm\n");
+	sna_utok(send_receive_mode, sizeof(CM_SEND_RECEIVE_MODE), 
+		&cpic->send_receive_mode);
+        if(cpic->send_receive_mode != CM_HALF_DUPLEX 
+		&& cpic->send_receive_mode != CM_FULL_DUPLEX)
+	{
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        }
+        if(cpic->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmsst(struct cpic *c, __u32 *send_type)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmsst\n");
+	if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	/* Do some error checking on this later. */
+	sna_utok(send_type, sizeof(CM_SEND_TYPE), &cpic->send_type);
+	switch(cpic->send_type)
+	{
+		case (CM_BUFFER_DATA):
+			break;
+
+		case (CM_SEND_AND_FLUSH):
+			break;
+
+		case (CM_SEND_AND_CONFIRM):
+			break;
+
+		case (CM_SEND_AND_PREP_TO_RECEIVE):
+			break;
+
+		case (CM_SEND_AND_DEALLOCATE):
+			break;
+
+		default:
+			return (CM_PROGRAM_PARAMETER_CHECK);
+	}
+
+	return (CM_OK);
+}
+
+__u32 sna_cmstc(struct cpic *c, __u32 *transaction_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmstpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmstpn\n");
+	sna_utok(tp_name_length, sizeof(CM_INT32), &cpic->tp_name_length);
+        if(cpic->tp_name_length < 1 || cpic->tp_name_length > 64)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT && cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+	if(sna_utok(tp_name, cpic->tp_name_length, cpic->tp_name))
+		return (CM_PRODUCT_SPECIFIC_ERROR);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeaeq(struct cpic *c, __u32 *ae_qualifier, 
+	__u32 *ae_qualifier_length, __u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeaeq\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->ae_qualifier, cpic->ae_qualifier_length, ae_qualifier);
+	sna_ktou(&cpic->ae_qualifier_length, sizeof(cpic->ae_qualifier_length),
+		ae_qualifier_length);
+	sna_ktou(&cpic->ae_qualifier_format, sizeof(cpic->ae_qualifier_format),
+		ap_title_format);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeapt(struct cpic *c, __u32 *ap_title, __u32 *ap_title_length,
+	__u32 *ap_title_format)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeapt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->ap_title, cpic->ap_title_length, ap_title);
+	sna_ktou(&cpic->ap_title_length, sizeof(cpic->ap_title_length),
+		ap_title_length);
+	sna_ktou(&cpic->ap_title_format, sizeof(cpic->ap_title_format),
+		ap_title_format);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmeacn(struct cpic *c, __u32 *application_context_name,
+	__u32 *appl_context_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmeapt\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->application_context_name, 
+		cpic->application_context_length, application_context_name);
+	sna_ktou(&cpic->application_context_length, 
+		sizeof(cpic->application_context_length), 
+		appl_context_name_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmecs(struct cpic *c, __u32 *conversation_state)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmecs\n");
+	sna_ktou(&cpic->state, sizeof(cpic->state), conversation_state);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmect(struct cpic *c, __u32 *conversation_type)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmectx(struct cpic *c, __u32 *context_id, __u32 *context_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmeid(struct cpic *c, __u32 *initialization_data,
+	__u32 *requested_length, __u32 *initialization_data_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+	CM_INT32 len;
+	
+        sna_debug(5, "sna_cmeid\n");
+	sna_utok(requested_length, sizeof(CM_INT32), &len);
+ 	if(len < 0)
+		return (CM_PROGRAM_PARAMETER_CHECK);
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->init_data, len, initialization_data);
+	sna_ktou(&len, sizeof(len), initialization_data_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmemn(struct cpic *c, __u32 *mode_name, __u32 *mode_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmemn\n");
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->mode_name, cpic->mode_name_length, mode_name);
+	sna_ktou(&cpic->mode_name_length, sizeof(cpic->mode_name_length),
+		mode_name_length);
+
+	return (CM_OK);
+}
+
+__u32 sna_cmepid(struct cpic *c, __u32 *partner_id_type, __u32 *partner_id,
+	__u32 *requested_length, __u32 *partner_id_length, 
+	__u32 *partner_id_scope, __u32 *directory_syntax,
+	__u32 *directory_encoding)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmepln(struct cpic *c, __u32 *partner_lu_name,
+	__u32 *partner_lu_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmepln\n");
+
+/*
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->partner_lu_name, cpic->partner_lu_name_length, 
+		partner_lu_name);
+	sna_ktou(&cpic->partner_lu_name_length, 
+		sizeof(cpic->partner_lu_name_length), partner_lu_name_length);
+*/
+	return (CM_OK);
+}
+
+__u32 sna_cmesi(struct cpic *c, __u32 *call_id, __u32 *buffer,
+	__u32 *requested_length, __u32 *data_received)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesl(struct cpic *c, __u32 *sync_level)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesrm(struct cpic *c, __u32 *send_receive_mode)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmesui(struct cpic *c, __u32 *user_id, __u32 *user_id_length)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmetc(struct cpic *c, __u32 *transaction_control)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmetpn(struct cpic *c, __u32 *tp_name, __u32 *tp_name_length)
+{
+        struct sna_tcb *cpic = c->vi.sna;
+
+        sna_debug(5, "sna_cmetpn\n");
+
+        if(cpic->state != CM_INIT_INCOMING)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ktou(&cpic->tp_name, cpic->tp_name_length, tp_name);
+	sna_ktou(&cpic->tp_name_length, sizeof(cpic->tp_name_length),
+		tp_name_length);
+
+	return (CM_OK);
+}
+
+/* Build SKB, send on for further processing. */
+__u32 sna_cmallc(struct cpic *c)
+{
+	struct sna_tcb *tcb = c->vi.sna;
+
+	sna_debug(5, "sna_cmallc\n");
+	if(tcb->state != CM_INIT)
+		return (CM_PROGRAM_STATE_CHECK);
+
+	sna_ps_verb_router(ALLOCATE, tcb);
+	tcb->state = CM_INIT_INCOMING;
+
+	return (CM_OK);
+}
+
+__u32 sna_cmcfmd(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmcfmd\n");
+
+	return (CM_OK);
+}
+
+__u32 sna_cmdfde(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmacci(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmwait(struct cpic *c, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmflus(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmincl(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmptr(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmrts(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmtrts(struct cpic *c, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cminic(struct cpic *c)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmcfm(struct cpic *cpic, __u32 *a1)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmrcvx(struct cpic *cpic, __u32 *a1, __u32 *a2,
+                __u32 *a3, __u32 *a4, __u32 *a5)
+{
+	return (CM_OK);
+}
+
+__u32 sna_cmdeal(struct cpic *c)
+{
+	struct sna_tcb *cpic = c->vi.sna;
+
+	sna_debug(5, "sna_cmdeal\n");
+
+	return (CM_OK);
+}
+
+int sna_cpic_setsockopt(struct socket *sock, int level, int optname,
+                         char *optval, int optlen)
+{
+        int err = 0;
+
+        switch(level)
+        {
+                case SOL_SNA_CPIC:
+			switch(optname)
+			{
+				case (CPIC_DEFINE_SIDE):
+				{
+					struct cpic_define_side_info c;
+					if(optlen < sizeof(c))
+						return (-EINVAL);
+					if(copy_from_user(&c, optval,
+						sizeof(c)))
+						return (-EFAULT);
+					err = cpic_register_side_info(&c);
+					break;
+				}
+
+				case (CPIC_DELETE_SIDE):
+				{
+					struct cpic_delete_side_info c;
+					if(optlen < sizeof(c))
+                                                return (-EINVAL);
+                                        if(copy_from_user(&c, optval,
+                                                sizeof(c)))
+                                                return (-EFAULT);
+                                        err = cpic_unregister_side_info(&c);
+					break;
+				}
+
+				default:
+					return (-EINVAL);
+			}
+			break;
+
+		default:
+			return (-EINVAL);
+	}
+
+	return (err);
+}
+
+int sna_cpic_ioctl(int cmd, void *arg)
+{
+        switch(cmd)
+        {
+                case (SIOCGCPICS):
+                        cpic_query_side_info(arg);
+                        break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (0);
+}
+
+static struct cpic_ops sna_cpic_ops = {
+        PF_SNA,
+	sna_cpic_find_tcb_by_pid,
+        sna_cpic_release_session,
+        sna_cpic_create_session,
+	sna_cmsaeq,
+	sna_cmsac,			/* 5 */
+	sna_cmsacn,
+	sna_cmsapt,
+	sna_cmsbt,
+	sna_cmscsp,
+	sna_cmscst,			/* 10 */
+	sna_cmscsu,
+	sna_cmsct,
+	sna_cmscu,
+	sna_cmsdt,
+	sna_cmsed,			/* 15 */
+	sna_cmsend,
+	sna_cmserr,
+	sna_cmsf,
+	sna_cmsid,
+	sna_cmsld,			/* 20 */
+	sna_cmsmn,
+	sna_cmsndx,
+	sna_cmspdp,
+	sna_cmspid,
+	sna_cmspln,			/* 25 */
+	sna_cmspm,
+	sna_cmsptr,
+	sna_cmsqcf,
+	sna_cmsqpm,
+	sna_cmsrc,			/* 30 */
+	sna_cmsrt,
+	sna_cmssl,
+	sna_cmssrm,
+	sna_cmsst,
+	sna_cmstc,			/* 35 */
+	sna_cmstpn,
+	sna_cmeaeq,
+	sna_cmeapt,
+	sna_cmeacn,
+	sna_cmecs,			/* 40 */
+	sna_cmect,
+	sna_cmectx,
+	sna_cmeid,
+	sna_cmemn,
+	sna_cmepid,			/* 45 */
+	sna_cmepln,
+	sna_cmesi,
+	sna_cmesl,
+	sna_cmesrm,
+	sna_cmesui,			/* 50 */
+	sna_cmetc,
+	sna_cmetpn,
+	sna_cmallc,
+	sna_cmcanc,
+	sna_cmcfmd,			/* 55 */
+	sna_cmcfm,
+	sna_cmdeal,
+	sna_cmrcv,
+	sna_cmdfde,
+	sna_cmacci,			/* 60 */
+	sna_cmwait,			
+	sna_cmsltp,
+	sna_cmflus,
+	sna_cmincl,
+	sna_cmprep,			/* 65 */
+	sna_cmptr,	
+	sna_cmrcvx,
+	sna_cmrts,
+	sna_cmtrts,
+	sna_cminic			/* 70 */
+};
+
+int sna_cpic_create(struct sna_start_node *start)
+{
+        cpic_register(&sna_cpic_ops);
+        return (0);
+}
+
+int sna_cpic_destroy(struct sna_delete_node *delete)
+{
+        cpic_unregister(PF_SNA);
+        return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cpic_get_info_side(char *buffer, char **start,
+        off_t offset, int length)
+{
+	return (cpic_get_info_side(buffer, start, offset, length));
+}
+
+int sna_cpic_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	struct sna_tcb *cpic;
+	off_t pos = 0, begin = 0;
+	int len = 0;
+
+	len += sprintf(buffer, "%-5s%-6s%-6s\n", "cvid", "state", "flags");
+#ifdef NOT
+	for(cpic = sna_cpic_clients; cpic != NULL; cpic = cpic->next)
+        {
+		len += sprintf(buffer + len, "%04X %02X %04X\n",
+			cpic->conversation_id, cpic->state, cpic->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+#endif
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.4/net/sna/sna_cs.c linux/net/sna/sna_cs.c
--- linux-2.4.4/net/sna/sna_cs.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_cs.c	Mon May 14 21:09:19 2001
@@ -0,0 +1,1835 @@
+/* sna_cs.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/if_arp.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif
+
+extern char sna_version[];
+extern char sna_product_id[];
+extern char sna_product_name[];
+
+__u32	sysctl_xid_idle_limit		= SNA_XID_IDLE_LIMIT;
+__u32	sysctl_xid_retry_interval	= SNA_XID_RETRY_INTERVAL;
+__u32	sysctl_xid_retry_limit		= SNA_XID_RETRY_LIMIT;
+
+static struct sna_cs_pinfo	*cs_clients 	= NULL;
+static struct sna_dlc_cb 	*dlc_clients 	= NULL;
+
+static __u32	sna_dlc_system_id	= 0;
+static __u32	sna_port_system_id 	= 0;
+static __u32	sna_ls_system_id 	= 0;
+
+int sna_cs_insert_cs(struct sna_cs_pinfo *ics)
+{
+        sna_debug(5, "sna_cs_insert_cs\n");
+        ics->next 	= cs_clients;
+        cs_clients 	= ics;
+
+        return (0);
+}
+
+int sna_cs_delete_dlc(struct net_device *dev)
+{
+	struct sna_dlc_cb *dlc, **clients = &dlc_clients;
+
+	sna_debug(5, "sna_cs_delete_dlc %s\n", dev->name);
+
+        while((dlc = *clients) != NULL)
+        {
+		if(!strncmp(dlc->dev->name, dev->name, 8))
+		{
+			*clients = dlc->next;
+                        kfree(dlc);
+                        return (0);
+		}
+		clients = &dlc->next;
+        }
+
+	return (-ENOENT);
+}
+
+struct sna_cs_pinfo *sna_cs_find(char *name)
+{
+        struct sna_cs_pinfo *f;
+
+	sna_debug(5, "sna_cs_find %s\n", name);
+        for(f = cs_clients; f != NULL; f = f->next)
+		if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                       	return (f);
+
+        return (NULL);
+}
+
+struct sna_dlc_cb *sna_cs_find_dlc_name(char *name)
+{
+        struct sna_dlc_cb *f;
+
+	sna_debug(5, "sna_cs_find_dlc_name\n");
+        for(f = dlc_clients; f != NULL; f = f->next)
+                if(!strcmp(f->dev->name, name))
+			break;
+
+        return (f);
+}
+
+struct sna_port_cb *sna_cs_find_port(struct sna_port_cb *plist,
+	char *saddr)
+{
+        struct sna_port_cb *f;
+
+	sna_debug(5, "sna_cs_find_port\n");
+        for(f = plist; f != NULL; f = f->next)
+		if(!strncmp(f->saddr, saddr, 1))
+			break;
+        return (f);
+}
+
+struct sna_ls_cb *sna_cs_find_ls(struct sna_ls_cb *list, char *dname,
+	char *daddr)
+{
+        struct sna_ls_cb *f;
+
+        sna_debug(5, "sna_cs_find_ls_name\n");
+        for(f = list; f != NULL; f = f->next)
+	{
+		sna_debug(5, "%s %s\n", f->dname, dname);
+                if(!strncmp(f->dname, dname, 6) && f->daddr[0] == daddr[0])
+			break;
+	}
+
+        return (f);
+}
+
+int sna_cs_shutdown(void)
+{
+        return (0);
+}
+
+int sna_cs_create(struct sna_start_node *start)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_pc_create_parms *pc;
+	struct sna_rm_act_session_rq *as;
+
+	sna_debug(5, "sna_cs_create %s\n", start->netid.name);
+	cs = sna_cs_find(start->netid.name);
+	if(cs)
+		return (-EEXIST);
+	cs = (struct sna_cs_pinfo *)kmalloc(sizeof(struct sna_cs_pinfo), 
+		GFP_ATOMIC);
+	memcpy(&cs->netid, &start->netid, sizeof(struct sna_netid));
+        memcpy(&cs->nodeid, &start->nodeid, sizeof(struct sna_nodeid));
+	cs->next = NULL;
+	cs->prev = NULL;
+        sna_cs_insert_cs(cs);
+
+	/* Create the intranode Path Control - One per Node */
+	pc = (struct sna_pc_create_parms *)kmalloc(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memset(pc, 0, sizeof(struct sna_pc_create_parms));
+	pc->type 	= SNA_PC_INTRANODE;
+	pc->dlc		= NULL;
+	pc->port	= NULL;
+	pc->ls		= NULL;
+	memcpy(&pc->fqcp, &cs->netid, sizeof(struct sna_netid));
+	sna_pc_init(pc);
+	memcpy(&cs->intranode_pc_id, &pc->pc_id, 8);
+	kfree(pc);
+	cs->node_type		= start->type;
+
+	/* Activate the loopback link - hidden */
+	as = (struct sna_rm_act_session_rq *)kmalloc(sizeof(struct sna_rm_act_session_rq), GFP_ATOMIC);
+	memcpy(&as->plu_netid, &cs->netid, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "CONNECT");
+	sna_rm_activate_session(as);
+
+	return (0);
+}
+
+int sna_cs_destroy(struct sna_delete_node *delete)
+{
+	struct sna_cs_pinfo *cs, **clients = &cs_clients; 
+
+	sna_debug(5, "sna_cs_destroy\n");
+	while((cs = *clients) != NULL)
+        {
+                if(!strncmp(cs->netid.name, delete->netid.name, 8))
+                {
+			struct sna_dlc_cb *dlc;
+			struct sna_port_cb *port, **pclients;
+			struct sna_ls_cb *ls;
+
+                        *clients = cs->next;
+			for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+			{
+				pclients = &dlc->port_list;
+				while((port = *pclients) != NULL)
+				{
+					if(strncmp(port->netid.name, delete->netid.name, 8))
+					{
+						pclients = &port->next;
+						break;
+					}
+					else
+						*pclients = port->next;
+
+					for(ls = port->ls_list; ls != NULL; ls = ls->next)					
+					{
+						ls->port 	= NULL;
+						ls->dlc 	= NULL;
+						kfree(ls);
+						port->ls_qlen--;
+						sna_mod_dec_use_count();
+					}
+
+#ifdef CONFIG_SNA_LAR
+        				sna_lar_erase(port->netid.name, 
+						port->netid.net);
+#endif
+
+					switch(port->dev->type)
+		                        {
+#ifdef CONFIG_SNA_LLC
+                		                case (ARPHRD_ETHER):
+                        		        case (ARPHRD_IEEE802):
+                        		        case (ARPHRD_FDDI):
+                        		                unregister_8022_client(port->saddr[0]);
+                                		        break;
+#endif
+					}
+					
+					port->ls_list 	= NULL;
+					port->dev 	= NULL;
+#ifdef CONFIG_SNA_LLC
+					port->llc_dl	= NULL;
+#endif
+					kfree(port);
+					dlc->port_qlen--;
+					sna_mod_dec_use_count();
+				}
+			}
+
+			cs->dlc_list = NULL;
+			sna_pc_destroy(cs->intranode_pc_id);
+                        kfree(cs);
+                        return (0);
+                }
+                clients = &cs->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cs_query_connection_network(int type, 
+	struct sna_query_connection_network *query_connection_network)
+{
+
+	return (0);
+}
+
+int sna_cs_query_link_station(struct sna_query_link_station *query_link_station)
+{
+#ifdef NOT
+	struct sna_ls_cb *ls_cb;
+        struct sna_cs_pinfo *cs
+                = sna_cs_find(query_link_station->connection_name);
+
+        printk("sna_cs_query_link_station\n");
+
+        if(cs == NULL)
+		return (-1);
+
+        printk("cs != NULL\n");
+	ls_cb = sna_cs_find_ls_name(query_link_station->ls_name);
+		return (-1);
+
+	query_link_station->adj_node_type	= ls_cb->adj_node_type;
+	query_link_station->fsm_ls_state	= 0;
+	query_link_station->ls_entered_act_state= ls_cb->ls_entered_act_state;
+	query_link_station->node_act		= ls_cb->node_act;
+	query_link_station->ls_activation	= ls_cb->ls_activation;
+	memcpy(query_link_station->dest_addr, ls_cb->dest_addr, 6);
+	query_link_station->tx_win_size		= ls_cb->tx_win_size;
+	query_link_station->rx_win_size		= ls_cb->rx_win_size;
+	query_link_station->fsm_xid_state	= 0;
+	query_link_station->fsm_nonact_xid_state= 0;
+	query_link_station->fsm_ls_role_state	= 0;
+#endif
+
+	return (0);
+}
+
+int sna_cs_define_connection_network(
+	struct sna_define_connection_network *define_connection_network)
+{
+
+	return (0);
+}
+
+int sna_cs_define_dlc(struct net_device *dev)
+{
+	sna_debug(5, "sna_cs_define_dlc %s\n", dev->name);
+	switch(dev->type)
+	{
+#ifdef CONFIG_SNA_LOOPBACK
+		case (ARPHRD_LOOPBACK):
+		{
+			struct sna_dlc_cb *dlc = (struct sna_dlc_cb *)
+                                kmalloc(sizeof(struct sna_dlc_cb),
+                                GFP_KERNEL);
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+                        dlc->port_list  = NULL;
+                        dlc->port_qlen  = 0;
+                        dlc->next       = dlc_clients;
+                        dlc_clients     = dlc;
+			break;
+		}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+		case (ARPHRD_IEEE802):
+		case (ARPHRD_FDDI):
+		{
+			struct sna_dlc_cb *dlc = (struct sna_dlc_cb *)
+				kmalloc(sizeof(struct sna_dlc_cb),
+				GFP_KERNEL);
+                        dlc->proc_id    = sna_dlc_system_id++;
+                        dlc->dev        = dev;
+                        dlc->flags      |= (SNA_UP | SNA_RUNNING);
+			dlc->port_list	= NULL;
+			dlc->port_qlen	= 0;
+                        dlc->next 	= dlc_clients;
+                        dlc_clients 	= dlc;
+                        break;
+		}
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+
+		default:
+			return (-EINVAL);
+	}
+
+	return (0);
+}
+
+int sna_cs_delete_ls(struct sna_delete_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls, **clients;
+
+	sna_debug(5, "sna_cs_delete_link_station\n");
+        cs = sna_cs_find(dls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if(!dlc)
+                return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dls->saddr);
+	if(!port)
+		return (-ENOENT);
+        clients = &port->ls_list;
+        while((ls = *clients) != NULL)
+        {
+                if(!strcmp(ls->daddr, dls->daddr)
+			&& !strcmp(ls->dname, dls->dname))
+                {
+                        *clients = ls->next;
+			sna_pc_destroy(ls->pc_id);
+                        kfree(ls);
+			port->ls_qlen--;
+			sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &ls->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_cs_define_ls(struct sna_define_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_ls_cb *ls;
+	struct sna_pc_create_parms *pc;
+	struct sna_tg_update *tg;
+	unsigned char name[20];
+        int len = 0, err;
+
+	sna_debug(5, "sna_cs_define_link_station\n");
+	cs = sna_cs_find(dls->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dls->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dls->saddr);
+	if(!port)
+		return (-ENOENT);
+	ls = sna_cs_find_ls(port->ls_list, dls->dname, dls->daddr);
+	if(ls)
+		return (-EEXIST);
+
+	ls = (struct sna_ls_cb *)kmalloc(sizeof(struct sna_ls_cb),
+		GFP_KERNEL);
+	memset(ls, '0', sizeof(struct sna_ls_cb));
+	memcpy(&ls->netid, &dls->netid, sizeof(struct sna_netid));
+	memcpy(&ls->plu_name, &dls->plu_name, sizeof(struct sna_netid));
+	memcpy(ls->dname, dls->dname, MAX_ADDR_LEN);
+	memcpy(ls->daddr, dls->daddr, SNA_PORT_ADDR_LEN);
+	ls->sport	= dls->saddr[0];
+	memcpy(ls->devname, dls->name, 8);
+	ls->auto_act	= dls->autoact;
+	ls->auto_deact	= dls->autodeact;
+	ls->port	= port;
+	ls->dlc		= dlc;
+	ls->flags	= (SNA_UP | SNA_STOPPED);
+	ls->proc_id	= sna_ls_system_id++;
+	ls->next      	= port->ls_list;
+        port->ls_list  	= ls;
+	port->ls_qlen++;
+
+	/* Update this TG */
+	tg = (struct sna_tg_update *)kmalloc(sizeof(struct sna_tg_update),
+                GFP_ATOMIC);
+        if(!ls->tg_id)
+                sna_tdm_init_tg_update(tg);
+        memcpy(&tg->tg_desc.dlc.mac, &ls->dname, MAX_ADDR_LEN);
+	tg->dev				= port->dev;
+	tg->lsap			= port->saddr[0];
+        tg->node_type                   = cs->node_type;
+        tg->tg_desc.dlc.lsap            = ls->daddr[0];
+        tg->tg_desc.id.pcp_len = len = sna_netid_to_char(&port->netid, name);
+        tg->tg_desc.id.pcp_name = (unsigned char *)kmalloc(len + 1, GFP_ATOMIC);        strcpy(tg->tg_desc.id.pcp_name, name);
+        err = sna_tdm_tg_update(tg);
+        if(err < 0)
+                return (err);
+
+	/* Create Internode PC instance - our side of the link */
+	pc = (struct sna_pc_create_parms *)kmalloc(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memset(pc, 0, sizeof(struct sna_pc_create_parms));
+
+	/* Used to be memcpy( , &ls->netid, ); */
+	memcpy(&pc->fqcp, &ls->netid, sizeof(struct sna_netid));
+	pc->type 	= SNA_PC_INTERNODE;
+	pc->dlc		= dlc;
+	pc->ls		= ls;
+	pc->port	= port;
+	pc->max_tx_btu	= dlc->dev->mtu;
+	pc->max_rx_btu	= dlc->dev->mtu;
+	sna_pc_init(pc);
+	memcpy(&ls->pc_id, &pc->pc_id, 8);
+	kfree(pc);
+
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_cs_delete_port(struct sna_delete_port *dport)
+{
+	struct sna_port_cb *port, **clients;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "sna_cs_delete_port (%s, %s)\n", dport->name,dport->saddr);
+	cs = sna_cs_find(dport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dport->name);
+        if(!dlc)
+                return (-ENOENT);
+
+#ifdef CONFIG_SNA_LAR
+	sna_lar_erase(dport->netid.name, dport->netid.net);
+#endif
+
+	clients = &dlc->port_list;
+        while((port = *clients) != NULL)
+        {
+                if(!strcmp(port->saddr, dport->saddr))
+                {
+                        *clients = port->next;
+			switch(port->dev->type)
+			{
+#ifdef CONFIG_SNA_LLC
+				case (ARPHRD_ETHER):
+				case (ARPHRD_IEEE802):
+				case (ARPHRD_FDDI):
+					unregister_8022_client(port->saddr[0]);
+					break;
+#endif
+#ifdef CONFIG_SNA_ATM
+				case (ARPHRD_ATM):
+					break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+				case (ARPHRD_CHANNEL):
+					break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+				case (ARPHRD_HDLC):
+					break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+				case (ARPHRD_SDLC):
+					break;
+#endif
+				default:
+					break;
+			}
+                        kfree(port);
+			dlc->port_qlen--;
+			sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &port->next;
+        }
+
+	return (-ENOENT);
+}
+
+int sna_cs_define_port(struct sna_define_port *dport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+#ifdef CONFIG_SNA_LAR
+	struct sna_lar_snpa snpa;
+	char group[9];
+	int i;
+#endif
+
+	sna_debug(5, "sna_cs_define_port\n");
+	cs = sna_cs_find(dport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(dport->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, dport->saddr);
+	if(port)
+		return (-EEXIST);
+	port = (struct sna_port_cb *)kmalloc(sizeof(struct sna_port_cb), 
+		GFP_KERNEL);
+	memset(port, '0', sizeof(struct sna_port_cb));
+	memcpy(&port->netid, &dport->netid, sizeof(struct sna_netid));
+	memcpy(&port->saddr, &dport->saddr, SNA_PORT_ADDR_LEN);
+	port->dev	= dlc->dev;
+	port->proc_id	= sna_port_system_id++;
+	port->flags	= (SNA_UP | SNA_STOPPED);
+	port->ls_list	= NULL;
+	port->ls_qlen	= 0;
+	port->btu	= dport->btu;
+	port->mia	= dport->mia;
+	port->moa	= dport->moa;
+
+	switch(dport->role)
+	{
+		case (SNA_PORT_ROLE_PRI):
+		case (SNA_PORT_ROLE_SEC):
+		case (SNA_PORT_ROLE_NEG):
+			port->role = dport->role;
+			break;
+		default:
+			return (-EINVAL);
+	}
+
+#ifdef CONFIG_SNA_LAR
+	for(i = 0; i < 6; i++)
+		snpa.mac[i] = port->dev->dev_addr[i];
+	snpa.lsap = port->saddr[0];
+	strncpy(group, "IROUTSNA", 8);
+	group[8] = '\0';
+
+	/* for local devices */
+        sna_lar_record(&port->netid, group, &snpa, SNA_RTCAP_APPN_NN, 1);
+#endif
+
+	/* Link to data link control block port list */
+        port->next      = dlc->port_list;
+        dlc->port_list  = port;
+        dlc->port_qlen++;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_cs_query_statistics(struct sna_query_stats *qs)
+{
+
+	return (0);
+}
+
+int sna_cs_start_ls(struct sna_start_link_station *dls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+//	struct sna_tg_update *tg;
+	struct sna_rm_act_session_rq *as;
+//	unsigned char name[20];
+//	int len = 0, err;
+
+        sna_debug(5, "sna_cs_start_ls\n");
+        cs = sna_cs_find(dls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(dls->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, dls->saddr);
+        if(!port)
+                return (-ENOENT);
+        ls = sna_cs_find_ls(port->ls_list, dls->dname, dls->daddr);
+        if(!ls)
+                return (-ENOENT);
+
+	ls->flags     &= ~SNA_STOPPED;
+        ls->flags     |= SNA_RUNNING;
+
+/*	This has been moved to define_ls() probably permanantly
+
+	tg = (struct sna_tg_update *)kmalloc(sizeof(struct sna_tg_update),
+                GFP_ATOMIC);
+	if(!ls->tg_id)
+        	sna_tdm_init_tg_update(tg);
+	memcpy(&tg->tg_desc.dlc.mac, &ls->dname, MAX_ADDR_LEN);
+        tg->node_type                   = cs->node_type;
+        tg->tg_desc.dlc.lsap            = ls->daddr[0];
+	tg->tg_desc.id.pcp_len = len = sna_netid_to_char(&port->netid, name);
+	tg->tg_desc.id.pcp_name = (unsigned char *)kmalloc(len + 1, GFP_ATOMIC);
+	strcpy(tg->tg_desc.id.pcp_name, name);
+	err = sna_tdm_tg_update(tg);
+	if(err < 0)
+		return (err);
+
+*/
+
+	as = (struct sna_rm_act_session_rq *)kmalloc(sizeof(struct sna_rm_act_session_rq), GFP_ATOMIC);
+	as->tcb_id	= ls->proc_id;
+	memcpy(&as->plu_netid, &dls->netid_plu, sizeof(struct sna_netid));
+	strcpy(as->mode_name, "#BATCH");
+	sna_rm_activate_session(as);
+
+	return (0);
+}
+
+/* Start the "port". Depending on the underlying device and
+ * network type and what DLC support we have enabled we will
+ * start the DLC specific actions to start the DLC to send up
+ * packets. We mux all similar DLC types into the same rx
+ * handlers and demux it there. Actual specific DLC handlers are
+ * located in sna_dlc.c.
+ */
+int sna_cs_start_port(struct sna_start_port *sport)
+{
+	struct sna_port_cb *port;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+
+	sna_debug(5, "sna_cs_start_port\n");
+	cs = sna_cs_find(sport->netid.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name(sport->name);
+	if(!dlc)
+		return (-ENOENT);
+	port = sna_cs_find_port(dlc->port_list, sport->saddr);
+	if(!port)
+		return (-ENOENT);
+
+	switch(port->dev->type)
+	{
+#ifdef CONFIG_SNA_LOOPBACK
+		case (ARPHRD_LOOPBACK):
+			break;
+#endif
+
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+		case (ARPHRD_IEEE802):
+		case (ARPHRD_FDDI):
+			port->flags |= SNA_UP;
+			port->llc_dl = register_8022_client(port->saddr[0],
+				sna_dlc_llc_rcv, sna_dlc_llc_event);
+			if(port->llc_dl == NULL)
+			{
+				printk("Unable to register 8022 client\n");
+				return (-1);
+			}
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+
+		default:
+			return (-EINVAL);
+	}
+
+	port->flags	&= ~SNA_STOPPED;
+	port->flags	|= SNA_RUNNING;
+
+	return (0);
+}
+
+int sna_cs_stop_ls(struct sna_stop_link_station *sls)
+{
+	struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+	struct sna_tg_cb *tg;
+
+        sna_debug(5, "sna_cs_stop_ls\n");
+        cs = sna_cs_find(sls->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(sls->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, sls->saddr);
+        if(!port)
+                return (-ENOENT);
+        ls = sna_cs_find_ls(port->ls_list, sls->dname, sls->daddr);
+        if(!ls)
+                return (-ENOENT);
+	tg = sna_tdm_find_tg_by_id(ls->tg_id);
+	if(tg)
+	{
+		del_timer(&tg->co_retry);
+		tg->co_status = CO_RESET;
+		tg->co_retries = 0;
+	}
+
+	ls->flags &= ~SNA_RUNNING;
+	ls->flags |= SNA_STOPPED;
+
+#ifdef NOT
+	/* Send formal disconnect to partner if link is active */
+	if(tg->xid_info != NULL)
+	{
+		if(tg->xid_info->xid_status == XID_ACTIVE)
+			llc_disconnect(port->llc_dl, port->dev, 
+				tg->tg_vector.desc.dlc.mac,
+				tg->tg_vector.desc.dlc.lsap, 0);
+	}
+#endif
+
+	return (0);
+}
+
+int sna_cs_stop_port(struct sna_stop_port *sport)
+{
+	struct sna_port_cb *port;
+        struct sna_cs_pinfo *cs;
+        struct sna_dlc_cb *dlc;
+
+        sna_debug(5, "sna_cs_stop_port\n");
+        cs = sna_cs_find(sport->netid.name);
+        if(!cs)
+                return (-ENOENT);
+        dlc = sna_cs_find_dlc_name(sport->name);
+        if(!dlc)
+                return (-ENOENT);
+        port = sna_cs_find_port(dlc->port_list, sport->saddr);
+        if(!port)
+                return (-ENOENT);
+
+#ifdef CONFIG_SNA_LAR
+        sna_lar_erase(sport->netid.name, sport->netid.net);
+#endif
+
+        switch(port->dev->type)
+        {
+#ifdef CONFIG_SNA_LLC
+		case (ARPHRD_ETHER):
+                case (ARPHRD_IEEE802):
+                case (ARPHRD_FDDI):
+			port->flags &= ~SNA_RUNNING;
+			port->flags |= SNA_STOPPED;
+			if((llc_disconnect(port->llc_dl, port->dev, 0,0,0)) < 0)
+				break;	/* Already disconnected. */
+			/* Need to wait for the correct event response. */
+			break;
+#endif
+#ifdef CONFIG_SNA_ATM
+		case (ARPHRD_ATM):
+			break;
+#endif
+#ifdef CONFIG_SNA_CHANNEL
+		case (ARPHRD_CHANNEL):
+			break;
+#endif
+#ifdef CONFIG_SNA_HDLC
+		case (ARPHRD_HDLC):
+			break;
+#endif
+#ifdef CONFIG_SNA_SDLC
+		case (ARPHRD_SDLC):
+			break;
+#endif
+	}
+
+	return (0);
+}
+
+int sna_dlc_ginfo(struct sna_dlc_cb *dlc, char *buf, int len)
+{
+	struct dlcreq dr;
+	int done = 0;
+
+	sna_debug(5, "sna_dlc_ginfo\n");
+	if(!buf)
+        {
+                done += sizeof(dr);
+                return (done);
+        }
+        if(len < (int)sizeof(dr))
+                return done;
+        memset(&dr, 0, sizeof(struct dlcreq));
+
+        /* Move the data here */
+//	strncpy(dr.dlc_net, cs->netid.net, 8);
+//	strncpy(dr.dlc_name, cs->netid.name, 8);
+	strncpy(dr.devname, dlc->dev->name, SNA_RESOURCE_NAME_LEN);
+	dr.port_qlen		= dlc->port_qlen;
+	dr.proc_id 		= dlc->proc_id;
+	dr.flags 		= dlc->flags;
+
+        if(copy_to_user(buf, &dr, sizeof(struct dlcreq)))
+                return (-EFAULT);
+        buf += sizeof(struct dlcreq);
+        len -= sizeof(struct dlcreq);
+        done += sizeof(struct dlcreq);
+
+	return (done);
+}
+
+int sna_cs_query_dlc(char *arg)
+{
+        struct sna_dlc_cb *dlc;
+        struct dlconf dc;
+        char *pos;
+        int len, total;
+
+        sna_debug(5, "sna_cs_query_dlc\n");
+        if(copy_from_user(&dc, arg, sizeof(dc)))
+                return (-EFAULT);
+
+        pos = dc.dlc_buf;
+        len = dc.dlc_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+                int done;
+
+                if(pos == NULL)
+                        done = sna_dlc_ginfo(dlc, NULL, 0);
+                else
+                        done = sna_dlc_ginfo(dlc, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        dc.dlc_len = total;
+        if(copy_to_user(arg, &dc, sizeof(dc)))
+                return (-EFAULT);
+
+        return (0);
+}
+
+int sna_port_ginfo(struct sna_port_cb *port, char *buf, int len)
+{
+        struct portreq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_port_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(pr);
+                return (done);
+        }
+        if(len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct portreq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &port->netid, sizeof(struct sna_netid));
+	strncpy(pr.devname, port->dev->name, SNA_RESOURCE_NAME_LEN);
+	memcpy(&pr.saddr, port->saddr, 12);
+	pr.ls_qlen	= port->ls_qlen;
+	pr.proc_id	= port->proc_id;
+	pr.flags	= port->flags;
+	pr.role		= port->role;
+	pr.btu		= port->btu;
+	pr.mia		= port->mia;
+	pr.moa		= port->moa;
+
+        if(copy_to_user(buf, &pr, sizeof(struct portreq)))
+                return (-EFAULT);
+        buf += sizeof(struct portreq);
+        len -= sizeof(struct portreq);
+        done += sizeof(struct portreq);
+
+        return (done);
+}
+
+int sna_cs_query_port(char *arg)
+{
+	struct portconf pc;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        char *pos;
+        int len, total;
+
+        sna_debug(10, "sna_cs_query_port\n");
+        if(copy_from_user(&pc, arg, sizeof(pc)))
+                return (-EFAULT);
+
+        pos = pc.portc_buf;
+        len = pc.port_len;
+
+	/*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+        	for(port = dlc->port_list; port != NULL; port = port->next)
+        	{
+        	        int done;
+	
+	                if(pos == NULL)
+	                        done = sna_port_ginfo(port, NULL, 0);
+	                else
+	                        done = sna_port_ginfo(port,pos+total,len-total);
+	                if(done < 0)
+	                        return (-EFAULT);
+	                total += done;
+	        }
+	}
+
+        pc.port_len = total;
+        if(copy_to_user(arg, &pc, sizeof(pc)))
+                return (-EFAULT);
+	return (0);
+}
+
+int sna_ls_ginfo(struct sna_ls_cb *ls, char *buf, int len)
+{
+        struct lsreq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_ls_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(lr);
+                return (done);
+        }
+        if(len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lsreq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &ls->netid, sizeof(struct sna_netid));
+	memcpy(&lr.devname, ls->devname, SNA_RESOURCE_NAME_LEN);
+	memcpy(&lr.dname, ls->dname, SNA_FQCP_NAME_LEN);
+	memcpy(&lr.daddr, ls->daddr, 12);
+	lr.sport	= ls->sport;
+	lr.proc_id	= ls->proc_id;
+	lr.flags	= ls->flags;
+	lr.auto_act	= ls->auto_act;
+	lr.auto_deact	= ls->auto_deact;
+
+        if(copy_to_user(buf, &lr, sizeof(struct lsreq)))
+                return (-EFAULT);
+        buf += sizeof(struct lsreq);
+        len -= sizeof(struct lsreq);
+        done += sizeof(struct lsreq);
+
+        return (done);
+}
+
+int sna_cs_query_ls(char *arg)
+{
+        struct lsconf lc;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+        char *pos;
+        int len, total;
+
+       	sna_debug(10, "sna_cs_query_ls\n");
+        if(copy_from_user(&lc, arg, sizeof(lc)))
+                return (-EFAULT);
+
+        pos = lc.lsc_buf;
+        len = lc.ls_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+		for(port = dlc->port_list; port != NULL; port = port->next)
+		{
+        		for(ls = port->ls_list; ls != NULL; ls = ls->next)
+        		{
+	                	int done;
+	
+		                if(pos == NULL)
+		                        done = sna_ls_ginfo(ls, NULL, 0);
+		                else
+			                done = sna_ls_ginfo(ls,pos+total,len-total);
+		                if(done < 0)
+		                        return (-EFAULT);
+		                total += done;
+		        }
+		}
+	}
+
+        lc.ls_len = total;
+        if(copy_to_user(arg, &lc, sizeof(lc)))
+                return (-EFAULT);
+        return (0);
+}
+
+/* Build a specified Xid control vector at the specified memory location,
+ * we build it using dynamic data were applicable.
+ */
+int sna_cs_build_xid_cv(struct sna_tg_cb *tg, struct sk_buff *skb, __u8 type)
+{
+	int len = 0, size;
+	unsigned char name[50], scratch[50];
+	__u8 l, s, r, *cv_start;
+
+	sna_debug(10, "sna_cs_build_xid_cv %d -%s-\n",
+		tg->tg_vector.desc.id.pcp_len, 
+		tg->tg_vector.desc.id.pcp_name);
+
+	switch(type)
+	{
+		case (CV_KEY_NETNAME):
+			size = 1 + 3 + tg->tg_vector.desc.id.pcp_len;
+			cv_start = (__u8 *)skb_put(skb, size);
+			len = 1;
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+			l = tg->tg_vector.desc.id.pcp_len + 1;
+                        memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+			r = CV_CP_NAME;
+			memcpy(cv_start + len, &r, sizeof(__u8));
+			len += sizeof(__u8);
+			fatoe_strncpy(name, tg->tg_vector.desc.id.pcp_name,
+				tg->tg_vector.desc.id.pcp_len);
+			memcpy(cv_start + len, name, 
+				tg->tg_vector.desc.id.pcp_len);
+			len += tg->tg_vector.desc.id.pcp_len;
+			break;
+
+		case (CV_KEY_PRODUCT_ID):
+			memset(scratch, 0, 50);
+			sprintf(scratch, "%s %s", sna_product_name,sna_version);
+			size = 10 + strlen(sna_product_id) + strlen(scratch);
+                        cv_start = (__u8 *)skb_put(skb, size);
+
+			/* Cv type */
+			memcpy(cv_start + len, &type, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* entire length of cv */
+			l = (6 + strlen(sna_product_id))+(2 + strlen(scratch));
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* Length of data fields */
+			l = 2 + strlen(sna_product_id) + 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* Common SV code */
+			s = 0x11;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8) + 1;
+
+			/* version length */
+			l = 2 + strlen(sna_product_id);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* version codec */
+			s = 0x02;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual version */
+			atoe_strncpy(name, sna_product_id, 
+				strlen(sna_product_id));
+			memcpy(cv_start + len, name, strlen(sna_product_id));
+			len += strlen(sna_product_id);
+
+			/* Product Name length */
+			l = 2 + strlen(scratch);
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* product name codec */
+			s = 0x06;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += sizeof(__u8);
+
+			/* actual product name */
+			memset(name, 0, 50);
+			fatoe_strncpy(name, scratch, strlen(scratch));
+                        memcpy(cv_start + len, name, strlen(scratch));
+			len += strlen(scratch);
+			break;
+	}
+
+	return (len);
+}
+
+/* Initialize an XID, we load any defaults and initialize any fields
+ * that we have the data provided in sna_tg_cb. The xid is not valid
+ * when this function finishes, we return the length of data added.
+ */
+sna_xid3 *sna_cs_init_xid(struct sna_tg_cb *tg, struct sk_buff *skb)
+{
+	struct sna_nodeid *n;
+	sna_xid3 *xid;
+
+	sna_debug(5, "sna_cs_init_xid\n");
+	xid = (sna_xid3 *)skb_push(skb, sizeof(sna_xid3));
+        xid->xid_node           = SNA_XID_NODE_T2;
+        xid->xid_type           = SNA_XID_TYPE_3;
+        xid->nc1                = 0x00;
+	xid->nc2		= 0x00;
+        xid->tx_adptv_bind_pacing= 1;
+        xid->rx_adprv_bind_pacing= 1;
+        xid->quiesce_tg_req      = 0;
+        xid->pu_cap_sup          = 1;
+        xid->appn_pbn            = 0;
+        xid->adptv_bind_pacing   = 0x01;
+        xid->tg_sharing_prohibited = 0;
+        xid->dedicated_scv       = 0;
+        xid->parallel_tg_sup     = 0;
+        xid->dlur_actpu          = 0;
+        xid->dlus_lu_reg         = 1;
+        xid->gen_odai_usage_opt_set = 0;
+        xid->dlc_type           = 0x01;
+        xid->dlc_len            = 11;
+	xid->ls_flags		= 0x00;
+	xid->dlc_init_mode      = 1;
+
+	/* only dynamic inits for now. */
+	n = sna_nof_find_nodeid(sna_char_to_netid
+		(tg->tg_vector.desc.id.pcp_name));
+	if(n)
+	{
+		xid->block_id	= n->block_id;
+		xid->pu_id	= n->pu_id;
+	}
+
+	sna_debug(5, "Nodeid is %X %X\n", xid->block_id, xid->pu_id);
+	xid->tg_num             = tg->tg_vector.desc.id.tg_number;
+        xid->max_btu_len	= htons(tg->dev->mtu);
+        xid->max_rx_iframes 	= 0x07;
+
+	return (xid);
+}
+
+/* Build a complete XID header. This is done by using the data we
+ * have saved and by using the existing state information.
+ * We receive an SKB will space allocated for the MAC header, we need
+ * to push on enough space for the DL header and XID header, then we
+ * return the skb.
+ */
+int sna_cs_build_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+	struct net_device *dev = tg->dev;
+	struct sk_buff *skb;
+	int size, len;
+
+	sna_debug(5, "sna_cs_build_xid\n");
+	/* compute total packet size, we lie for now and make bigger */
+	size = dev->hard_header_len + LLC_XID_SIZE + 150;
+	skb = alloc_skb(size, GFP_ATOMIC);
+	skb->dev = dev;
+
+	/* build the actual xid information for a specific xid type */
+	switch(xid->xid_status)
+	{
+		case (XID_S_NULL):
+		{
+			llchdr *llc;
+			skb_reserve(skb, LLC_XID_SIZE);
+        		skb_reserve(skb, dev->hard_header_len);
+			llc = (llchdr *)skb_push(skb, LLC_XID_SIZE);
+                        llc->dsap       = tg->tg_vector.desc.dlc.lsap;
+                        llc->ssap       = tg->lsap;
+                        llc->ctrl.ctrl  = LLC_CTRL_XID_CMD;
+			llc->ctrl.uctrl.pf = xid->xid_direction;
+			break;
+		}
+
+		case (XID_S_NEG):
+		{
+			llchdr *llc;
+			sna_xid3 *x3;
+			skb_reserve(skb, 80);	/* may need to make correct */
+			skb_reserve(skb, LLC_XID_SIZE);
+                        skb_reserve(skb, dev->hard_header_len);
+			x3 = sna_cs_init_xid(tg, skb);
+			len = sizeof(sna_xid3);
+			len += sna_cs_build_xid_cv(tg, skb, CV_KEY_NETNAME);
+                        len += sna_cs_build_xid_cv(tg, skb, CV_KEY_PRODUCT_ID);
+			x3->len 	= len;
+			x3->nc2        	= 0xF7;
+			x3->ls_flags   	= 0x41;
+			llc = (llchdr *)skb_push(skb, LLC_XID_SIZE);
+                        llc->dsap       = tg->tg_vector.desc.dlc.lsap;
+                        llc->ssap       = tg->lsap;
+                        llc->ctrl.ctrl  = LLC_CTRL_XID_CMD;
+			break;
+		}
+
+		/* this should never happen, but if it does we can handle it */
+		case (XID_ACTIVE):
+			kfree_skb(skb);
+			return (0);
+
+		case (XID_S_PN):
+		case (XID_S_PRI):
+		case (XID_S_SEC):
+		case (XID_FAIL):
+		default:
+			kfree_skb(skb);
+			return (-1);
+	}
+
+	if(sna_debug_level > 5)
+        {
+                printk("Jay, check out the Xids on that packet ;)\n");
+                hexdump(skb->data, skb->len);
+        }
+
+	/* add the physical header to the packet */
+        dev->hard_header(skb, skb->dev, ETH_P_802_3,
+                tg->tg_vector.desc.dlc.mac, NULL, skb->len);
+
+	/* save a copy of this Xid */
+	if(xid->last_tx_xid != NULL)
+		kfree_skb(xid->last_tx_xid);
+	xid->last_tx_xid = skb_copy(skb, GFP_ATOMIC);
+
+	/* transmit xid */
+	xid->xid_count++;
+        dev_queue_xmit(skb);
+
+	return (0);
+}
+
+int sna_cs_xid_xchg_state(struct sk_buff *skb)
+{
+	sna_xid3 *xid = (sna_xid3 *)&skb->data[3];
+
+	sna_debug(5, "sna_cs_xid_xchg_state %02X\n", xid->nc2);
+	if(xid->len == 0)
+		return (XID_NULL);
+
+	if(xid->nc2 == 0xFB)
+		return (XID_PN);
+
+	if(xid->nc2 == 0xF7)
+		return (XID_NEG);
+	else
+		return (-1);
+
+	return (0);
+}
+
+int sna_cs_fsm_tgn_neg(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_fsm_tgn_neg\n");
+
+	return (0);
+}
+
+int sna_cs_validate_adjacent_node_id(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_validate_adjacent_node_id\n");
+
+	return (0);
+}
+
+int sna_cs_xid_error_chk(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_cs_xid_error_chk\n");
+
+	return (0);
+}
+
+int sna_cs_process_xid(struct sna_tg_cb *tg)
+{
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "sna_cs_process_xid\n");
+	switch(xid->xid_status)
+	{
+		case (XID_RESET):	/* Send XID PN Cmd or Rsp */
+		case (XID_S_NULL):	/* last tx xnull timed out, retry */
+			xid->xid_status = XID_S_NULL;
+			sna_cs_build_xid(tg);
+			break;
+
+		/* received a xid null, this could be a poll or a resposne */
+		case (XID_R_NULL):
+			sna_debug(5, "Received an XID_R_NULL can proceed\n");
+			if(xid->xid_initiator)			/* rx poll */
+			{
+				printk("Sending an Null Xid Response\n");
+				xid->xid_status = XID_S_NULL;	/* tx final */
+				sna_cs_build_xid(tg);
+			}
+			else	/* rx final, proceed to next state */
+			{
+				xid->xid_status = XID_S_NEG;
+				/* Will be followed by a Xid Poll sent by the
+				 * remote side, then we will proceed to actually
+				 * sending the NEG xid in case (XID_S_NEG).
+				 * sna_cs_build_xid(tg);
+				 */
+			}
+			break;
+
+		/* At this point we have verified the host exists and have
+		 * exchanged NULL Xids. We now start to negotiate the options.
+		 */
+		case (XID_S_NEG):
+			sna_debug(5, "Permission to send NEG XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_R_NEG):
+			sna_debug(5, "Responding with another NEG\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_ACTIVE):
+                        sna_debug(5, "Active XID estabilished\n");
+                        xid->xid_retries = 0;
+			wake_up_interruptible(&tg->sleep);
+			break;
+
+		case (XID_R_PN):
+			sna_debug(5, "I see a Pre Neg XID\n");
+			xid->xid_status = XID_S_NEG;
+			sna_cs_build_xid(tg);
+			break;
+
+		case (XID_S_PN):
+		case (XID_FAIL):
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return (-1);
+	}
+
+	return (0);
+}
+
+/* Only called if we have an incomming XID, this is basicly the same as
+ * connect_out(), just from the other side.
+ */
+int sna_cs_connect_in(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ethhdr *eth_hdr = skb->mac.ethernet;
+	struct sna_xid_info *xid;
+	struct sna_tg_cb *tg;
+
+	if(sna_debug_level > 5)
+	{
+		printk("sna_cs_connect_in\n");
+		hexdump(skb->data, skb->len);
+	}
+
+        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+	if(!tg)
+	{
+		kfree_skb(skb);
+		return (-ENOENT);
+	}
+
+	/* xid is one of ours increase the count */
+	xid = tg->xid_info;
+	xid->xid_count++;
+
+	/* determine type of xid packet */
+        switch(sna_cs_xid_xchg_state(skb))
+        {
+                case (XID_NULL):
+			/* Reveived Null Xid Poll, send response */
+			if(xid->xid_status == XID_RESET)
+			{
+				tg->co_status = CO_TEST_OK;
+				xid->xid_initiator = 1;		/* remote */
+				xid->xid_direction = XID_INBOUND;
+				xid->xid_status = XID_R_NULL;
+				break;
+			}
+
+			if(!xid->xid_initiator && xid->xid_status == XID_S_NEG)
+			{
+				sna_debug(5, "Some funky shit happen'n here\n");
+                        	break;
+			}
+			else
+			{
+				sna_debug(5, "Can't handle NULL XID\n");
+				kfree_skb(skb);
+				return (-1);
+			}
+
+                case (XID_NEG):
+			sna_debug(5, "Received an XID NEG\n");
+			xid->xid_direction = XID_INBOUND;
+			xid->xid_status = XID_S_NEG;
+			break;
+
+                case (XID_PN):
+			xid->xid_direction = XID_INBOUND;
+			xid->xid_status = XID_S_NEG;
+			break;
+
+		default:
+        		sna_debug(5, "Got XID not handle ignoring\n");
+			kfree_skb(skb);
+			return (-1);
+	}
+
+	/* we need to do further processing on this xid, save then do it. */
+	if(xid->last_rx_xid != NULL)
+        	kfree_skb(xid->last_rx_xid);
+        xid->last_rx_xid = skb;
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+
+	return (0);
+}
+
+/* Complete any necessary DLC processing to bring up a link 
+ *
+ * One could argue that this is a nasty little function. It is
+ * not only called by other functions but is also a timer-expire
+ * backend.
+ */
+void sna_cs_connect_out(unsigned long data)
+{
+	struct sna_tg_cb *tg = (struct sna_tg_cb *)data;
+	struct sna_xid_info *xid = tg->xid_info;
+
+	sna_debug(5, "sna_cs_connect_out (test %d %d) (xid %d %d)\n", 
+		tg->co_retries, tg->co_max_retries, xid->xid_retries, 
+		xid->xid_retry_limit);
+
+	del_timer(&tg->co_retry);
+	switch(tg->co_status)
+	{
+		case (CO_RESET):
+		case (CO_S_TEST_C):
+			if(tg->co_retries < tg->co_max_retries)
+			{
+				struct sk_buff *skb;
+				struct net_device *dev = tg->dev;
+
+				skb = alloc_skb(dev->hard_header_len
+					+ LLC_TYPE1_SIZE + 20, GFP_ATOMIC);
+				if(!skb)
+					return;
+				skb_reserve(skb, LLC_TYPE1_SIZE);
+				skb_reserve(skb, dev->hard_header_len);
+				skb->dev = dev;
+
+				tg->co_status = CO_S_TEST_C;
+				tg->co_retries++;
+				llc_test(tg->lsap, tg->tg_vector.desc.dlc.lsap, 
+					tg->tg_vector.desc.dlc.mac, skb, dev);
+				tg->co_retry.expires = jiffies+tg->co_interval;
+				add_timer(&tg->co_retry);
+			}
+			else
+				tg->co_status = CO_FAIL;
+			return;
+
+		case (CO_R_TEST_R):	/* Received valid TEST rsp */
+			tg->co_status = CO_TEST_OK;
+			/* Fall through */
+
+		case (CO_TEST_OK):
+			tg->co_retries = 0;
+			break;
+
+		case (CO_FAIL):
+		default:
+			wake_up_interruptible(&tg->sleep);
+			return;
+	}
+
+	switch(xid->xid_status)
+	{
+		/* Null Xid poll failed, retry */
+		case (XID_S_NULL):
+			xid->xid_direction = XID_OUTBOUND;
+			xid->xid_status = XID_S_NULL;
+			break;
+
+		case (XID_R_NEG):
+			xid->xid_direction = XID_OUTBOUND;
+			break;
+		default:
+//                      printk("Got XID not handle ignoring\n");
+//			xid->xid_status = XID_RESET;
+			break;
+	}
+
+	del_timer(&xid->xid_timer);
+	sna_cs_process_xid(tg);
+	return;
+}
+
+/* Finally activate the actual connection (XIDs) and return to the call
+ * a nice shinny pcid.
+ */
+int sna_cs_activate_route(struct sna_activate_route *ar)
+{
+	struct sna_tdm_node_cb *nc;
+	struct sna_tg_cb *tc;
+	struct sna_cs_pinfo *cs;
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+	struct sna_pc_pinfo *pc;
+	struct sna_pc_create_parms *pp;
+	struct sna_activate_as *as;
+	char tsap[3];		/* XXX */
+
+	sna_debug(5,"sna_cs_activate_route to %s\n",sna_pr_netid(&ar->cp_name));
+	pc = sna_pc_find_by_netid(&ar->cp_name);
+	if(pc)
+	{
+		sna_debug(5, "found an already active route\n");
+		/* route is already active, this can be either a loopback
+		 * connection or an actual physical connection. No further
+		 * XID negotiation is needed. We just return the Path Control
+		 * ID.
+		 */
+		memcpy(&ar->pc_id, &pc->pc_id, 8);
+		return (0);
+	}
+
+/*
+	nc = sna_tdm_find_node_entry(&ar->cp_name);
+	if(!nc)
+		return (-ENOENT);
+	tc = sna_tdm_find_tg(nc, ar->tg_id);
+*/
+	tc = sna_tdm_find_tg_by_id(ar->tg_id);
+	if(!tc)
+		return (-ENOENT);
+	cs = sna_cs_find("EHEAD   ");
+//	cs = sna_cs_find(ar->cp_name.name);
+	if(!cs)
+		return (-ENOENT);
+	dlc = sna_cs_find_dlc_name("eth0");
+	if(!dlc)
+		return (-ENOENT);
+	tsap[0] = 0x04;
+	port = sna_cs_find_port(dlc->port_list, tsap);
+	if(!port)
+		return (-ENOENT);
+
+	tc->co_status 			= CO_RESET;
+	tc->xid_info->xid_status 	= XID_RESET;
+	tc->xid_info->xid_initiator 	= 0x00;		/* US */
+	tc->xid_info->xid_direction	= XID_OUTBOUND;
+	sna_cs_connect_out((unsigned long)tc);
+
+	sna_debug(5, "returned from connect_out to sleep\n");
+
+	/* Now we must wait for the link activation to complete */
+	cli();
+	interruptible_sleep_on(&tc->sleep);
+        if(signal_pending(current))
+        {
+        	sti();
+		return (-ERESTARTSYS);
+	}
+	sti();
+
+	sna_debug(5, "woke from sleep.. why?\n");
+
+	/* check reason for being woken up.. test/xid failed, or success */
+	if(tc->co_status != CO_TEST_OK 
+		&& tc->xid_info->xid_status != XID_ACTIVE)
+	{
+		sna_debug(5, "failed activation\n");
+		return (-ENONET);	/* test/xid link activation failed */
+	}
+
+	/* we now have an activated link, lets finish her up */
+	pp = (struct sna_pc_create_parms *)kmalloc
+		(sizeof(struct sna_pc_create_parms), GFP_ATOMIC);
+	memcpy(&pp->fqcp, &cs->netid, sizeof(struct sna_netid));
+	pp->dlc		= dlc;
+	pp->ls		= NULL;
+	pp->port	= port;
+	pp->type	= 0;
+	pp->max_tx_btu	= 0; 
+	pp->max_rx_btu	= 0;
+	pp->bind_seg	= 0;
+	pp->limited_tg	= 0;
+	pp->tg_number	= ar->tg_id;
+	pp->odai	= 0;
+	pp->local_seg	= 0;
+	pp->godai	= 0;
+	sna_pc_init(pp);
+	memcpy(&ar->pc_id, &pp->pc_id, 8);
+	kfree(pp);
+
+	/* lets finally activate this links address space and return */
+	as = (struct sna_activate_as *)kmalloc
+		(sizeof(struct sna_activate_as), GFP_ATOMIC);
+	memcpy(&as->pc_id, &ar->pc_id, 8);
+	as->intranode			= 0;
+	as->odai			= 0;
+	as->max_btu			= 0;
+	as->tx_rx_bind_pacing 		= 0;
+	as->dependent_lulu 		= 0;
+	as->adp_bind_pacing_dep_lulu 	= 0;
+	as->generalized_oadi 		= 0;
+	sna_asm_activate_as(as);
+	kfree(as);
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_cs_get_info_dlc(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_dlc_cb *dlc;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the LLC data for the /proc filesystem. */
+        len += sprintf(buffer, "%-7s%-8s%-6s%-10s\n", "dlc_id", 
+		"name", "flags", "port_qlen");
+
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+                len += sprintf(buffer + len, "%-7d%-8s%02X    %-10d\n", 
+			dlc->proc_id, dlc->dev->name, dlc->flags,
+			dlc->port_qlen);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_cs_get_info_port(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_dlc_cb *dlc;
+        struct sna_port_cb *port;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the Port data for the /proc filesystem. */
+        len += sprintf(buffer, "%-17s%-8s%-7s%-5s%-5s%-5s%-5s%-6s%-8s\n", 
+		"NetID.Node",
+		"port_id", "device", "port", "btu", "mia", "moa", "flags", 
+		"ls_qlen");
+
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+	{
+        	for(port = dlc->port_list; port != NULL; port = port->next)
+        	{
+			len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&port->netid));
+        	        len += sprintf(buffer + len, "%-8d%-7s%02X   %-5d%-5d%-5d%02X    %-8d\n", 
+				port->proc_id,
+        	                port->dev->name, port->saddr[0], port->btu,
+				port->mia, port->moa, port->flags,
+				port->ls_qlen);
+	
+			pos = begin + len;
+	                if(pos < offset)
+	                {
+	                        len = 0; 
+				begin = pos;
+       	         	}
+                	if(pos > offset + length)
+                        	break;
+        	}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_cs_get_info_ls(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_dlc_cb *dlc;
+	struct sna_port_cb *port;
+        struct sna_ls_cb *ls;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the Link Station data for the /proc filesystem. */
+        len += sprintf(buffer, "%-18s%6s%7s%5s%13s%6s%5s%7s%6s\n", 
+		"NetID.Node", "ls_id", "device", "port", "adjacent_mac",
+		"aport", "aact", "adeact", "flags");
+
+	/* Triple linked lists are always fun. */
+	for(dlc = dlc_clients; dlc != NULL; dlc = dlc->next)
+        {
+		for(port = dlc->port_list; port != NULL; port = port->next)
+		{
+        		for(ls = port->ls_list; ls != NULL; ls = ls->next)
+        		{
+                        	len += sprintf(buffer + len, "%-18s",
+					sna_pr_netid(&ls->netid));
+                		len += sprintf(buffer + len, 
+					"%6d%7s   %02X %6s"
+					"    %02X%5d%7d  %04X\n", 
+					ls->proc_id, ls->dlc->dev->name,
+					ls->sport, sna_pr_ether(ls->dname),
+					ls->daddr[0],
+					ls->auto_act, ls->auto_deact,
+					ls->flags);
+
+                			if(pos < offset)
+                			{
+                        			len = 0;
+						begin = pos;
+                			}
+                			if(pos > offset + length) 
+                        			break;
+        		}
+		}
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
diff -ruN linux-2.4.4/net/sna/sna_dfc.c linux/net/sna/sna_dfc.c
--- linux-2.4.4/net/sna/sna_dfc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_dfc.c	Mon May 14 21:09:28 2001
@@ -0,0 +1,1540 @@
+/* sna_dfc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Data Flow Control (DFC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if_ether.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+/* Needs to put data right on the rx_queue of the local listener
+ * corresponding with the bracket ID in the packet.
+ */
+static int sna_dfc_send_to_ps(struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+	struct snathdr *th;
+	__u32 lfsid;
+
+	sna_debug(5, "sna_dfc_send_to_ps\n");
+/*
+	lfsid = sna_pc_find_lfsid_by_daf(skb->th.fm.f5.daf);
+	if(!lfsid)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	rcb = sna_asm_find_rcb_by_lfsid(lfsid);
+	if(!rcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+
+	tcb = sna_cpic_find_tcb_by_id(rcb->tcb_id);
+	if(!tcb)
+	{
+		kfree_skb(skb);
+		return (-1);
+	}
+*/
+	th = (struct snathdr *)skb->data;
+	printk("DAF is %02X\n", th->fid.f2.daf);
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if(tcb == NULL)
+	{
+		printk("Not client found\n");
+		return (-1);
+	}
+
+	skb_queue_tail(&tcb->receive_queue, skb);
+	wake_up_interruptible(&tcb->sleep);
+        return (0);
+}
+
+static int sna_dfc_process_ru_data(struct sk_buff *skb)
+{
+	struct snarhdr *rh = (struct snarhdr *)&skb->data[6];
+	struct fmhdr *fm = NULL;
+
+	sna_debug(5, "sna_dfc_process_ru_data\n");
+	/* User Data */
+	if(rh->fi != SNA_RH_FI_FMH)
+	{
+		printk("inside user data if\n");
+
+		/* will never fail for now */
+		if(rh->eci == SNA_RH_ECI_EC || skb->data != NULL)
+                        sna_dfc_send_to_ps(skb);
+                else
+			kfree_skb(skb);
+
+                return (0);
+	}
+
+	/* Control data */
+	fm = (struct fmhdr *)&skb->data[9];
+	printk("FM type is %02X %02X %02X\n", fm->len, fm->type, skb->data[10]);
+        switch(fm->type)
+        {
+                case (FMH_5):    /* ATTACH */
+			sna_rm_process_hs_to_rm(skb);
+
+#ifdef NOT
+                        sna_build_hs_to_ps_header(mu);
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+
+                        /* Received HS_PS_CONNECTED from RM */
+                        lulu->ps_id      = hs_ps_connected->ps_id;
+                        lulu->bracket_id = hs_ps_connected->bracket_id;
+
+                        sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+                        kfree(hs_ps_connected);
+
+                        if(local->half_session == SNA_HS_PRI)
+                                lulu->current_bracket_sqn
+                                        = lulu->shs_bb_register;
+                        else
+                                lulu->current_bracket_sqn
+                                        = lulu->phs_bb_register;
+#endif
+                        break;
+
+                case (FMH_7):    /* Error Description. */
+			sna_dfc_send_to_ps(skb);
+                        break;
+
+                case (FMH_12):    /* Security. */
+#ifdef NOT
+                        mu->layer.hs_to_ps = *(struct sna_hs_to_ps *)kmalloc(sizeof(struct sna_hs_to_ps), GFP_KERNEL);
+                        mu->layer.hs_to_rm.hs_id = local->hs_id;
+                        sna_send_to_rm(mu);
+#endif
+                        break;
+
+		default:
+			printk("packet does NOT match anything!!!!!!\n");
+			kfree_skb(skb);
+			break;
+        }
+
+        return (0);
+}
+
+int sna_dfc_send_rsp_to_rm_or_ps(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_send_rsp_to_rm_or_ps\n");
+
+	return (0);
+}
+
+int sna_dfc_generate_rm_ps_inputs(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_generate_rm_ps_inputs\n");
+	sna_dfc_process_ru_data(skb);
+
+	return (0);
+}
+
+int sna_dfc_rcv_fsms(struct sk_buff *skb)
+{
+	sna_dfc_generate_rm_ps_inputs(skb);
+
+	/* if normal flow response */
+//	sna_dfc_send_rsp_to_rm_or_ps(skb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *llucb = &local->lulu;
+        int err;
+
+        err = sna_rcv_state_error(mu);
+        if(err)
+                sna_free_buffer(mu);
+        else
+                llucb->saved_mu_ptr = mu;
+#endif
+
+        return (0);
+}
+
+int sna_dfc_rcv(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dfc_rcv\n");
+	sna_dfc_rcv_fsms(skb);
+
+	return (0);
+}
+
+/* Maintain states by invoking the appropriate FSM while sending requests
+ * and responses.
+ */
+int sna_dfc_send_fsms(struct sk_buff *skb)
+{
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+        struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+        lulu->direction = SNA_HS_SEND;
+        th->snf = lulu->ct_rcv.snf;
+
+        if(req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_NORM)
+        {
+                if(lulu->rqd_required_on_ceb == SNA_DFC_NO)
+                {
+                        lulu->normal_flow_rq_cnt++;
+                        if(lulu->normal_flow_rq_cnt > 24)
+                                lulu->rqd_required_on_ceb = SNA_DFC_YES;
+                }
+                sna_ct_update(mu);
+
+                if(req_h->cebi == SNA_RH_CEBI_CEB)
+                {
+                        if(SNA_DFC_RQE1(req_h))
+                                SNA_DFC_SET_RQD1(req_h);
+
+                        if(SNA_DFC_RQD(req_h))
+                        {
+                                lulu->rqd_required_on_ceb = SNA_DFC_NO;
+                                lulu->normal_flow_rq_cnt = 0;
+                        }
+
+/*
+                        if(rq = SNA_DEALLOCATE_ABEND)
+                                SNA_DFC_SET_RQD1(req_h);
+*/
+                }
+
+                if(sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT)
+                        == SNA_DFC_FSM_PEND_SEND_REPLY)
+                        sna_fsm_chain_rcv_fmp19(mu, 0);
+
+                if(req_h->bbi == SNA_RH_BBI_BB)
+                {
+                        if(lulu->direction == SNA_HS_SEND)
+                        {
+                                if(local->half_session == SNA_HS_PRI)
+                                {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_PRI;
+                                }
+                                else
+                                {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_send.snf.bracket_started_by = SNA_HS_SEC;
+                                }
+                        }
+                        else
+                        {
+                                if(local->half_session == SNA_HS_PRI)
+                                {
+                                        lulu->shs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_SEC;
+                                }
+                                else
+                                {
+                                        lulu->phs_bb_register.number
+                                                = th->snf.number;
+                                        lulu->ct_rcv.snf.bracket_started_by = SNA_HS_PRI;
+                                }
+                        }
+
+                        if(req_h->bci == SNA_RH_BCI_BC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_BEGIN_CHAIN);
+                        if(req_h->eci == SNA_RH_ECI_EC)
+                                sna_fsm_chain_send_fmp19(mu,
+                                        SNA_DFC_FSM_END_CHAIN);
+                }
+        }
+
+        if(req_h->rri == SNA_RH_RRI_RSP && th->efi == SNA_TH_EFI_NORM)
+        {
+                sna_ct_update(mu);
+                sna_fsm_chain_rcv_fmp19(mu, 0);
+        }
+
+        if(req_h->rri == SNA_RH_RRI_REQ && th->efi == SNA_TH_EFI_EXP)
+                lulu->sig_rq_outstanding = SNA_DFC_YES;
+#endif
+
+        sna_tc_send_mu(skb);
+
+        return (0);
+}
+
+/* Initialize the TH and RH fields of an MU record. */
+int sna_dfc_init_th_rh(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snathdr *th;
+	struct snarhdr *rh;
+
+	sna_debug(5, "sna_dfc_init_th_rh\n");
+	skb->h.raw = skb_push(skb, sizeof(struct snarhdr));
+	rh = skb->h.rh;
+	rh->rri		= SNA_RH_RRI_REQ;
+	rh->ru		= SNA_RH_RU_FMD;
+	rh->fi		= SNA_RH_FI_NO_FMH;
+	rh->sdi		= SNA_RH_SDI_NO_SD;
+	rh->rti		= SNA_RH_RTI_POS;
+	rh->bci		= SNA_RH_BCI_NO_BC;
+        rh->eci      	= SNA_RH_ECI_NO_EC;
+        rh->rlwi     	= SNA_RH_RLWI_NO_RLW;
+        rh->qri      	= SNA_RH_QRI_NO_QR;
+        rh->pi       	= SNA_RH_PI_NO_PAC;
+        rh->bbi      	= SNA_RH_BBI_NO_BB;
+        rh->ebi      	= SNA_RH_EBI_NO_EB;
+        rh->cdi      	= SNA_RH_CDI_NO_CD;
+        rh->csi      	= SNA_RH_CSI_CODE0;
+        rh->edi      	= SNA_RH_EDI_NO_ED;
+        rh->cebi     	= SNA_RH_CEBI_NO_CEB;
+
+	if(rcb == NULL)
+	{
+		skb->h.raw[0] = 0x6B;
+		skb->h.raw[1] = 0x81;
+		skb->h.raw[2] = 0;
+	}
+
+	skb->nh.raw = skb_push(skb, sizeof(struct sna_fid2));
+        th = skb->nh.fidh;
+        th->fid.f2.efi          = SNA_TH_EFI_NORM;
+        th->fid.f2.snf.sqn      = 0;
+        th->fid.f2.snf.biui     = 0;
+	if(rcb != NULL)
+	{
+		th->fid.f2.oaf = rcb->oaf;
+		th->fid.f2.daf = rcb->daf;
+	}
+	else
+	{
+		struct sna_fid2_cheat *t = (struct sna_fid2_cheat *)skb->nh.raw;
+		t->bits[0] = 0x2F;	/* 0x2D */
+		t->bits[1] = 0;
+		t->bits[2] = 0;
+		t->bits[3] = 0x02;
+		t->bits[4] = 0x80;
+		t->bits[5] = 0x03;
+/*
+		th->fid.f2.ft  = 0x02;
+		th->fid.f2.mpf = 1;
+		th->fid.f2.efi = 1;
+		th->fid.f2.oaf = 0x02;
+		th->fid.f2.daf = 0x00;
+*/
+	}
+
+        return (0);
+}
+
+/* Send an MU according to passed instructions. */
+static int sna_dfc_send_fmd_mu(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	struct snarhdr *rh;
+	struct sna_ps_to_hs op = rcb->l.ps_to_hs;
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+#endif
+
+	sna_debug(5, "sna_dfc_send_fmd_mu %d %d\n", rcb->oaf, rcb->daf);
+        sna_dfc_init_th_rh(skb, rcb);
+	rh = skb->h.rh;
+
+	if(op.fmh)
+	{
+		printk("putting on FI_FMH\n");
+		rh->fi = SNA_RH_FI_FMH;
+/*
+		if(op.type == SNA_DEALLOCATE_ABEND)
+		{
+			lulu->deallocate_abend = SNA_DFC_YES;
+		}
+*/
+	}
+
+#ifdef NOT
+
+        if(lulu->ct_send.rq_code == SNA_CT_RQCODE_EC)
+        {
+                req_h->bci = SNA_RH_BCI_BC;
+                lulu->betc = SNA_DFC_NO;
+                if(mu->layer.ps_to_hs.allocate == SNA_DFC_YES)
+                        req_h->bbi = SNA_RH_BBI_BB;
+        }
+
+        if(mu->layer.ps_to_hs.type != SNA_MU_FLUSH)
+        {
+        /*      mu->rh = rh_stuff_in_ps_to_hs;  */
+                lulu->betc = SNA_DFC_YES;
+        }
+
+        if(req_h->bci && req_h->eci && mu->biu->ru.ru.raw == NULL)
+        {
+                mu->biu->ru.ru.lustat
+                        = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+        }
+#endif
+
+        sna_dfc_send_fsms(skb);
+        return (0);
+}
+
+/* Process the record received from presentation services (PS) and determine
+ * the proper response (positive or negative) or MU (data or signal) that needs
+ * to be sent to the partner HS via transmission control (TC). If an error
+ * is found while processing the PS_TO_HS record, the buffer will be freed
+ * by this procedure.
+ */
+int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb)
+{
+	sna_debug(5, "sna_dfc_send_from_ps\n");
+
+	/* SNA_MU_SEND_DATA_RECORD */
+	sna_dfc_send_fmd_mu(skb, rcb);
+
+#ifdef NOT
+        struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+        struct sna_lu_lu_cb *lulu = &local->lulu;
+        struct sna_ru *ru = &mu->biu->ru;
+
+        if(mu->layer.ps_to_hs.bracket_id == local->lulu.bracket_id)
+        {
+                sna_free_buffer(mu);
+                return (0);
+        }
+
+        switch(mu->layer.ps_to_hs.ps_to_hs_variant)
+        {
+                case (SNA_MU_SEND_DATA_RECORD):
+                        sna_dfc_send_fmd_mu(skb);
+                        break;
+
+                case (SNA_MU_CONFIRMED):
+                        if(lulu->ct_rcv.rq_code == SNA_DFC_RQD2_HEX
+                                || lulu->ct_rcv.rq_code == SNA_DFC_RQD3_HEX)
+                        {
+                                sna_send_rsp_mu(NULL, SNA_NORMAL, SNA_DFC_POS, 0);
+                        }
+                        else
+                                sna_free_buffer(mu);
+                        break;
+
+                case (SNA_MU_SEND_ERROR):
+                        if(local->state == SNA_DFC_FSM_BETC)
+                        {
+                                lulu->send_error_rsp_state = SNA_DFC_NEG_OWED;
+                                sna_free_buffer(mu);
+                        }
+                        else
+                                sna_send_rsp_mu(NULL, SNA_TH_EFI_NORM
+                                        ,SNA_DFC_NEG, 0x08460000);
+                        break;
+
+                case (SNA_MU_REQUEST_TO_SEND):
+                        sna_init_th_rh(mu);
+                        ru->ru.sig = *(struct sna_ru_sig *)kmalloc(sizeof(struct sna_ru_sig), GFP_KERNEL);
+                        local->rq_code = SNA_LOCAL_SIG;
+                        sna_dfc_send_fsms(mu);
+                        break;
+
+                default:
+                        return (-1);
+        }
+#endif
+
+        return (0);
+}
+
+#ifdef NOT
+
+static int sna_try_to_rcv_signal(struct sna_mu *mu);
+static int sna_build_hs_to_ps_header(struct sna_mu *mu);
+static int sna_ct_update(struct sna_mu *mu);
+static int sna_format_error(struct sna_mu *mu);
+static int sna_format_error_exp_rsp(struct sna_mu *mu);
+static int sna_format_error_norm_rsp(struct sna_mu *mu);
+static int sna_format_error_rq_dfc(struct sna_mu *mu);
+static int sna_format_error_rq_fmd(struct sna_mu *mu);
+static int sna_invalid_sense_code(struct sna_mu *mu);
+static int sna_ok_to_reply(struct sna_mu *mu);
+static int sna_rcv_state_error(struct sna_mu *mu);
+static int sna_reply_to_bid(struct sna_mu *mu);
+static int sna_send_bid_pos_rsp(struct sna_mu *mu);
+static int sna_send_rsp_if_required(struct sna_mu *mu);
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense);
+static int sna_signal_status(struct sna_mu *mu);
+static int sna_stray_rsp(struct sna_mu *mu);
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal);
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain);
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu);
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu);
+
+/* Process records received from the resource manager (RM). This procedure
+ * is called by the half session router.
+ */
+int sna_dfc_send_from_rm(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_ru *ru = &mu->biu->ru;
+
+	switch(mu->record_type)
+	{
+		case (SNA_REC_BID_WITHOUT_ATTACH):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM, 
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.lustat = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_REPLY):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.bis = *(struct sna_ru_bis *)kmalloc(sizeof(struct sna_ru_bis), GFP_KERNEL);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BIS_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_BRACKET_FREED):
+			sna_free_buffer(mu);
+			break;
+
+		case (SNA_REC_HS_PS_CONNECTED):
+			lulu->ps_id = hs_ps_connected->ps_id;
+			local->lulu.bracket_id = hs_ps_connected->bracket_id;
+
+			sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			else
+			{
+				lulu->current_bracket_sqn.number
+					= lulu->sqn_send_cnt.number++;
+				lulu->current_bracket_sqn.bracket_started_by
+					= local->half_session;
+				if(local->half_session == SNA_HS_PRI)
+					lulu->phs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+				else
+					lulu->shs_bb_register.number
+						= lulu->current_bracket_sqn.number;
+			}
+			break;
+
+		case (SNA_REC_RTR_RQ):
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.rtr = *(struct sna_ru_rtr *)kmalloc(sizeof(struct sna_ru_rtr), GFP_KERNEL);
+			local->rq_code = SNA_LOCAL_RTR;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_YIELD_SESSION):
+			if(lulu->session_just_started == SNA_DFC_YES)
+				lulu->session_just_started = SNA_DFC_NO;
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			sna_init_th_rh(mu);
+			ru->ru.lustat = *(struct sna_ru_lustat *)kmalloc(sizeof(struct sna_ru_lustat), GFP_KERNEL);
+			local->rq_code = SNA_LOCAL_LUSTAT;
+			sna_dfc_send_fsms(mu);
+			break;
+
+		case (SNA_REC_SECURITY_REPLY_2):
+			if(ru->ru.security_reply_2.send_parm.type 
+				== SNA_MU_DEALLOCATE_FLUSH)
+			{
+				lulu->session_just_started = SNA_DFC_NO;
+			}
+
+			mu = sna_get_buffer(SNA_BM_TYPE_PERM,
+				local->perm_buf_pool_id, 0, SNA_BM_NO_WAIT);
+			ru->ru.security_reply_2 = *(struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_KERNEL);
+			sna_send_fmd_mu(mu);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+/* This procedure determines if a REQUEST_TO_SEND record should be sent
+ * to PS to indicate a SIGNAL has been received. This procedure is called
+ * by the half-session router.
+ */
+static int sna_try_to_rcv_signal(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+
+	if(sna_fsm_bsm_fmp19(0, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB
+		&& lulu->sig_received == SNA_DFC_YES)
+	{
+		switch(sna_signal_status(mu))
+		{
+			case (SNA_DFC_SIG_CURRENT):
+				sna_dfc_send_to_ps(NULL);
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_STRAY):
+				lulu->sig_received = SNA_DFC_NO;
+				break;
+
+			case (SNA_DFC_SIG_FUTURE):
+				break;
+		}
+	}
+
+	return (0);
+}
+
+/* Process MUs received from TC. This procedure is called by TC. */
+int sna_dfc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u32 err;
+
+	lulu->direction = SNA_HS_RECEIVE;
+	if(local->sense == 0x00000000)
+	{
+		if(req_h->ru == SNA_RH_RU_DFC)
+		{
+			local->rq_code = req_h->rri;
+			if(local->rq_code == SNA_LOCAL_NO_CRV
+				|| local->rq_code == SNA_LOCAL_NO_BIS
+				|| local->rq_code == SNA_LOCAL_NO_LUSTAT
+				|| local->rq_code == SNA_LOCAL_NO_RTR
+				|| local->rq_code == SNA_LOCAL_NO_SIG)
+			{
+				local->rq_code = SNA_LOCAL_OTHER;
+			}
+		}
+		else
+			local->rq_code = SNA_LOCAL_OTHER;
+
+		err = sna_format_error(mu);
+		if(err)
+		{
+			sna_free_buffer(mu);
+			local->sense = err;
+			return (0);
+		}
+
+		if(req_h->rri == SNA_RH_RRI_REQ)
+		{
+			if(th->efi == SNA_TH_EFI_NORM)
+				sna_dfc_rcv_fsms(mu);
+			else
+			{
+				lulu->sig_received = SNA_DFC_YES;
+				lulu->sig_snf = th->snf;
+				sna_send_rsp_mu(mu, SNA_TH_EFI_EXP, 
+					SNA_DFC_POS, 0);
+				sna_free_buffer(mu);
+			}
+		}
+		else
+		{
+			if(sna_stray_rsp(mu))
+				sna_free_buffer(mu);
+			else
+				sna_dfc_rcv_fsms(mu);
+		}
+	}
+
+	return (0);
+}
+
+int sna_dfc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_mu *mu = NULL;
+
+	lulu->first_speaker 				= init_hs->type;
+	lulu->alternate_code				= SNA_DFC_TRUE;
+	lulu->sqn_send_cnt.number			= 0;
+	lulu->current_bracket_sqn.bracket_started_by 	= SNA_HS_PRI;
+	lulu->current_bracket_sqn.number 		= 0;
+	lulu->phs_bb_register.bracket_started_by 	= SNA_HS_PRI;
+	lulu->phs_bb_register.number 			= 0;
+	lulu->shs_bb_register.bracket_started_by 	= SNA_HS_SEC;
+	lulu->shs_bb_register.number 			= 0;
+	lulu->rqd_required_on_ceb 			= SNA_DFC_NO;
+	lulu->normal_flow_rq_cnt 			= 0;
+	lulu->sig_received 				= SNA_DFC_NO;
+	lulu->sig_snf.number 				= 0;
+	lulu->ps_id 					= 0;
+
+	/* Reset all FSMs to state 1 */
+
+	lulu->betc 			= SNA_DFC_YES;
+	lulu->send_error_rsp_state 	= 1; 
+	lulu->bb_rsp_state 		= 1;
+	lulu->rtr_rsp_state 		= 1;
+	lulu->sig_rq_outstanding 	= SNA_DFC_NO;
+
+	if(local->half_session == SNA_HS_PRI)
+		lulu->session_just_started = SNA_DFC_YES;
+	else
+		lulu->session_just_started = SNA_DFC_NO;
+
+	lulu->saved_mu_ptr = mu;
+	sna_dfc_send_to_ps(mu);
+
+        return (0);
+}
+
+/* Fill in mu->hs_to_ps_header based on the contents of mu->rh. */
+static int sna_build_hs_to_ps_header(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu->header_type = SNA_MU_HS_TO_PS;
+	mu->layer.hs_to_ps.fmh = SNA_DFC_NO;
+
+	if(req_h->fi == SNA_RH_FI_FMH)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			mu->layer.hs_to_ps.fmh = SNA_DFC_YES;
+		else
+			mu->dcf = sizeof(mu->biu->rh);
+	}
+
+	if(req_h->eci == SNA_RH_ECI_EC)
+	{
+		if(SNA_DFC_RQE1(req_h) && req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_FLUSH;
+
+		if(SNA_DFC_RQ1(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_FLUSH;
+		
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cdi != SNA_RH_CDI_CD
+			&& req_h->cebi != SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_CONFIRM;
+
+		if((SNA_DFC_RQ2(req_h) || SNA_DFC_RQ3(req_h)) 
+			&& req_h->cdi == SNA_RH_CDI_CD)
+			mu->layer.hs_to_ps.type = SNA_MU_PREPARE_TO_RCV_CONFIRM;
+
+		if((SNA_DFC_RQD2(req_h) || SNA_DFC_RQD3(req_h)) 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+			mu->layer.hs_to_ps.type = SNA_MU_DEALLOCATE_CONFIRM;
+	}
+	else
+		mu->layer.hs_to_ps.type = SNA_MU_NOT_END_OF_DATA;
+
+	return (0);
+}
+
+/* Record information about the last chain sent or received. This is done by
+ * updating the correlation table entry.
+ */
+static int sna_ct_update(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ct *ct = &local->lulu.ct_rcv;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->bci == SNA_RH_BCI_BC)
+		{
+			ct->entry_present	= SNA_DFC_YES;
+			ct->snf 		= th->snf;
+			ct->neg_rsp_sense 	= 0;
+			ct->rh.rh.req_h.ru 	= req_h->ru;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+				ct->rq_code = local->rq_code;
+			else
+				ct->rq_code = SNA_CT_OTHER;
+
+		}
+
+		if(req_h->eci == SNA_RH_ECI_EC)
+			ct->rh.rh.req_h.ru = req_h->ru;
+	}
+	else
+	{
+		if(rsp_h->sdi == SNA_RH_SDI_SD)
+			ct->neg_rsp_sense = local->sense;
+	}
+
+	return (0);
+}
+
+/* Perform format checks on all requests and responses for LU-LU session.
+ * These checks are optional. If an error is detected, the local->sense
+ * is set to the appropriate sense data. None, some, or all of these checks
+ * may be done.
+ */
+static int sna_format_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int rcode;
+
+	rcode = SNA_DFC_FALSE;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(req_h->ru == SNA_RH_RU_FMD)
+			sna_format_error_rq_fmd(mu);
+		else
+			sna_format_error_rq_dfc(mu);
+	}
+
+	if(th->efi == SNA_TH_EFI_NORM)
+		sna_format_error_norm_rsp(mu);
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		sna_format_error_exp_rsp(mu);
+
+	if(local->sense != 0x00000000)
+		rcode = SNA_DFC_TRUE;
+
+	return (rcode);
+}
+
+/* Perform format checks on expedited-flow responses. These checks are
+ * optional.
+ */
+static int sna_format_error_exp_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x40110000;
+
+	if(req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->qri == SNA_RH_QRI_QR)
+		local->sense = 0x40150000;
+
+	if(local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x40120000;
+
+	if(rsp_h->rti == SNA_RH_RTI_NEG)
+		memcpy(&local->sense, &mu->biu->ru, 4);
+
+	return (0);
+}
+
+/* Perform format checks on normal-flow responses. These checks are optional. */
+static int sna_format_error_norm_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if((req_h->sdi == SNA_RH_SDI_SD && rsp_h->rti == SNA_RH_RTI_POS)
+		|| (req_h->sdi == SNA_RH_SDI_NO_SD 
+		&& rsp_h->rti == SNA_RH_RTI_NEG))
+	{
+		local->sense = 0x40130000;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC && req_h->fi == SNA_RH_FI_NO_FMH)
+		local->sense = 0x400F000;
+
+	if(req_h->ru == SNA_RH_RU_FMD && rsp_h->rti == SNA_RH_RTI_POS 
+		&& req_h->fi == SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if((rsp_h->rti == SNA_RH_RTI_NEG
+		&& *(__u32 *)mu->biu->ru.ru.raw != 0x08130000)
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08140000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08190000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x08460000
+		|| *(__u32 *)mu->biu->ru.ru.raw != 0x088B0000)
+	{
+		local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+	}
+
+	return (0);
+}
+
+/* Perform format checks for data flow control (DFC) request. These checks
+ * are optional.
+ */
+static int sna_format_error_rq_dfc(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(th->efi == SNA_TH_EFI_NORM && (local->rq_code != SNA_LOCAL_BIS 
+		|| local->rq_code != SNA_LOCAL_LUSTAT
+		|| local->rq_code != SNA_LOCAL_RTR))
+	{
+		local->sense = 0x10030000;
+	}
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code != SNA_LOCAL_SIG)
+		local->sense = 0x10030000;
+
+	if(th->efi == SNA_TH_EFI_EXP && local->rq_code == SNA_LOCAL_SIG)
+	{
+		local->sense = 0x10050000;
+	}
+
+	if(req_h->fi != SNA_RH_FI_FMH)
+		local->sense = 0x400F0000;
+
+	if(req_h->bci == SNA_RH_BCI_NO_BC || req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x400B0000;
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->edi == SNA_RH_EDI_ED)
+		local->sense = 0x40160000;
+
+	if(req_h->pdi == SNA_RH_PDI_PD)
+		local->sense = 0x40170000;
+
+	/* Other wise. */
+	if(local->rq_code == SNA_LOCAL_LUSTAT)
+	{
+		if(mu->dcf > sizeof(struct sna_ru_lustat))
+		{
+			if(mu->biu->ru.ru.lustat.status)
+				sna_format_error_rq_fmd(mu);
+			else
+				return (0);
+		}
+	}
+
+	return (0);
+}
+
+/* Perform format checks on FM data (FMD) requests. The checks are optional. */
+static int sna_format_error_rq_fmd(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_fmh1 *fmh = &mu->biu->ru.ru.fmh1;
+	int fmh_type;
+
+	fmh_type = fmh->type;
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		local->sense = 0x40110000;
+
+	if(!SNA_DFC_RQD(req_h) || !SNA_DFC_RQE(req_h))
+		local->sense = 0x40140000;
+
+	if(1)	/* See SNA formats RH formats 5.2-2 */
+		local->sense = 0x40070000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		local->sense = 0x40030000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->ru == SNA_RH_RU_FMD
+		&& req_h->fi != SNA_RH_FI_FMH)
+	{
+		local->sense = 0x40003000;
+	}
+
+	if(req_h->csi == SNA_RH_CSI_CODE1)
+		local->sense = 0x40100000;
+
+	if(req_h->ebi == SNA_RH_EBI_EB)
+		local->sense = 0x40040000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40090000;
+
+	if(req_h->cdi == SNA_RH_CDI_CD && SNA_DFC_RQD1(req_h))
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->eci == SNA_RH_ECI_NO_EC)
+		local->sense = 0x40040000;
+
+	if(req_h->bci == SNA_RH_BCI_BC && ((req_h->bbi == SNA_RH_BBI_BB
+		&& req_h->qri == SNA_RH_QRI_NO_QR) 
+		||(req_h->bbi == SNA_RH_BBI_BB || req_h->qri == SNA_RH_QRI_QR)))
+		local->sense = 0x40180000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB && req_h->cdi == SNA_RH_CDI_CD)
+		local->sense = 0x40090000;
+
+	if(req_h->cebi == SNA_RH_CEBI_CEB 
+		&& (SNA_DFC_RQE2(req_h) || SNA_DFC_RQE3(req_h)))
+		local->sense = 0x40040000;
+
+	if(req_h->cebi == SNA_RH_CEBI_NO_CEB && req_h->cdi == SNA_RH_CDI_NO_CD
+		&& req_h->eci == SNA_RH_ECI_EC && SNA_DFC_RQE(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_NO_CEB
+		&& SNA_DFC_RQD1(req_h))
+		local->sense = 0x40190000;
+
+	if(req_h->bbi == SNA_RH_BBI_BB && req_h->cebi == SNA_RH_CEBI_CEB
+		&& SNA_DFC_RQE1(req_h))
+		local->sense = 0x40040000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->cebi == SNA_RH_CEBI_CEB
+		&& fmh->type == SNA_FMH_HDR_ERROR && SNA_DFC_RQE(req_h))
+		local->sense = 0x40060000;
+
+	if(req_h->fi == SNA_RH_FI_FMH && req_h->ru == SNA_RH_RU_FMD
+		&& (fmh->type != SNA_FMH_HDR_ATTACH 
+		|| fmh->type != SNA_FMH_HDR_ERROR))
+	{
+		if(fmh->type == SNA_FMH_HDR_SECURITY)
+		{
+			if(req_h->eci == SNA_RH_ECI_EC 
+				&& req_h->cebi == SNA_RH_CEBI_NO_CEB)
+				local->sense = 0x080F6051;
+		}
+		else
+			local->sense = 0x10084001;
+	}
+
+	return (0);
+}
+
+/* Determine if sense data on a negative response is valid. */
+static int sna_invalid_sense_code(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(req_h->rri == SNA_RH_RRI_RSP && req_h->bbi == SNA_RH_BBI_BB)
+	{
+		if(local->half_session == SNA_HS_PRI)
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x08140000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(local->sense != 0x08130000 
+				|| local->sense != 0x0814000
+				|| local->sense != 0x088B0000)
+			{
+				return (SNA_DFC_TRUE);
+			}
+		}
+	}
+	else
+	{
+		if(req_h->rri == SNA_RH_RRI_RSP 
+			&& req_h->bbi == SNA_RH_BBI_NO_BB)
+		{
+			if(local->sense == 0x08190000)
+				return (SNA_DFC_TRUE);
+		}
+		else
+		{
+			if(req_h->rri == SNA_RH_RRI_RSP)
+				return (SNA_DFC_TRUE);
+			else
+			{
+				if(local->sense == 0x08460000)
+					return (SNA_DFC_TRUE);
+			}
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine whether or not a request is a valid reply. A reply is a request
+ * sent (or received) after receiving (or sending) an (RQE,CD) request.
+ */
+static int sna_ok_to_reply(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_BIS || local->rq_code == SNA_LOCAL_RTR)
+		return (SNA_DFC_FALSE);
+
+	if(req_h->bbi == SNA_RH_BBI_BB || req_h->bci == SNA_RH_BCI_NO_BC)
+		return (SNA_DFC_FALSE);
+
+	if((sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_SEND_REPLY)
+		|| (sna_fsm_chain_send_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		!= SNA_DFC_FSM_PEND_RCV_REPLY))
+		return (SNA_DFC_FALSE);
+
+	if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_INB)
+		return (SNA_DFC_FALSE);
+
+	return (SNA_DFC_TRUE);
+}
+
+/* Perform state error checking on received RQ/RSP. The types of errors
+ * found here are protocol violations by the sender of the RQ/RSP. These
+ * checks are optional. None, some, or all of the checks may be made.
+ */
+static int sna_rcv_state_error(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	if(th->efi == SNA_TH_EFI_EXP && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		{
+			local->sense = 0x200E0000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal Flow request. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT) == SNA_DFC_FSM_BB 
+			&& mu->biu->ru.ru.fmh1.type != FMH_5)
+		{
+			if(sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_CURRENT))
+				return (SNA_DFC_TRUE);	/* local->sense set. */
+		}
+
+		if(SNA_DFC_RQE(req_h) && req_h->bbi == SNA_RH_BBI_BB 
+			&& req_h->cebi == SNA_RH_CEBI_CEB)
+		{
+			local->sense = 0x40040000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	/* Normal flow response. */
+	if(th->efi == SNA_TH_EFI_NORM && req_h->rri == SNA_RH_RRI_RSP)
+	{
+		if(rsp_h->ru != req_h->ru)
+		{
+			local->sense = 0x40110000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->ru == SNA_RH_RU_DFC
+			&& rsp_h->rri != req_h->rri)
+		{
+			local->sense = 0x40120000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(rsp_h->qri != req_h->qri)
+		{
+			local->sense = 0x40210000;
+			return (SNA_DFC_TRUE);
+		}
+
+		if(sna_invalid_sense_code(mu))
+		{
+			local->sense = 0x20120000;
+			return (SNA_DFC_TRUE);
+		}
+	}
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Determine if a normal-flow request is a reply to a BID request. A reply
+ * is a request sent (or received) immediately after receving (or sending) a
+ * request carrying (RQE, CD. A reply implies a positive response to the
+ * (RQE, CD) request.
+ */
+static int sna_reply_to_bid(struct sna_mu *mu)
+{
+//	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(sna_ok_to_reply(mu))
+		return (SNA_DFC_TRUE);
+	else
+		return (SNA_DFC_FALSE);
+}
+
+/* Send RM a positive reponse to a BID, and receive the HS_PS_CONNECTED
+ * record that will result in this half-session being connected to a PS.
+ */
+static int sna_send_bid_pos_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_hs_ps_connected *hs_ps_connected = NULL;
+	struct sna_bid_rsp *pos_bid;
+
+	pos_bid = (struct sna_bid_rsp *)kmalloc(sizeof(struct sna_bid_rsp), 
+		GFP_KERNEL);
+	pos_bid->hs_id = local->hs_id;
+	pos_bid->sense = 0;
+	sna_send_to_rm(mu);
+
+	/* Receive the hs_ps_connected record. */
+	lulu->ps_id 		= hs_ps_connected->ps_id;
+	lulu->bracket_id 	= hs_ps_connected->bracket_id;
+
+	sna_fsm_bsm_fmp19(mu, SNA_DFC_FSM_INB);
+	kfree(hs_ps_connected);
+
+	lulu->current_bracket_sqn.number = 0;
+
+	return (0);
+}
+
+/* Send a response to the passed MU if required. */
+static int sna_send_rsp_if_required(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_TH_EFI_NORM, SNA_DFC_POS, 0);
+		else
+		{
+			if(SNA_DFC_RQE(req_h) && req_h->cebi == SNA_RH_CEBI_CEB)
+				printk("error\n");
+			else
+				sna_send_rsp_mu(mu, SNA_TH_EFI_NORM,SNA_DFC_NEG,
+					lulu->bb_rsp_sense);
+		}
+
+		lulu->bb_rsp_state = 0;
+		lulu->bb_rsp_sense = 0;
+	}
+
+	if(SNA_DFC_RQD(req_h))
+	{
+		if(SNA_DFC_POS_RSP(req_h))
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+		else
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG,
+				lulu->rtr_rsp_sense);
+
+		lulu->rtr_rsp_state = 0;
+	}
+
+	if(SNA_DFC_NEG_RSP(req_h))
+	{
+		if((req_h->bci == SNA_RH_BCI_BC && req_h->ru == SNA_RH_RU_FMD)
+			|| (req_h->ru == SNA_RH_RU_DFC
+			&& req_h->bbi != SNA_RH_BBI_BB))
+		{
+			sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_NEG, 0x08460000);
+			lulu->send_error_rsp_state = 0;
+		}
+	}
+
+	if(sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT) 
+		== SNA_DFC_FSM_PEND_REPLY)
+		sna_send_rsp_mu(mu, SNA_NORMAL, SNA_DFC_POS, 0);
+
+	return (0);
+}
+
+/* Create and send a response. The response is based on the request MU (if
+ * passed by the caller) or on information about the last chain received
+ * (if a null MU is passed).
+ */
+static int sna_send_rsp_mu(struct sna_mu *mu, int flow, int rsp, int sense)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	struct sna_ct *ct = &lulu->ct_send;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int direction;
+	int null_mu = 0;
+
+	if(mu == NULL)
+	{
+		null_mu = 1;
+		mu = sna_get_buffer(SNA_BM_TYPE_PERM, local->perm_buf_pool_id,
+			0, SNA_BM_NO_WAIT);
+	}
+
+	sna_init_th_rh(mu);
+	mu->dcf 	= sizeof(struct sna_req_h);
+	req_h->rri 	= SNA_RH_RRI_RSP;
+	req_h->bci 	= SNA_RH_BCI_BC;
+	req_h->eci 	= SNA_RH_ECI_EC;
+
+	if(rsp == SNA_DFC_NEG)
+	{
+		req_h->sdi 	= SNA_RH_SDI_SD;
+		rsp_h->rti 	= SNA_RH_RTI_NEG;
+		mu->dcf 	+= sizeof(mu->biu->ru.ru);
+		local->sense 	= sense;
+	}
+	else
+		rsp_h->rti = SNA_RH_RTI_POS;
+
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		if(null_mu)
+		{
+			req_h->ru 	= ct->rh.rh.rsp_h.ru;
+			req_h->dr1i 	= ct->rh.rh.rsp_h.dr1i;
+			req_h->dr2i 	= ct->rh.rh.rsp_h.dr2i;
+			req_h->qri 	= ct->rh.rh.rsp_h.qri;
+
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+				local->rq_code = ct->rq_code;
+			}
+		}
+		else
+		{
+			req_h->ru 	= req_h->ru;
+			req_h->dr1i 	= req_h->dr1i;
+			req_h->dr2i 	= req_h->dr2i;
+			req_h->qri 	= req_h->qri;
+			local->rq_code 	= req_h->csi;
+			if(req_h->ru == SNA_RH_RU_DFC)
+			{
+				mu->dcf += sizeof(local->rq_code);
+				mu->biu->ru.ru.raw = &ct->rq_code;
+			}
+		}
+	}
+	else
+	{
+		th->efi = SNA_TH_EFI_EXP;
+		req_h->ru = SNA_RH_RU_DFC;
+		req_h->dr1i = req_h->dr1i;
+		local->rq_code = SNA_LOCAL_SIG;
+	}
+
+	if(req_h->ru == SNA_RH_RU_DFC)
+		req_h->fi = SNA_RH_FI_FMH;
+
+	direction = lulu->direction;
+	lulu->direction = SNA_HS_SEND;
+	if(!sna_fsm_chain_rcv_fmp19(mu, SNA_DFC_FSM_CURRENT))
+		sna_dfc_send_fsms(mu);
+	else
+		sna_free_buffer(mu);
+
+	lulu->direction = direction;
+
+	return (0);
+}
+
+/* Determine if a SIGNAL is for a past, current, or future bracket. The
+ * in-bracket (INB) state exists when this procedure is called.
+ */
+static int sna_signal_status(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_lu_lu_cb *lulu = &local->lulu;
+	int result, reg;
+
+	if(lulu->current_bracket_sqn.number 
+		== lulu->current_bracket_sqn.number)
+		return (SNA_DFC_SIG_CURRENT);
+
+	if(SNA_HS_PRI)
+		reg = lulu->phs_bb_register.number;
+	else
+		reg = lulu->shs_bb_register.number;
+
+	result = (lulu->sig_snf.number -  reg) % 25;
+	if(result < 0)
+	{
+		result += 25;
+		if(result == 0)
+			return (SNA_DFC_SIG_STRAY);
+		if(result == 24)
+			return (SNA_DFC_SIG_FUTURE);
+		if(result > 24)
+			return (SNA_DFC_SIG_STRAY);
+	}
+
+	return (0);
+}
+
+/* Determines if a response is stray. (A stray response is one that was sent
+ * in a bracket (conversation) but recevied in a different (later bracket).
+ */
+static int sna_stray_rsp(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(local->rq_code == SNA_LOCAL_RTR)
+	{
+		local->sense = 0x200E0000;
+		return (SNA_DFC_TRUE);
+	}
+
+	if(local->rq_code == SNA_LOCAL_SIG)
+		return (SNA_DFC_TRUE);
+
+	if(local->rq_code == SNA_LOCAL_LUSTAT || req_h->ru == SNA_RH_RU_FMD)
+	{
+		/* More. */
+		return (SNA_DFC_TRUE);
+	}
+
+	/* More. */
+
+	return (SNA_DFC_FALSE);
+}
+
+/* Enforce the bracket protocol. State transitions are forced via the input
+ * signals INB (go in brackets) and BETB (go between bracket). The inputs R,
+ * RQ, ... are used for error checking only. INB state means DFC (the half
+ * session) is connected to a PS; BETB state means DFC is not connected to a
+ * PS.
+ */
+static int sna_fsm_bsm_fmp19(struct sna_mu *mu, int signal)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+
+	if(local->state == SNA_DFC_FSM_BETB)
+	{
+		if(signal == SNA_DFC_FSM_INB)
+			local->state = SNA_DFC_FSM_INB;
+		else
+			local->sense = 0x20030000;
+		return (0);
+	}
+
+	if(local->state == SNA_DFC_FSM_INB)
+	{
+		if(signal == SNA_DFC_FSM_BETB)
+			local->state = SNA_DFC_FSM_BETB;
+		
+		return (0);
+	}
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for received chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been received and any required
+ * associated response or reply has been sent. A reply is a request sent after
+ * receiving an (RQE, CD) chain that has not been negatively responsed to. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_rcv_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the chaining protocol for sending chains. A chain is "complete"
+ * when the end-of-chain (EC) request has been sent and any required associated
+ * response or reply has been received. A reply is a request recevied after
+ * sending an (RQE, CD) chain that has not received a negative response. A
+ * reply implies a positive response to the (RQE, CD) chain.
+ */
+static int sna_fsm_chain_send_fmp19(struct sna_mu *mu, int chain)
+{
+
+	return (0);
+}
+
+/* Enforce the setting of the QRI indicator in the RH. This indicator is
+ * set the same for all MUs in a chain; ie. all MUs in a chain have QRI = QR
+ * or have QRI = -QR.
+ */
+static int sna_fsm_qri_chain_rcv_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+/* Maintain a purging state for received BB chains that have been negatively
+ * responded to indicating a bracket error (0813, 0814, 088B). It is called
+ * with a PURGE signal when the negative response is sent and reset when
+ * the end-of-chain (EC) RU is received. When in the purging state, no records
+ * are generated for PS or RM as a result of receiving a request RU in the
+ * BB chain (ie. the remainder of the BB chain is purged).
+ */
+static int sna_fsm_rcv_purge_fmp19(struct sna_mu *mu)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_dlc.c linux/net/sna/sna_dlc.c
--- linux-2.4.4/net/sna/sna_dlc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_dlc.c	Mon May 14 21:09:36 2001
@@ -0,0 +1,267 @@
+/* sna_dlc.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+#ifdef CONFIG_SNA_LLC
+#include <net/llc.h>
+#include <linux/llc.h>
+#endif
+
+#ifdef CONFIG_SNA_LOOPBACK
+int sna_loopback_xmit(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_loopback_xmit\n");
+	netif_rx(skb);
+	return (0);
+}
+#endif
+
+#ifdef CONFIG_SNA_LLC
+int sna_dlc_gen_rsp(int type, struct sk_buff *skb)
+{
+	llchdr *llc;
+        struct sk_buff *newskb;
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct net_device *dev = skb->dev;
+        int size;
+
+        sna_debug(5, "sna_dlc_gen_rsp\n");
+	switch(type)
+	{
+		case (LLC_STATE_REMOTE_RESET_INDICATION):	/* Out */
+		case (LLC_STATE_RECEIVE_SABME_CMD):		/* In */
+		{
+			struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc SAMBE cmd received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+                                struct sna_xid_info *xid = tg->xid_info;
+                                del_timer(&xid->xid_timer);
+				xid->xid_status = XID_ACTIVE;
+				sna_cs_connect_out((unsigned long)tg);
+			}
+
+			/* Send SAMBE response */
+			size = dev->hard_header_len + 3;
+        		newskb = alloc_skb(size, GFP_ATOMIC);
+        		skb_reserve(newskb, 3);
+        		skb_reserve(newskb, dev->hard_header_len);
+        		newskb->dev = dev;
+			llc = (llchdr *)skb_push(newskb, 3);
+                        llc->dsap       = 0x04;
+                        llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_UA_RSP;
+			llc->ctrl.uctrl.pf = 1;
+			break;
+		}
+
+		case (LLC_STATE_RECEIVE_RR_CMD):
+			size = dev->hard_header_len + 3 + 2;
+                        newskb = alloc_skb(size, GFP_ATOMIC);
+                        skb_reserve(newskb, 3 + 2);
+                        skb_reserve(newskb, dev->hard_header_len);
+                        newskb->dev = dev;
+			llc = (llchdr *)skb_push(newskb, 3 + 2);
+                        llc->dsap       = 0x04;
+                        llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_RR_RSP;
+			llc->ctrl.ictrl.ns = 1;
+			llc->ctrl.ictrl.nr = 1;
+			llc->ctrl.ictrl.pf = 1;
+                        break;
+
+		case (LLC_STATE_RECEIVE_DISC_CMD):
+		{
+                        struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc SAMBE cmd received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+                                struct sna_xid_info *xid = tg->xid_info;
+                                del_timer(&xid->xid_timer);
+                                xid->xid_status = XID_RESET;
+                        }
+
+                        /* Send DISC/UA response */
+                        size = dev->hard_header_len + 3;
+                        newskb = alloc_skb(size, GFP_ATOMIC);
+                        skb_reserve(newskb, 3);
+                        skb_reserve(newskb, dev->hard_header_len);
+                        newskb->dev = dev;
+                        llc = (llchdr *)skb_push(newskb, 3);
+                        llc->dsap       = 0x04;
+			llc->ssap       = 0x04 + LLC_PDU_RSP;
+                        llc->ctrl.ctrl  = LLC_CTRL_UA_RSP;
+                        llc->ctrl.uctrl.pf = 1;
+                        break;
+                }
+
+		default:
+			kfree_skb(skb);
+			return (0);
+	}
+
+	if(sna_debug_level > 5)
+        {
+                printk("Lets see a nice LLC RSP for SNA\n");
+                hexdump(newskb->data, newskb->len);
+        }
+
+        dev->hard_header(newskb, newskb->dev, ETH_P_802_3,
+                eth_hdr->h_source, NULL, newskb->len);
+        dev_queue_xmit(newskb);
+        kfree_skb(skb);
+
+	return (0);
+}
+
+int sna_dlc_llc_rcv(struct sk_buff *skb, struct net_device *dev,
+	struct packet_type *pt)
+{
+	llchdr *llc_hdr = (llchdr *)skb->data;
+	int err;
+
+	sna_debug(5, "sna_dlc_llc_rcv\n");
+	switch(llc_decode_pdu(llc_hdr))
+	{
+		case (LLC_XID_CMD):
+                        sna_debug(5, "llc XID cmd received passing to cs\n");
+			sna_cs_connect_in(skb, dev);
+			break;
+
+		case (LLC_XID_RSP):
+		{
+                        struct ethhdr *eth_hdr = skb->mac.ethernet;
+                        struct sna_tg_cb *tg;
+
+                        sna_debug(5, "llc XID rsp received.\n");
+                        tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+                        if(tg)
+                        {
+				struct sna_xid_info *xid = tg->xid_info;
+
+				del_timer(&xid->xid_timer);
+				if(xid->last_rx_xid != NULL)
+                                	kfree_skb(xid->last_rx_xid);
+				xid->last_rx_xid = skb;
+				xid->xid_count++;
+
+				/* determine type of xid packet */
+				switch(sna_cs_xid_xchg_state(skb))
+				{
+					case (XID_NULL):
+						xid->xid_status = XID_R_NULL;
+						break;
+
+					case (XID_NEG):
+						xid->xid_status = XID_R_NEG;
+						break;
+
+					case (XID_PN):
+						xid->xid_status = XID_R_PN;
+						break;
+
+					default:
+						sna_debug(5, "Got XID not handle reset\n");
+						xid->xid_status = XID_RESET;
+						break;
+				}
+
+                                sna_cs_connect_out((unsigned long)tg);
+                        }
+                        break;
+
+                }
+
+		case (LLC_I_CMD):
+			sna_debug(5, "llc I cmd received \n");
+			err = sna_pc_mu_error_checker(skb);
+			if(err < 0)
+			{
+				/* Should send proper sense code */
+				kfree_skb(skb);
+				return (-1);
+			}
+			sna_pc_mu_rcv_router(skb);
+			break;
+
+		case (LLC_TEST_CMD):
+			sna_debug(5, "Got TEST_CMD\n");
+			break;
+
+		case (LLC_TEST_RSP):
+		{
+			struct ethhdr *eth_hdr = skb->mac.ethernet;
+			struct sna_tg_cb *tg;
+
+			sna_debug(5, "Got TEST RSP\n");
+			tg = sna_tdm_find_tg_by_mac(eth_hdr->h_source);
+			if(tg)
+			{
+				kfree_skb(skb);
+				del_timer(&tg->co_retry);
+				tg->co_status = CO_R_TEST_R;
+				sna_cs_connect_out((unsigned long)tg);
+			}
+			break;
+		}
+
+		default:
+			kfree_skb(skb);
+			break;
+	}
+
+	return (0);
+}
+
+int sna_dlc_llc_event(int rsp, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_dlc_llc_event %02X\n", rsp);
+	sna_dlc_gen_rsp(rsp, skb);
+
+	return (0);
+}
+#endif	/* CONFIG_SNA_LLC */
diff -ruN linux-2.4.4/net/sna/sna_ds.c linux/net/sna/sna_ds.c
--- linux-2.4.4/net/sna/sna_ds.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ds.c	Mon May 14 21:09:46 2001
@@ -0,0 +1,142 @@
+/* sna_ds.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_ds_pinfo *ds_clients = NULL;
+
+int sna_ds_insert(struct sna_ds_pinfo *ds)
+{
+	sna_debug(5, "sna_ds_insert\n");
+        ds->next = ds_clients;
+        ds_clients = ds;
+
+        return (0);
+}
+
+struct sna_ds_pinfo *sna_ds_find(__u8 *name)
+{
+	struct sna_ds_pinfo *f;
+
+	for(f = ds_clients; f != NULL; f = f->next)
+                if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                        break;
+
+        return (f);
+}
+
+int sna_ds_shutdown(void)
+{
+        struct sna_ds_pinfo *d;
+        struct sna_ds_pinfo **clients = &ds_clients;
+        unsigned long flags;
+
+        printk("sna_ds_shutdown\n");
+
+        save_flags(flags);
+        cli();
+
+        while((d = *clients) != NULL)
+        {
+                *clients = d->next;
+                kfree(d);
+        }
+
+        restore_flags(flags);
+
+        return (0);
+}
+
+int sna_ds_create(struct sna_start_node *start)
+{
+	struct sna_ds_pinfo *ds;
+
+	sna_debug(5, "sna_ds_create %s\n", start->netid.name);
+	ds = sna_ds_find(start->netid.name);
+	if(ds)
+		return (-EEXIST);
+	ds = (struct sna_ds_pinfo *)kmalloc(sizeof(struct sna_ds_pinfo), 
+		GFP_ATOMIC);
+	memcpy(&ds->netid, &start->netid, sizeof(struct sna_netid));
+	ds->next = NULL;
+	ds->prev = NULL;
+
+        sna_ds_insert(ds);
+	return (0);
+}
+
+int sna_ds_destroy(struct sna_delete_node *delete)
+{
+        struct sna_ds_pinfo *ds, **clients = &ds_clients;
+
+        sna_debug(5, "sna_ds_destroy\n");
+        while((ds = *clients) != NULL)
+        {
+                if(!strncmp(ds->netid.name, delete->netid.name, 8))
+                {
+                        *clients = ds->next;
+                        kfree(ds);
+                        return (0);
+                }
+                clients = &ds->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_ds_update_directory(void)
+{
+
+	return (0);
+}
+
+int sna_ds_update_cp_status(void)
+{
+
+	return (0);
+}
+
+int sna_ds_locate_message(void)
+{
+
+	return (0);
+}
+
+int sna_ds_request_local_search(void)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_ebcdic.c linux/net/sna/sna_ebcdic.c
--- linux-2.4.4/net/sna/sna_ebcdic.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ebcdic.c	Mon May 14 21:09:55 2001
@@ -0,0 +1,186 @@
+/* sna_ebcdic.c: Linux-SNA EBCDIC/ASCII converter.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+
+#include <linux/sna.h>
+
+unsigned char etor(unsigned char a)
+{
+        return(ebcdic_to_rotated[a]);
+}
+
+char *etor_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = etor(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+/* Convert a single charater from EBCDIC to ASCII */
+unsigned char etoa(unsigned char a)
+{
+        return(ebcdic_to_ascii_sna[a]);
+}
+
+/* Convert a single character from ASCII to EBCDIC */
+unsigned char atoe(unsigned char a)
+{
+	return(ascii_to_ebcdic_sna[a]);
+}
+
+char *atoe_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while((*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *etoa_strcpy(char *dest, char *src)
+{
+        char *tmp = dest;
+
+        while((*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *atoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = atoe(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+char *fatoe_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count--)
+		(*dest++ = atoe(*src++));
+
+	return (tmp);
+}
+
+char *etoa_strncpy(char *dest, char *src, size_t count)
+{
+        char *tmp = dest;
+
+        while(count-- && (*dest++ = etoa(*src++)) != '\0')
+                /* Nothing */;
+
+        return (tmp);
+}
+
+int atoe_strcmp(const char *acs, const char *ect)
+{
+        register signed char __res;
+
+        while(1)
+        {
+                if((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+        }
+
+        return (__res);
+}
+
+int etoa_strcmp(const char *ecs, const char *act)
+{
+        register signed char __res;
+
+        while(1)
+        {
+                if((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+        }
+
+        return (__res);
+}
+
+int atoe_strncmp(const char *acs, const char *ect, size_t count)
+{
+        register signed char __res = 0;
+
+        while(count)
+        {
+                if((__res = atoe(*acs) - *ect++) != 0 || !*acs++)
+                        break;
+                count--;
+        }
+
+        return (__res);
+}
+
+int etoa_strncmp(const char *ecs, const char *act, size_t count)
+{
+        register signed char __res = 0;
+
+        while(count)
+        {
+                if((__res = etoa(*ecs) - *act++) != 0 || !*ecs++)
+                        break;
+                count--;
+        }
+
+        return (__res);
+}
+
+#define nibble(v, w)    ((v >> (w * 4)) & 0x0F)
+
+static unsigned char rbits[16] = {
+        0x00, 0x08, 0x04, 0x0C, 0x02, 0x0A, 0x06, 0x0E,
+        0x01, 0x09, 0x05, 0x0D, 0x03, 0x0B, 0x07, 0x0F
+};
+
+unsigned char flip_nibble(unsigned char v)
+{
+        return (rbits[v & 0x0F]);
+}
+
+unsigned char flip_byte(unsigned char v)
+{
+        return ((flip_nibble(nibble(v, 0)) << 4) | flip_nibble(nibble(v, 1)));
+}
diff -ruN linux-2.4.4/net/sna/sna_hsr.c linux/net/sna/sna_hsr.c
--- linux-2.4.4/net/sna/sna_hsr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_hsr.c	Mon May 14 21:10:03 2001
@@ -0,0 +1,165 @@
+/* sna_hsr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Half Session Router (HSR)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+#include <linux/uio.h>
+#include <linux/unistd.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/sna.h>
+
+#ifdef NOT
+struct sna_hs_local *hs_local_list = NULL;
+
+__u16	sys_snf_ids = 0;
+
+int sna_hs_local_queue_head(struct sna_hs_local *local);
+
+/* This procedure causes the half-session to be initialized. */
+int sna_hs_create(struct sna_init_hs *hs)
+{
+	struct sna_hs_local *local;
+	struct sna_init_hs_rsp *hs_rsp;
+
+	local = SNA_HS_MALLOC(struct sna_hs_local);
+	memset(local, 0, sizeof(struct sna_hs_local));
+	local->hs_id 			= hs->hs_id;
+	local->lu_id 			= hs->lu_id;
+	local->half_session 		= hs->type;
+	local->sense 			= 0;
+	local->perm_buf_pool_id 	= hs->perm_buf_pool_id;
+	local->limit_buf_pool_id	= hs->limit_buf_pool_id;
+	local->dynamic_buf_pool_id	= hs->dynamic_buf_pool_id;
+	local->catch_mu			= NULL;
+	sna_hs_local_queue_head(local);
+
+	sna_tc_init(hs);
+	sna_dfc_init(hs);
+
+	hs_rsp = SNA_HS_MALLOC(struct sna_init_hs_rsp);
+	hs_rsp->sense = local->sense;
+	hs_rsp->hs_id = local->hs_id;
+
+	if(local->sense == 0)
+		hs_rsp->type = 1;
+	else
+		hs_rsp->type = 0;
+
+	sna_send_to_sm((struct sna_mu *)hs_rsp);
+
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	return (0);
+}
+
+/* Does processing for the half-session (FM profile 19). Message units
+ * received from RM and PS are routed to DFC. Message units received from
+ * PC are routed to TC. THe half-session continues to operate until and error
+ * condition occurs or the half session process is destroyed. If an error
+ * condition occurs, local->sense is set (by DFC or TC) with the sense
+ * data indicating what kind of error occured. When this field is set, the
+ * half-session sends an ABORT message to SM. This causes SM to send an
+ * UNBIND(protocol error) for this session. HS recevies BUFFERS_RESERVED
+ * signals from buffer manager and builds and sends the appropriate pacing
+ * response.
+ *
+ * sna_process_lu_lu_session();
+ */
+int sna_hs_local_queue_head(struct sna_hs_local *local)
+{
+	struct sna_hs_local *next, *prev;
+
+	prev 		= hs_local_list;
+	next 		= prev->next;
+	local->next	= next;
+	local->prev	= prev;
+	next->prev	= local;
+	prev->next	= local;
+
+	return (0);
+}
+
+struct sna_hs_local *sna_hs_find_local(__u8 hs_id)
+{
+	struct sna_hs_local *local;
+
+        for(local = hs_local_list; local != NULL; local = local->next)
+        {
+		if(local->hs_id == hs_id)
+			return (local);
+        }
+
+        return (NULL);
+}
+
+struct sna_mu *sna_catch_mu(struct sna_hs_local *local)
+{
+	while(local->catch_mu == NULL)
+		schedule();
+
+	return (local->catch_mu);
+}
+#endif
+
+extern int sna_dfc_send_from_ps(struct sk_buff *skb, struct sna_rcb *rcb);
+
+int sna_hs_process_lu_lu_session(int who, struct sk_buff *skb,
+	struct sna_rcb *rcb)
+{
+	sna_debug(5, "sna_hs_process_lu_lu_session\n");
+	switch(who)
+	{
+		case (SNA_PS):
+			sna_dfc_send_from_ps(skb, rcb);
+			break;
+
+#ifdef NOT
+		case (SNA_RM):
+			sna_dfc_send_from_rm(skb);
+			break;
+
+		case (SNA_PC):
+			sna_tc_rcv(skb);
+			break;
+#endif
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_isr.c linux/net/sna/sna_isr.c
--- linux-2.4.4/net/sna/sna_isr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_isr.c	Mon May 14 21:10:10 2001
@@ -0,0 +1,106 @@
+/* sna_isr.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_isr_create(struct sna_cp_create_parms *newisr)
+{
+
+	return (0);
+}
+
+int sna_isr_assign_lfsid_rsp(void)
+{
+
+	return (0);
+}
+
+int sna_isr_lfsid_in_use(void)
+{
+
+	return (0);
+}
+
+int sna_isr_session_route_inop(void)
+{
+
+	return (0);
+}
+
+int sna_isr_update_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_delete_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_query_slu_mode(void)
+{
+
+	return (0);
+}
+
+int sna_isr_abort_sc(void)
+{
+
+	return (0);
+}
+
+int sna_isr_assign_pcid_rsp(void)
+{
+
+	return (0);
+}
+
+int sna_isr_cinit(void)
+{
+
+	return (0);
+}
+
+int sna_isr_init_neg_rsp(void)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_lar.c linux/net/sna/sna_lar.c
--- linux-2.4.4/net/sna/sna_lar.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_lar.c	Mon May 14 21:10:20 2001
@@ -0,0 +1,666 @@
+/* sna_lar.c: SNA Lan Address Resolution Protocol.
+ * - Basicly ARP for SNA, listens on LLC SAP 0xDC.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+#include <net/llc.h>
+#include <linux/llc.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_arp.h>
+
+#include <linux/delay.h>	/* For udelay() */
+
+__u8 sysctrl_find_timer_expire	=	SNA_LAR_FIND_TIMER_EXPIRE;
+__u8 sysctrl_find_count		=	SNA_LAR_FIND_COUNT;
+__u8 sysctrl_ad_timer_expire	=	SNA_LAR_AD_TIMER_EXPIRE;
+__u8 sysctrl_ad_count		=	SNA_LAR_AD_COUNT;
+__u8 sysctrl_solicit_timer_expire=	SNA_LAR_SOLICIT_TIMER_EXPIRE;
+__u8 sysctrl_query_timer_expire	=	SNA_LAR_QUERY_TIMER_EXPIRE;
+
+static struct timer_list find_timer;
+static struct timer_list ad_timer;
+static struct timer_list solicit_timer;
+static struct timer_list query_timer;
+wait_queue_head_t sleep;
+
+static struct datalink_proto *lar_dl 	= NULL;	/* LLC Data Link 0xDC */
+static struct sna_lar_dinfo *lar_list 	= NULL;	/* List of LAR entries */
+
+__u16 sys_correlator_id = 0;
+
+static char lar_group_mac[] = {0x03, 0x00, 0x00, 0x00, 0x00, 0x02};
+
+int sna_lar_tx_query(char *net, char *group, unsigned long rtcap);
+
+static void sna_lar_find_timer_expire(unsigned long data)
+{
+
+	return;
+}
+
+static void sna_lar_ad_timer_expire(unsigned long data)
+{
+
+	return;
+}
+
+static void sna_lar_solicit_timer_expire(unsigned long data)
+{
+
+	return;
+}
+
+static void sna_lar_query_timer_expire(unsigned long data)
+{
+	/* Wake up sleeping, query. Need to make this query specific. */
+	wake_up_interruptible(&sleep);
+
+	return;
+}
+
+int sna_lar_find_member(void)
+{
+
+	return (0);
+}
+
+int sna_lar_find(void)
+{
+
+	return (0);
+}
+
+int sna_lar_glare(struct sna_lar_dinfo *d, char *buf, int len)
+{
+	struct larreq lr;
+	int i, done = 0;
+
+	if(!buf)
+	{
+        	done += sizeof(lr);
+                return (done);
+        }
+        if(len < (int)sizeof(lr))
+        	return done;
+        memset(&lr, '\0', sizeof(struct larreq));
+
+	/* Move the data here */
+	memcpy(&lr.netid, d->netid.net, SNA_RESOURCE_NAME_LEN);
+	for(i = 0; lr.netid[i] != 0x20; i++); lr.netid[i] = 0;
+	memcpy(&lr.name, d->netid.name, SNA_RESOURCE_NAME_LEN);
+	for(i = 0; lr.name[i] != 0x20; i++); lr.name[i] = 0;
+	memcpy(&lr.group, d->group, SNA_RESOURCE_NAME_LEN);
+	memcpy(&lr.mac, d->snpa.mac, ETH_ALEN);
+	lr.lsap = d->snpa.lsap;
+	lr.rtcap = d->rtcap;
+
+	if(copy_to_user(buf, &lr, sizeof(struct larreq)))
+        	return (-EFAULT);
+        buf += sizeof(struct larreq);
+        len -= sizeof(struct larreq);
+        done += sizeof(struct larreq);
+
+	return (done);
+}
+
+int sna_lar_search(char *arg)
+{
+	struct sna_lar_dinfo *d;
+	struct larconf larc;
+	char *pos;
+	int len, total, err = 0;
+
+	sna_debug(5, "sna_lar_search\n");
+	if(copy_from_user(&larc, arg, sizeof(larc)))
+                return (-EFAULT);
+
+	/* Transmit Query, then sleep until timer expires */
+	err = sna_lar_tx_query(larc.larc_net, larc.larc_group, larc.larc_rtcap);
+	if(err >= 0)
+		interruptible_sleep_on(&sleep);
+	else
+		sna_debug(1, "sna_lar_search: error lar_tx_query (%d)\n", err);
+
+	pos = larc.larc_buf;
+        len = larc.larc_len;
+
+	/*
+	 * Get the data and put it into the structure
+	 */
+	total = 0;
+	for(d = lar_list; d != NULL; d = d->next)
+	{
+		int done;
+
+		if(strncmp(d->netid.net, larc.larc_net, 8)
+			|| strncmp(d->group, larc.larc_group, 8)
+			|| d->rtcap != larc.larc_rtcap)
+			continue;
+
+		if(pos == NULL)
+			done = sna_lar_glare(d, NULL, 0);
+		else
+			done = sna_lar_glare(d, pos + total, len - total);
+		if(done < 0)
+			return (-EFAULT);
+		total += done;
+	}
+
+	larc.larc_len = total;
+        if(copy_to_user(arg, &larc, sizeof(larc)))
+                return (-EFAULT);
+
+	return (0);
+}
+
+/* Find an existing record in our local database, return NULL if
+ * nothing is found.
+ */
+struct sna_lar_dinfo *sna_lar_cache_find(char *netid_net, char *netid_name,
+	char *gname, __u32 rtcap)
+{
+	struct sna_lar_dinfo *d;
+
+	sna_debug(20, "sna_lar_cache_find\n");
+	for(d = lar_list; d != NULL; d = d->next)
+	{
+		if(!strncmp(netid_net, d->netid.net, 8)
+			&& !strncmp(netid_name, d->netid.name, 8)
+			&& !strncmp(gname, d->group, 8))
+			return (d);
+	}
+
+	return (NULL);
+}
+
+/* Record will look for an existing matching entry, if found the record
+ * will be updated, otherwise a new record will be created.
+ */
+int sna_lar_record(struct sna_netid *netid, char *group,
+	struct sna_lar_snpa *snpa, __u32 rtcap, __u8 ldev)
+{
+	struct sna_lar_dinfo *d; 
+
+	sna_debug(5, "sna_lar_record\n");
+	d = sna_lar_cache_find(netid->net, netid->name, group, rtcap);
+	if(d != NULL)
+		return (-1);
+
+	d = (struct sna_lar_dinfo *)kmalloc(sizeof(struct sna_lar_dinfo),
+		GFP_ATOMIC);
+	memset(d, '\0', sizeof(struct sna_lar_dinfo));
+	memcpy(&d->netid, netid, sizeof(struct sna_netid));
+	strncpy(d->group, group, 8);
+	memcpy(&d->snpa, snpa, sizeof(struct sna_lar_snpa));
+	d->rtcap	= rtcap;
+	d->ldev		= ldev;
+	d->prev		= NULL;
+	d->next		= lar_list;
+	lar_list	= d;
+
+	return (0);
+}
+
+int sna_lar_erase(char *name, char *net)
+{
+	struct sna_lar_dinfo *d, **clients = &lar_list;
+
+	sna_debug(5, "sna_lar_erase %s.%s\n", name, net);
+	while((d = *clients) != NULL)
+        {
+                if(!strncmp(d->netid.name, name, 8)
+			&& !strncmp(d->netid.net, net, 8))
+                {
+                        *clients = d->next;
+                        kfree(d);
+                        return (0);
+                }
+                clients = &d->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_lar_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+	printk("sna_lar_getsockopt\n");
+
+	return (0);
+}
+
+int sna_lar_ioctl(int cmd, void *arg)
+{
+	sna_debug(5, "sna_lar_ioctl\n");
+        switch(cmd)
+        {
+		case (SIOCGLAR):
+			sna_lar_search(arg);
+			break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (0);
+}
+
+int sna_lar_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err = 0;
+
+        switch(optname)
+        {
+		case (SNA_LAR_ERASE):
+			break;
+
+		case (SNA_LAR_RECORD):
+			break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (err);
+}
+
+
+#ifdef CONFIG_PROC_FS
+int sna_lar_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_lar_dinfo *d;
+        off_t pos = 0, begin = 0;
+        int len = 0, i;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%-18s%-9s%-6s%-13s%-5s\n",
+		"netid.node", "group", "rtcap", "mac_address", "lsap");
+
+        for(d = lar_list; d != NULL; d = d->next)
+        {
+                len += sprintf(buffer + len, "%-18s", sna_pr_netid(&d->netid));
+		len += sprintf(buffer + len, "%-9s%04X  ", d->group, d->rtcap);
+		for(i = 0; i < 6; i++)
+			len += sprintf(buffer+len, "%02X", d->snpa.mac[i]);
+		len += sprintf(buffer + len, " %02X", d->snpa.lsap);
+		len += sprintf(buffer + len, "\n");
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+int sna_lar_rcv_event(int rsp, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_nof_dar_event\n");
+        if(skb != NULL)
+                kfree_skb(skb);
+
+	return (0);
+}
+
+int sna_lar_tx_find(void)
+{
+
+	return (0);
+}
+
+int sna_lar_tx_found(void)
+{
+
+	return (0);
+}
+
+int sna_lar_tx_solicit(void)
+{
+
+	return (0);
+}
+
+int sna_lar_tx_advertise(void)
+{
+
+	return (0);
+}
+
+int sna_lar_tx_query(char *net, char *group, unsigned long rtcap)
+{
+	struct sna_lar_dinfo *d;
+	struct net_device *dev;
+	struct sk_buff *skb;
+	struct larhdr *lar_hdr;
+	llchdr *llc_hdr;
+	int size;
+
+	sna_debug(5, "sna_lar_tx_query\n");
+
+	/* Find first entry which is a local dev and on same net. */
+	for(d = lar_list; d != NULL; d = d->next)
+		if(d->ldev && !strncmp(d->netid.net, net, 8))
+			break;
+	if(d == NULL)   /* Must at least have local node registered. */
+                return (-ENOENT);
+
+	rtnl_lock();
+        dev = dev_getbyhwaddr(ARPHRD_ETHER, d->snpa.mac);
+        if(dev == NULL)
+                return (-ENETUNREACH);
+	rtnl_unlock();
+
+	size = dev->hard_header_len;
+        size += LLC_TYPE1_SIZE;
+        size += SNA_LAR_QUERY_SIZE;
+        skb = alloc_skb(size, GFP_ATOMIC);
+
+        skb->dev = dev;
+        skb_reserve(skb, dev->hard_header_len);
+
+        /* Build LLC header - Type 1 / UI CMD */
+        llc_hdr = (llchdr *)skb_put(skb, LLC_TYPE1_SIZE);
+        llc_hdr->dsap           = LLC_SAP_LAR;
+        llc_hdr->ssap           = LLC_SAP_LAR;
+        llc_hdr->ctrl.ctrl      = LLC_CTRL_UI_CMD;
+
+        /* Build LAR Notify packet */
+        lar_hdr = (struct larhdr *)skb_put(skb, SNA_LAR_QUERY_SIZE);
+        lar_hdr->mvlen  = htons(SNA_LAR_QUERY_SIZE);
+        lar_hdr->mvid   = SNA_LAR_T_QUERY;
+
+        /* Correlator */
+        lar_hdr->mv.query.correlator.svlen     = 6;
+        lar_hdr->mv.query.correlator.svid      = 0x05;
+	lar_hdr->mv.query.correlator.correlator = htonl(++sys_correlator_id);
+
+	/* Target Netid Name */
+        lar_hdr->mv.query.tnetid.svlen          = 10;
+        lar_hdr->mv.query.tnetid.svid           = 0x0D;
+        atoe_strncpy(lar_hdr->mv.query.tnetid.netid, net, 8);
+
+        /* Group Name */
+        lar_hdr->mv.query.gname.svlen    	= 10;
+        lar_hdr->mv.query.gname.svid     	= 0x00;
+        atoe_strncpy(lar_hdr->mv.query.gname.name, group, 8);
+
+        /* Routing Capabilities */
+        lar_hdr->mv.query.rtcap.svlen          	= 6;
+        lar_hdr->mv.query.rtcap.svid           	= 0x02;
+        memcpy(&lar_hdr->mv.query.rtcap.rtcap, &rtcap, 4);
+
+        /* Return CCE MAC Address */
+        lar_hdr->mv.query.cce_mac.svlen        	= 8;
+        lar_hdr->mv.query.cce_mac.svid         	= 0x04;
+        memcpy(lar_hdr->mv.query.cce_mac.mac, &d->snpa.mac, ETH_ALEN);
+
+	/* Add MAC header and Transmit */
+        dev->hard_header(skb, dev, ETH_P_802_3, lar_group_mac,
+                NULL, skb->len);
+        dev_queue_xmit(skb);
+
+	/* Start Query Timer */
+	del_timer(&query_timer);
+        query_timer.expires = jiffies + (sysctrl_query_timer_expire * HZ);
+        add_timer(&query_timer);
+
+	return (0);
+}
+
+int sna_lar_process_notify(struct larhdr *lar)
+{
+	struct sna_netid *netid = (struct sna_netid *)kmalloc(sizeof(struct sna_netid), GFP_ATOMIC);
+	struct sna_lar_snpa s;
+	int i;
+	unsigned char net[9], name[9], group[9], fn[20];
+
+	sna_debug(10, "sna_lar_process_notify\n");
+	if(sys_correlator_id != ntohl(lar->mv.notify.correlator.correlator))
+	{
+		sna_debug(5, "Correlator does not match\n");
+		return (-1);
+	}
+
+	etoa_strncpy(net, lar->mv.notify.rnetid.netid, 
+		lar->mv.notify.rnetid.svlen-2);
+	net[8] = '\0';
+	etoa_strncpy(name, lar->mv.notify.rname.name, 
+		lar->mv.notify.rname.svlen-2);
+	name[8] = '\0';
+	etoa_strncpy(group, lar->mv.notify.group.gname.name,
+		lar->mv.notify.group.gname.svlen-2);
+	group[8] = '\0';
+
+	sprintf(fn, "%s.%s", net, name);
+	netid = sna_char_to_netid(fn);
+	sna_debug(10, "%s - %s\n", netid->net, netid->name);
+
+	for(i = 0; i < ETH_ALEN; i++)
+		s.mac[i] = flip_byte(lar->mv.notify.rmac.mac[i]);
+        s.lsap = flip_byte(lar->mv.notify.rlsap.lsap);
+
+	sna_lar_record(netid, group, &s, lar->mv.notify.rtcap.rtcap, 0);
+
+	return (0);
+}
+
+int sna_lar_tx_notify(struct net_device *dev, struct larhdr *lar, char *cce_mac)
+{
+	struct sna_lar_dinfo *d;
+	struct sk_buff *skb;
+	struct larhdr *lar_hdr;
+	llchdr *llc_hdr;
+	int size, i;
+
+	sna_debug(5, "sna_lar_tx_notify (%s)\n", sna_pr_ether(cce_mac));
+
+	/* response to query only if we have a local node on the same network */
+	for(d = lar_list; d != NULL; d = d->next)
+		if(d->ldev && !etoa_strncmp(lar->mv.query.tnetid.netid,
+			d->netid.net, 8))
+			break;
+	if(d == NULL)
+		return (-ENOENT);
+
+	size = dev->hard_header_len;
+	size += LLC_TYPE1_SIZE; 
+	size += SNA_LAR_NOTIFY_SIZE;
+	skb = alloc_skb(size, GFP_ATOMIC);
+
+	skb->dev = dev;
+	skb_reserve(skb, dev->hard_header_len);
+
+	/* Build LLC header - Type 1 / UI CMD */
+	llc_hdr = (llchdr *)skb_put(skb, LLC_TYPE1_SIZE);
+	llc_hdr->dsap 		= LLC_SAP_LAR;
+	llc_hdr->ssap 		= LLC_SAP_LAR;
+	llc_hdr->ctrl.ctrl 	= LLC_CTRL_UI_CMD;
+
+	/* Build LAR Notify packet */
+	lar_hdr = (struct larhdr *)skb_put(skb, SNA_LAR_NOTIFY_SIZE);
+	lar_hdr->mvlen	= htons(SNA_LAR_NOTIFY_SIZE);
+	lar_hdr->mvid	= SNA_LAR_T_NOTIFY;
+
+	/* Correlator */
+	lar_hdr->mv.notify.correlator.svlen 	= 6;
+	lar_hdr->mv.notify.correlator.svid	= 0x05;
+	lar_hdr->mv.notify.correlator.correlator
+		= lar->mv.query.correlator.correlator;
+
+	/* Resource LSAP */
+	lar_hdr->mv.notify.rlsap.svlen 		= 3;
+	lar_hdr->mv.notify.rlsap.svid 		= 0x0B;
+	lar_hdr->mv.notify.rlsap.lsap		= flip_byte(d->snpa.lsap);
+
+	/* Resource MAC */
+	lar_hdr->mv.notify.rmac.svlen		= 8;
+	lar_hdr->mv.notify.rmac.svid		= 0x0C;
+	for(i = 0; i < ETH_ALEN; i++)
+		lar_hdr->mv.notify.rmac.mac[i] = d->snpa.mac[i];
+
+	/* Resource NetID */
+	lar_hdr->mv.notify.rnetid.svlen		= 10;
+	lar_hdr->mv.notify.rnetid.svid		= 0x0E;
+	atoe_strncpy(lar_hdr->mv.notify.rnetid.netid, d->netid.net, 8);
+
+	/* Resource Name */
+	lar_hdr->mv.notify.rname.svlen		= 10;
+	lar_hdr->mv.notify.rname.svid		= 0x01;
+	atoe_strncpy(lar_hdr->mv.notify.rname.name, d->netid.name, 8);
+
+	/* Group Names */
+	lar_hdr->mv.notify.group.svlen		= 12;
+	lar_hdr->mv.notify.group.svid		= 0x81;
+	lar_hdr->mv.notify.group.gname.svlen	= 10;
+	lar_hdr->mv.notify.group.gname.svid	= 0x00;
+	atoe_strncpy(lar_hdr->mv.notify.group.gname.name, d->group, 8);
+
+	/* Routing Capabilities */
+	lar_hdr->mv.notify.rtcap.svlen		= 6;
+	lar_hdr->mv.notify.rtcap.svid		= 0x02;
+	memcpy(&lar_hdr->mv.notify.rtcap.rtcap, &d->rtcap, 4);
+
+	/* Return CCE MAC Address */
+	lar_hdr->mv.notify.cce_mac.svlen	= 8;
+	lar_hdr->mv.notify.cce_mac.svid		= 0x04;
+	memcpy(lar_hdr->mv.notify.cce_mac.mac, d->snpa.mac, ETH_ALEN);
+
+	/* Add MAC header and Transmit */
+	dev->hard_header(skb, dev, ETH_P_802_3, lar->mv.query.cce_mac.mac, 
+		NULL, skb->len);
+	dev_queue_xmit(skb);
+
+	return (0);
+}
+
+int sna_lar_rcv(struct sk_buff *skb, struct net_device *dev,
+        struct packet_type *pt)
+{
+	struct ethhdr *eth_hdr = skb->mac.ethernet;
+	struct larhdr *lar_hdr = skb->nh.larh;
+
+	sna_debug(10, "sna_lar_rcv %02X\n", lar_hdr->mvid);
+	switch(lar_hdr->mvid)
+	{
+		case (SNA_LAR_T_SOLICIT):
+		case (SNA_LAR_T_ADVERTISE):
+		case (SNA_LAR_T_FIND):
+		case (SNA_LAR_T_FOUND):
+			sna_debug(0, "lar_rcv: non-implemented rcv bug jschlst.\n");
+			break;
+
+		case (SNA_LAR_T_QUERY):
+			sna_lar_tx_notify(dev, skb->nh.larh, eth_hdr->h_dest);
+			break;
+
+		case (SNA_LAR_T_NOTIFY):
+			sna_lar_process_notify(skb->nh.larh);
+			break;
+
+		default:
+			break;
+	}
+
+        kfree_skb(skb);
+	return (0);
+}
+
+/* Register LAR SAP and listen for Queries on all LLC devices. */
+int sna_lar_create(void)
+{
+	/* Initialize timers. */
+	init_timer(&find_timer);
+	init_timer(&ad_timer);
+	init_timer(&solicit_timer);
+	init_timer(&query_timer);
+	find_timer.function     = sna_lar_find_timer_expire;
+	ad_timer.function	= sna_lar_ad_timer_expire;
+	solicit_timer.function	= sna_lar_solicit_timer_expire;
+	query_timer.function	= sna_lar_query_timer_expire;
+
+	init_waitqueue_head(&sleep);
+
+	lar_dl = register_8022_client(LLC_SAP_LAR, sna_lar_rcv,
+		sna_lar_rcv_event);
+	if(lar_dl == NULL)
+	{
+		printk("LAR unable to register with 802.2\n");
+		return (-1);
+	}
+
+	return (0);
+}
+
+/* Remove the LAR SAP and close any listeners. */
+int sna_lar_destroy(void)
+{
+	struct sna_lar_dinfo *d, **clients = &lar_list;
+
+	/* Remove timers. */
+	del_timer(&find_timer);
+	del_timer(&ad_timer);
+	del_timer(&solicit_timer);
+	del_timer(&query_timer);
+
+	unregister_8022_client(LLC_SAP_LAR);
+
+        while((d = *clients) != NULL)
+        {
+        	*clients = d->next;
+                kfree(d);
+        }
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_nof.c linux/net/sna/sna_nof.c
--- linux-2.4.4/net/sna/sna_nof.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_nof.c	Mon May 14 21:10:29 2001
@@ -0,0 +1,1101 @@
+/* sna_nof.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <net/llc.h>
+#include <linux/llc.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+extern int sna_cpic_create(struct sna_start_node *start);
+extern int sna_cpic_destroy(struct sna_delete_node *delete);
+
+/* One entry for each "node" started. */
+static struct sna_nof_pinfo *nof_node_list = NULL;
+
+struct sna_nodeid *sna_nof_find_nodeid(struct sna_netid *n)
+{
+	struct sna_nof_pinfo *p;
+
+	sna_debug(5, "sna_nof_find_nodeid\n");
+	for(p = nof_node_list; p != NULL; p = p->next)
+		if(!strcmp(n->net, p->netid.net) 
+			&& !strcmp(n->name, p->netid.name))
+				return (&p->nodeid);
+
+	return (NULL);
+}
+
+int sna_nof_insert(struct sna_nof_pinfo *nof)
+{
+        sna_debug(5, "sna_nof_insert\n");
+        nof->next = nof_node_list;
+        nof_node_list = nof;
+
+        return (0);
+}
+
+struct sna_nof_pinfo *sna_nof_find(char *node_name)
+{
+        struct sna_nof_pinfo *f;
+
+        for(f = nof_node_list; f != NULL; f = f->next)
+        {
+		if(!strncmp(f->netid.name, node_name, SNA_NODE_NAME_LEN))
+                        continue;
+        }
+
+        return (f);
+}
+
+int sna_nof_delete_dlc(struct net_device *dev)
+{
+        sna_debug(5, "sna_nof_delete_dlc %s\n", dev->name);
+        return (sna_cs_delete_dlc(dev));
+}
+
+int sna_nof_define_dlc(struct net_device *dev)
+{
+        sna_debug(5, "sna_nof_define_dlc %s\n", dev->name);
+	return(sna_cs_define_dlc(dev));
+}
+
+static int sna_nof_delete_node(struct sna_delete_node *delete)
+{
+	struct sna_nof_pinfo *tmp; 
+	struct sna_nof_pinfo **clients = &nof_node_list;
+	int err = -ENOENT;
+
+        sna_debug(5, "sna_nof_delete_node %s\n", delete->netid.name);
+	sna_attach_destroy(delete);
+	sna_cpic_destroy(delete);
+	sna_rm_destroy(delete);
+	sna_trs_destroy(delete);
+	sna_cs_destroy(delete);
+	sna_ds_destroy(delete);
+	sna_ss_destroy(delete);
+	sna_asm_destroy(delete);
+
+
+        while((tmp = *clients) != NULL)
+        {
+                if(!strncmp(tmp->netid.name, delete->netid.name, 8))
+                {
+                        *clients = tmp->next;
+			tmp->next = NULL;
+			tmp->prev = NULL;
+                        kfree(tmp);
+			sna_mod_dec_use_count();
+			err = 0;
+                }
+		else
+                	clients = &tmp->next;
+        }
+
+        return (err);
+}
+
+static int sna_nof_stop_node(struct sna_stop_node *stop)
+{
+	sna_debug(5, "sna_nof_stop_node %s\n", stop->netid.name);
+	printk("Function not implemented use delete\n");
+
+	return (-EINVAL);
+}
+
+static int sna_nof_start_node(struct sna_start_node *start)
+{
+	struct sna_nof_pinfo *nof;
+
+	sna_debug(5, "sna_nof_start_node %s\n", start->netid.name);
+	if(sna_nof_find(start->netid.name) != NULL)
+		return (-EINVAL);
+	nof = (struct sna_nof_pinfo *)kmalloc(sizeof(struct sna_nof_pinfo),
+		GFP_ATOMIC);
+	memset(nof, '\0', sizeof(struct sna_nof_pinfo));
+        memcpy(&nof->netid, &start->netid, sizeof(struct sna_netid));
+	nof->nodeid.block_id	= start->nodeid.block_id;
+	nof->nodeid.pu_id	= start->nodeid.pu_id;
+	nof->type	= start->type;
+	nof->lu_seg	= start->lu_seg;
+	nof->bind_seg	= start->bind_seg;
+	nof->max_lus	= start->max_lus;
+
+	switch(start->type)
+	{
+		case (SNA_LEN_END_NODE):
+		case (SNA_APPN_END_NODE):
+		case (SNA_APPN_NET_NODE):
+			nof->type = start->type;
+			break;
+
+		default:
+			return (-EINVAL);
+	}
+	nof->status	= (SNA_UP | SNA_RUNNING);
+	nof->prev       = NULL;
+        nof->next       = nof_node_list;
+        nof_node_list   = nof;
+
+	sna_asm_create(start);
+	sna_ss_create(start);
+	sna_ds_create(start);
+	sna_cs_create(start);
+	sna_trs_create(start);
+	sna_cpic_create(start);
+	sna_attach_create(start);
+	sna_tc_init();
+
+	sna_mod_inc_use_count();
+
+#ifdef NOT
+	nof->netid_registered			= start->netid_registered;
+	nof->ls_supp_type			= start->ls_supp_type;
+	nof->resource_registration		= start->resource_registration;
+	nof->segment_generation_lvl		= start->segment_generation_lvl;
+	nof->mode_to_cos_mapping		= start->mode_to_cos_mapping;
+	nof->ms_node_type			= start->ms_node_type;
+	nof->mj_vector_file			= start->mj_vector_file;
+	nof->ms_log_file			= start->ms_log_file;
+	nof->peer_resource_registration		
+		= start->peer_resource_registration;
+	nof->network_node_type			= start->network_node_type;
+	nof->directory_type_supp		= start->directory_type_supp;
+	nof->rs_tree_update_type		= start->rs_tree_update_type;
+	nof->tdm_node_name			= start->tdm_node_name;
+	nof->cosdm_node_name			= start->cosdm_node_name;
+	nof->max_rs_cache_trees			= start->max_rs_cache_trees;
+	nof->max_oos_tdm_updates		= start->max_oos_tdm_updates;
+	nof->resource_service_search		
+		= start->resource_service_search;
+	nof->general_odai_usage_supp		
+		= start->general_odai_usage_supp;
+#endif
+
+	return (0);
+}
+
+static int sna_nof_reset_session_limit(struct sna_reset_session_limit *rsl)
+{
+
+	return (0);
+}
+
+static int sna_nof_delete_link_station(struct sna_delete_link_station *dls)
+{
+	int err;
+
+	sna_debug(5, "sna_nof_delete_link_station\n");
+	err = sna_cs_delete_ls(dls);
+	return (err);
+}
+
+static int sna_nof_deactivate_control_sessions(struct sna_deactivate_control_sessions *dcs)
+{
+
+	return (0);
+}
+
+static int sna_nof_delete_port(struct sna_delete_port *dp)
+{
+	sna_debug(5, "sna_nof_delete_port\n");
+	return (sna_cs_delete_port(dp));
+}
+
+static int sna_nof_define_mode(struct sna_define_mode *dm)
+{
+	sna_debug(5, "sna_nof_define_mode\n");
+	return (sna_rm_define_mode(dm));
+}
+
+static int sna_nof_activate_control_sessions(struct sna_activate_control_sessions *acs)
+{
+	return (0);
+}
+
+static int sna_nof_change_session_limit(struct sna_change_session_limit *csl)
+{
+
+	return (0);
+}
+
+static int sna_nof_define_adjacent_node(struct sna_define_adjacent_node *daj)
+{
+	return (0);
+}
+
+static int sna_nof_define_class_of_service(struct sna_define_cos *cos)
+{
+	sna_debug(5, "sna_nof_define_class_of_service\n");
+	return (sna_cosm_define_cos(cos));
+}
+
+static int sna_nof_define_connection_network(struct sna_define_connection_network *dcn)
+{
+	return (0);
+}
+
+static int sna_nof_define_directory_entry(struct sna_define_directory_entry *de)
+{
+	return (0);
+}
+
+static int sna_nof_define_isr_tuning(struct sna_define_isr_tuning *dit)
+{
+	return (0);
+}
+
+static int sna_nof_define_link_station(struct sna_define_link_station *dls)
+{
+	sna_debug(5, "sna_nof_define_link_station\n");
+	return (sna_cs_define_ls(dls));
+}
+
+static int sna_nof_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	sna_debug(5, "sna_nof_define_local_lu\n");
+	return (sna_rm_define_local_lu(dlu));
+}
+
+static int sna_nof_define_node_chars(struct sna_define_node_chars *dnc)
+{
+	sna_debug(5, "sna_nof_define_node_chars\n");
+	return (sna_tdm_define_node_chars(dnc));
+}
+
+static int sna_nof_define_partner_lu(struct sna_define_partner_lu *dplu)
+{
+	sna_debug(5, "sna_nof_define_partner_lu\n");
+	return (sna_rm_define_remote_lu(dplu));
+}
+
+static int sna_nof_define_port(struct sna_define_port *dp)
+{
+	sna_debug(5, "sna_nof_define_port\n");
+	return (sna_cs_define_port(dp));
+}
+
+static int sna_nof_define_tp(struct sna_define_tp *dtp)
+{
+	return (0);
+}
+
+static int sna_nof_delete_adjacent_node(struct sna_delete_adjacent_node *dan)
+{
+	return (0);
+}
+
+static int sna_nof_delete_class_of_service(struct sna_delete_cos *cos)
+{
+	sna_debug(5, "sna_nof_delete_class_of_service\n");
+	return (sna_cosm_delete_cos(cos));
+}
+
+static int sna_nof_delete_connection_network(struct sna_delete_connection_network *dcn)
+{
+	return (0);
+}
+
+static int sna_nof_delete_directory_entry(struct sna_delete_directory_entry *dde)
+{
+	return (0);
+}
+
+static int sna_nof_delete_isr_tuning(struct sna_delete_isr_tuning *dit)
+{
+	return (0);
+}
+
+static int sna_nof_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+	sna_debug(5, "sna_nof_delete_local_lu\n");
+	return (sna_rm_delete_local_lu(dlu));
+}
+
+static int sna_nof_delete_mode(struct sna_delete_mode *dm)
+{
+	sna_debug(5, "sna_nof_delete_mode\n");
+	return (0);
+//	return (sna_rm_delete_mode(dm));
+}
+
+static int sna_nof_delete_partner_lu(struct sna_delete_partner_lu *dplu)
+{
+	sna_debug(5, "sna_nof_delete_partner_lu\n");
+	return (sna_rm_delete_remote_lu(dplu));
+}
+
+static int sna_nof_delete_tp(struct sna_delete_tp *dtp)
+{
+	return (0);
+}
+
+static int sna_nof_initialize_session_limit(struct sna_initialize_session_limit *isl)
+{
+	return (0);
+}
+
+static int sna_nof_start_link_station(struct sna_start_link_station *sls)
+{
+	sna_debug(5, "sna_nof_start_link_station\n");
+	return (sna_cs_start_ls(sls));
+}
+
+static int sna_nof_start_port(struct sna_start_port *sp)
+{
+	sna_debug(5, "sna_nof_start_port\n");
+	return (sna_cs_start_port(sp));
+}
+
+static int sna_nof_start_tp(struct sna_start_tp *stp)
+{
+	return (0);
+}
+
+static int sna_nof_stop_link_station(struct sna_stop_link_station *sls)
+{
+	sna_debug(5, "sna_nof_stop_link_station\n");
+	return (sna_cs_stop_ls(sls));
+}
+
+static int sna_nof_stop_port(struct sna_stop_port *sp)
+{
+	sna_debug(5, "sna_nof_stop_port\n");
+	return (sna_cs_stop_port(sp));
+}
+
+/*
+ * NOF: Operators facility into the SNA node.
+ *
+ * setsockopt:
+ *  - 
+ * getsockopt:
+ *  -
+ */
+
+#ifdef CONFIG_PROC_FS
+int sna_nof_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_nof_pinfo *nof;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        /* Output the NOF data for the /proc filesystem. */
+        len += sprintf(buffer, "%s%s %s\n%-17s%-5s%-7s%-9s%-8s\n", 
+		"Linux-SNA v", sna_version, sna_maintainer, "NetID.Node",
+		"type", "lu_seg", "bind_seg", "max_lus");
+
+        for(nof = nof_node_list; nof != NULL; nof = nof->next)
+        {
+		len += sprintf(buffer + len, "%-18s",sna_pr_netid(&nof->netid));
+		len += sprintf(buffer + len, "%02X   %-7d%-9d%-8ld\n",
+			nof->type, nof->lu_seg, nof->bind_seg, nof->max_lus);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+int sna_nof_setsockopt(struct socket *sock, int level, int optname,
+        char *optval, int optlen)
+{
+        int err;
+
+        switch(optname)
+        {
+                case (SNA_ACTIVATE_CONTROL_SESSIONS):
+                {
+                        struct sna_activate_control_sessions act_ctrl_sess;
+                        if(optlen<sizeof(struct sna_activate_control_sessions))
+                                return (-EINVAL);
+                        if(copy_from_user(&act_ctrl_sess, optval,
+                                sizeof(struct sna_activate_control_sessions)))
+                                return (-EFAULT);
+                        err = sna_nof_activate_control_sessions(&act_ctrl_sess);
+                        break;
+                }
+
+                case (SNA_CHANGE_SESSION_LIMIT):
+                {
+                        struct sna_change_session_limit chg_sess_limit;
+                        if(optlen < sizeof(struct sna_change_session_limit))
+                                return (-EINVAL);
+                        if(copy_from_user(&chg_sess_limit, optval,
+                                sizeof(struct sna_change_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_change_session_limit(&chg_sess_limit);
+                        break;
+                }
+
+                case (SNA_DEACTIVATE_CONTROL_SESSIONS):
+                {
+                        struct sna_deactivate_control_sessions deact_cntrl_sess;
+                        if(optlen < sizeof(struct sna_deactivate_control_sessions))
+                                return (-EINVAL);
+                        if(copy_from_user(&deact_cntrl_sess, optval,
+                                sizeof(struct sna_deactivate_control_sessions)))                                return (-EFAULT);
+			err = sna_nof_deactivate_control_sessions(&deact_cntrl_sess);
+                        if(err)
+                                return (err);
+                        break;
+                }
+
+                case (SNA_DEFINE_ADJACENT_NODE):
+                {
+                        struct sna_define_adjacent_node define_adjacent_node;
+                        if(optlen < sizeof(struct sna_define_adjacent_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_adjacent_node, optval,
+                                sizeof(struct sna_define_adjacent_node)))
+                                return (-EFAULT);
+                        err = sna_nof_define_adjacent_node(&define_adjacent_node);
+                        break;
+                }
+
+                case (SNA_DEFINE_CLASS_OF_SERVICE):
+                {
+                        struct sna_define_cos cos;
+                        if(optlen < sizeof(struct sna_define_cos))
+                                return (-EINVAL);
+                        if(copy_from_user(&cos, optval,
+                                sizeof(struct sna_define_cos)))
+                                return (-EFAULT);
+                        err = sna_nof_define_class_of_service(&cos);
+                        break;
+                }
+
+                case (SNA_DEFINE_CONNECTION_NETWORK):
+                {
+                        struct sna_define_connection_network define_cn;
+                        if(optlen < sizeof(struct sna_define_connection_network))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_cn, optval,
+                                sizeof(struct sna_define_connection_network)))
+                                return (-EFAULT);
+                        err = sna_nof_define_connection_network(&define_cn);
+                        break;
+                }
+
+                case (SNA_DEFINE_DIRECTORY_ENTRY):
+                {
+                        struct sna_define_directory_entry define_dir_entry;
+                        if(optlen < sizeof(struct sna_define_directory_entry))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_dir_entry, optval,
+                                sizeof(struct sna_define_directory_entry)))
+                                return (-EFAULT);
+                        err = sna_nof_define_directory_entry(&define_dir_entry);
+                        break;
+                }
+
+                case (SNA_DEFINE_ISR_TUNING):
+                {
+                        struct sna_define_isr_tuning define_isr_tuning;
+                        if(optlen < sizeof(struct sna_define_isr_tuning))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_isr_tuning, optval,
+                                sizeof(struct sna_define_isr_tuning)))
+                                return (-EFAULT);
+                        err = sna_nof_define_isr_tuning(&define_isr_tuning);
+                        break;
+                }
+
+                case (SNA_DEFINE_LINK_STATION):
+                {
+                        struct sna_define_link_station define_ls;
+                        if(optlen < sizeof(struct sna_define_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_ls, optval,
+                                sizeof(struct sna_define_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_define_link_station(&define_ls);
+                        break;
+                }
+
+                case (SNA_DEFINE_LOCAL_LU):
+                {
+                        struct sna_define_local_lu define_llu;
+                        if(optlen < sizeof(struct sna_define_local_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_llu, optval,
+                                sizeof(struct sna_define_local_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_define_local_lu(&define_llu);
+                        break;
+                }
+
+                case (SNA_DEFINE_MODE):
+                {
+                        struct sna_define_mode define_mode;
+                        if(optlen < sizeof(struct sna_define_mode))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_mode, optval,
+                                sizeof(struct sna_define_mode)))
+                                return (-EFAULT);
+                       	err = sna_nof_define_mode(&define_mode);
+                        break;
+                }
+
+                case (SNA_DEFINE_NODE_CHARS):
+                {
+                        struct sna_define_node_chars define_node_chars;
+                        if(optlen < sizeof(struct sna_define_node_chars))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_node_chars, optval,
+                                sizeof(struct sna_define_node_chars)))
+                                return (-EFAULT);
+                        err = sna_nof_define_node_chars(&define_node_chars);
+                        break;
+                }
+
+                case (SNA_DEFINE_PARTNER_LU):
+                {
+                        struct sna_define_partner_lu define_plu;
+                        if(optlen < sizeof(struct sna_define_partner_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_plu, optval,
+                                sizeof(struct sna_define_partner_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_define_partner_lu(&define_plu);
+                        break;
+                }
+
+                case (SNA_DEFINE_PORT):
+                {
+                        struct sna_define_port define_port;
+                        if(optlen < sizeof(struct sna_define_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_port, optval,
+                                sizeof(struct sna_define_port)))
+                                return (-EFAULT);
+                        err = sna_nof_define_port(&define_port);
+                        break;
+                }
+
+                case (SNA_DEFINE_TP):
+                {
+                        struct sna_define_tp define_tp;
+                        if(optlen < sizeof(struct sna_define_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&define_tp, optval,
+                                sizeof(struct sna_define_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_define_tp(&define_tp);
+                        break;
+                }
+
+                case (SNA_DELETE_ADJACENT_NODE):
+                {
+                        struct sna_delete_adjacent_node delete_adjacent_node;
+                        if(optlen < sizeof(struct sna_delete_adjacent_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_adjacent_node, optval,
+                                sizeof(struct sna_delete_adjacent_node)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_adjacent_node(&delete_adjacent_node);
+                        break;
+                }
+
+                case (SNA_DELETE_CLASS_OF_SERVICE):
+                {
+                        struct sna_delete_cos cos;
+                        if(optlen < sizeof(struct sna_delete_cos))
+                                return (-EINVAL);
+                        if(copy_from_user(&cos, optval,
+                                sizeof(struct sna_delete_cos)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_class_of_service(&cos);
+                        break;
+                }
+
+                case (SNA_DELETE_CONNECTION_NETWORK):
+                {
+                        struct sna_delete_connection_network delete_cn;
+                        if(optlen < sizeof(struct sna_delete_connection_network))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_cn, optval,
+                                sizeof(struct sna_delete_connection_network)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_connection_network(&delete_cn);
+                        break;
+                }
+
+                case (SNA_DELETE_DIRECTORY_ENTRY):
+                {
+                        struct sna_delete_directory_entry delete_dir_entry;
+                        if(optlen < sizeof(struct sna_delete_directory_entry))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_dir_entry, optval,
+                                sizeof(struct sna_delete_directory_entry)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_directory_entry(&delete_dir_entry);
+                        break;
+                }
+
+                case (SNA_DELETE_ISR_TUNING):
+                {
+                        struct sna_delete_isr_tuning delete_isr_tuning;
+                        if(optlen < sizeof(struct sna_delete_isr_tuning))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_isr_tuning, optval,
+                                sizeof(struct sna_delete_isr_tuning)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_isr_tuning(&delete_isr_tuning);
+                        break;
+                }
+
+                case (SNA_DELETE_LINK_STATION):
+                {
+                        struct sna_delete_link_station delete_ls;
+                        if(optlen < sizeof(struct sna_delete_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_ls, optval,
+                                sizeof(struct sna_delete_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_link_station(&delete_ls);
+                        break;
+                }
+
+                case (SNA_DELETE_LOCAL_LU):
+                {
+                        struct sna_delete_local_lu delete_llu;
+                        if(optlen < sizeof(struct sna_delete_local_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_llu, optval,
+                                sizeof(struct sna_delete_local_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_local_lu(&delete_llu);
+                        break;
+                }
+
+                case (SNA_DELETE_MODE):
+                {
+                        struct sna_delete_mode delete_mode;
+                        if(optlen < sizeof(struct sna_delete_mode))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_mode, optval,
+                                sizeof(struct sna_delete_mode)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_mode(&delete_mode);
+                        break;
+                }
+
+                case (SNA_DELETE_PARTNER_LU):
+                {
+                        struct sna_delete_partner_lu delete_plu;
+                        if(optlen < sizeof(struct sna_delete_partner_lu))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_plu, optval,
+                                sizeof(struct sna_delete_partner_lu)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_partner_lu(&delete_plu);
+                        break;
+                }
+
+                case (SNA_DELETE_PORT):
+                {
+                        struct sna_delete_port delete_port;
+                        if(optlen < sizeof(struct sna_delete_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_port, optval,
+                                sizeof(struct sna_delete_port)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_port(&delete_port);
+                        break;
+                }
+
+                case (SNA_DELETE_TP):
+                {
+                        struct sna_delete_tp delete_tp;
+                        if(optlen < sizeof(struct sna_delete_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_tp, optval,
+                                sizeof(struct sna_delete_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_tp(&delete_tp);
+                        break;
+                }
+
+                case (SNA_INITIALIZE_SESSION_LIMIT):
+                {
+                        struct sna_initialize_session_limit init_sess_limit;
+                        if(optlen < sizeof(struct sna_initialize_session_limit))                                return (-EINVAL);
+                        if(copy_from_user(&init_sess_limit, optval,
+                                sizeof(struct sna_initialize_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_initialize_session_limit(&init_sess_limit);
+                        break;
+                }
+
+                case (SNA_RESET_SESSION_LIMIT):
+                {
+                        struct sna_reset_session_limit reset_sess_limit;
+                        if(optlen < sizeof(struct sna_reset_session_limit))
+                                return (-EINVAL);
+                        if(copy_from_user(&reset_sess_limit, optval,
+                                sizeof(struct sna_reset_session_limit)))
+                                return (-EFAULT);
+                        err = sna_nof_reset_session_limit(&reset_sess_limit);
+                        break;
+                }
+
+                case (SNA_START_LINK_STATION):
+                {
+                        struct sna_start_link_station start_link_station;
+                        if(optlen < sizeof(struct sna_start_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_link_station, optval,
+                                sizeof(struct sna_start_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_start_link_station(&start_link_station);
+                        break;
+                }
+
+                /* Start the SNA Node. */
+                case (SNA_START_NODE):
+                {
+                        struct sna_start_node start_node;
+                        if(optlen < sizeof(struct sna_start_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_node, optval,
+                                sizeof(struct sna_start_node)))
+                                return (-EFAULT);
+                        err = sna_nof_start_node(&start_node);
+                        break;
+                }
+
+		case (SNA_STOP_NODE):
+		{
+			struct sna_stop_node stop_node;
+                        if(optlen < sizeof(struct sna_stop_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_node, optval,
+                                sizeof(struct sna_stop_node)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_node(&stop_node);
+                        break;
+                }
+
+		case (SNA_DELETE_NODE):
+		{
+			struct sna_delete_node delete_node;
+                        if(optlen < sizeof(struct sna_delete_node))
+                                return (-EINVAL);
+                        if(copy_from_user(&delete_node, optval,
+                                sizeof(struct sna_delete_node)))
+                                return (-EFAULT);
+                        err = sna_nof_delete_node(&delete_node);
+                        break;
+                }
+
+                case (SNA_START_PORT):
+                {
+                        struct sna_start_port start_port;
+                        if(optlen < sizeof(struct sna_start_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_port, optval,
+                                sizeof(struct sna_start_port)))
+                                return (-EFAULT);
+                        err = sna_nof_start_port(&start_port);
+                        break;
+                }
+
+                case (SNA_START_TP):
+                {
+                        struct sna_start_tp start_tp;
+                        if(optlen < sizeof(struct sna_start_tp))
+                                return (-EINVAL);
+                        if(copy_from_user(&start_tp, optval,
+                                sizeof(struct sna_start_tp)))
+                                return (-EFAULT);
+                        err = sna_nof_start_tp(&start_tp);
+                        break;
+                }
+
+                case (SNA_STOP_LINK_STATION):
+                {
+                        struct sna_stop_link_station stop_ls;
+                        if(optlen < sizeof(struct sna_stop_link_station))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_ls, optval,
+                                sizeof(struct sna_stop_link_station)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_link_station(&stop_ls);
+                        break;
+                }
+
+                case (SNA_STOP_PORT):
+                {
+                        struct sna_stop_port stop_port;
+                        if(optlen < sizeof(struct sna_stop_port))
+                                return (-EINVAL);
+                        if(copy_from_user(&stop_port, optval,
+                                sizeof(struct sna_stop_port)))
+                                return (-EFAULT);
+                        err = sna_nof_stop_port(&stop_port);
+                        break;
+                }
+
+                default:
+                        return (-EINVAL);
+        }
+
+	return (err);
+}
+
+int sna_nof_getsockopt(struct socket *sock, int level, int optname,
+        char *optval, int *optlen)
+{
+        int len;
+
+        if(get_user(len, optlen))
+                return (-EFAULT);
+
+        switch(optname)
+        {
+                case (SNA_QUERY_CLASS_OF_SERVICE):
+                {
+                        struct sna_query_class_of_service *cos;
+
+                        len = min(len, sizeof(cos));
+                        if(copy_to_user((void *)optval, &cos, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_CONNECTION_NETWORK):
+                {
+                        struct sna_query_connection_network *cn;
+
+                        len = min(len, sizeof(cn));
+                        if(copy_to_user((void *)optval, &cn, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_DLC):
+                {
+                        struct sna_query_dlc *dlc;
+
+                        len = min(len, sizeof(dlc));
+                        if(copy_to_user((void *)optval, &dlc, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_ISR_TUNING):
+                {
+                        struct sna_query_isr_tuning *isr;
+
+                        len = min(len, sizeof(isr));
+                        if(copy_to_user((void *)optval, &isr, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_LINK_STATION):
+                {
+                        struct sna_query_link_station *ls;
+
+                        len = min(len, sizeof(ls));
+                        if(copy_to_user((void *)optval, &ls, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_PORT):
+                {
+                        struct sna_query_port *port;
+
+                        len = min(len, sizeof(port));
+                        if(copy_to_user((void *)optval, &port, len))
+                                return (-EFAULT);
+                        break;
+                }
+
+                case (SNA_QUERY_STATISTICS):
+                {
+                        struct sna_query_statistics *stats;
+
+                        len = min(len, sizeof(stats));
+                        if(copy_to_user((void *)optval, &stats, len))
+                                return (-EFAULT);
+                }
+
+                default:
+			return (-EINVAL);
+        }
+
+        if(put_user(len, optlen))
+                return (-EFAULT);
+
+        return (0);
+}
+
+int sna_nof_ginfo(struct sna_nof_pinfo *nof, char *buf, int len)
+{
+	struct snareq sr;
+	int done = 0;
+
+	sna_debug(10, "sna_nof_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(sr);
+                return (done);
+        }
+        if(len < (int)sizeof(sr))
+                return done;
+        memset(&sr, 0, sizeof(struct snareq));
+
+        /* Move the data here */
+	strncpy(sr.net, nof->netid.net, 8);
+	strncpy(sr.name, nof->netid.name, 8);
+	sr.type 	= nof->type;
+	sr.lu_seg	= nof->lu_seg;
+	sr.bind_seg	= nof->bind_seg;
+	sr.max_lus	= nof->max_lus;
+	sr.node_status	= nof->status;
+	memcpy(&sr.nodeid, &nof->nodeid, sizeof(struct sna_nodeid));
+
+	if(copy_to_user(buf, &sr, sizeof(struct snareq)))
+                return (-EFAULT);
+        buf += sizeof(struct snareq);
+        len -= sizeof(struct snareq);
+        done += sizeof(struct snareq);
+
+        return (done);
+}
+	
+int sna_nof_query_node(char *arg)
+{
+	struct sna_nof_pinfo *nof;
+	struct snaconf sc;
+	char *pos;
+        int len, total;
+
+	sna_debug(10, "sna_nof_query_node\n");
+	if(copy_from_user(&sc, arg, sizeof(sc)))
+                return (-EFAULT);
+
+	pos = sc.snac_buf;
+        len = sc.snac_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+	for(nof = nof_node_list; nof != NULL; nof = nof->next)
+	{
+		int done;
+
+                if(pos == NULL)
+                        done = sna_nof_ginfo(nof, NULL, 0);
+                else
+                        done = sna_nof_ginfo(nof, pos + total, len - total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+	}
+
+	sc.snac_len = total;
+	if(copy_to_user(arg, &sc, sizeof(sc)))
+                return (-EFAULT);
+
+	return (0);
+}
+
+int sna_nof_ioctl(int cmd, void *arg)
+{
+	sna_debug(5, "sna_nof_ioctl\n");
+        switch(cmd)
+        {
+		case (SIOCGLS):
+			sna_cs_query_ls(arg);
+			break;
+
+		case (SIOCGPORT):
+			sna_cs_query_port(arg);
+			break;
+
+		case (SIOCGDLC):
+			sna_cs_query_dlc(arg);
+			break;
+
+                case (SIOCGNODE):
+			sna_nof_query_node(arg);
+			break;
+
+		case (SIOCGMODE):
+			sna_rm_query_mode(arg);
+			break;
+
+		case (SIOCGLU):
+			sna_rm_query_lu(arg);
+			break;
+
+		case (SIOCGPLU):
+			sna_rm_query_plu(arg);
+			break;
+
+		case (SIOCGCOS):
+			sna_cosm_query_cos(arg);
+			break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (0);
+} 
diff -ruN linux-2.4.4/net/sna/sna_pc.c linux/net/sna/sna_pc.c
--- linux-2.4.4/net/sna/sna_pc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_pc.c	Mon May 14 21:10:39 2001
@@ -0,0 +1,587 @@
+/* sna_pc.c: Linux Systems Network Architecture implementation
+ * - Path Control (Route message units between HS and DLC). 
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/sna.h>
+
+static struct sna_pc_pinfo *pc_clients = NULL;
+
+struct sna_pc_pinfo *sna_pc_find(unsigned char *pc_id)
+{
+	struct sna_pc_pinfo *pc;
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+		if(!memcmp(&pc->pc_id, pc_id, 8))
+			return (pc);
+
+	return (NULL);
+}
+
+struct sna_pc_pinfo *sna_pc_find_by_netid(struct sna_netid *n)
+{
+	struct sna_pc_pinfo *pc;
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+		if(!strcmp(pc->fqcp.net, n->net)
+			&& !strcmp(pc->fqcp.name, n->name))
+			return (pc);
+
+	return (NULL);
+}
+
+/* Destroy a single PC instance. */
+int sna_pc_destroy(unsigned char *pc_id)
+{
+	struct sna_pc_pinfo *pc, **clients;
+
+	clients = &pc_clients;
+	while((pc = *clients) != NULL)
+	{
+		if(!memcmp(&pc->pc_id, pc_id, 8))
+		{
+			*clients = pc->next;
+			kfree(pc);
+			return (0);
+		}
+		clients = &pc->next;
+	}
+
+	return (-ENOENT);
+}
+
+/* Create a single PC instance. Return the PC ID. */
+int sna_pc_init(struct sna_pc_create_parms *npc)
+{
+	struct sna_pc_pinfo *pc;
+
+        sna_debug(5, "sna_pc_init %s\n", sna_pr_netid(&npc->fqcp));
+        pc = (struct sna_pc_pinfo *)kmalloc(sizeof(struct sna_pc_pinfo),
+		GFP_ATOMIC);
+	if(!pc)
+		return (-ENOMEM);
+	pc->type		= npc->type;
+	pc->dlc			= npc->dlc;
+	pc->ls			= npc->ls;
+	pc->port		= npc->port;
+
+	pc->max_tx_btu		= npc->max_tx_btu;
+	pc->max_rx_btu		= npc->max_rx_btu;
+	pc->bind_seg		= npc->bind_seg;
+	pc->limited_tg		= npc->limited_tg;
+	pc->tg_number		= npc->tg_number;
+
+	pc->odai		= npc->odai;
+	memcpy(&pc->fqcp, &npc->fqcp, sizeof(struct sna_netid));
+	pc->local_seg		= npc->local_seg;
+	pc->godai		= npc->godai;
+	pc->next		= pc_clients;
+	pc_clients		= pc;
+
+	sna_ss_generate_pcid(pc->fqcp.net, pc->fqcp.name);
+	sna_ss_update_pcid(pc->pc_id);
+
+        return (0);
+}
+
+int sna_pc_mu_error_checker(struct sk_buff *skb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_pc_mu_error_checker (skb %d)\n", skb->len);
+
+	/* Need to check that FID type is valid and
+	 * correct TH, RH, and RU lengths.
+	 */
+
+	return (err);
+}
+
+struct sna_lfsid *sna_pc_xtract_lfsid(struct sk_buff *skb)
+{
+	struct snathdr *th = skb->nh.fidh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "sna_pc_xtract_lfsid %02X\n", th->fid.f0.ft);
+	l = (struct sna_lfsid *)kmalloc(sizeof(struct sna_lfsid), GFP_ATOMIC);
+	switch(th->fid.f0.ft)	/* type field is in the same location for all */
+	{
+		case (SNA_TH_FID0):
+		case (SNA_TH_FID1):
+			break;
+
+		case (SNA_TH_FID2):
+			l->odai 	= th->fid.f2.odai;
+			l->sid.hl.sidh 	= th->fid.f2.oaf;
+			l->sid.hl.sidl 	= th->fid.f2.daf;
+			break;
+
+		case (SNA_TH_FID3):
+			break;
+
+		case (SNA_TH_FID4):
+			break;
+
+		case (SNA_TH_FID5):
+			break;
+
+		case (SNA_TH_FIDF):
+			break;
+
+		default:
+			return (NULL);
+	}
+
+	return (l);
+}
+
+int sna_pc_mu_rcv_router(struct sk_buff *skb)
+{
+	struct snarhdr *rh = skb->h.rh;
+	struct sna_lfsid *l;
+
+	sna_debug(5, "sna_pc_mu_rcv_router\n");
+	l = sna_pc_xtract_lfsid(skb);
+	switch(rh->ru)
+	{
+		case (SNA_RH_RU_FMD):
+			sna_tc_rcv(skb, l);
+			break;
+
+		case (SNA_RH_RU_SC):
+			sna_asm_rcv(skb, l);
+			break;
+
+		case (SNA_RH_RU_DFC):
+		case (SNA_RH_RU_NC):
+			/* haven't seen these two bad boys used lately, as I
+			 * forget where they should go we will let them die.
+			 */
+		default:
+			sna_debug(5, "Unknown RU catagory %02X\n", rh->ru);
+			kfree_skb(skb);
+			break;
+	}
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_pc_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_pc_pinfo *pc;
+	off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%-17s%-10s\n",
+                "NetID.Node", "path_control_id", "tg_number");
+
+	for(pc = pc_clients; pc != NULL; pc = pc->next)
+	{
+                len += sprintf(buffer + len, "%-18s%"
+			"02X%02X%02X%02X%02X%02X%02X%02X %10d\n", 
+			sna_pr_netid(&pc->fqcp), 
+			pc->pc_id[0], pc->pc_id[1], pc->pc_id[2],
+			pc->pc_id[3], pc->pc_id[4], pc->pc_id[5], pc->pc_id[6],
+			pc->pc_id[7], pc->tg_number);
+
+		/* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+
+	/* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+#ifdef NOT
+/* Internode. */
+static int sna_pc_alert_handler(struct sna_mu *mu, __u32 sense)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_alert_signal: received alert signal.\n");
+
+	msg->mu = mu;
+	msg->sense = sense;
+//	sna_ms(msg);
+
+	return (0);
+}
+
+/* Internode. */
+static int sna_pc_flush_handler(void)
+{
+	if(sna_pc_debug > 5)
+		printk("sna_pc_flush_handler: activated\n");
+
+	return (0);
+}
+
+static int sna_pc_hs_adder(struct sna_pc_hs_table *newhs)
+{
+	struct sna_pc_hs_table *next, *prev;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_hs_adder: adding hs.\n");
+
+	next = sna_hs_table;
+	prev = next->prev;
+	newhs->next = next;
+	newhs->prev = prev;
+	next->prev = newhs;
+	prev->next = newhs;
+
+	return (0);
+}
+
+static struct sna_pc_hs_table *sna_pc_hs_finder(__u8 lfsid)
+{
+	struct sna_pc_hs_table *i;
+
+	for(i = sna_hs_table; i->next != NULL; i = i->next)
+        {
+                if(i->lfsid == lfsid)
+                        return (i);
+        }
+
+	return (NULL);
+}
+
+static int sna_pc_hs_deleter(__u8 lfsid)
+{
+	struct sna_pc_hs_table *prev, *next, *result;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_hs_deleter: deleting hs.\n");
+
+	prev = sna_pc_hs_finder(lfsid);
+	if(prev == NULL)
+		return (-1);
+
+        next = prev->next;
+        result = NULL;
+        if(next != prev)
+	{
+                result = next;
+                next = next->next;
+                next->prev = prev;
+                prev->next = next;
+                result->next = NULL;
+                result->prev = NULL;
+        }
+	kfree(result);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+		printk("sna_pc_local_bind_rq_send: active\n");
+
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+	msg->cmd = SNA_BIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_bind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+        if(sna_pc_debug > 5)
+                printk("sna_pc_local_bind_rsp_send: active\n");
+
+	sna_pc_hs_adder(NULL);
+
+	msg->mu = mu;
+        msg->cmd = SNA_BIND_RSP_RCV;
+//        sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_flush_ls(void)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_flush_ls: active\n");
+
+	msg->cmd = SNA_LS_FLUSHED;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rq_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_unbind_rq_send: active\n");
+
+	msg->mu = mu;
+	msg->cmd = SNA_UNBIND_RQ_RCV;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_local_unbind_rsp_send(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_local_unbind_rsp_send: active\n");
+
+	msg->mu = mu;
+        msg->cmd = SNA_UNBIND_RSP_RCV;
+    //    sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_send_free_lfsid(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	if(sna_pc_debug > 5)
+                printk("sna_pc_free_lfsid: active\n");
+
+	msg->mu = mu;
+	msg->cmd = SNA_FREE_LFSID;
+//	sna_asm(msg);
+
+	return (0);
+}
+
+static int sna_pc_enqueuer(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+
+	switch(mu->tx_priority)
+	{
+		case (SNA_TP_NETWORK):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_network);
+			break;
+
+		case (SNA_TP_HIGH):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_high);
+			break;
+
+		case (SNA_TP_MEDIUM):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_medium);
+			break;
+
+		case (SNA_TP_LOW):
+			sna_msg_queue_tail(msg, &sna_trpr_qs_low);
+			break;
+	}
+
+	mark_bh(PC_UPM_BM);
+	return (0);
+}
+
+static int sna_pc_fsm_send_mu(void)
+{
+	return (0);
+}
+
+static __u16 sna_pc_get_mu_pcid(__u8 lfsid)
+{
+	struct sna_pc_hs_table *hs_table_entry;
+
+	hs_table_entry = sna_pc_hs_finder(lfsid);
+
+	return (hs_table_entry->pc_id);
+}
+
+static int sna_pc_remote_send_mu_processing(struct sna_mu *mu)
+{
+	if(mu->dcf > 600) // sna_pc_max_btu_size)
+		sna_pc_segment_generator(mu);
+	else
+		sna_pc_enqueuer(mu);
+
+	return (0);
+}
+
+static int sna_pc_segment_generator(struct sna_mu *mu)
+{
+	struct sna_mu *newmu = NULL, *cmu = NULL;
+	int over_size, len = 0;
+	int sna_pc_max_btu_size = 600;
+
+//	sna_copy_mu(cmu, mu);
+
+//	sna_cut_mu_tail(mu, over_size);
+	sna_pc_enqueuer(mu);
+
+	for(over_size = cmu->dcf - sna_pc_max_btu_size;
+		over_size >= sna_pc_max_btu_size;
+		len = over_size - sna_pc_max_btu_size, over_size -= len)
+	{
+//		newmu = sna_bm_get_buff(len);
+		newmu->pc_id		= cmu->pc_id;
+		newmu->hs_id		= cmu->hs_id;
+		newmu->lfsid		= cmu->lfsid;
+		newmu->tx_priority	= cmu->tx_priority;
+		newmu->dcf		= len;
+		newmu->biu->rh 		= cmu->biu->rh;
+		newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+		newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_MID_MIU;
+//		newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+		newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+		newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+		newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+		newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+		sna_pc_enqueuer(newmu);
+	}
+
+//	newmu = sna_bm_get_buff(len);
+        newmu->pc_id    	= cmu->pc_id;
+        newmu->hs_id    	= cmu->hs_id;
+        newmu->lfsid    	= cmu->lfsid;
+	newmu->tx_priority      = cmu->tx_priority;
+        newmu->dcf      	= len;
+        newmu->biu->rh  	= cmu->biu->rh;
+        newmu->biu->th.fid.fid2.fid = SNA_TH_FID2;
+	newmu->biu->th.fid.fid2.mpf = SNA_TH_MPF_EBIU;
+//	newmu->biu->th.fid.fid2.odai = cmu->biu->th.fid.fid0.odai;
+	newmu->biu->th.fid.fid2.efi = cmu->biu->th.fid.fid0.efi;
+        newmu->biu->th.fid.fid2.daf = cmu->biu->th.fid.fid0.daf;
+        newmu->biu->th.fid.fid2.oaf = cmu->biu->th.fid.fid0.oaf;
+        newmu->biu->th.fid.fid2.snf = cmu->biu->th.fid.fid0.snf;
+
+	sna_pc_enqueuer(newmu);
+
+	return (0);
+}
+
+static int sna_pc_send_mu_to_dlc(struct sna_mu *mu)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->mu = mu;
+	msg->cmd = SNA_PC_TO_DLC;
+//	sna_dlc(msg);
+
+	return (0);
+}
+
+/* Process the four different tx priority queues in a fair way. */
+static void sna_pc_upm_queue_aging_manager(void)
+{
+	unsigned long start_time = jiffies;
+	struct sna_msg_queue *msg;
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_high))
+	{
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_high);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+	}
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_network))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_network);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_medium))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+/*
+		msg = sna_dequeue_msg(&sna_trpr_qs_medium);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+*/
+        }
+
+	while(!sna_msg_queue_empty(&sna_trpr_qs_low))
+        {
+		/* Give chance to other bottom halves to run */
+                if (jiffies - start_time > 1)
+                        goto sna_pc_upm_queue_age_break;
+
+		msg = sna_dequeue_msg(&sna_trpr_qs_low);
+	        sna_pc_send_mu_to_dlc(msg->mu);
+        }
+	return;
+
+sna_pc_upm_queue_age_break:
+	mark_bh(PC_UPM_BM);
+	return;
+}
+#endif
diff -ruN linux-2.4.4/net/sna/sna_ps_conv.c linux/net/sna/sna_ps_conv.c
--- linux-2.4.4/net/sna/sna_ps_conv.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_conv.c	Mon May 14 21:10:59 2001
@@ -0,0 +1,2424 @@
+/* sna_ps_conv.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Conversations (PS.CONV)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static int sna_ps_fmh5_options(struct sk_buff *skb, int tp_len, char *tp, 
+	int luw_len, int nqlu_len, char *nqlu, char *luw_i,
+	char *luw_s, int cc_len, char *cc)
+{
+	struct fmhdr *fm = skb->f.fm;
+	__u8 *ptr = &fm->fm.f5.raw;
+	int len = 0;
+
+	sna_debug(5, "sna_ps_fmh5_options\n");
+
+	/* Transaction program name field */
+	if(tp_len >= 1 && tp_len <= 64)	
+	{
+		memcpy(ptr, &tp_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, tp, tp_len);
+		len += tp_len;
+	}
+	else
+		return (-1);
+
+	/* Logical-Unit-of-Work Identifier field */
+	if((luw_len <= 26 && luw_len >= 10)
+		&& (nqlu_len >= 1 && nqlu_len <= 17))
+	{
+		memcpy(ptr + len, &luw_len, sizeof(__u8));
+		len += 1;
+		memcpy(ptr + len, &nqlu_len, sizeof(__u8));
+		len += 1;
+
+		memcpy(ptr + len, nqlu, nqlu_len);
+		len += nqlu_len;
+
+        	memcpy(ptr + len, luw_i, luw_len - 1);
+		len += luw_len - 1;
+        	memcpy(ptr + len, luw_s, 1);
+		len += 1;
+	}
+	else
+	{
+		if(luw_len != 0 || nqlu_len != 0)
+			return (-1);
+	}
+
+	/* Conversation correlator field */
+	if(cc_len >= 1 && cc_len <= 8)
+	{
+		memcpy(ptr + len, &cc_len, 1);
+		len += 1;
+		memcpy(ptr + len, cc, cc_len);
+		len += cc_len;
+	}
+	else
+	{
+		if(cc_len != 0)
+			return (-1);
+	}
+
+	return (len);
+}
+
+static int sna_ps_build_fmh5(struct sna_tcb *tcb, struct sna_rcb *rcb,
+	struct sk_buff *skb)
+{
+	struct fmhdr *fm = skb->f.fm;
+	char cc[9];
+	int len = 0;
+	unsigned char luw_s;
+
+	sna_debug(5, "sna_ps_build_fmh5\n");
+	fm->type	= FMH_5;
+	fm->fm.f5.cmd	= 0x02FF;
+	fm->fm.f5.vid	= 0;
+	fm->fm.f5.pvid	= 0;
+	fm->fm.f5.spwdi	= 0;
+	fm->fm.f5.pipi	= 0;
+	fm->fm.f5.xaid	= 0;
+	fm->fm.f5.fxct	= 3;
+
+	fm->fm.f5.resrc_type	= 0xD1;
+	fm->fm.f5.sync_level	= 0x01;
+
+	sprintf(cc, "%04X", tcb->tcb_id);
+	luw_s = 9;
+	len = sna_ps_fmh5_options(skb, tcb->tp_name_length, 
+		tcb->tp_name, 10, tcb->partner_lu_name_length, 
+		tcb->partner_lu_name, cc, &luw_s, 8, cc);
+	fm->len = sizeof(struct sna_fmh5) + len;
+	printk("fmh5 len is %d %d\n", fm->len, (sizeof(struct sna_fmh5) + len));
+
+	return (0);
+}
+
+static int sna_ps_rcb_allocated(struct sna_tcb *tcb, struct sna_rcb *rcb)
+{
+	struct sk_buff *skb;
+	int size;
+
+	sna_debug(5, "sna_ps_rcb_allocated\n");
+
+	size = 250;	/* Enough for a FM5 */
+	skb = alloc_skb(size, GFP_ATOMIC);
+	skb_reserve(skb, sizeof(struct snarhdr));
+	skb_reserve(skb, sizeof(struct sna_fid2));
+	skb->f.raw = skb_put(skb,50);
+
+	sna_ps_build_fmh5(tcb, rcb, skb);
+	rcb->l.ps_to_hs.fmh = 1;
+
+	printk("after build_fmh5\n");
+	printk("%d %d\n", rcb->oaf, rcb->daf);
+
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        switch(rcb_allocated->rcode)
+        {
+                case (OK):
+                        allocate_verb->rcode = OK;
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        allocate_verb->resource = rcb->rcb_id;
+                        sna_set_init_rcb(rcb);
+
+                        switch(allocate_verb->rcntrl)
+                        {
+                                case (WHEN_SESSION_ALLOCATED):
+                                        rcb->session_req = ANY;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONWINNER_ALLOCATED):
+                                        rcb->session_req = CONWINNER;
+                                        rcb->conv_group_id = NULL;
+                                        break;
+
+                                case (WHEN_CONV_GROUP_ALLOCATED):
+                                        rcb->session_req = SPECIFIC;
+                                        rcb->conv_group_id = allocate_verb->conversaion_group_id;
+                                        break;
+
+                                case (IMMEDIATE):
+                                        /* Do nothing */
+                                        break;
+                        }
+
+                        if(allocate_verb->rcntrl == IMMEDIATE)
+                        {
+                                sna_create_and_init_limited_mu(rcb, mu);
+                                mu->ps_to_hs.allocate = YES;
+                        }
+                        else
+                                sna_obtain_session_proc(rcb, allocate_verb);
+
+                        if(allocate_verb->rcode == OK)
+                                sna_build_fmh5(mu);
+                        else
+                                fsm_conversation(r, allocation_error_rc, rcb);
+                        break;
+
+                case (UNSUCCESSFUL):
+                        allocate_verb->rcode = UNSUCCESSFUL;
+                        break;
+
+                case (SYNC_LEVEL_NOT_SUPPORTED):
+                        rcb = search_rcb(rcb_allocated->rcb_id);
+                        init_allocated_rcb();
+                        fsm_conversation(r, allocation_error_rc, rcb);
+                        allocate_verb->rcode = ALLOCATION_ERROR;
+                        allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED_BY_LU;                        break;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_allocate(struct sna_tcb *tcb)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_ps_allocate %d %d\n", tcb->oaf, tcb->daf);
+	rcb_id = sna_rm_allocate_rcb(tcb);
+	rcb = sna_rm_find_rcb_by_id(rcb_id);
+	if(rcb == NULL)
+		return (-1);
+
+	sna_debug(5, "now in ps alloc %d %d\n", rcb->oaf, rcb->daf);
+	sna_ps_rcb_allocated(tcb, rcb);
+
+	return (0);
+}
+
+static int sna_ps_send_data_buffer_management(struct sk_buff *skb, 
+	struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "sna_ps_send_data_buffer_management\n");
+	rcb = sna_rm_find_rcb_by_id(tcb->rcb_id);
+	if(rcb == NULL)
+	{
+		sna_debug(5, "no rcb located\n");
+		return (-1);
+	}
+	memset(&rcb->l.ps_to_hs, 0, sizeof(struct sna_ps_to_hs));
+
+	sna_hs_process_lu_lu_session(SNA_PS, skb, rcb);
+
+#ifdef NOT
+        mu = get_buf_send_pool();
+        if(mu == NULL)
+                sna_create_and_init_limited_mu(rcb, mu);
+        else
+        {
+                if(mu is full and more data to send)
+                        send_to_hs(mu);
+                sna_create_and_init_limited_mu(rcb, mu);
+        }
+
+        while(data != NULL)
+        {
+                mu = data_up_to_size_of_mu;
+                if(mu is full and more data to send)
+                {
+                        send_to_hs(mu);
+                        if(more data to send)
+                                sna_create_and_init_limited_mu(rcb, mu);
+                }
+                else
+                        save_mu_to_send_later(mu);
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_send_data(struct sna_tcb *tcb)
+{
+        struct sk_buff *skb;
+
+	sna_debug(5, "sna_ps_send_data %d\n", tcb->tcb_id);
+	skb = skb_dequeue(&tcb->transmit_queue);
+        if(skb == NULL)
+	{
+		printk("No more data on tcb transmit queue\n");
+		return (-1);
+	}
+
+	sna_ps_send_data_buffer_management(skb, tcb);
+
+#ifdef NOT
+	struct sna_rcb *rcb;
+
+        rcb = search_rcb(send_data_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                send_data_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                switch(fstate = sm_error_or_failure())
+                {
+                        case (CONV_FAILURE_PROTOCOL_ERROR):
+                        case (CONV_FAILURE_SON):
+                                if(state == CONV_FAILURE_SON)
+                                        send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                                break;
+
+                        case (RCVD_ERROR):
+                                if(mu == NULL)
+                                        sna_create_and_init_limited_mu(rcb, mu);                                mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+                                send_to_hs(mu);
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+                                state = fsm_error_or_failure();
+                                if(state == CONV_FAILURE_SON
+                                        || state == CONV_FAILURE_PROTOCOL_ERROR)                                {
+                                        if(state == CONV_FAILURE_SON)
+                                                send_data_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                        else
+                                                send_data_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                        fsm_conversation(r, resource_failure_rc, rcb);
+                                }
+                                else
+                                        sna_dequeue_fmh7_proc(send_data_verb, rcb);
+                                break;
+
+                        case (NO_REQUESTS):
+                                send_data_verb->rcode = OK;
+                                if(send_data_verb->max_length > 0)
+                                {
+                                        err = process_LL();
+                                        if(err != 0x0001)
+                                                send_data_verb->rcode = PROGRAM_PARAM_CHECK;
+                                        else
+                                                sna_send_data_buffer_management(send_data_verb->data, rcb);
+                                }
+                                break;
+
+                        default:
+                                /* Error */
+                }
+
+                send_data_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+                rcb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+        return (0);
+}
+
+static int sna_ps_rcv_wait(struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_rcv_wait\n");
+
+	/* handle signals */
+        if(signal_pending(current))
+        	return (-ERESTARTSYS);
+
+	if(skb_peek(&tcb->receive_queue) != NULL)
+	{
+		printk("Queue already has data on it, retuning now!\n");
+		return (0);
+	}
+
+	interruptible_sleep_on(&tcb->sleep);
+
+	return (0);
+}
+
+static int sna_ps_rcv_immediate(struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_rcv_immediate %d\n", tcb->tcb_id);
+
+#ifdef NOT
+        struct sna_rcb *rcb;
+
+        rcb = search_rcb(receive_immediate_verb->resource);
+        if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+                receive_immediate_verb->rcode = PROGRAM_STATE_CHECK;
+        else
+        {
+                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                state = fsm_error_or_failure();
+                if(state == RCVD_ERROR)
+                {
+                        if(find_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+                                sna_receive_rm_or_hs_to_ps_records(suspend_list);
+                        if(state == CONV_FAILURE_SON
+                                || state == CONV_FAILURE_PROTOCOL_ERROR)
+                        {
+                                if(state == CONV_FAILURE_SON)
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_RETRY;
+                                else
+                                        receive_immediate_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+                                fsm_conversation(r, resource_failure_rc, rcb);
+                        }
+                        else
+                                sna_dequeue_fmh7_proc(receive_immediate_verb, rcb);
+                }
+                else
+                {
+                        fsm_conversation(s, receive_immediate, rcb);
+                        rcb->post_conditions.max_length = receive_immediate_verb->max_length;
+                        rcb->post_conditions.fill = receive_immediate_verb->fill;
+                        receive_immediate_verb->data = NULL;
+                        sna_perform_receive_proc(rcv, receive_immediate_verb);
+                        fsm_post(receive_immediate);
+                }
+
+                receive_immediate_verb->max_length = length_data_returned;
+                receive_immediate_verb->rq_to_send_rcvd = NO;
+        }
+#endif
+
+	return (0);
+}
+
+int sna_ps_conv(int verb, struct sna_tcb *tcb)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_ps_conv\n");
+        switch(verb)
+        {
+                case (ALLOCATE):
+                        err = sna_ps_allocate(tcb);
+                        break;
+
+#ifdef NOT
+		case (CONFIRM):
+                        sna_confirm_proc(confirm_verb);
+                        break;
+
+                case (TEST):
+                        sna_test_proc(test_verb);
+                        break;
+
+                case (CONFIRMED):
+                        sna_confirmed_proc(confirmed_verb);
+                        break;
+
+                case (DEALLOCATE):
+                        sna_deallocate_proc(deallocate_verb);
+                        break;
+
+                case (FLUSH):
+                        sna_flush_proc(flush_verb);
+                        break;
+
+                case (GET_ATTRIBUTES):
+                        sna_get_attributes_proc(get_attributes_verb);
+                        break;
+
+                case (POST_ON_RECEIPT):
+                        sna_post_on_receipt_proc(post_on_receipt_verb);
+                        break;
+
+                case (SEND_ERROR):
+                        sna_send_error_proc(send_error_verb);
+                        break;
+
+		case (PREPARE_TO_RECEIVE):
+                        sna_prepare_to_receive_proc(prepare_to_receive_verb);
+                        break;
+
+                case (REQUEST_TO_SEND):
+                        sna_request_to_send_proc(request_to_send);
+                        break;
+#endif
+		case (RECEIVE_AND_WAIT):
+			err = sna_ps_rcv_wait(tcb);
+			break;
+
+		case (RECEIVE_IMMEDIATE):
+			err = sna_ps_rcv_immediate(tcb);
+                        break;
+
+                case (SEND_DATA):
+                        err = sna_ps_send_data(tcb);
+                        break;
+
+                default:
+                        return (-EINVAL);
+        }
+
+        return (err);
+}
+
+#ifdef NOT
+
+static int sna_confirm_proc(struct sna_confirm_verb *confirm_verb)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirm_verb->resource);
+	if(rcb->sync_level == NONE || send data != logical bounds)
+	{
+		if(rcb->sync_level == NONE)
+			confirm_verb->rcode = PROGRAM_PARAM_CHECK;
+		else
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		if(fsm_conversation(s, confirm, rcb) cause state check)
+			confirm_verb->rcode = PROGRAM_STATE_CHECK;
+		else
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			switch(fsm_error_or_failure())
+			{
+				case (CONV_FAILURE_PROTOCOL_ERROR):
+					confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (CONV_FAILURE_SON):
+					confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+					break;
+
+				case (RCVD_ERROR):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+					state = fsm_error_or_failure();
+					if(state == CONV_FAILURE_SON
+						|| state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						if(state == CONV_FAILURE_SON)
+							confirm_verb->rcode = RESOURCE_FAILURE_RETRY;
+						else
+							confirm_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+					}
+					else
+						sna_dequeue_fmh7_proc(confirm_verb, rcb);
+					break;
+
+				case (NO_REQUESTS):
+					sna_complete_confirm_proc(confirm_verb, rcb);
+			}
+
+		confirm_verb->request_to_send_received = rcb->rq_to_send_rcvd;
+		rcb->request_to_send_received = NO;
+	}
+
+	return (0);
+}
+
+static int sna_comfirmed_proc(struct sna_confirmed_verb *confirmed_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(confirmed->resource);
+	if(fsm_conversation(s, confirmed, rcb) > cause state_condition)
+	{
+		confirmed_verb->rcode = PROGRAM_STATE_CHECK;
+	{
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(fsm_error_or_failure())
+		{
+			case (NO_REQUESTS):
+				sna_send_confirmed_proc(rcb);
+				break;
+
+			case (RCVD_ERROR):
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				break;
+
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				/* Do nothing */
+				break;
+		}
+
+		fsm_conversation(s, confirmed, rcb);
+		confirmed_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_proc(struct sna_deallocate_verb *deallocate_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(deallocate_verb->resource);
+	switch(deallocate_verb->type)
+	{
+		case (FLUSH):
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == NONE)
+			{
+				if(fsm_conversatio(s, deallocate_flush, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					deallocate_flush_proc(deallocate_verb, rcb);
+			}
+			break;
+
+		case (CONFIRM):
+			if(fsm_conversation(s, deallocate_confirm, rcb) > state_check)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				if(rcb->sync_level == CONFIRM
+					|| rcb->sync_level == SYNCPT)
+				{
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				}
+				else
+					deallocate_verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			break;
+
+		case (SYNC_LEVEL):
+			if(rcb->sync_level == CONFIRM)
+			{
+				if(fsm_conversation(s, deallocate_confirm_rc, rcb) > state_condition)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+					sna_deallocate_confirm_proc(deallocate_verb, rcb);
+				break;
+			}
+
+			if(rcb->sync_level == SYNCPT)
+			{
+				if(fsm_conversation(s, deallocate_defer, rcb) > state_condiation)
+				{
+					deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(tp == logical_bounds())
+					{
+						fsm_conversation(s, deallocate_defer, rcb);
+						deallocate_verb->rcode = OK;
+					}
+					else
+						deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+
+				break;
+			}
+
+		case (ABEND_PROG):
+		case (ABEND_SVC):
+		case (ABEND_TIMER):
+			if(fsm_conversation(s, deallocate_abend, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+				sna_deallocate_abend_proc(deallocate_verbm rcb);
+			break;
+
+		case (LOCAL):
+			if(fsm_conversation(s, deallocate_local, rcb) > state_condition)
+			{
+				deallocate_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				deallocate_verb->rcode = OK;
+				fsm_conversation(s, deallocate_local, rcb);
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_flush_proc(struct sna_flush_verb *flush_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	rcb = search_rcb(flush_verb->resource);
+	if(fsm_conversation(s, flush, rcb) > state_condition)
+		flush_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			switch(fsm_conversation())
+			{
+				case (SEND_STATE):
+					if(mu != NULL)
+						send_to_hs(mu);
+					break;
+
+				case (PREP_TO_RCV_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+					send_to_hs(mu);
+					break;
+
+				case (DEALL_DEFER):
+					if(mu == NULL)
+						sna_create_and_init_limited_mu(rcb, mu);
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					send_to_hs(mu);
+					break;
+
+			}
+
+			if(fsm_conversation() == DEALL_DEFER)
+				sna_end_conversation_proc(rcb);
+			fsm_conversation(s, flush, rcb);
+		}
+
+		flush_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_get_attributes_proc(struct sna_get_attributes_verb *get_attributes_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_partner_lu *plu;
+
+	rcb = search_rcb(get_attributes_verb->resources);
+	get_attributes_verb->conversation_group_id = rcb->conversation_group_id;
+	get_attributes_verb->partner_fq_lu_name = plu->fq_lu_name;
+	get_attributes_verb->partner_lu_name = rcb->lu_name;
+	get_attributes_verb->mode_name = rcb->mode_name;
+	get_attributes_verb->sync_level = rcb->sync_level;
+	get_attributes_verb->rcode = OK;
+
+	fsm_conversation(s, get_attributes, rcb);
+
+	return (0);
+}
+
+static int sna_post_on_receipt_proc(struct sna_post_on_receipt_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(post_on_receipt_verb->resource);
+	if(fsm_conversation(s, post_on_receipt, rcb) > state_condition)
+	{
+		post_on_receipt_verb->rcode = PROGRAM_STATE_CHECK;
+	}
+	else
+	{
+		fsm_conversation(s, post_on_receipt, rcb);
+		fsm_post(post_on_receipt);
+		rcb->post_conditions.fill = post_on_receipt_verb->fill;
+		rcb->post_conditions.max_length = post_receipt_verb->max_length;
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		post_on_receipt_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_prepare_to_receive_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(prepare_to_receive_verb->resource);
+	if(tp->data_sent != logical_bounday)
+		prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		switch(prepare_to_receive_verb->type)
+		{
+			case (FLUSH):
+			case (SYNC_LEVEL):
+				if(prepare_to_receive_verb->sync_level == NONE)
+				{
+					if(fsm_conversation(s, prepare_to_receive_flush, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_flush_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+			case (CONFIRM):
+				if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+				{
+					prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+				}
+				else
+				{
+					if(sync_level == CONFIRM
+						|| sync_level == SYNCPT)
+					{
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					}
+					else
+						prepare_to_receive_verb->rcode = PROGRAM_PARAM_CHECK;
+				}
+				break;
+
+			case (SYNC_LEVEL):
+				if(sync_level == CONFIRM)
+				{
+					if(fsm_conversation(s, prepare_to_receive_confirm, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+						sna_prepare_to_receive_confirm_proc(prepare_to_receive_verb, rcb);
+					break;
+				}
+
+				if(sync_level == SYNCPT)
+				{
+					if(fsm_conversation(s, prepare_to_receive_defer, rcb) > state_condition)
+					{
+						prepare_to_receive_verb->rcode = PROGRAM_STATE_CHECK;
+					}
+					else
+					{
+						fsm_conversation(s, prepare_to_receve_defer, rcb);
+						rcb->locks = prepare_to_receive_verb->locks;
+						prepare_to_receive_verb->rcode = OK;
+					}
+
+					break;
+				}
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_receive_and_wait_proc(struct sna_receive_and_wait_verb *receive_and_wait_verb)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	if(fsm_conversation(s, receive_and_wait, rcb) > state_condition)
+		receive_and_wait_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		if(fsm_error_or_failure() == RCVD_ERROR)
+		{
+			if(fsm_conversation() == SEND_STATE)
+			{
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+			}
+
+			if(check_fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+			{
+				sna_receive_rm_or_hs_to_ps_buffer_list(suspend_list);
+			}
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					receive_and_wait_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(receive_and_wait_verb, rcb);
+		}
+		else
+		{
+			fsm_conversation(s, receive_and_wait, rcb);
+			recevie_and_wait_verb->data = NULL;
+			sna_receive_and_test_posting(rcb, receive_and_wait_verb);
+		}
+
+		receive_and_wait_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_request_to_send_proc(struct sna_request_to_send_verb *request_to_send_verb)
+{
+	struct sna_rcb *rcb
+
+	rcb = search_rcb(request_to_send_verb->resource);
+	if(fsm_conversation(s, receive_immediate, rcb) > state_condition)
+		request_to_send_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		state = fsm_error_or_failure();
+		if(state == NO_REQUESTS || state == RCVD_ERROR)
+		{
+			if(rcb->ec_type != DEALLOCATE_FLUSH)
+			{
+				sna_send_request_to_send_proc(rcb);
+				sna_wait_for_rsp_to_rq_to_send_proc(rcb);
+			}
+		}
+		request_to_send_verb->rcode = OK;
+	}
+
+	return (0);
+}
+
+static int sna_send_err_proc(struct sna_send_error_verb *send_error_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(send_error_verb->resource);
+	if(fsm_conversation(s, send_error, rcb) > state_condition)
+		send_error_verb->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+		switch(state = fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+			case (CONV_FAILURE_SON):
+				fsm_conversation(s, send_error, rcb);
+				if(state == CONV_FAILURE_SON)
+					send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (NO_REQUESTS):
+			case (RCVD_ERROR):
+				switch(fsm_conversation())
+				{
+					case (SEND_STATE):
+						sna_send_error_in_send_state(send_error_verb, rcb);
+						break;
+
+					case (RCVD_CONFIRM):
+					case (RCVD_CONFIRM_SEND):
+					case (RCVD_CONFIRM_DEALL):
+						sna_send_error_to_hs_proc(rcb);
+						fsm_conversation(s, send_error, rcb);
+						sna_send_error_done_proc(send_error_verb, rcb);
+						break;
+
+					case (RCV_STATE):
+						sna_send_error_in_receive_state(send_error_verb, rcb);
+						break;
+
+					default:
+						/* Error */
+				}
+			}
+		}
+
+		send_error_verb->rq_to_send_rcvd = rcb->rq_to_send_rcvd;
+		rcb->rq_to_send_rcvd = NO;
+	}
+
+	return (0);
+}
+
+static int sna_test_proc(struct sna_test_verb *test_verb)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(test_verb->resource);
+	test_verb->rcode = OK;
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(test_verb->param)
+	{
+		case (POSTED):
+			if(fsm_conversation(s, test_posted, rcb) > state_condition)
+			{
+				test_verb->rcode = PROGRAM_STATE_CHECK;
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FAILURE_SON):
+						test_verb->rcode = RESOURCE_FAILURE_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (CONV_FAILURE_PROTOCOL_ERROR):
+						test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+						fsm_conversation(r, resource_failure_rc, rcb);
+						break;
+
+					case (RCVD_ERROR):
+						if(fmh7_in_list(rcb->hs_to_ps_buffer_list) == NOT)
+						{
+							sna_receive_rm_or_hs_to_ps_records(suspend_list);
+						}
+						state = fsm_error_or_failure();
+						if(state == CONV_FAILURE_SON
+							|| state == CONV_FAILURE_PROTOCOL_ERROR)
+						{
+							if(state == CONV_FAILURE_SON)
+								test_verb->rcode = RESOURCE_FAILURE_RETRY;
+							else
+								test_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+							fsm_conversation(r, resource_failure_rc, rcb);
+						}
+						else
+							sna_dequeue_fmh7_proc(test_verb, rcb);
+						break;
+
+					case (NO_REQUESTS):
+						sna_test_for_post_statisfied(rcb);
+						switch(fsm_port)
+						{
+							case (PEND_POST):
+								test_verb->rcode = UNSUCCESSFUL;
+								break;
+
+							case (POSTED):
+								if(fmh7 next to process)
+									sna_dequeue_fmh7_proc(test_verb, rcb);
+								else
+									test_verb->subcode = NOT_DATA || DATA;
+						}
+
+						if(fsm_conversation() != END_CONV)
+							fsm_conversation(s, test, rcb);
+						fsm_post(test);
+						break;
+
+					case (REQUEST_TO_SEND_RECEIVED):
+						if(fsm_conversation(s, test_rq_to_send_rcvd, rcb) > state_condition)
+							test_verb->rcode = PROGRAM_STATE_CHECK;
+						else
+						{
+							if(rcb->rq_to_send_rcvd == YES)
+								rcb->rq_to_send_rcvd = NO;
+							else
+								test_verb->rcode = UNSUCCESSFUL;
+							fsm_conversation(s, test_rq_to_send_rcvd, rcv);
+						}
+						break;
+
+					default:
+						/* error */
+				}
+			}
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+
+/************************************************************************
+* Low level procedures							*
+************************************************************************/
+
+static int sna_complete_confirm_proc(struct sna_confirm *confirm, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_MU_BUFF);
+	if(mu == NULL)
+		sna_create_and_init_limited_mu(rcb, mu);
+
+	switch(fsm_conversation())
+	{
+		case (SEND_STATE):
+			mu->ps_to_hs.type = CONFIRM;
+			send_to_hs(mu);
+			break;
+
+		case (PREP_TO_RCV_DEFER):
+			if(rcb->locks == SHORT?)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT;
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+
+			send_to_hs(mu);
+			break;
+
+		case (DEALL_DEFER):
+			mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+			send_to_hs(mu);
+			break;
+
+	}
+
+	fsm_conversation(s, confirm, rcb);
+	sna_wait_for_confirmed_proc(confirm, rcb);
+
+	return (0);
+{
+
+static int sna_complete_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(deallocate->type)
+	{
+		case (ABEND_PROG):
+			sense = 0x08640000;
+			break;
+
+		case (ABEND_SVC):
+			sense = 0x08640001;
+			break;
+
+		case (ABEND_TIMER):
+			sense = 0x08640002;
+			break;
+	}
+
+	mu = bm(GET_SEND_BUF);
+	if(mu != NULL)
+		send_to_hs(mu);
+
+	sna_create_and_init_limited_mu(rcb, mu);
+	if(log_data != NULL)
+	{
+		mu->log_data = log_data;
+		mu->sense = sense;
+
+		err_log_gds = create();
+		sna_send_data_buffer_management(err_log_gds, rcb);
+		Log_err(err_log_gds);
+	}
+	else
+		store_mu(no_log_data);
+
+	mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_conversation_failure_proc(struct sna_conversation_failure *conv_failure)
+{
+	struct sna_rcb *rcb;
+
+	rcb = search_rcb(conv_failure->resource);
+	if(rcb != NULL)
+	{
+		if(conv_failure->reason == PROTOCOL_VIOLATION)
+			fsm_error_or_failure(conv_fail_protocol);
+		else
+			fsm_error_or_failure(conv_fail_son);
+
+		if(fsm_post == PEND_POSTED)
+			fsm_port(post);
+	}
+
+	return (0);
+}
+
+static int sna_create_and_init_limited_mu(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->limit_buf_pool_id, wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, rcb->send_ru_size, wait);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= send_data_record;
+	mu->ps_to_hs.allocate 		= NO;
+	mu->ps_to_hs.fmh 		= NO;
+	mu->ps_to_hs.type 		= FLUSH;
+	mu->dcf 			= (data->size + rh->size);
+
+	return (0);
+}
+
+static int sna_deallocate_abend_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	sna_receive_rm_or_hs_to_ps_records(susped_list);
+
+	state = fsm_error_or_failure();
+	if(state == NO_REQUEST || state == RCVD_ERROR)
+	{
+		switch(fsm_conversation())
+		{
+			case (RCV_STATE):
+				if(DEALLOCATE_FLUSH != received)
+				{
+					sna_send_eror_to_hs_proc(rcb);
+					sna_wait_for_send_error_done_proc(deallocate, rcb);
+				}
+				break;
+
+			case (RCVD_CONFIRM):
+			case (RCVD_CONFIRM_SEND):
+			case (RCVD_CONFIRM_DEALL):
+				sna_send_error_to_hs_proc(rcb);
+				sna_wait_for_send_error_done_proc(deallocate, rcb);
+				break;
+
+			case (SEND_STATE):
+			case (PREP_TO_RCV_DEFER):
+			case (DEALL_DEFER):
+				sna_complete_deallocate_abend_proc(deallocate,rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	deallocate->rcode = OK;
+	sna_fsm_conversation(s, dellocate, rcb);
+	sna_end_conversation_proc(rcb);
+
+	return (0);
+}
+
+static int sna_deallocate_confirm_proc(struct sna_deallocate *deallocate)
+{
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+
+	if(tp->data != at_logical_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		fsm_conversation(s, deallocate_confim, rcb);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (CONV_FAILURE_SON)
+				deallocate->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, RESOURCE_FAILURE_RC, rcb);
+				break;
+
+			case (RCVD_ERROR):
+				if(mu == NULL)
+					sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+				send_to_hs(mu);
+
+				if(fmh7 !in rcb->hs_to_ps_buffer_list)
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				else
+					sna_receive_rm_or_hs_to_ps_records(suspend_list); /* Empty */
+
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON
+					{
+						deallocate->rcode = RESOURCE_FAILURE_RETRY;
+					}
+
+					if(state == CONV_FAILURE_PROTOCOL_ERROR)
+					{
+						deallocate->rcode = RESOURCE_FAILURE_NO_RETRY;
+					}
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_deqeue_fmh7_proc(deallocate, rcb);
+
+			case (NO_REQUESTS):
+				if(mu == NULL)
+					mu = sna_create_and_init_limited_mu(rcb, mu);
+				mu->ps_to_hs.type = DEALLOCATE_CONFIRM;
+				sna_wait_for_confirmed_proc(deallocate, rcb);
+				break;
+
+			default:
+				/* Error */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_deallocate_flush_proc(struct sna_deallocate *deallocate, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(tp->data != logical_record_boundary)
+		deallocate->rcode = PROGRAM_STATE_CHECK;
+	else
+	{
+		sna_receive_rm_or_hs_to_ps_records(suspends_list);
+		state = fsm_error_or_failure();
+		if(state == RCVD_ERROR || state == NO_REQUESTS)
+		{
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+		}
+
+		deallocate->rcode = OK;
+		fsm_conversation(s, deallocate_flush, rcb);
+		sna_end_conversation_proc(rcb);
+	}
+
+	return (0);
+}
+
+static int sna_dequeue_fmh7_proc(*tp, struct sna_rcb *rcb)
+{
+
+	fsm_post(receive_immediate);
+	if(rcb->hs_to_ps_buffer_list == fmh-7)
+	{
+		remove_first_from_list(rcb->hs_to_ps_buffer_list);
+		sna_process_fmh7_proc(rcb, tp);
+	}
+	else
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+		tp->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_end_conversation_proc(struct sna_rcb *rcb, struct sna_rcb_deallocated *rcb_deallocated)
+{
+	struct sna_mu *mu;
+	struct sna_deallocate_rcb *deallocate_rcb;
+
+	for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		bm(FREE, mu);
+
+	if(rcb->send_buffer != NULL)
+		bm(FREE, rcb->send_buffer);
+
+	deallocate_rcb = (struct sna_deallocate_rcb *)kmalloc(sizeof(deallocate_rcb), GFP_ATOMIC);
+	rcb_deallocated = sna_wait_for_rm_reply(rcb);
+	destroy(rcb_deallocated);
+
+	return (0);
+}
+
+static int sna_get_dallocate_from_hs(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	chain_type = sna_get_end_chain_from_hs(rcb);
+	if(chain_type == DEALLOCATE_FLUSH || chain_type == DEALLOCATE_CONFIRM)
+		do_nothing(); ??
+
+	state = fsm_error_or_failure();
+	if(state == CONV_FAILURE_PROTOCOL_ERROR || state == CONV_FAILURE_SON)
+		do_nothing(); ??
+
+	/* Otherwise */
+	sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+	tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+	rcb->fsm_conversation(r, resource_failure_rc, rcb);
+
+	return (0);
+}
+
+static int sna_get_end_chain_from_hs(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(end_of_chain != recieved_for_this_conv)
+	{
+		for(mu = rcb->hs_to_ps_buffer_list; mu != NULL; mu = mu->next)
+		{
+			if(mu->hs_to_ps.type == END_OF_CHAIN)
+				type = mu;
+
+			bm(FREE, mu);
+		}
+	}
+
+	while(end_of_chain != recieved)
+	{
+		record = grab_record(rcb);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				destroy(record);
+				break;
+
+			case (MU):
+				if(mu->hs_to_ps.type == END_OF_CHAIN)
+					type = mu;
+				bm(FREE, mu);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	/* Update rcb to show receipt of eoc type */
+	rcb->end_of_chain = eoc;
+
+	return (0);
+}
+
+static int sna_obtain_session_proc(struct sna_rcb *rcb, sna_allocate_verb *allocate_verb, __u8 session_req, __u8 conv_group_id)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *session_allocated;
+
+	get_session = (struct sna_get_session *)kmalloc(sizeof(get_session), GFP_ATOMIC);
+	get_session->tcb_id 	= rcb->tcb_id;
+	get_session->rcb_id 	= rcb->rcb_id;
+	get_session->type	= session_req;
+	get_session->conv_group_id = conv_group_id;
+	send_to_rm(get_session);
+
+	session_allocated = sna_wait_for_rm_reply();
+	switch(session_allocated->rcode)
+	{
+		case (OK):
+			rcb->send_ru_size = session_allocated->send_ru_size;
+			rcb->limit_buf_pool_id = session_allocated->limit_buf_pool_id;
+			rcb->perm_buf_pool_id = session_allocated->perm_buf_pool_id;
+			sna_create_and_init_limited_mu(rcb, mu);
+			if(session_allocated->in_conversation == YES)
+				mu->ps_to_hs.allocate = NO;
+			else
+				mu->ps_to_hs.allocate = YES;
+			break;
+
+		default:
+			allocate_verb->rcode = ALLOCATION_ERROR;
+			switch(sesion_allocated->rcode);
+			{
+				case (UNSUCCESSFUL_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_RETRY;
+					break;
+
+				case (UNSUCCESSFUL_NO_RETRY):
+					allocate_verb->subcode = ALLOCATION_FAILURE_NO_RETRY;
+					break;
+
+				case (SYNC_LEVEL_NOT_SUPPORTED):
+					allocate_verb->subcode = SYNC_LEVEL_NOT_SUPPORTED;
+					break;
+			}
+			break;
+	}
+
+	destroy(session_allocated);
+
+	return (0);
+}
+
+static int sna_perform_receive_ec_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	if(tp->data_sent != logical_record_boundary)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	if(rcb->sync_level == NONE
+		&& rcb->ec_type == CONFIRM
+		|| rcb->ec_type == PREPARE_TO_RCV_CONFIRM
+		|| rcb->ec_type == DEALLOCATE_CONFIRM)
+	{
+		sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+		receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+	}
+
+	/* Otherwise */
+	switch(rcb->ec_type)
+	{
+		case (CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM;
+			fsm_conversation(r, confirm_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_SEND;
+			fsm_conversation(r, confirm_send_indicator, rcb);
+			break;
+
+		case (PREPARE_TO_RCV_FLUSH):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = SEND;
+			fsm_conversation(r, send_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_CONFIRM):
+			receive_verb->rcode = OK;
+			receive_verb->what_received = CONFIRM_DEALLOCATE;
+			fsm_conversation(r, confirm_deallocate_indicator, rcb);
+			break;
+
+		case (DEALLOCATE_FLUSH):
+			receive_verb->rcode = DEALLOCATE_NORMAL;
+			fsm_conversation(r, deallocate_normal_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perform_receive_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(mu_ptr != NULL || rcb->ec_indicator != NOT_END_OF_DATA)
+	{
+		for(mu = mu_ptr; (mu != NULL && post_not_satisfied); mu = mu->next)
+		{
+			if(mu->type == FMH_7)
+			{
+				if(no_data_copied_to_pass_to_tp)
+				{
+					sna_process_fmh7_proc(rcb,receive_verb);
+					continue;
+				}
+			}
+			else
+			{
+				if(mu->end_of_data != TRUE)
+					sna_process_data_proc(rcb, receive_verb, DATA_NEEDED);
+				else	/* All data received */
+				{
+					if(mu->hs_to_ps.type == NOT_END_OF_DATA)
+					{
+						bm(FREE, mu);
+						continue;
+					}
+					else
+					{
+						ec_received_post_ok;
+						break;
+					}
+				}
+			}
+		}
+
+		if(no_data_returned && fmh7 != processed
+			&& rcb->ec_type != NOT_END_OF_DATA)
+		{
+			sna_preform_receive_ec_processing(rcb, receive_verb);
+			return_to_tp (rcb->ec_type);
+		}
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (CONV_FAILURE_SON):
+				receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			default:
+				if(receive_verb->type == RECEIVE_IMMEDIATE)
+					receive_verb->rcode = UNSUCCESSFUL;
+				else
+					receive_verb->rcode = OK;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_perform_more_rcv_processing(struct sna_rcb *rcb, struct sna_receive_verb *receive_verb)
+{
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		default:
+			if(receive_verb->type == RECEIVE_IMMEDIATE)
+				receive_verb->rcode = UNSUCCESSFUL;
+			else
+				receive_verb->rcode = OK;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_confirm_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	fsm_conversation(s, prepare_to_receive_confirm, rcb);
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_SON):
+			prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (RCVD_ERROR):
+			if(mu == NULL)
+				sna_create_and_init_limited_mu(rcb, mu);
+			mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+			state = fsm_error_or_failure();
+			if(state == CONV_FAILURE_SON
+				|| state == CONV_FALIURE_PROTOCOL_ERROR)
+			{
+				if(state == CONV_FAILURE_SON)
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					prepare_to_receive_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+			}
+			else
+				sna_dequeue_fmh7_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		case (NO_REQUESTS):
+			if(rcb->locks == SHORT)
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_SHORT
+			else
+				mu->ps_to_hs.type = PREPARE_TO_RCV_CONFIRM_LONG;
+			sna_wait_for_confirmed_proc(prepare_to_receive_verb, rcb);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (0);
+}
+
+static int sna_perpare_to_receive_flush_proc(struct sna_prepare_to_receive_verb *prepare_to_receive_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	sna_receive_rm_or_hs_to_ps_records(suspend_list);
+	state = fsm_error_or_failure();
+	if(state == RCVD_ERROR || state == NO_REQUESTS)
+	{
+		if(mu == NULL)
+			sna_create_and_init_limited_mu(rcb, mu);
+		mu->ps_to_hs.type = PREPARE_TO_RECEIVE_FLUSH;
+		send_to_hs(mu);
+	}
+
+	prepare_to_receive_verb->rcode = OK;
+	fsm_conversation(s, prepare_to_receive_flush, rcb);
+
+	return (0);
+}
+
+static int sna_process_data_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_receive_verb *receive_verb)
+{
+
+	return 0;
+}
+
+static int sna_process_fmh7_log_data_proc(struct sna_rcb *rcb, __u8 fmh_sense_data, struct sna_tp_verb *tp_verb)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	/* Get log data */
+	receive_and_wait = (struct sna_receive_and_wait *)kmalloc(sizeof(receive_and_wait), GFP_ATOMIC);
+	receive_and_wait->resource 	= rcb->rcb_id;
+	receive_and_wait->fill 		= LL;
+	receive_and_wait->max_length 	= 0x7FFF;
+	receive_and_wait->data 		= NULL;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	if(receive_and_wait->rcode == OK
+		&& receive_and_wait->what_received == DATA_COMPLETE)
+	{
+		if(gds_id == 0x12E1)
+			Log_err();
+		else
+		{
+			Log_err();
+			sna_ps_protocol_error(rcb->hs_id, 0x1008201D);
+			fsm_error_or_failure_signal(CONV_FAIL_PROTOCOL);
+		}
+	}
+	else
+	{
+		if(receive_and_wait->rcode == RESOURCE_FAILURE_RETRY)
+			Log_err(son);
+		else
+			Log_err(proto);
+	}
+
+	destroy(receive_and_wait);
+
+	/* Set the states of the FSMs */
+	if(fmh_sense_data == 0x08640000
+		|| fmh_sense_data == 0x08640001
+		|| fmh_sense_data == 0x08640002)
+	{
+		if(fsm_error_or_failure() == NO_REQUESTS)
+			sna_get_deallocate_from_hs(tp_verb, rcb);
+		sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+	}
+	else
+	{
+		switch(fsm_error_or_failure())
+		{
+			case (CONV_FAILURE_PROTOCOL_ERROR):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+				break;
+
+			case (CONV_FAILURE_SON):
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+				fsm_error_or_failure(CONV_FAIL_SON);
+				break;
+
+			default:
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+		}
+	}
+
+	sna_set_rcb_rcv_defaults(rcb);
+
+	return (0);
+}
+
+static int sna_process_fmh7_proc(struct sna_rcb *rcb, struct sna_mu *mu, struct sna_tp_verb *tp_verb)
+{
+	struct sna_mu *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	/* Validate FMH-7 */
+	err = sna_check_fmh7(mu);
+	if(err)
+	{
+		sna_ps_protocol_error(rcb->hs_id, err);
+		tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+		fsm_conversation(r, resource_failure_rc, rcb);
+		rcb->post_condiations.max_length = 0;
+	}
+	else
+	{
+		sna_set_init_rcb_rcv(rcb);
+		if(mu->data_received == ALL)
+		{
+			/* Remember if fmh7 has sense and log data */
+			type = mu->ec_type;
+			bm(FREE, mu);
+		}
+		mu_ptr = rcb->hs_to_ps_buffer_list;
+
+		/* Get log data if present */
+		if(fmh7->log_data == TRUE)
+		{
+			sna_process_fmh7_log_data_proc(rcb, fmh7_sense_data, tp_verb);
+		}
+		else
+		{
+			if(fmh_sense_data == 0x08640000
+				|| fmh_sense_data == 0x08640001
+				|| fmh_sense_data == 0x08640002)
+			{
+				sna_get_deallocate_from_hs(tp_verb, rcb);
+				sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+			}
+			else
+			{
+				switch(fsm_error_or_failure())
+				{
+					case (CONV_FALIURE_PROTOCOL_ERROR):
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_PROTOCOL);
+						break;
+
+					case (CONV_FAILURE_SON):
+						sna_set_fmh7_rcb(rcb, fmh7_sense_data, tp_verb);
+						fsm_error_or_failure(CONV_FAIL_SON);
+						break;
+
+					default:
+						sna_set_fmh7_rc(rcb, fmh7_sense_data, tp_verb);
+						break;
+				}
+			}
+		}
+	}
+	
+	return (0);
+}
+
+static int sna_receive_and_test_posting(struct sna_rcb *rcb, struct sna_receive_and_wait *receive_and_wait)
+{
+	/* Test post */
+	fsm_post(POST_ON_RECEIPT);
+	rcb->post_conditions.fill = receive_and_wait->fill;
+	rcb->post_conditions.max_length = receive_and_wait->max_length;
+	sna_test_for_post_satisfied(rcb);
+	sna_perform_receive_processing(rcb, receive_and_wait);
+
+	if(fsm_post() == PEND_POSTED)	/* Remove if, its not needed, IBM... */
+	{
+		while(fsm_port() == PEND_POST)
+		{
+			sna_receive_rm_or_hs_to_ps_records(suspend_list);
+			sna_test_for_post_satisfied(rcb);
+			sna_performa_receive_processing(rcb, receive_and_wait);
+		}
+	}
+
+	sna_receive_and_wait->max_length = tp->data_returned;
+	fsm_post(RECEIVE_IMMEDIATE);
+
+	return (0);
+}
+
+static int sna_receive_rm_or_hs_to_ps_records(struct sna_suspend_list *suspend_list)
+{
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+
+	more_records = 1;
+	if(suspend_list == NULL)
+		suspend_flag = NO_SUSPEND;
+	else
+		suspend_flag = SUSPEND;
+
+	while(more_records)
+	{
+		/* Shrink */
+		if(suspend_flag == SUSPEND)
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+			{
+				mu = find_record_hs_to_ps_q();
+				if(mu == NULL)
+					mu = find_record_suspend();
+			}
+		}
+		else	/* NO_SUSPEND */
+		{
+			mu = find_record_rm_to_ps_q();
+			if(mu == NULL)
+				mu = find_record_hs_to_ps_q();
+		}
+
+		if(mu != NULL)
+		{
+			if(mu->type == CONVERSATION_FAILURE)
+			{
+				dequeue_rm_to_ps_q(mu);
+				rcb = search_rcb(mu->rcb_id);
+				if(rcb != NULL)
+					sna_conversation_failure_proc(mu);
+				else
+					destroy(mu);
+			}
+			else
+			{
+				dequeue_hs_to_ps_q(mu);
+				switch(mu->type)
+				{
+					case (REQUEST_TO_SEND):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							rcb->rq_to_send_rcvd = YES;
+						destroy(mu);
+						break;
+
+					case (RECEIVE_ERROR):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+							fsm_error_or_failure(RECEIVE_ERROR, rcb);
+						destroy(mu);
+						break;
+
+					case (RSP_TO_REQUEST_TO_SEND):
+					case (CONFIRMED):
+						destroy(mu);
+						break;
+
+					case (MU):
+						rcb = search_rcb(mu->bracket_id);
+						if(rcb != NULL)
+						{
+							if(fsm_conversation() == RCB_STATE || fsm_error_or_failure() == RCVD_ERROR)
+							{
+								queue_hs_to_ps_buffer_list(rcb->hs_to_ps_buffer_list, mu);
+							}
+							else
+							{
+								bm(FREE, mu);
+								if(fsm_conversation() == END_CONV)
+								{
+									sna_ps_protocol_error(rcb->hs_id, 0x20040000);
+								}
+							}
+						}
+						else
+							bm(FREE, mu);
+						break;
+				}
+			}
+
+			if(suspend_flag == SUSPEND 
+				&& found_rcb_id_in_suspend == TRUE)
+			{
+				suspend_flag = NO_SUSPEND;
+			}
+		}
+		else
+			more_records = 0;
+	}
+
+	return (0);
+}
+
+static int sna_send_confirmed_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, rcb->perm_buf_pool_id, no_wait);
+	if(mu == NULL)
+		mu = bm(GET_BUFFER, demand, size, no_wait);
+
+	mu->header_type = PS_TO_HS;
+	mu->ps_to_hs.bracket_id = rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant = CONFIRMED;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_err_done_proc(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	switch(send_error_verb->type)
+	{
+		case (PROG):
+			state = fsm_conversation();
+			if(state == SEND_STATE)
+			{
+				if(data sent by tp is at logical bounds)
+					sense = 0x08890000;
+				else
+					sense = 0x08890001;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		case (SVC):
+			state = fsm_conversation();
+
+			if(state == SEND_STATE)
+			{
+				if(data is at logical bounds)
+					sense = 0x08890100;
+				else
+					sense = 0x08890101;
+				break;
+			}
+
+			if(state == RCV_STATE
+				|| state == RCVD_CONFIRM
+				|| state == RCVD_CONFIRM_SEND
+				|| state == RCVD_CONFIRM_DEALL)
+			{
+				sense = 0x08890100;
+				break;
+			}
+
+		default:
+			/* Error */
+	}
+
+	if(send_error_verb->log_data != NULL)
+	{
+		create_fmh7_with_log_data();
+		create_log_gds(log_data);
+		sna_send_data_buffer_management(log_gds, rcb);
+		Log_err(sys);
+	}
+	else
+		create_fmh7_with_log_data();
+
+	if(FLUSH == NOT_IMPLEMENTED || fmh7->flush_immediately == TRUE)
+		send_to_hs(mu);
+
+	send_error_verb->rcode = OK;
+
+	return (0);
+}
+
+static int sna_send_err_in_receive_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu, *mu_ptr;
+
+	mu_ptr = rcb->hs_to_ps_buffer_list;
+
+	if(rcb->ec_type == DEALLOCATE_FLUSH)
+	{
+		if(mu_ptr != NULL)
+			bm(FREE, mu_ptr);
+		send_error_verb->rcode = DEALLOCATE_NORMAL;
+		fsm_conversation(r, deallocate_normal_rc, rcb);
+	}
+	else
+	{
+		sna_send_error_to_hs_proc(rcb);
+		sna_wait_for_send_error_done_proc(send_error_verb, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_send_err_in_send_state(struct sna_send_error_verb *send_error_verb, struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	if(fsm_error_or_failure() == NO_REQUESTS)
+	{
+		if(send_mu_buffer_present)
+			send_to_hs(mu);
+		fsm_conversation(s, send_error, rcb);
+		sna_send_error_done_proc(send_error_verb, rcb);
+	}
+	else
+	{
+		mu->ps_to_hs.type = PREPARE_TO_RCV_FLUSH;
+		send_to_hs(mu);
+		sna_receive_rm_or_hs_to_ps_records(suspend_list);
+
+		state = fsm_error_or_failure();
+		if(state == CONV_FAILURE_SON 
+			|| state == CONV_FAILURE_PROTOCOL_ERROR)
+		{
+			if(state == CONV_FAILURE_SON)
+				send_error_verb->rcode = RESOURCE_FAILURE_RETRY;
+			else
+				send_error_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+		}
+		else
+			sna_dequeue_fmh7_proc(send_error_verb, rcb);
+	}
+
+	set_rcb_send_fields_to_init(rcb);
+
+	return (0);
+}
+
+static int sna_send_err_to_hs_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant 	= SEND_ERROR;	/* verb?? */
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_send_request_to_send_proc(struct sna_rcb *rcb)
+{
+	struct sna_mu *mu;
+
+	mu = bm(GET_BUFFER, size);
+
+	mu->header_type			= PS_TO_HS;
+	mu->ps_to_hs.bracket_id		= rcb->bracket_id;
+	mu->ps_to_hs.ps_to_hs_variant	= REQUEST_TO_SEND;
+
+	send_to_hs(mu);
+
+	return (0);
+}
+
+static int sna_set_fmh7_rc(struct sna_rcb *rcb, __u8 fmh7_sense, struct sna_tp_verb *tp_verb)
+{
+	switch(fmh7_sense)
+	{
+		case (ALLOCATION_ERROR):
+			get_deallocate(rcb->hs_to_ps_buffer_list);
+			if(fsm_conversation() == END_CONV)
+			{
+				tp_verb->rcode = corresponding_rcode(END_CONV);?
+				fsm_conversation(r, allocation_error, rcb);
+			}
+			break;
+
+		case (RESOURCE_FAILURE_NO_RETRY):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+
+		case (PROG_ERROR_NO_TRUNC):
+		case (PROG_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = PROG_ERROR_PURGING;
+			else
+				tp_verb->rcode = PROG_ERROR_NO_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (PROG_ERROR_TRUNC):
+			tp_verb->rcode = PROG_ERROR_TRUNC;
+			fsm_conversation(r, program_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_NO_TRUNC):
+		case (SVC_ERROR_PURGING):
+			if(fsm_error_or_failure() == RCVD_ERROR)
+				tp_verb->rcode = SVC_ERROR_PURGING;
+			else
+				tp_verb->rcode = SVC_ERROR_NO_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (SVC_ERROR_TRUNC):
+			tp_verb->rcode = SVC_ERROR_TRUNC;
+			fsm_conversation(r, service_error_rc, rcb);
+			break;
+
+		case (DEALLOCATE_ABEND):
+			tp_verb->rcode = many_diff_choices();
+			fsm_conversation(r, deallocate_abend_rc, rcb);
+			break;
+
+		default:
+			ps_protocol_error(rcb->hs_id, fmh7_sense);
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_test_for_post_satisfied(struct sna_rcb *rcb)
+{
+
+	return 0;
+}
+
+static int sna_wait_for_confirmed_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+	struct sna_confirmed *confirmed;
+
+	while((confirmed = recv_confirmed()) == NULL)
+	{
+		record = get_record(1st);
+		switch(record->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(record);
+				if(fsm_error_or_failure() == CONV_FAILURE_SON)
+					tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+				else
+					tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+				fsm_conversation(r, resource_failure_rc, rcb);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(record);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				while(rcb->hs_to_ps_buffer_list == NULL
+					&& fsm_error_or_failure() == RCVD_ERROR)
+				{
+					sna_receive_rm_or_hs_to_ps_records(suspend_list);
+				}
+
+				state = fsm_error_or_failure();
+				if(state == CONV_FAILURE_SON
+					|| state == CONV_FAILURE_PROTOCOL_ERROR)
+				{
+					if(state == CONV_FAILURE_SON)
+						tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+					else
+						tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+					fsm_conversation(r, resource_failure_rc, rcb);
+				}
+				else
+					sna_dequeue_fmh7_proc(confirm_verb, rcb);
+				destroy(record);
+				break;
+
+			case (CONFIRMED):
+				tp_verb->rcode = OK;
+				if(fsm_conversation() == PEND_DEALL)
+				{
+					fsm_conversation(r, DEALLOCATION_INDICATOR, rcb);
+					sna_end_conversation_proc(rcb);
+				}
+				destroy(record);
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, 0x10010000);
+				fsm_conversation(r, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_rm_reply(struct sna_mu *mu)
+{
+	mu = NULL
+
+	while(mu == NULL)
+	{
+		sleep()
+		mu = get_record();
+
+		if(mu->type == CONVERSATION_FAILURE)
+			sna_conversation_failure_proc(mu);
+		else
+			return (0);
+	}	
+
+	return (0);
+}
+
+static int sna_wait_for_rsp_to_rq_to_send_proc(struct sna_rcb *rcb, struct sna_hs_to_ps_records *hs_to_ps_records)
+{
+	struct sna_mu *mu = NULL;
+
+	while(mu == NULL)
+	{
+		mu = get_record(1st);
+		switch(mu->type)
+		{
+			case (CONVERSATION_FAILURE):
+				sna_conversation_failure_proc(mu);
+				break;
+
+			case (REQUEST_TO_SEND):
+				rcb->rq_to_send_rcvd = YES;
+				destroy(mu);
+				break;
+
+			case (RECEIVE_ERROR):
+				fsm_error_or_failure(receive_error, rcb);
+				destroy(mu);
+				break;
+
+			case (RSP_TO_REQUEST_TO_SEND):
+				destroy(mu);
+				break;
+
+			case (MU):
+				queue_mu(rcb->hs_to_ps_buffer_list, mu);
+				queue_tail(hs_to_ps_buffer_list, mu);
+				if(rcb->ec_type == DEALLOCATE_FLUSH)
+					break;
+				break;
+
+			default:
+				sna_ps_protocol_error(rcb->hs_id, fmh7_sense);
+				fsm_conversation(s, confirmed, rcb);
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_wait_for_send_err_done_proc(struct sna_tp_verb *tp_verb, struct sna_rcb *rcb)
+{
+
+	sna_get_end_chain_from_hs(rcb);
+
+	switch(fsm_error_or_failure())
+	{
+		case (CONV_FAILURE_SON):
+			tp_verb->rcode = RESOURCE_FAILURE_RETRY;
+			fsm_conversation(s, resource_failure_rc, rcb);
+			break;
+
+		case (CONV_FAILURE_PROTOCOL_ERROR):
+			tp_verb->rcode = RESOURCE_FAILURE_NO_RETRY;
+			fsm_conversation(r, resource_failure_rc, rcb);
+
+		default:
+			switch(rcb->ec_type)
+			{
+				case (DEALLOCATE_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						tp_verb->rcode = DEALLOCATE_NORMAL;
+						fsm_conversation(r, deallocate_normal_rc, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						tp_verb->rcode = OK;
+						break;
+					}
+
+					break;
+
+				case (DEALLOCATE_CONFIRM):
+				case (CONFIRM):
+				case (PREPARE_TO_RCV_CONFIRM):
+				case (PREPARE_TO_RCV_FLUSH):
+					if(verb is SEND_ERROR)
+					{
+						purge_ec_type();
+						sna_send_error_done_proc(send_error, rcb);
+						break;
+					}
+
+					if(verb is DEALLOCATE)
+					{
+						sna_complete_deallocate_abend_proc(deallocate, rcb);
+						break;
+					}
+
+					break;
+			}
+	}
+
+	fsm_error_or_failure(reset);
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_ps_copr.c linux/net/sna/sna_ps_copr.c
--- linux-2.4.4/net/sna/sna_ps_copr.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_copr.c	Mon May 14 21:11:19 2001
@@ -0,0 +1,482 @@
+/* sna_ps_copr.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Control Operator (PS.CORP)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_copr(int verb, struct sna_tcb *tcb)
+{
+#ifdef NOT
+	switch(cnos_verb->type)
+	{
+		case (INITIALIZE_SESSION_LIMIT):
+			sna_init_session_limit_proc(cnos_verb);
+			break;
+
+		case (CHANGE_SESSION_LIMIT):
+			sna_change_sesion_limit_proc(cnos_verb);
+			break;
+
+		case (RESET_SESSION_LIMIT):
+			sna_reset_session_limit_proc(cnos_verb);
+			break;
+
+		case (PROCESS_SESSION_LIMIT):
+			sna_process_session_limit_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_CONVERSATION_GROUP):
+			sna_deact_conversation_group_proc(cnos_verb);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_deactivate_session_proc(cnos_verb);
+			break;
+
+		case (ACTIVATE_SESSION):
+			sna_activate_session_proc(cnos_verb);
+			break;
+
+		case (DEFINE_LOCAL_LU):
+		case (DEFINE_REMOTE_LU):
+		case (DEFINE_MODE):
+		case (DEFINE_TP):
+			sna_define_proc(cnos_verb);
+			break;
+
+		case (DELETE):
+			sna_delete_proc(cnos_verb);
+			break;
+
+		default:
+			/* Error */
+	}
+#endif
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_init_session_limit_proc(struct sna_init_session_limit_verb *verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu->lu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG))
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_reset_session_limit_proc(verb, __u8 rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp == AUTH_OK)
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_CHECK;
+		else
+		{
+			if(type == PARALLEL
+				&& (lucb->mode_name != SNASVCMG
+				|| lucb->mode_name != CPSVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+				if(verb->force == YES)
+				{
+					if(rcode == ALLOCATION_ERROR
+						|| rcode == LU_MODE_SESSION_LIMIT
+						|| rcode == RESOURCE_FAILURE_NO_RETRY
+						|| rcode == UNRECOGNIZED_MODE_NAME)
+					{
+						sna_change_action(verb);
+						rcode = OK_FORCED;
+					}
+				}
+			}
+			else
+				sna_local_session_limit_proc(verb);
+		}
+	}
+	else
+		rcode = PROGRAM_PARAMETER_CHECK;
+
+	return (0);
+}
+
+static int sna_change_session_limit_proc(verb, rcode)
+{
+	struct sna_lucb *lucb;
+
+	lucb = search_lucb();
+
+	if(lucb->tp != AUTH_OK)
+		rcode = PROGRAM_PARAMETER_CHECK;
+	else
+	{
+		type = lucb->parallel;
+
+		if(lucb->lu != plu)
+			rcode = PARAMETER_ERROR;
+		else
+		{
+			if(type == INTERLU_PARALLEL
+				&& lucb->mode_name != SNASVCMG)
+			{
+				sna_source_session_limit_proc(verb);
+			}
+			else
+			{
+				if(type == INTRALU_PARALLEL
+					&& (lucb->mode_name != SNASVCMG
+					|| lucb->mode_name != CPSVCMG)
+				{
+					sna_local_session_limit_proc(verb);
+				}
+				else
+					rcode = PROGRAM_PARAM_CHECK;
+			}
+		}
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_proc(verb, rcode)
+{
+	err = check_verb(activate_session);
+	switch(err)
+	{
+		case (NO_AUTH):
+			rcode = PROGRAM_PARAMETER_CHECK;
+			break;
+
+		case (ERROR_FOUND):
+			rcode = err;
+			break;
+
+		case (OK):
+			activate = (struct sna_rm_activate_session *)kmalloc(sizeof(activate), GFP_ATOMIC);
+			activate->tcb_id = ps_process_data->tcb_id;
+			activate->lu_name = verb->lu_name;
+			activate->mode_name = verb->mode_name;
+			send_to_rm(activate);
+
+			activated = recv_from_rm();
+			rcode = activated->rcode;
+			if(single sess && conwinner)
+				sec_code = OK.AS_SPECIFIED;
+			else
+				sec_code = OK.AS_NEGOTIATED;
+		}
+	}
+
+	destroy(activated);
+
+	return (0);
+}
+
+static int deact_conversation_group_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		deact_group = (struct sna_deactivate_conv_group *)kmalloc(sizeof(deact_group), GFP_ATOMIC);
+		deact_group->conv_group_id = verb->conv_group_id;
+		deact_group->type = verb->type;
+		if(deact_group->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deact_group->sense = verb->sense
+			else
+				deact_group->sense = 0x08A00002;
+		}
+		else
+			deact_group->sense = 0x00000000;
+		send_to_rm(deact_group);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int deactivate_session_proc(verb)
+{
+	err = check_verb(verb);
+	if(tp == AUTH_OK)
+	{
+		rcode = OK;
+		deactivate = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+		deactivate->tcb_id = ps_process_data->tcb_id;
+		deactivate->session_id = verb->session_id;
+		deactivate->type = verb->type;
+		if(deactivate->type == CLEANUP)
+		{
+			if(verb->sense != NULL)
+				deactivate->sense = verb->sense;
+			else
+				deactivate->sense = 0x08A00002;
+		}
+		else
+			deactivate->sense = 0x00000000;
+		send_to_rm(deactivate);
+	}
+	else
+		rcode = PROGRAM_PARAM_CHECK;
+
+	return (0);
+}
+
+static int sna_define_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		assign values to data_structs..?
+
+	return (0);
+}
+
+static int sna_display_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Display request data, just copy to user space for us */
+
+	return (0);
+}
+
+static int sna_delete_proc(verb)
+{
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_tp *tp;
+
+	err = check_verb(verb);
+	if(err == ABEND)
+		rcode = PROGRAM_PARAM_CHECK;
+	else
+		/* Delete attribs in delete verb */
+
+	return (0);
+}
+
+static int sna_local_session_limit_proc(verb)
+{
+
+	switch(session_type)
+	{
+		case (SINGLE):
+			err = sna_local_verb_parameter_check(verb);
+			break;
+
+		case (PARALLEL):
+			if(mode_name == SNASVCMG || mode_name == CPSVCMG)
+				err = sna_svcmg_verb_param_check(verb);
+			break;
+
+		case (INTRA_PARALLEL):
+			if(mode_name != SNASVCMG || mode_name != CPSVCMG)
+				err = sna_intra_lu_local_verb_param_check(verb);
+			break;
+
+	}
+
+	if(err = OK)
+		sna_change_action(verb);
+
+	return (0);
+}
+
+static int sna_local_verb_param_check(verb, struct sna_parnter_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+
+	/* Swich is bad here */
+	switch(err)
+	{
+		case (OK):
+			rcode = OK.AS_SPECIFIED;
+			break;
+
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (MODE):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		if(mode->local_max_session_limit != NULL)
+		{
+			case (MAX_ALLOWED):
+				rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+				break;
+		}
+	}
+
+	return (0);
+}
+
+static int sna_intra_lu_local_verb_parm_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *plu;
+
+	err = check_verb(verb);
+
+	rcode = OK.AS_NEGOTIATED;
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_ZERO;
+			break;
+
+		case LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+
+		case (MAX_ALLOWED):
+			rcode = REQUEST_EXCEEDS_MAX_ALLOWED;
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_svcmg_verb_param_check(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+
+	err = check_verb(verb);
+	switch(err)
+	{
+		case (ABEND):
+			rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (ERROR):
+			rcode = PARAM_ERROR;
+			break;
+
+		case (LIMIT_NOT_ZERO):
+			rcode = LU_MODE_SESSION_LIMIT_NOT_ZERO;
+			break;
+
+		case (LIMIT_EXCEEDED):
+			rcode = LU_SESSION_LIMIT_EXCEEDED;
+			break;
+	}
+
+	return (0);
+}
+
+struct sna_change_action(verb, struct sna_partner_lu *plu_list, struct sna_mode *mode_list)
+{
+
+	return (0);
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_ps_main.c linux/net/sna/sna_ps_main.c
--- linux-2.4.4/net/sna/sna_ps_main.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_main.c	Mon May 14 21:11:27 2001
@@ -0,0 +1,555 @@
+/* sna_ps_main.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Services (PS)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+int sna_ps_process_fmh5(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_ps_process_fmh5\n");
+	sna_attach_execute_tp(tcb_id, skb);
+
+#ifdef NOT
+        struct sna_tcb *tcb;
+        struct sna_rcb *rcb;
+        __u8 code;
+
+        code = sense;
+
+        rcb = search_rcb(mu->rcb_id?);
+        sna_init_attached_rcb(rcb, mu_with_attach);
+
+        move_to_head(rcb->hs_to_ps_buffer_list, mu_with_attach);
+
+        if(code == OK)
+        {
+                sna_ps_attach_chk(rcb, code);
+                if(pip != NULL)
+                        sna_receive_pip_field_from_hs(rcb, pip, code);
+                sna_ps_pip_chk(pip, code);
+        }
+
+        if(code == OK)
+                sna_upm_execute(tcb->tp_name, rcb->rcb_id, pip);
+        else
+                sna_attach_error_proc(rcb, code);
+#endif
+
+        return (0);
+}
+
+#ifdef NOT
+
+static int sna_ps(unsigned char *record)
+{
+	struct sna_ps_process_data *ps_process_data;
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+
+	/* Establish the enviroment ?? move to init */
+	ps_create_parms = (struct sna_ps_create_params)record;
+	ps_process_data			= ps_create_params;
+
+	lucb = search_lucb(ps_create_params->lu_id);
+	ps_process_data->lucb_ptr	= lucb;
+
+	tcb = search_tcb(ps_create_params->tcb_id);
+	ps_process_data->tcb_ptr	= tcb;
+
+	/* PS_initilize ?? */
+	
+	switch(record_type)
+	{
+		case (MU):
+			sna_process_fmh5(mu);
+			break;
+
+		case (START_TP):
+			sna_process_start_tp(start_tp);
+			break;
+
+		default:
+			Log_err();
+	}
+
+	sna_deallocation_cleanup_proc();	/* Everytime ? */
+
+	return (0);
+}
+
+static int sna_process_start_tp(struct sna_start_tp *start_tp, unsigned char *tp_name)
+{
+	struct sna_tcb *tcb;
+	struct sna_pip *pip; ???
+
+	pip = start_tp->pip;
+	destroy(pip);
+	sna_upm_execute(tp_name, NULL, pip);
+
+	return (0);
+}
+
+static int sna_receive_pip_field_from_hs(struct sna_rcb *rcb, struct sna_pip *pip, __u8 code)
+{
+	struct sna_receive_and_wait *receive_and_wait;
+
+	receive_and_wait = (struct sna_receive_and_wait *)kmalloc(sizeof(receive_and_wait), GFP_ATOMIC);
+	receive_and_wait->post_conditions.fill		= LL;
+	receive_and_wait->post_conditions.max_length	= 0x7FFF;
+
+	sna_receive_and_test_posting(rcb, receive_and_wait);
+	err = sna_chk_pip(receive_and_wait->pip);
+	if(!err)
+		return(receive_and_wait->pip);
+	else
+		code = 0x1008201D;
+
+	return (0);
+}
+
+static int sna_ps_attach_chk(struct sna_attach *attach, __u8 code, struct sna_pip *pip)
+{
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_mu *mu;
+
+	mu = sna_get_buf_from_list(rcb->hs_to_ps_buffer_list);
+	mu->tp_name = tcb->tp_name;
+
+	/* Check attach fields for the following */
+	if(lu_work_id fields are bad)
+		code = 0x10086011;
+
+	if(tp->conversation_type != BASIC || tp->conversation_type != MAPPED)
+		code = 0x10086034;
+
+	if(mu has been processed)
+	{
+		type_field = mu->end_of_chain_type;
+		bm(FREE, mu);
+	}
+
+	return (0);
+}
+
+static int sna_ps_pip_chk(struct sna_pip *pip, __u8 code)
+{
+	struct sna_tcb *tcb;
+	struct sna_tp *tp;
+
+	tp->tp_name = attach->tp_name;	/* Screwed Big time */
+
+	if(code != OK)
+		return (-??);
+
+	if(tp->pip_numbers != NULL)
+	{
+		if(tp->number_of_pip_subfields == 0
+			&& attach->pip != NULL)
+		{
+			code = 0x10086031;
+		}
+		else
+		{
+			if(tp->number_of_pip_subfields
+				!= attach->number_of_pip_subfields)
+			{
+				code = 0x10086032;
+			}
+			else
+			{
+				err = check_pip_format(pip);
+				if(err)
+					code = 0x1008201D;
+			}
+		}
+	}
+
+	if(tp->pip == NULL)
+	{
+		if(pip_data == BAD ;)
+			code = 0x1008201D;
+	}
+
+	return (0);
+}
+
+static int sna_attach_error_proc(struct sna_rcb *rcb, __u8 code/sense)
+{
+	struct sna_mu *mu;
+
+	switch(code)
+	{
+		case (0x1008200E):
+		case (0x10086000):
+		case (0x10086005):
+		case (0x10086009):
+		case (0x10086011):
+		case (0x10086040):
+		case (0x1008201D):
+			sna_ps_protocol_error(rcb->hs_id, code);
+			sna_end_conversation_proc(rcb);
+			break;
+
+		default:
+			sna_send_error_to_hs_proc(rcb);
+			sna_end_chain_from_hs(rcb);
+			if(fsm_error_or_failure() == CONV_FAILURE_SON
+				|| fsm_error_or_failure == CONV_FAILURE_PROTOCOL_ERROR)
+			{
+				Log_error();
+			}
+			else
+			{
+				switch(end-of-chain type)
+				{
+					case (DEALLOCATE_FLUSH):
+						Log_error();
+						break;
+
+					case (DEALLOCATE_CONFIRM):
+					case (CONFIRM):
+					case (PREPARE_TO_RCV_CONFIRM):
+					case (PREPARE_TO_RCV_FLUSH):
+						sna_upm_attach_log(code, log_data);
+						if(log_data != NULL)
+						{
+							Log_err();
+							attach_fmh-7();
+							sna_send_data_bm(log_data, rcb);
+						}
+					else
+						put_fmh7_into_send_mu();
+
+					mu->ps_to_hs.type = DEALLOCATE_FLUSH;
+					break;
+				}
+
+				sna_end_conversation_proc(rcb);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+#endif
+
+int sna_ps_verb_router(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_verb_router(%d)\n", verb);
+	switch(verb)
+	{
+		case (ALLOCATE):
+			sna_ps_conv(verb, tcb);
+			break;
+		case (CONFIRM):
+		case (CONFIRMED):
+		case (DEALLOCATE):
+		case (FLUSH):
+		case (GET_ATTRIBUTES):
+		case (POST_ON_RECEIPT):
+		case (PREPARE_TO_RECEIVE):
+		case (RECEIVE_AND_WAIT):
+		case (RECEIVE_IMMEDIATE):
+		case (REQUEST_TO_SEND):
+		case (SEND_DATA):
+		case (SEND_ERROR):
+		case (TEST):
+			sna_ps_conv(verb, tcb);
+			break;
+
+#ifdef NOT
+		case (MC_ALLOCATE):
+			sna_ps_mc(verb);
+			break;
+
+		case (MC_CONFIRM):
+		case (MC_CONFIRMED):
+		case (MC_DEALLOCATE):
+		case (MC_FLUSH):
+		case (MC_GET_ATTRIBUTES):
+		case (MC_POST_ON_RECEIPT):
+		case (MC_PREPARE_TO_RECEIVE):
+		case (MC_RECEIVE_AND_WAIT):
+		case (MC_REQUEST_TO_SEND):
+		case (MC_SEND_DATA):
+		case (MC_SEND_ERROR):
+		case (MC_TEST):
+			if(verb->resource =?= tcb->resource_list)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				if(rcb->conversation_type == MAPPED)
+				{
+					tcb->cntrl_component = SERVICE_COMPONENT;
+					sna_ps_mc(verb);
+					tcb->cntrl_component = TP;
+				}
+				else
+					verb->rcode = PROGRAM_PARAM_CHECK;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (INITIALIZE_SESSION_LIMIT):
+		case (CHANGE_SESSION_LIMIT):
+		case (RESET_SESSION_LIMIT):
+		case (SET_LUCB):
+		case (SET_PARTNER_LU):
+		case (SET_MODE):
+		case (SET_MODE_OPTIONS):
+		case (SET_TRANSACTION_PROGRAM):
+		case (SET_PRIVILAEGED_FUNCTION):
+		case (SET_RESOURCE_SUPPORTED):
+		case (SET_SYNC_LEVEL_SUPPORTED):
+		case (SET_MC_FUNCTION_SUPPORTED_TP):
+		case (GET_LUCB):
+		case (GET_PARTNER_LU):
+		case (GET_MODE):
+		case (GET_LU_OPTION):
+		case (GET_MODE_OPTION):
+		case (GET_TRANSACTION_PROGRAM):
+		case (GET_PRIVILEGED_FUNCTION):
+		case (GET_RESOURCE_SUPPORTED):
+		case (GET_SYNC_LEVEL_SUPPORTED):
+		case (GET_MC_FUNCTION_SUPPORTED_LU):
+		case (GET_MC_FUNCTION_SUPPORTED_TP):
+		case (LIST_PARTNER_LU):
+		case (LIST_MODE):
+		case (LIST_LU_OPTION):
+		case (LIST_MODE_OPTION):
+		case (LIST_TRANSACTION_PROGRAM):
+		case (LIST_PRIVILEGED_FUNCTION):
+		case (LIST_RESOURCE_SUPPORTED):
+		case (LIST_SYNC_LEVEL_SUPPORTED):
+		case (LIST_MC_FUNCTION_SUPPORTED_LU):
+		case (LIST_MC_FUNCTION_SUPPORTED_TP):
+		case (PROCESS_SESSION_LIMIT):
+		case (ACTIVATE_SESSION):
+		case (DEACTIVATE_CONVERSATION_GROUP):
+		case (DEACTIVATE_SESSION):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_copr(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (SYNCPT):
+		case (BACKOUT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_ps_sync(verb);
+			tcb->cntrl_component = TP;
+			break;
+
+		case (GET_TP_PROPERTIES):
+			sna_get_tp_properties_proc(verb);
+			break;
+
+		case (GET_TYPE):
+			verb->rcode = OK;
+			if(verb->resource == conversation_this_tp)
+			{
+				rcb = search_rcb(verb->resource.rcb_id);
+				verb->type = rcb->conversation_type;
+			}
+			else
+				verb->rcode = PROGRAM_PARAM_CHECK;
+			break;
+
+		case (WAIT):
+			tcb->cntrl_component = SERVICE_COMPONENT;
+			sna_wait_proc(verb);
+			tcb->cntrl_component = TP;
+			break;
+#endif
+		default:
+			return (-EINVAL);
+	}
+
+	return (0);
+}
+
+#ifdef NOT
+
+static int sna_deallocation_cleanup_proc(struct sna_rcb *rcb)
+{
+	struct sna_terminate_ps *terminate_ps;
+	struct sna_tcb *tcb;
+
+	for(tcb = tcb_list; tcb != NULL; tcb = tcb->next)
+	{
+		if(tcb->rcb_id == rcb->rb_id)
+			sna_upm_return_processing(rcb);
+	}
+
+	send_to_rm(terminate_ps);
+
+	return (0);
+}
+
+static int sna_get_tp_properties_proc(struct sna_get_tp_properties *get_tp_properties)
+{
+	struct sna_lucb *lucb;
+	struct sna_tcb *tcb;
+
+	get_tp_properties->own_tp_name		= tcb->tp_name;
+	get_tp_properties->own_tp_instance	= tcb->tcb_id;
+	get_tp_properties->own_fq_lu_name	= lucb->fq_lu_name;
+	get_tp_properties->security_profile	= tcb->init_security.profile;
+	get_tp_properties->security_user_id	= tcb->init_security.user_id;
+	get_tp_properties->rcode		= OK;
+
+	return (0);
+}
+
+static int sna_wait_proc(struct sna_wait *wait, unsigned char *data)
+{
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	err = sna_check_resource_list();
+	if(err)
+	{
+		wait->rcode = PROGRAM_PARAM_CHECK;
+		return (-?);
+	}
+
+	if(no_activated_resource)
+	{
+		wait->rcode = POSTING_NOT_ACTIVE;
+		return (-?);
+	}
+
+	for(each_resource_posting_active)
+	{
+		sna_test_for_resource_posted(rcb, rc);
+		if(rc != UNSUCCESSFULL)
+		{
+			wait->rcode = rc;
+			return (-?);
+		}
+
+	/* Spin until resource becomes posted */
+	rc = UNSUCCESSFULL;
+	while(rc == UNSUCCESSFULL)
+	{
+		sna_receive_rm_or_hs_to_ps_records(temp_resource_list);
+		rcb = rcb_data_active();
+		sna_test_for_resource_posted(rcb, rc);
+	}
+
+	resource_posted = rcb->rcb_id;
+	wait->rcode = rc;
+
+	return (0);
+}
+
+static int sna_ps_protocol_err(__u8 hs_id, __u8 tcb_id, __u8 sense)
+{
+	struct sna_unbind_protocol_error *unbind_proto_err;
+
+	unbind_proto_err->hs_id 	= hs_id;
+	unbind_proto_err->tcb_id	= tcb_id;
+	unbind_proto_err->sense		= sense;
+
+	send_to_rm(unbind_proto_err);
+
+	return (0);
+}
+
+static int sna_init_attached_rcb(struct sna_rcb *rcb, attach)
+{
+	rcb->conversation_type 	= attach->conversation_type;
+	rcb->limit_buf_pool_id 	= attach->limit_buf_pool_id;
+	rcb->perm_buf_pool_id	= attach->perm_buf_pool_id;
+	rcb->send_ru_size	= attach->send_ru_size;
+	rcb->post_conditions.fill	= LL;
+	rcb->post_conditions.max_length	= 0;
+	rcb->locks		= SHORT;
+	rcb->rq_to_send_rcvd	= NO;
+
+	sna_empty_list(rcb->hs_to_ps_buffer_list);
+
+	fsm_conversation	= RCV;
+	fsm_error_or_failure	= NO_REQUESTS;
+	fsm_post		= RESET;
+
+	if(rcb->conversation_type == MAPPED_CONVERSATION)
+	{
+		sna_empty_list(rcb->mc_receive_buffer);
+		rcb->mc_rq_to_send_rcvd	= NO;
+		rcb->mapper_save_area	= /* I decide, Hah! */
+		rcb->mc_max_send_size	= /* I decide this too!! Wee */
+	}
+
+	return (0);
+}
+
+static int sna_test_for_resource_posted(struct sna_rcb *rcb)
+{
+	struct sna_test *test;
+	struct sna_mc_test *mc_test;
+
+	switch(rcb->conversation_type)
+	{
+		case (BASIC):
+			test = (struct sna_test *)kmalloc(sizeof(test), GFP_ATOMIC);
+			test->resource 	= rcb->rcb_id;
+			test->test	= POSTED;
+			err = sna_test_proc(test);
+			break;
+
+		case (MAPPED):
+			mc_test = (struct sna_test *)kmalloc(sizeof(mc_test), GFP_ATOMIC);
+			mc_test->resource	= rcb->rcb_id;
+			mc_test->test		= POSTED;
+			err = sna_mc_test_proc(mc_test);
+			break;
+
+		default:
+			/* Error */
+	}
+
+	return (err);
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_ps_mc.c linux/net/sna/sna_ps_mc.c
--- linux-2.4.4/net/sna/sna_ps_mc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_mc.c	Mon May 14 21:11:37 2001
@@ -0,0 +1,48 @@
+/* sna_ps_mc.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Presentation Service Mapped Conversations (PS.MC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_mc(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_mc\n");
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_ps_sync.c linux/net/sna/sna_ps_sync.c
--- linux-2.4.4/net/sna/sna_ps_sync.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ps_sync.c	Mon May 14 19:28:58 2001
@@ -0,0 +1,32 @@
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+
+int sna_ps_sync(int verb, struct sna_tcb *tcb)
+{
+	sna_debug(5, "sna_ps_sync\n");
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_rm.c linux/net/sna/sna_rm.c
--- linux-2.4.4/net/sna/sna_rm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_rm.c	Mon May 14 21:12:01 2001
@@ -0,0 +1,3272 @@
+/* sna_rm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Resource Manager (RM)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/sna.h>
+#include <linux/cpic.h>
+#include <net/cpic.h>
+
+static struct sna_mode_cb *mode_list 	= NULL;
+static struct sna_lu_cb *lu_list	= NULL;
+static struct sna_plu_cb *plu_list	= NULL;
+
+static __u32 sna_mode_system_id = 1;
+static __u32 sna_lu_system_id	= 1;
+static __u32 sna_plu_system_id	= 1;
+static __u32 sna_rcb_system_id	= 1;
+static __u32 sna_bracket_id	= 1;
+static __u32 sna_conversation_correlator = 1;
+static __u32 sys_correlator_cnt = 1;
+
+static struct sna_rcb *rcb_list	= NULL;
+
+struct sna_rcb *sna_rm_find_rcb_by_id(__u8 rcb_id)
+{
+        struct sna_rcb *rcb;
+
+        for(rcb = rcb_list; rcb != NULL; rcb = rcb->next)
+                if(rcb->rcb_id == rcb_id)
+                        return (rcb);
+        return (NULL);
+}
+
+int sna_rm_send_attach_to_ps(__u32 tcb_id, __u32 rcb_id, struct sk_buff *skb)
+{
+	sna_debug(5, "sna_rm_send_attach_to_ps\n");
+	sna_ps_process_fmh5(tcb_id, rcb_id, skb);
+
+	return (0);
+}
+
+int sna_rm_create_ps(__u32 *tcb_id, __u32 *rcb_id, struct sk_buff *skb)
+{
+	struct sna_tcb *tcb;
+	struct snathdr *th = (struct snathdr *)skb->data;
+
+	sna_debug(5, "sna_rm_create_ps DAF is %02X\n", th->fid.f2.daf);
+	*tcb_id = sna_cpic_create_tcb();
+	tcb = sna_cpic_find_tcb_by_daf(th->fid.f2.daf);
+	if(!tcb)
+	{
+		sna_debug(5, "No TCB found\n");
+		return (-1);
+	}
+	*rcb_id = sna_rm_allocate_rcb(tcb);
+	*tcb_id = tcb->tcb_id;
+
+	return (0);
+}
+
+static int sna_rm_process_attach(struct sk_buff *skb)
+{
+	__u32 tcb_id = 0, rcb_id = 0;
+
+	sna_debug(5, "sna_rm_process_attach\n");
+	sna_rm_create_ps(&tcb_id, &rcb_id, skb);
+	sna_rm_send_attach_to_ps(tcb_id, rcb_id, skb);
+
+#ifdef NOT
+        struct sna_scb *scb;
+        __u8 tcb_id, rcb_id, err;
+
+        tcb_id = 0;
+        rcb_id = 0;
+
+        scb = sna_search_scb();
+
+        if(FSM_SCB_STATUS != PENDING_ATTACH)
+                sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 0x20030000);
+        else
+        {
+                err = sna_attach_chk(fmh5, mu->layer.hs_to_rm.hs_id);
+                switch (err)
+                {
+                        case (0xFFFFFFFF):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x080F6051);
+                                sna_free_buffer(mu);
+                                break;
+
+
+                        case (0x10086040):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086040);
+                                sna_free_buffer(mu);
+                                break;
+
+                        case (0x10086011):
+                                sna_send_deactivate_session(ACTIVE, scb->hs_id,
+                                        ABNORMAL, 0x10086011);
+                                sna_free_buffer(mu);
+                                break;
+                }
+
+                if(fmh5->fmh5cmd == ATTACH)
+                {
+                        if(err == 0x00000000)
+                        {
+                                tp = sna_search_tp();   /* ??? */
+
+                                /* Spell insane for now */
+                                if(err == 0x00000000
+                                        || tp->instance_cnt
+                                        < tp->instance_limit)
+
+                                        err = sna_ps_creation_proc(mu, tcb_id,rcb_id, tp, create_rc);
+                                        if(err == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                if(tp->tp_cnt > 0
+                                                        && err == 0)
+                                                {
+                                                        sna_queue_attach_proc(mu);
+                                                }
+                                                else
+                                                {
+                                                        sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                        bm_free(FREE, mu);
+                                                }
+                                                if(tp->tp_cnt == 0)
+                                                        sna_purge_queued_requests(tp);
+                                        }
+
+                                        sna_queue_attach(mu);
+                                }
+                                else
+                                {
+                                        mu->tp = NULL;
+                                        sna_ps_creation_proc(mu, tcb_id, rcb_id, tp, create_rc);
+                                        if(create_rc == SUCCESS)
+                                        {
+                                                sna_fsm_scb_status(r, attach, undefined);
+                                                scb->rcb_id = rcb_id;
+                                                sna_connect_rcb_and_scb(rcb_id,
+mu->layer.hs_to_rm.hs_id);
+                                                sna_send_attach_to_ps(mu, tcb_id, rcb_id, sense_code);
+                                        }
+                                        else
+                                        {
+                                                sna_send_deactivate_session(active, mu->layer.hs_to_rm.hs_id, abnormal, 0x08640000);
+                                                bm_free(FREE, mu);
+                                        }
+                                }
+                        }
+                }
+        }
+#endif
+
+        return (0);
+}
+
+int sna_rm_process_hs_to_rm(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_rm_process_hs_to_rm\n");
+
+	/* if FMH-5 */
+	sna_rm_process_attach(skb);
+
+	return (0);
+}
+
+int sna_rm_destroy(struct sna_delete_node *d)
+{
+	struct sna_mode_cb *mode, **mclients = &mode_list;
+	struct sna_lu_cb *lu, **lclients = &lu_list;
+	struct sna_plu_cb *plu, **pclients = &plu_list;
+
+	while((mode = *mclients) != NULL)
+	{
+		*mclients = mode->next;
+		kfree(mode);
+		sna_mod_dec_use_count();
+	}
+
+	while((lu = *lclients) != NULL)
+	{
+		*lclients = lu->next;
+		kfree(lu);
+		sna_mod_dec_use_count();
+	}
+
+	while((plu = *pclients) != NULL)
+	{
+		*pclients = plu->next;
+		kfree(plu);
+		sna_mod_dec_use_count();
+	}
+
+	return (0);
+}
+
+struct sna_mode_cb *sna_rm_find_mode(char *mode_name)
+{
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_find_mode\n");
+	for(mode = mode_list; mode != NULL; mode = mode->next)
+		if(!strcmp(mode->mode_name, mode_name))
+			return (mode);
+
+	return (NULL);
+}
+
+struct sna_lu_cb *sna_rm_find_local_lu(char *lu_name)
+{
+	struct sna_lu_cb *lu;
+
+	sna_debug(5, "sna_rm_find_local_lu\n");
+	for(lu = lu_list; lu != NULL; lu = lu->next)
+		if(!strcmp(lu->lu_name, lu_name))
+			return (lu);
+
+	return (NULL);
+}
+
+struct sna_plu_cb *sna_rm_find_remote_lu(struct sna_netid *id)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_rm_find_remote_lu\n");
+	for(plu = plu_list; plu != NULL; plu = plu->next)
+		if(!strcmp(plu->netid_plu.net, id->net)
+			&& !strcmp(plu->netid_plu.name, id->name))
+			return (plu);
+
+	return (NULL);
+}
+
+int sna_rm_delete_local_lu(struct sna_delete_local_lu *dlu)
+{
+        struct sna_lu_cb *lu, **clients;
+
+        clients = &lu_list;
+        while((lu = *clients) != NULL)
+        {
+                if(!strcmp(lu->lu_name, dlu->lu_name))
+                {
+                        *clients = lu->next;
+                        kfree(lu);
+                        sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &lu_list;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_rm_delete_remote_lu(struct sna_delete_partner_lu *dplu)
+{
+        struct sna_plu_cb *plu, **clients;
+
+        clients = &plu_list;
+        while((plu = *clients) != NULL)
+        {
+                if(!strcmp(plu->netid_plu.net, dplu->netid_plu.net)
+			&& !strcmp(plu->netid_plu.name, dplu->netid_plu.name))
+                {
+                        *clients = plu->next;
+                        kfree(plu);
+                        sna_mod_dec_use_count();
+                        return (0);
+                }
+                clients = &plu_list;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_rm_delete_mode(struct sna_delete_mode *dm)
+{
+	struct sna_mode_cb *mode, **clients;
+
+	clients = &mode_list;
+	while((mode = *clients) != NULL)
+	{
+		if(!strcmp(mode->mode_name, dm->mode_name))
+		{
+			*clients = mode->next;
+			kfree(mode);
+			sna_mod_dec_use_count();
+			return (0);
+		}
+		clients = &mode_list;			
+	}
+
+	return (-ENOENT);
+}
+
+int sna_rm_define_local_lu(struct sna_define_local_lu *dlu)
+{
+	struct sna_lu_cb *lu;
+
+        lu = sna_rm_find_local_lu(dlu->lu_name);
+        if(lu != NULL)
+                return (-EEXIST);
+
+        lu = (struct sna_lu_cb *)kmalloc(sizeof(struct sna_lu_cb),
+                GFP_ATOMIC);
+
+	memcpy(&lu->netid, &dlu->netid, sizeof(struct sna_netid));
+	strncpy(lu->lu_name, dlu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lu->sync_point	= dlu->sync_point;
+	lu->lu_sess_limit=dlu->lu_sess_limit;
+        lu->flags      	= SNA_UP;
+        lu->proc_id    	= sna_lu_system_id++;
+        lu->next       	= lu_list;
+	lu->prev	= NULL;
+        lu_list        	= lu;
+        sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_rm_define_remote_lu(struct sna_define_partner_lu *lu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_rm_define_remote_lu -%s-\n",
+		sna_pr_netid(&lu->netid_plu));
+
+	plu = sna_rm_find_remote_lu(&lu->netid_plu);
+	if(plu != NULL)
+		return (-EEXIST);
+
+	plu = (struct sna_plu_cb *)kmalloc(sizeof(struct sna_plu_cb),
+		GFP_ATOMIC);
+
+	memcpy(&plu->netid, &lu->netid, sizeof(struct sna_netid));
+	memcpy(&plu->netid_plu, &lu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&plu->netid_fqcp, &lu->netid_fqcp, sizeof(struct sna_netid));
+	plu->parallel_ss= lu->parallel_ss;
+	plu->cnv_security=lu->cnv_security;
+	plu->flags	= SNA_UP;
+	plu->proc_id	= sna_plu_system_id++;
+	plu->next	= plu_list;
+	plu->prev	= NULL;
+	plu_list	= plu;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_rm_define_mode(struct sna_define_mode *dm)
+{
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_define_mode\n");
+
+	mode = sna_rm_find_mode(dm->mode_name);
+	if(mode != NULL)
+		return (-EEXIST);
+
+	mode = (struct sna_mode_cb *)kmalloc(sizeof(struct sna_mode_cb),
+		GFP_ATOMIC);
+
+	memcpy(&mode->netid, &dm->netid, sizeof(struct sna_netid));
+	memcpy(&mode->netid_plu, &dm->netid_plu, sizeof(struct sna_netid));
+	strncpy(mode->mode_name, dm->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mode->cos_name, dm->cos_name, SNA_RESOURCE_NAME_LEN);
+	mode->tx_pacing = dm->tx_pacing;
+	mode->rx_pacing = dm->rx_pacing;
+	mode->max_tx_ru = dm->max_tx_ru;
+	mode->max_rx_ru = dm->max_rx_ru;
+	mode->crypto	= dm->crypto;
+	mode->flags	= SNA_UP;
+	mode->proc_id	= sna_mode_system_id++;
+
+	mode->max_sessions	= SNA_MODE_MAX_SESSIONS;
+	mode->min_conwinners	= SNA_MODE_MIN_CONWINNERS;
+	mode->min_conlosers	= SNA_MODE_MIN_CONLOSERS;
+	mode->active.sessions	= 0;
+	mode->active.conwinners	= 0;
+	mode->active.conlosers	= 0;
+	mode->pending.sessions	= 0;
+	mode->pending.conwinners= 0;
+	mode->pending.conlosers	= 0;
+
+	mode->next	= mode_list;
+	mode->prev	= NULL;
+	mode_list	= mode;
+	sna_mod_inc_use_count();
+
+	return (0);
+}
+
+int sna_mode_ginfo(struct sna_mode_cb *mode, char *buf, int len)
+{
+        struct modereq mr;
+        int done = 0;
+
+	sna_debug(10, "sna_mode_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(mr);
+                return (done);
+        }
+        if(len < (int)sizeof(mr))
+                return done;
+        memset(&mr, 0, sizeof(struct modereq));
+
+        /* Move the data here */
+	memcpy(&mr.netid, &mode->netid, sizeof(struct sna_netid));
+	memcpy(&mr.plu_name, &mode->netid_plu, sizeof(struct sna_netid));
+	strncpy(mr.mode_name, mode->mode_name, SNA_RESOURCE_NAME_LEN);
+	strncpy(mr.cos_name, mode->cos_name, SNA_RESOURCE_NAME_LEN);
+	mr.tx_pacing		= mode->tx_pacing;
+	mr.rx_pacing		= mode->rx_pacing;
+	mr.max_tx_ru		= mode->max_tx_ru;
+	mr.max_rx_ru		= mode->max_rx_ru;
+	mr.crypto		= mode->crypto;
+	mr.proc_id		= mode->proc_id;
+	mr.flags		= mode->flags;
+	mr.auto_activation	= mode->auto_activation;
+	mr.max_sessions		= mode->max_sessions;
+	mr.min_conlosers	= mode->min_conlosers;
+	mr.min_conwinners	= mode->min_conwinners;
+	mr.act_sessions		= mode->active.sessions;
+	mr.act_conwinners	= mode->active.conwinners;
+	mr.act_conlosers	= mode->active.conlosers;
+	mr.pend_sessions	= mode->pending.sessions;
+	mr.pend_conwinners	= mode->pending.conwinners;
+	mr.pend_conlosers	= mode->pending.conlosers;
+
+        if(copy_to_user(buf, &mr, sizeof(struct modereq)))
+                return (-EFAULT);
+        buf += sizeof(struct modereq);
+        len -= sizeof(struct modereq);
+        done += sizeof(struct modereq);
+
+        return (done);
+}
+
+int sna_lu_ginfo(struct sna_lu_cb *lu, char *buf, int len)
+{
+        struct lureq lr;
+        int done = 0;
+
+        sna_debug(10, "sna_lu_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(lr);
+                return (done);
+        }
+        if(len < (int)sizeof(lr))
+                return done;
+        memset(&lr, 0, sizeof(struct lureq));
+
+        /* Move the data here */
+	memcpy(&lr.netid, &lu->netid, sizeof(struct sna_netid));
+	strncpy(lr.name, lu->lu_name, SNA_RESOURCE_NAME_LEN);
+	lr.sync_point		= lu->sync_point;
+	lr.lu_sess_limit	= lu->lu_sess_limit;
+	lr.proc_id		= lu->proc_id;
+	lr.flags		= lu->flags;
+
+        if(copy_to_user(buf, &lr, sizeof(struct lureq)))
+                return (-EFAULT);
+        buf += sizeof(struct lureq);
+        len -= sizeof(struct lureq);
+        done += sizeof(struct lureq);
+
+        return (done);
+}
+
+int sna_plu_ginfo(struct sna_plu_cb *plu, char *buf, int len)
+{
+        struct plureq pr;
+        int done = 0;
+
+        sna_debug(10, "sna_plu_ginfo\n");
+        if(!buf)
+        {
+                done += sizeof(pr);
+                return (done);
+        }
+        if(len < (int)sizeof(pr))
+                return done;
+        memset(&pr, 0, sizeof(struct plureq));
+
+        /* Move the data here */
+	memcpy(&pr.netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&pr.plu_name, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&pr.fqcp_name, &plu->netid_fqcp, sizeof(struct sna_netid));
+	pr.parallel_ss	= plu->parallel_ss;
+	pr.cnv_security	= plu->cnv_security;
+	pr.proc_id	= plu->proc_id;
+	pr.flags	= plu->flags;
+
+        if(copy_to_user(buf, &pr, sizeof(struct plureq)))
+                return (-EFAULT);
+        buf += sizeof(struct plureq);
+        len -= sizeof(struct plureq);
+        done += sizeof(struct plureq);
+
+        return (done);
+}
+
+int sna_rm_query_mode(char *arg)
+{
+	struct modeconf mc;
+	struct sna_mode_cb *mode;
+	char *pos;
+	int len, total;
+
+	sna_debug(5, "sna_rm_query_mode\n");
+	if(copy_from_user(&mc, arg, sizeof(mc)))
+                return (-EFAULT);
+
+        pos = mc.modec_buf;
+        len = mc.mode_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(mode = mode_list; mode != NULL; mode = mode->next)
+        {
+		int done;
+
+                if(pos == NULL)
+                	done = sna_mode_ginfo(mode, NULL, 0);
+                else
+                        done = sna_mode_ginfo(mode,pos+total,len-total);
+                if(done < 0)
+                	return (-EFAULT);
+                total += done;
+        }
+
+        mc.mode_len = total;
+        if(copy_to_user(arg, &mc, sizeof(mc)))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_rm_query_lu(char *arg)
+{
+	struct luconf lc;
+	struct sna_lu_cb *lu;
+	char *pos;
+        int len, total;
+
+	sna_debug(5, "sna_rm_query_lu\n");
+        if(copy_from_user(&lc, arg, sizeof(lc)))
+                return (-EFAULT);
+
+        pos = lc.luc_buf;
+        len = lc.lu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(lu = lu_list; lu != NULL; lu = lu->next)
+        {
+        	int done;
+
+                if(pos == NULL)
+                	done = sna_lu_ginfo(lu, NULL, 0);
+                else
+                        done = sna_lu_ginfo(lu,pos+total,len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        lc.lu_len = total;
+        if(copy_to_user(arg, &lc, sizeof(lc)))
+                return (-EFAULT);
+        return (0);
+}
+
+int sna_rm_query_plu(char *arg)
+{
+	struct pluconf pc;
+	struct sna_plu_cb *plu;
+	char *pos;
+        int len, total;
+
+	sna_debug(5, "sna_rm_query_plu\n");
+        if(copy_from_user(&pc, arg, sizeof(pc)))
+                return (-EFAULT);
+
+        pos = pc.pluc_buf;
+        len = pc.plu_len;
+
+        /*
+         * Get the data and put it into the structure
+         */
+        total = 0;
+        for(plu = plu_list; plu != NULL; plu = plu->next)
+        {
+	        int done;
+
+                if(pos == NULL)
+	                done = sna_plu_ginfo(plu, NULL, 0);
+                else
+                        done = sna_plu_ginfo(plu, pos+total, len-total);
+                if(done < 0)
+                        return (-EFAULT);
+                total += done;
+        }
+
+        pc.plu_len = total;
+        if(copy_to_user(arg, &pc, sizeof(pc)))
+                return (-EFAULT);
+        return (0);
+}
+
+static int sna_rm_session_activation_polarity(struct sna_netid *plu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_plu_cb *plu;
+	struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_session_activation_polarity %s.%s\n",
+		plu_name->net, plu_name->name);
+
+	plu = sna_rm_find_remote_lu(plu_name);
+	if(!plu)
+		return (-ENOENT);
+	mode = sna_rm_find_mode(mode_name);
+	if(!mode)
+		return (-ENOENT);
+
+        if(mode->pending.sessions == mode->max_sessions)
+                return (SNA_SESSION_NONE);
+/*
+        if((mode->pending.sessions +  mode->active.sessions) > 0
+                && partner->parallel == SUPPORTED)
+                return (SNA_SESSION_NONE);
+*/
+        if((mode->max_sessions - mode->min_conlosers)
+                > (mode->active.conwinners + mode->pending.conwinners))
+                return (SNA_SESSION_FIRST_SPEAKER);
+        else
+                return (SNA_SESSION_BIDDER);
+
+	return (0);
+}
+
+static int sna_rm_send_activate_session(struct sna_netid *plu_name,
+        unsigned char *mode_name, int polarity)
+{
+	struct sna_sm_act_session_rq *as;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_rm_send_activate_session\n");
+	mode = sna_rm_find_mode(mode_name);
+	if(!mode)
+		return (-ENOENT);
+
+	as = (struct sna_sm_act_session_rq *)kmalloc(sizeof(struct sna_sm_act_session_rq), GFP_ATOMIC);
+        as->correlator	= sys_correlator_cnt++;
+	as->polarity	= (__u8)polarity;
+	memcpy(&as->plu_netid, plu_name, sizeof(struct sna_netid));
+	memcpy(as->mode_name, mode_name, SNA_RESOURCE_NAME_LEN);
+        mode->pending.sessions++;
+        if(polarity == SNA_SESSION_FIRST_SPEAKER)
+                mode->pending.conwinners++;
+        else
+                mode->pending.conlosers++;
+	sna_sm_process_activation_session(as);
+
+        return (0);
+}
+
+int sna_rm_activate_session(struct sna_rm_act_session_rq *as)
+{
+	int err = 0;
+
+	sna_debug(5, "sna_rm_activate_session\n");
+        switch(sna_rm_session_activation_polarity(&as->plu_netid,as->mode_name))
+        {
+                case (SNA_SESSION_FIRST_SPEAKER):
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_FIRST_SPEAKER);
+                        break;
+
+                case (SNA_SESSION_BIDDER):
+                        sna_rm_send_activate_session(&as->plu_netid,
+                                as->mode_name, SNA_SESSION_BIDDER);
+                        break;
+
+		case (SNA_SESSION_NONE):
+		default:
+			err = -1;    /* LU_MODE_SESSION_LIMIT_EXCEEDED */
+			break;
+        }
+
+	kfree(as);
+        return (err);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_rm_get_info_local_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_lu_cb *lu;
+	off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-6s%-18s%-9s%-11s%-14s%-5s\n",
+                "lu_id", "netid.node", "lu_name", "sync_point",
+		"lu_sess_limit", "flags");
+
+        for(lu = lu_list; lu != NULL; lu = lu->next)
+        {
+                len += sprintf(buffer + len, "%-6d%-18s%-9s%-11d%-14d%04X\n",
+                        lu->proc_id, sna_pr_netid(&lu->netid), 
+			lu->lu_name, lu->sync_point,
+			lu->lu_sess_limit, lu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+	return (len);
+}
+
+int sna_rm_get_info_remote_lu(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_plu_cb *plu;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-7s%-18s%-18s%-18s%-12s%-12s%-5s\n",
+                "plu_id", "netid.node", "netid.plu", "netid.fqcp",
+		"parallel_ss", "cnv_security", "flags");
+
+        for(plu = plu_list; plu != NULL; plu = plu->next)
+        {
+                len += sprintf(buffer + len, "%-7d%-17s%-17s%-17s%-12d%-12d%04X\n",
+			plu->proc_id, sna_pr_netid(&plu->netid), 
+			sna_pr_netid(&plu->netid_plu), 
+			sna_pr_netid(&plu->netid_fqcp),
+			plu->parallel_ss, plu->cnv_security, plu->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */
+                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_rm_get_info_mode(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_mode_cb *mode;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+        len += sprintf(buffer, "%-8s%-18s%-18s%-10s%-10s%-10s%-10s%-10s%-7s%-5s\n", 
+		"mode_id", "netid.node", 
+		"netid.plu", "mode_name", "tx_pacing", "rx_pacing",
+		"max_tx_ru", "max_rx_ru", "crypto", "flags");
+
+        for(mode = mode_list; mode != NULL; mode = mode->next)
+        {
+                len += sprintf(buffer + len, "%-8d%-17s%-17s%-8s%-10d%-10d%-10d%-10d%-7d%04X\n",
+			mode->proc_id, sna_pr_netid(&mode->netid), 
+			sna_pr_netid(&mode->netid_plu), mode->mode_name, 
+			mode->tx_pacing,
+			mode->rx_pacing, mode->max_tx_ru, mode->max_rx_ru,
+			mode->crypto, mode->flags);
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+__u8 sna_rm_create_rcb(struct sna_tcb *tcb)
+{
+	struct sna_rcb *rcb;
+
+	sna_debug(5, "sna_rm_create_rcb\n");
+        rcb = (struct sna_rcb *)kmalloc(sizeof(struct sna_rcb), GFP_ATOMIC);
+	rcb->tcb_id	= tcb->tcb_id;
+	rcb->rcb_id	= sna_rcb_system_id++;
+	tcb->rcb_id     = rcb->rcb_id;
+	rcb->hs_id	= 0;
+	rcb->bracket_id	= sna_bracket_id++;
+	rcb->session_id	= 0;
+	rcb->conversation_correlator = sna_conversation_correlator++;
+
+#ifdef NOT
+	/* This is really in the wrong place but works for now. */
+        sna_asm_assign_lfsid(rcb);
+	rcb->oaf	= tcb->oaf;
+	rcb->daf	= tcb->daf;
+#endif
+
+#ifdef NOT
+        rcb->sync       = alloc_rcb->sync;
+        rcb->security_select = alloc_rcb->security_select;
+        sna_fsm_rsb_status(S, ALLOCATE_RCB, UNDEFINED);
+#endif
+
+	memcpy(rcb->lu_name, tcb->partner_lu_name, tcb->partner_lu_name_length);
+	rcb->lu_name_length = tcb->partner_lu_name_length;
+
+	memcpy(rcb->mode_name, tcb->mode_name, tcb->mode_name_length);
+	rcb->mode_name_length = tcb->mode_name_length;
+
+	memcpy(rcb->tp_name, tcb->tp_name, tcb->tp_name_length);
+	rcb->tp_name_length = tcb->tp_name_length;
+
+	rcb->state	= FSM_RCB_STATUS_FSP;
+	rcb->next	= rcb_list;
+	rcb_list	= rcb;
+
+	return (rcb->rcb_id);
+}
+
+__u8 sna_rm_allocate_rcb(struct sna_tcb *tcb)
+{
+	__u8 rcb_id;
+
+	sna_debug(5, "sna_rm_allocate_rcb\n");
+	rcb_id = sna_rm_create_rcb(tcb);
+
+        return (rcb_id);
+}
+
+#ifdef CONFIG_RM
+
+#include <net/sna/sna_th.h>
+#include <net/sna/sna_rh.h>
+#include <net/sna/sna_ru.h>
+#include <net/sna/sna_asm.h>
+#include <net/sna/sna_mu.h>
+#include <net/sna/sna_ipc.h>
+#include <net/sna/sna_sm.h>
+#include <net/sna/sna_dfc.h>
+#include <net/sna/sna_tc.h>
+#include <net/sna/sna_hs.h>
+
+static __u8 sys_rcb_id_cnt;
+static __u8 sys_tcb_id_cnt;
+static __u8 sys_scb_id_cnt;
+static __u8 sys_bracket_id_cnt;
+static __u8 sys_correlator_cnt;
+
+static struct sna_lucb *sna_lucb_list = NULL;	/* LU CB list */
+struct sna_scb *sna_scb_list = NULL;
+struct sna_rcb *sna_rcb_list = NULL;
+struct sna_tcb *sna_tcb_list = NULL;
+
+static int sna_process_initiator_to_rm(struct sna_mu *mu);
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name);
+static int sna_activate_session_rsp_proc(struct sna_mu *mu);
+static int sna_allocate_rcb_proc(struct sna_mu *mu);
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5);
+static int sna_attach_length_chk();
+static int sna_security_chk();
+static int sna_bid_proc(struct sna_mu *mu);
+static int sna_bid_rsp_proc(struct sna_mu *mu);
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id);
+static int sna_bis_race_loser(__u8 hs_id);
+static int sna_change_sessions_proc(struct sna_mu *mu);
+static int sna_check_for_bis_reply(__u8 hs_id);
+static int sna_complete_luw_id();
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id);
+static int sna_create_rcb(struct sna_allocate_rcb *alloc_rcb,
+        struct sna_rcb_allocated *rcb_allocd);
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+        struct sna_session_info *session_info);
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp,
+        struct sna_tp *tp);
+static int sna_deactivate_free_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_deactivate_pending_sessions(unsigned char *lu_name,
+        unsigned char *mode_name);
+static int sna_dequeue_waiting_request(__u8 hs_id);
+static int sna_enqueue_free_scb(__u8 hs_id);
+static int sna_first_speaker_proc(struct sna_get_session *get_session,
+        __u8 hs_id);
+static int sna_free_session_proc(struct sna_mu *mu);
+static int sna_get_session_proc(struct sna_get_session *get_session);
+static int sna_ps_abend_proc(struct sna_mu *mu);
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id,
+        struct sna_tp *target_tp);
+static int sna_ps_termination_proc(struct sna_mu *mu);
+static int sna_purge_queued_requests(struct sna_tp *tp);
+static int sna_queue_attach_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu);
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate);
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop);
+static int sna_rtr_rq_proc(struct sna_mu *mu);
+static int sna_rtr_rsp_proc(struct sna_mu *mu);
+static int sna_security_proc(struct sna_mu *mu);
+static int sna_send_bis(__u8 hs_id);
+static int sna_send_bis_reply(__u8 hs_id);
+static int sna_send_bis_rq(__u8 hs_id);
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type,
+	__u32 sense);
+static int sna_send_rtr_proc(struct sna_mu *mu);
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id);
+static int sna_session_activated_proc(struct sna_mu *mu);
+static int sna_session_activation_polarity(unsigned char *lu_name, unsigned char *mode_name);
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated);
+static int sna_session_deactivation_polarity(unsigned char *lu_name, 
+	unsigned char *mode_name);
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id);
+static int sna_should_send_bis(__u8 hs_id);
+static int sna_start_tp_proc(struct sna_start_tp *start_tp);
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp);
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_info *info);
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, 
+	struct sna_rcb_allocated *rcb_allocd);
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, int err);
+static int sna_fsm_scb_status(int signal);
+static int sna_fsm_bis(int signal);
+static int sna_fsm_rcb_status(int signal);
+
+static int sna_process_hs_to_rm(struct sna_mu *mu)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(some_type_of_id);
+	if(scb == NULL)
+	{
+		kfree(mu);
+		return (-1);
+	}
+
+	if(fsm_bis == CLOSED)
+	{
+		switch(mu->record_type)
+		{
+			case (SNA_REC_BID):
+				sna_bid_proc(mu);
+				break;
+
+			case (SNA_REC_BID_RSP):
+				sna_bid_rsp_proc(mu);
+				break;
+
+			case (MU):
+				if(MU == FMH5)
+					sna_attach_proc(mu);
+				if(MU == FMH12)
+					sna_security_proc(mu);
+					break;
+
+			case (SNA_REC_FREE_SESSION):
+				sna_free_session_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RQ):
+				sna_rtr_rq_proc(mu);
+				break;
+
+			case (SNA_REC_RTR_RSP):
+				sna_rtr_rsp_proc(mu);
+				break;
+
+			case (SNA_REC_BIS_RQ):
+				sna_fsm_bis(r, bis_reply, bis_reply->hs_id);
+				kfree(IPS);
+				break;
+
+			default:
+				kfree(mu);
+		}
+	}
+	else
+	{
+		if(MU)
+			bm_free(FREE, mu);
+		else
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_ps_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ALLOCATE_RCB):
+			sna_allocate_rcb_proc(mu);
+			break;
+
+		case (SNA_REC_GET_SESSION):
+			sna_get_session_proc(mu);
+			break;
+
+		case (SNA_REC_DEALLOCATE_RCB):
+			rcb = sna_search_rcb(deallocate_rcb->rcb_id);
+			if(scb == NULL)
+			{
+				bracket_freed = (struct sna_bracket_freed *)kmalloc(sizeof(struct sna_bracket_freed), GFP_ATOMIC);
+				bracket_freed->bracket_id = rcb->bracket_id;
+				sna_hs(bracket_freed);
+			}
+			discard(rcb);
+			rcb_deallocated = (struct sna_rcb_deallocated *)kmalloc(sizeof(struct sna_rcb_deallocated), GFP_ATOMIC);
+			sna_ps(rcb_deallocated);
+			break;
+
+		case (SNA_REC_TERMINATE_PS):
+			sna_ps_termination_proc(mu);
+			break;
+
+		case (SNA_REC_CHANGE_SESSIONS):
+			sna_change_sessions_proc(mu);
+			break;
+
+		case (SNA_REC_RM_ACTIVATE_SESSION):
+			sna_rm_activate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_SESSION):
+			sna_rm_deactivate_session_proc(mu);
+			break;
+
+		case (SNA_REC_RM_DEACTIVATE_CONV_GROUP):
+			sna_rm_deactivate_conv_group_proc(mu);
+			break;
+
+		case (SNA_REC_UNBIND_PROTOCOL_ERROR):
+			sna_send_deactivate_session(active, unbind_protocol_error->hs_id, abnormal, unbind_protocol_error->sense);
+			break;
+
+		case (SNA_REC_ABEND_NOTIFICATION):
+			sna_ps_abend_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+static int sna_process_sm_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_ACTIVATE_SESSION_RSP):
+			sna_activate_session_rsp_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_ACTIVATED):
+			sna_session_activated_proc(mu);
+			break;
+
+		case (SNA_REC_SESSION_DEACTIVATED):
+			sna_session_deactivated_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* We will cast data to appropiate struct type below */
+static int sna_process_initiator_to_rm(struct sna_mu *mu)
+{
+	switch(mu->record_type)
+	{
+		case (SNA_REC_START_TP):
+			sna_start_tp_proc(mu);
+			break;
+
+		case (SNA_REC_SEND_RTR):
+			sna_send_rtr_proc(mu);
+			break;
+
+		case (SNA_REC_RM_TIMER_POP):
+			sna_rm_timer_deactivate_sess_proc(mu);
+			break;
+
+		default:
+			kfree(mu);
+	}
+
+	return (0);
+}
+
+/* The only etrance point for RM, we cast data into appropiate record later */
+static int sna_rm_create(int caller, struct sna_mu *mu)
+{
+	struct sna_previous_time *ptime;
+
+	ptime = sna_time();
+
+	switch(caller)
+	{
+		case (SNA_SM):
+			sna_process_sm_to_rm(mu);
+			break;
+
+		case (SNA_HS):
+			sna_process_hs_to_rm(mu);
+			break;
+
+		case (SNA_INIT):
+			sna_process_initiator_to_rm(mu);
+			break;
+
+		case (SNA_PS):
+			sna_process_ps_to_rm(mu);
+			break;
+
+		default:
+			return (-1);
+	}
+
+	return (0);
+}
+
+static int sna_activate_needed_sessions(__u8 *lu_name, __u8 *mode_name)
+{
+	struct sna_lucb *lucb;
+	struct sna_mode *mode;
+	__u8 polarity;
+
+	lucb = sna_search_lucb(lu_name);		/* ??? */
+	mode = sna_search_mode(lucb, mode_name);	/* ??? */
+
+	while((polarity = sna_session_activation_polarity(lu_name, mode_name)) 
+		!= NULL)
+	{
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+		else	/* Bidder */
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_BIDDER);
+
+	}
+
+	while((mode->active.conwinners + mode->pending.conwinners)
+		< min(mode->auto_act_limit, mode->min_conwinners))
+	{
+		polarity = sna_session_activation_polarity(lu_name, mode_name);
+		if(polarity == SNA_SESSION_FIRST_SPEAKER)
+			sna_send_activate_session(lu_name, mode_name, 
+				SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	return (0);
+}
+
+static int sna_activate_session_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_act_sess_rsp *rsp =(struct sna_act_sess_rsp *)mu->record_ptr;
+
+	if(pending_act->correlator == act_sess_rsp->sorrelator)
+	{
+		mode = pending_act->mode;
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->pending->conwinners--;
+		else
+			mode->pending->conlosers--;
+
+		mode->pending->sessions--;
+		if(act_sess_rsp->type == POS)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->active->conwinners++;
+			else
+				mode->active->conlosers++;
+			mode->active->sessions++;
+
+			sna_successful_session_activation(pending_act->lu_name, 
+				pending_act->mode_name,act_sess_rsp->sess_info);
+		}
+		else
+		{
+			sna_unsuccessful_session_activation(pending_act->lu_name,
+				pending_act->mode_name, act_sess_rsp->err_type);
+			remove_and_toss_pending_activation;
+		}
+	}
+
+	return (0);
+}
+
+static __u32 sna_attach_chk(__u8 hs_id, struct sna_fmh5 *fmh5)
+{
+	__u8 err;
+
+	if(fmh5->fmh5cmd != ATTACH)
+		return (0x1008600B);
+
+	err = sna_attach_length_chk(fmh5);
+	if(err)
+		return (err);
+
+	if(fmh5->luw_id)	/* ??? */
+	{
+		/* This is wrong/bad */
+		if(fmh5->luw_net == NULL && fmh5->lu_net != NULL)
+			return (0x10086011);
+	}
+	else
+	{
+		if(fmh5->sync_leve == SYNCPT)
+			return (0x10086011);
+	}
+
+	if(TP_is_a_local_TP)
+	{
+		switch(fmh5->sync)
+		{
+			case (NONE):
+			case (CONFIRM):
+				break;
+			case (CONFIRM | SYNCPT | BACKOUT):
+				if(RemoteLU != supportabove)
+					return (0x10086040);
+			default:
+				return (0x10086040);
+		}
+
+		if(fmh5->sync != supported_by_TP)
+			return (0x10086041);
+		if(TP_temp_disabled)
+			return (0x084B6031);
+		if(TP_perm_disabled)
+			return (0x084C0000);
+
+		err = sna_attach_security_chk(fmh5);
+		if(err)
+			return (err);
+	}
+	else
+		return (0x1008600B);
+
+	return (0x00000000);
+}
+
+/* Need better Docs to do this one */
+static int sna_attach_length_chk()
+{
+
+	return 0;
+}
+
+static int sna_security_chk()
+{
+
+	return 0;
+}
+
+static int sna_bid_proc(struct sna_mu *mu)
+{
+	struct sna_bid *bid = (struct sna_bid *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_bid_rsp *bid_rsp;
+
+	scb = sna_search_scb(bid->hs_id);	/* ??? */
+	if(FSM_BIS == BIS_RCVD || FSM_BIS == CLOSED)
+		send_deactivate_session(active, bid->hs_id, abnormal, 0x20080000);
+	else
+	{
+		mode = sna_search_mode(bid);
+		if(mode->parallel == SNA_RM_FALSE
+			&& mode->session_limit == 0
+			&& mode->drain_partner == SNA_RM_FALSE
+			&& FSM_BIS == BIS_SENT)
+		{
+			bid_rsp->rti	= NEG;
+			bid_rsp->sense	= 0x088B0000;
+			sna_hs(bid_rsp);
+		}
+		else
+		{
+			if(FSM_SCB_STATUS == FREE)
+			{
+				FSM_SCB_STATUS(R, bid, UNDEFINED);
+				if(session_is_in_free_sessino_pool)
+					scb = pull_scb_pool();
+				bid_rsp->rti	= POS;
+				bid_rsp->sense	= 0;
+				sna_hs(bid_rsp);
+				if(scb->timer_unique_id != NULL)
+				{
+					stop_timer();
+					scb->timer_unique_id = NULL;
+				}
+			}
+			else
+			{
+				if(first_speaker)
+				{
+					bid_rsp->rti 	= NEG;
+					bid_rsp->sense 	= 0x08130000;
+					sna_hs(bid_rsp);
+					if(sense_code == 0x08140000)
+					{
+						Remember_LU_stuff;
+					}
+				}
+				else
+					send_deactivate_session(active, 
+						bid->hs_id,abnormal,0x20030000);
+			}
+		}
+	}
+
+	bm_free(FREE, bid);
+
+	return (0);
+}
+
+static int sna_bid_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_bid_rsp *rsp = (struct sna_bid_rsp *)mu->record_ptr;
+	struct sna_session_allocated *sallocated;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	if(rsp->rti == NEG && rsp->sense == 0x88B0000)
+	{
+		if(parallel != supported)
+		{
+			mode->conwinners 	= 0;
+			mode->conlosers 	= 0;
+			mode->sessions 		= 0;
+			send_deactivate_session(active, rsp->hs_id, cleanup, 0);
+		}
+		else
+			send_deactivate_session(active, rsp->hs_id, abnormal, 0x20100000);
+	}
+	else
+	{
+		rcb = sna_search_rcb(PENDING_SCB, rsp->hs_id);
+		if(rsp->rti == POS)
+		{
+			sna_set_rcb_and_scb_fields(rcb->rcb_id, rsp->hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, rsp->hs_id, reply);
+			scb = sna_search_scb(hs);
+
+			sallocated->rcode 		= OK;
+			sallocated->send_ru_size 	= scb->send_ru_size;
+			sallocated->limit_buf_pool_id 	=scb->limit_buf_pool_id;
+			sallocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+			sallocated->in_conver		= SNA_RM_TRUE;
+
+			sna_ps(sallocated);
+		}
+		else
+		{
+			rcb->hs_id = NULL;
+			sna_fsm_rcb_status(R, NEG_BID_RSP, UNDEFINED);
+			if(rsp->sense == 0x08140000)
+				remember_LU_owes_rtr;
+			
+			get_session = rcb->get_session;
+			sna_get_session_proc(get_session);
+		}
+	}
+
+	return (0);
+}
+
+static int sna_bidder_proc(struct sna_get_session *get_session, __u8 hs_id)
+{
+	struct sna_rcb *rcb;
+	struct sna_bid_without_attach *bid_wo_attach;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	rcb->hs_id = hs_id;
+
+	sna_fsm_rcb_status = FSM_RCB_STATUS_BIDDER;
+	rcb->session_parms_ptr = get_session;
+
+	sna_hs(bid_wo_attach);
+
+	return (0);
+}
+
+static int sna_bis_race_loser(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->pending.conwinners--;
+	else
+		mode->pending.conlosers--;
+
+	sna_hs(bis_reply);
+	close = sna_session_deactivation_polarity(mode->lu_name,
+		mode->mode_name);
+
+	if(close == EITHER)
+	{
+		sna_send_bis_rq(hs_id);
+		remove_from_free_sess_pool;
+	}
+
+	return (0);
+}
+
+static int sna_change_sessions_proc(struct sna_mu *mu)
+{
+	struct sna_change_sessions *chg_sess = (struct sna_change_sessions *)mu->record_ptr;
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+	struct sna_session_allocated *sess_allocd;
+
+	if(chg_sess->rsp == SNA_RM_TRUE)
+	{
+		mode = sna_search_mode(chg_sess->lu_name, chg_sess->mode_name);
+		conwinners = mode->active.conwinners + mode->pending.conwinners;
+		conlosers = mode->active.conlosers + mode->pending.conlosers;
+		old_slimit = mode->max_sessions - chg_sess->delta;
+		plateau = min(mode->active.sessions + mode->pending.sessions, old_slimit);
+		conwinner_incr = max(0, mode->min_conwinners - conwinners);
+		session_decr = max(0, plateau - mode->max_sessions);
+		conloser_incr = max(0, mode->min_conlosers - conlosers);
+		need_to_activate = conwinner_incr + conloser_incr;
+		room_for_activation = max(0, mode->max_sessions - plateau);
+		decrement_for_polarity = max(0, need_to_activate - room_for_activation);
+		mode->termination_cnt = mode->termination_cnt + session_decr + decrement_for_polarity;
+
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_pending_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+		if(mode->termination_cnt > 0)
+		{
+			sna_deactivate_free_sessions(chg_sess->lu_name, 
+				chg_sess->mode_name);
+		}
+	}
+
+	if((mode->sessions == 0 && mode->drain_self == SNA_RM_FALSE)
+		|| (mode->active.sessions - (mode->pending.conwinners + mode->pending.conlosers) == 0))
+	{
+		struct sna_get_session *get_session;
+
+		while((get_session = sna_get_waiting_sessions(chg_sess->lu_name, chg_sess->mode_name)) != NULL)
+		{
+			struct sna_session_allocated *sallocated;
+			sallocated->rcode = UNSUCCESSFUL_NO_RETRY;
+			sna_ps(sallocated);
+			bm_free(FREE, get_session);
+		}
+	}
+
+	sna_activate_needed_sessions(chg_sess->lu_name, chg_sess->mode_name);
+
+	return (0);
+}
+
+static int sna_check_for_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if(mode->drain_self == SNA_RM_FALSE 
+		|| (sna_get_waiting_gsess(mode->lu_name,mode->mode_name)==NULL))
+	{
+		if(sess_free_brackets(hs_id))
+		{
+			sna_send_bis_reply(hs_id);
+			remove_from_free_sess_pool;
+		}
+	}
+
+	return (0);
+}
+
+/* Need to create an IBM S/370 time structure to complete function */
+static int sna_complete_luw_id()
+{
+
+	return 0;
+}
+
+static int sna_connect_rcb_and_scb(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	rcb = sna_search_rcb(rcb_id);
+
+	rcb->session_id = scb->session_id;
+	scb->bracket_id = rcb->bracket_id;
+
+	hs_ps_connected->bracket_id 	= rcb->bracket_id;
+	hs_ps_connected->ps_id 		= rcb->tcb_id;
+
+	sna_hs(hs_ps_connected);
+
+	return (0);
+}
+
+static int sna_create_scb(unsigned char *lu_name, unsigned char *mode_name,
+				struct sna_session_info *session_info)
+{
+	struct sna_scb *scb;
+
+	scb = (struct sna_scb *)kmalloc(sizeof(scb), GFP_ATOMIC);
+	scb->hs_id 		= session_info->hs_id;
+	scb->lu_name 		= lu_name;
+	scb->mode_name		= mode_name;
+	scb->rcb_id		= 0;
+	scb->session_id		= session_info->session_id;
+	scb->send_ru_size 	= session_info->send_ru_size;
+	scb->limit_buf_pool_id	= session_info->limit_buf_pool_id;
+	scb->perm_buf_pool_id 	= session_info->perm_buf_pool_id;
+	scb->bracket_id		= 0;
+	scb->random		= session_info->random;
+	scb->limit_resource 	= session_info->limit_resource;
+	scb->timer_unique_id 	= 0;
+	scb->conversation.gid	= conv_gid++;
+
+	if(session_info->bracket_type == SNA_SESSION_FIRST_SPEAKER)
+	{
+		sna_fsm_bis(FSM_BIS_FSP);
+		sna_fsm_scb_status(FSM_SCB_STATUS_FSP);
+		scb->first_speaker = SNA_RM_TRUE;
+	}
+
+	if(session_info->bracket_type == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_bis(FSM_BIS_BIDDER);
+		sna_fsm_scb_status(FSM_SCB_STATUS_BIDDER);
+		scb->first_speaker = SNA_RM_FALSE;
+	}
+
+	return (0);
+}
+
+static int sna_create_tcb_and_ps(struct sna_start_tp *start_tp, 
+	struct sna_tp *tp)
+{
+	struct sna_tcb *tcb;
+	struct sna_ps_create_parms *ps_create_parms;
+	int err;
+
+	tcb = (struct sna_tcb *)kmalloc(sizeof(tcb), GFP_ATOMIC);
+	tcb->tcb_id		= tcb_id++;
+	tcb->tp_name		= start_tp->tp_name;
+	tcb->own_lu_id		= lucb->lu_id;
+	tcb->luw_id.fq_lu_name 	= start_tp->fq_lu_name;
+	sna_complete_luw_id(tcb);
+	tcb->ctrl_cmpnt	= tp;
+
+	/* Shrink these once I know which way is up */
+	if(start_tp->security.user_id != NULL)
+		tcb->security.user_id = start_tp->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+	if(start_tp->security.profile != NULL)
+		tcb->security.profile = start_tp->security.profile;
+	else
+		rcb->security.profile = NULL;
+
+	ps_create_parms = (struct sna_ps_create_parms *)kmalloc(sizeof(ps_create_parms), GFP_ATOMIC);
+
+	/* INITILIZE PS_CREATE_PARMS !!! */
+	err = sna_ps_creation_proc(ps_create_parms);
+	if(err)
+	{
+		bm_free(FREE, tcb);
+		start_tp->tcb_id = NULL;
+	}
+
+	tp->tp_cnt++;
+	start_tp->tcb_id = tcb->tcb_id;
+
+	return (0);
+}
+
+static int sna_deactivate_free_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_scb *scb;
+
+	/* XXXX */
+	while(free_session)
+	{
+		polarity = sna_session_deactivation_polarity(lu_name,mode_name);
+		scb = sna_search_scb(lu_name, mode_name);
+		remove_from_free_session_pool;
+		sna_send_bis(scb->hs_id);
+	}
+
+	return (0);
+}
+
+/* Saving it for a little later, when fsp functions firm up */
+static int sna_deactivate_pending_sessions(unsigned char *lu_name, 
+	unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(mode_name);
+
+	return (0);
+}
+
+static int sna_dequeue_waiting_request(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_get_session *get_session;
+
+	mode = sna_search_mode(hs_id);
+	if((get_session = sna_get_waiting_gsess(hs_id)) != NULL)
+	{
+		/* Remove from waiting queue */
+
+		sna_get_session_proc(get_session);
+	}
+
+	return (0);
+}
+
+static int sna_enqueue_free_scb(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(hs_id);
+	if(nobody_is_using_this_scb)
+	{
+		if(timer_is_to_be_set)
+			start_timer(scb->timer);
+		scb->timer_unique_id = timer_id++;
+	}
+	put_scb_in_free_pool(scb);	/* ??? */
+
+	return (0);
+}
+
+static int sna_first_speaker_proc(struct sna_get_session *get_session, 
+	__u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *session_allocd;
+
+	sna_set_rcb_and_scb_fields(get_session->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get_session->rcb_id, hs_id);
+
+	session_allocd = (struct sna_session_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+	session_allocd->rcode = OK;
+
+	scb = sna_search_scb(hs_id);
+	session_allocd->send_ru_size		= scb->send_ru_size;
+	session_allocd->limit_buf_pool_id	= scb->limit_buf_pool_id;
+	session_allocd->perm_buf_pool_id	= scb->perm_buf_pool_id;
+	session_allocd->in_conver 		= SNA_RM_FALSE;
+
+	sna_ps(session_allocd);
+
+	return (0);
+}
+
+static int sna_free_session_proc(struct sna_mu *mu)
+{
+	struct sna_free_session *free = (struct sna_free_session *)mu->record_ptr;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_rtr_rq *rtr_rq;
+	struct sna_bracket_freed *bracket_freed;
+	struct sna_get_session *get_session;
+	int send_now;
+
+	scb = sna_search_scb(free->hs_id);
+	rcb = sna_search_rcb(scb->rcb_id);
+
+	if(rcb == NULL)
+	{
+		bracket_freed = (struct sna_bracket_freed *)kmalloc(sizeof(bracket_freed), GFP_ATOMIC);
+		bracket_freed->bracket_id = scb->bracket_id;
+		sna_hs(bracket_freed);
+	}
+
+	scb->rcb_id = NULL;
+	if(sna_fsm_scb_status() == PENDING_FMH12)
+	{
+		sna_send_deactivate_session(active, scb->hs_id, abnormal, 0x080F6051);
+		return (-1);
+	}
+	else
+		sna_fsm_scb_status(R, FREE_SESSION, UNDEFINED);
+
+	if(sna_fsm_rcb_status() == PENDING_SCB && rcb->hs_id == scb->hs_id)
+		return (0);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE)
+		{
+			if(no_get_session_rqs_waiting)
+			{
+				if(rtr_is_to_be_sent_now)
+				{
+					sna_hs(rtr_rq);
+					scb->rtr_owed = SNA_RM_FALSE;
+				}
+				else
+					sna_enqueue_free_scb(scb->hs_id);
+				return (0);
+			}
+			else
+				return (0);
+		}
+	}
+
+	send_now = sna_should_send_bis(scb->hs_id);
+	if(send_now)
+		sna_send_bis(scb->hs_id);
+	if(sna_fsm_bis() == BIS_SENT || sna_fsm_bis() == CLOSED)
+		return (0);
+	else
+	{
+		sna_enqueue_free_scb(scb->hs_id);
+		if(get_sessions_waiting)
+			sna_dequeue_waiting_request(scb->hs_id);
+	}
+
+	bm_free(FREE, free_session);
+
+	return (0);
+}
+
+static int sna_get_session_proc(struct sna_get_session *get_session)
+{
+	struct sna_mode *mode;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_partner_lu *partner_lu;
+	struct sna_session_allocated *session_allocd;
+
+	rcb = sna_search_rcb(get_session->rcb_id);
+	partner_lu = search_plu(rcb->lu_name);
+	mode = search_mode(rcb->lu_name, rcb->mode_name);
+
+	if(mode == NULL)	/* ??? */
+	{
+		session_allocd = (struct sna_session_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+		session_allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+		sna_ps(session_allocd);
+		bm_free(FREE, get_session);
+	}
+	else
+	{
+		if(sync_level_not_supported)
+		{
+			session_allocd = (struct sna_sessino_allocated *)kmalloc(sizeof(session_allocd), GFP_ATOMIC);
+			session_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+			sna_ps(session_allocd); /* ??? */
+			bm_free(get_session);
+		}
+
+		if(free_session_exists)
+		{
+			scb = sna_search_scb(free_session);
+			if(scb->first_speaker == SNA_RM_TRUE)
+			{
+				sna_first_speaker_proc(get_session, scb->hs_id);
+				bm_free(FREE, get_session);
+			}
+			else
+				sna_bidder_proc(get_session, scb->hs_id);
+			Remove_session_from_free_sess_pool;
+
+			if(scb->timer_unique_id != NULL)
+			{
+				remove_timer(scb->timer);
+				scb->timer_unique_id = NULL;
+			}
+		}
+		else
+		{
+			if(get_session_requests >= pending_active_sess_requests)
+			{
+				polarity = sna_session_activation_polarity(rcb->lu_name, rcb->mode_name);
+				switch(polarity)
+				{
+					case (SNA_SESSION_NONE):
+						if(partner_lu->parallel == SNA_RM_FALSE
+							&& active_session_for_another_mode == SNA_RM_TRUE)
+						{
+							if(session_is_free)
+							{
+								scb = sna_search_scb(free_session);
+								remove_from_free_session_pool;
+								sna_send_bis(scb->hs_id);
+								if(scb->timer_unique_id != NULL)
+								{
+									remove_timer(scb->timer);
+									scb->timer_unique_id = NULL;
+								}
+							}
+						}
+						break;
+
+					case (SNA_SESSION_FIRST_SPEAKER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_FIRST_SPEAKER);
+						break;
+
+					case (SNA_SESSION_BIDDER):
+						sna_send_activate_session(rcb->lu_name, rcb->mode_name, SNA_SESSION_BIDDER);
+						break;
+				}
+			}
+
+			sna_queue_get_session(get_session);	/* ??? */
+		}
+	}
+
+	return (0);
+}
+
+static int sna_ps_abend_proc(struct sna_mu *mu)
+{
+	struct sna_abend_notify *abend 
+		= (struct sna_abend_notify *)mu->record_ptr;
+	struct sna_tcb *tcb;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mu *mu;
+	struct sna_start_tp *tp;
+	struct sna_mode *mode;
+	struct sna_deactivate_session *deactivate_session;
+
+	tcb = sna_search_tcb(abend);
+	sna_destroy_queued_get_sessions(abend);
+	if(tcb != NULL)
+	{
+		for(each_rcb_associated_w_abended_PS;;)
+		{
+			if(sna_fsm_rcb_status() == FREE)
+				mode = sna_search_mode(rcb->lu_name, rcb->mode_name);
+			if(sna_fsm_rcb_status() == IN_USE 
+				|| sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				scb = sna_search_scb(rcb->hs_id);
+				bm_free(FREE, rcb);
+				if(scb != NULL)
+				{
+					deactivate_session = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate_session), GFP_ATOMIC);
+					deactivate_session->status = ACTIVE;
+					deactivate_session->hs_id = scb->hs_id;
+					deactivate_session->type = ABNORMAL;
+					deactivate_session->sense = 0x08640000;
+					sna_sm(deactivate_session);	/* ?? */
+
+					session_deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(session_deactivated), GFP_ATOMIC);
+					session_deactivated->hs_id = scb->hs_id;
+					session_deactivated->reason = ABNORMAL;
+					session_deactivated->sense = 0x08640000;
+					sna_session_deactivated_proc(session_deactivated);
+				}
+			}
+		}
+
+		tp = sna_search_tp(tcb->tp_name);
+		if(tp != NULL)
+		{
+			tp->tp_cnt--;
+			if(init_req_queued_for_tp && tp->tp_cnt < tp->max_tp)
+			{
+				remove_init_req_from_queue;
+				if(init_req_is_an_mu(containing_attach)
+				{
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					mu->layer.hs_to_rm.hs_id = rcb->hs_id;
+					scb = sna_search_rcb(rcb->hs_id);
+					sna_fsm_scb_status(r, free_session, undefined);
+					sna_fsm_scb_status(r, bid, undefined);
+					scb->bracket_id = NULL;
+					scb->rcb_id = NULL;
+					destroy_rcb(rcb);
+					sna_attach_proc(mu);
+				}
+
+				if(queued_init_req == START_TP)
+					sna_start_tp_proc(start_tp);
+			}
+		}
+	}
+
+	destroy_tcb(tcb);
+
+	return (0);
+}
+
+static int sna_ps_creation_proc(struct sna_mu *mu, __u8 *tcb_id, __u8 *rcb_id, 
+	struct sna_tp *target_tp)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_tcb *tcb;
+	struct sna_lucb *lucb;
+
+	tcb = (struct sna_tcb *)kmalloc(sizeof(tcb), GFP_ATOMIC);
+	tcb->tcb_id 	= sys_tcb_id_cnt++;
+	tcb->tp_name 	= mu->attach.tp_name;
+	tcb->ctrl_cmpnt = tp;
+	tcb->own_lu_id	= lucb->lu_id;
+
+	/* Colapse these later */
+	if(attach->security.user_id != NULL)
+		tcb->security.user_id = attach->security.user_id;
+	else
+		tcb->security.user_id = NULL;
+
+	if(attach->security.profile != NULL) 
+		tcb->security.profile = attach->security.profile;
+	else
+		tcb->security.profile = NULL;
+
+	if(attach->luw_id != NULL)
+		tcb->luw_id = attach->luw_id;
+	else
+	{
+		tcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+		sna_complete_luw_id(tcb);
+	}
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	rcb = (struct sna_rcb *)kmalloc(sizeof(rcb), GFP_ATOMIC);
+	rcb->rcb_id 	= sys_rcb_id_cnt++;
+	rcb->tcb_id 	= tcb->tcb_id;
+	rcb->lu_name 	= scb->lu_name;
+	rcb->mode_name 	= scb->mode_name;
+	rcb->tp_name 	= attach->tp_name;
+	rcb->bracket_id = sys_bracket_id_cnt++;
+	rcb->sync_level = attach->sync;
+	rcb->hs_to_ps_buffer_list = NULL;
+
+	if(attach->conversation != NULL)
+		rcb->conversation = attach->conversation;
+	else
+		rcb->conversation = NULL;
+
+	if(first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+
+	sna_fsm_rcb_status(r, attach, hs);
+	rcb->hs_id = mu->layer.hs_to_rm.hs_id;
+
+	/* Initlize PS_CREATE_PARMS */
+
+	if(ps != NULL)
+	{
+		create_rc = SUCCESS;
+		if(tp != NULL)
+			tp->tp_cnt++;
+	}
+	else
+	{
+		create_rc = FAILURE;
+		bm_free(FREE, tcb);
+		bm_free(FREE, rcb);
+	}
+
+	return (0);
+}
+
+static int sna_ps_termination_proc(struct sna_mu *mu)
+{
+	struct sna_terminate_ps *term_ps = (struct sna_terminate_ps *)mu->record_ptr;
+	struct sna_lucb *lucb;
+	struct sna_tp *tp;
+	struct sna_mu *mu;
+	struct sna_start_tp *start_tp;
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_hs_ps_connected *hs_ps_connected;
+	struct sna_tcb *tcb;
+	struct sna_rcb *rcb;
+
+	tcb = sna_search_tcb(term_ps);
+	tp  = sna_search_tp(term_ps);
+	if(tp != sna_NULL)
+	{
+		if(queued_init_req(tp) == SNA_RM_TRUE 
+			&& tp->max_tp != tp->tp_cnt)
+		{
+			switch(first_queued_req_rec_type)
+			{
+				case (MU_ATTACH):
+					mu->layer.rm_to_ps.tcb_id = tcb->tcb_id;
+					tcb->ctrl_cmpnt = tp;
+					if(attach->security != NULL)
+						tcb->security = attach->security;
+					if(attach->luw_id != NULL)
+						tcb->luw_id = attach->luw_id;
+					else
+					{
+						rcb->luw_id.fq_lu_name = lucb->fq_lu_name;
+						sna_complete_luw_id(tcb);
+					}
+
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					rcb->tcb_id = tcb->tcb_id;
+					hs_ps_connected = (struct hs_ps_connected *)kmalloc(sizeof(hs_ps_connected), GFP_ATOMIC);
+					hs_ps_connected->bracket_id = rcb->bracket_id;
+					hs_ps_connected->ps_id = rcb->tcb_id;
+
+					sna_hs(hs_pd_connected);
+					err = sna_ps(mu);
+					if(err < 0)
+						bm_free(FREE, mu);
+					break;
+
+				case (START_TP):
+					start_tp->tcb_id = tcb->tcb_id;
+					tcb->luw_id.fq_lu_name = start_tp->fq_lu_name;
+					sna_complete_luw_id(tcb);
+					tcb->ctrl_cmpnt = tp;
+					if(start_tp->security_select 
+						== SNA_SECURITY_PGM)
+					{
+						tcb->security = start_tp->security;
+					}
+					else
+						tcb->security = NULL;
+
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = OK;
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+						send_to_caller(start_tp_reply);
+					}
+					break;
+			}
+		}
+	}
+	else
+	{
+		tp->tp_cnt--;
+		destroy_tcb(tcb);
+		destroy_ps(terminate_ps);
+	}
+
+	bm_free(terminate_ps);
+
+	return (0);
+}
+
+static int sna_purge_queued_requests(struct sna_tp *tp)
+{
+	struct sna_start_tp_reply *start_tp_reply;
+	struct sna_start_tp *start_tp;
+	struct sna_mu *mu;
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+	struct sna_deactivate_session *deactivate_session;
+	struct sna_session_deactivated *session_deactivated;
+
+	if(tp != NULL)
+	{
+		while((request_type = get_wait_reqs(tp)) != NULL)
+		{
+			switch(request_type)
+			{
+				case (MU_ATTACH):
+					rcb = sna_search_rcb(mu->layer.rm_to_ps.rcb_id);
+					scb = sna_search_scb(rcb->hs_id);
+
+					destroy_rcb(rcb);
+					bm_free(FREE, mu);
+					if(scb != NULL)
+					{
+						deactivate_session = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate_session), GFP_ATOMIC);
+						deactivate_session->status = ACTIVE;
+						deactivate_session->hs_id = scb->hs_id;
+						deactivate_session->type = ABNORMAL;
+						deactivate_session->sense = 0x08640000;
+
+						sna_sm(deactivate_session);
+						session_deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(session_deactivated), GFP_ATOMIC);
+						session_deactivated->hs_id = scb->hs_id;
+						session_deactivated->reason = ABNORMAL_RETRY;
+						session_deactivated->sense = 0x08640000;
+						sna_session_deactivated_proc(session_deactivated);
+					}
+					break;
+
+				case (START_TP):
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						start_tp_reply->tcb_id = NULL;
+						send_tp_init_proc(start_tp_reply);
+					}
+
+					destroy_start_tp(start_tp);
+					break;
+			}
+		}
+	}
+
+
+	return (0);
+}
+
+static int sna_queue_attach_proc(struct sna_mu *mu)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	rcb = (struct sna_rcb *)kmalloc(sizeof(rcb), GFP_ATOMIC);
+	rcb->rcb_id 		= sys_rcb_id_cnt++;
+	rcb->tcb_id 		= NULL;
+	rcb->tp_name 		= mu->fmh5->tp_name;
+	rcb->hs_id 		= mu->layer.hs_to_rm.hs_id;
+	rcb->bracket_id 	= sys_bracket_id_cnt++;
+	rcb->sync 		= mu_fmh5->sync;
+	rcb->hs_buffer_list 	= NULL;
+
+	if(mu->fsmh5.conversation != NULL)
+		rcb->conversation = mu->fmh5.conversation;
+	else
+		rcb->conversation = NULL;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	rcb->lu_name 		= scb->lu_name;
+	rcb->mode_name 		= scb->mode_name;
+
+	if(scb->first_speaker == SNA_RM_TRUE)
+		sna_fsm_rcb_status(FSM_RCB_STATUS_FSP);
+	else
+		sna_fsm_rcb_status(FSM_RCB_STATUS_BIDDER);
+	sna_fsm_rcb_status(r, attach, hs);
+
+	scb->bracket_id 	= rcb->bracket_id;
+	scb->rcb_id		= rcb->rcb_id;
+	rcb->conversation.gid	= scb->conversation.gid;
+	rcb->session_id		= scb->session_id;
+	sna_fsm_scb_status(r,
+
+	mu->layer.rm_to_ps.rcb_id		=
+	mu->layer.rm_to_ps.send_ru_size
+	mu->layer.rm_to_ps.limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	mu->layer.rm_to_ps.perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	mu->layer.rm_to_ps.sense		= 0;
+
+	queue_attach_mu(mu);	/* What about rcb ?? */
+
+	return (0);
+}
+
+static int sna_rm_deactivate_conv_group_proc(struct sna_mu *mu)
+{
+	struct sna_rm_deactivate_conv_group *rm_dact_conv_group
+		= (struct sna_rm_deactivate_conv_group *)mu->record_ptr;
+	struct sna_rm_deactivate_session *rm_deactivate;
+	struct sna_scb *scb;
+
+	while((scb = sna_search_scb_gid(rm_dact_conv_group->gid)) != NULL)
+	{
+		rm_deactivate = (struct sna_rm_deactivate_session *)kmalloc(sizeof(rm_deactivate), GFP_ATOMIC);
+		rm_deactivate->tcb_id 		= NULL;
+		rm_deactivate->session_id 	= scb->hs_id;
+		rm_deactivate->type 		= rm_dact_conv_group->type;
+		rm_deactivate->sense		= rm_dact_conv_group->sense;
+
+		sna_rm_deactivate_session_proc(rm_deactivate);
+	}
+
+	destroy_rm_dact_conv_group(rm_dact_conv_group);
+
+	return (0);
+}
+
+static int sna_rm_deactivate_session_proc(struct sna_rm_deactivate_session *rm_deactivate)
+{
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rm_deactivate->session_id);
+	if(scb != NULL)
+	{
+		switch(rm_deactivate->type)
+		{
+			case (CLEANUP):
+				sna_send_deactivate_session(ACTIVE, rm_deactivate->session_id, CLEANUP, rm_deactivate);
+				kfree(rm_deactivate);
+				break;
+
+			case (NORMAL):
+				if(session_in_free_session_pool)
+				{
+					if(sna_fsm_bis() != BIS_SENT)
+						queue_deact(rm_deactivate);
+					else
+						kfree(rm_deactivate);
+				}
+				else
+				{
+					queue_deact(rm_deactivate);
+					sna_send_bis_rq(hs_id);
+					remove_from_free_pool(hs_id);
+				}
+				break;
+		}
+	}
+	else
+		kfree(rm_deactivate);
+
+	return (0);
+}
+
+static int sna_rm_timer_deactivate_session_proc(struct sna_rm_timer_pop *rm_timer_pop)
+{
+	struct sna_scb *scb;
+	struct sna_mode *mode;
+	struct sna_rm_deactivate_session *rm_deactivate;
+
+	mode = sna_search_mode(rm_timer_pop->lu_name, rm_timer_pop->mode_name);
+	scb = sna_search_scb(rm_timer_pop->unique_id);
+	if(scb != NULL)
+	{
+		if(scb_in_free_ses_pool && scb->first_speaker == SNA_RM_TRUE
+			&& mode->active.conwinners + mode->pending.conwinners 
+			> mode->auto_activate_limit)
+		{
+			rm_deactivate = (struct sna_rm_deactivate_session *)kmalloc(sizeof(rm_deactivate), GFP_ATOMIC);
+			rm_deactivate_session_proc(rm_deactivate);
+		}
+	}
+
+	kfree(rm_timer_pop);
+
+	return (0);
+}
+
+static int sna_rtr_rq_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rq *rtr_rq = (struct sna_rtr_rq *)mu->record_ptr;
+	struct sna_get_session *get_session;
+	struct sna_rtr_rsp *rtr_rsp;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(rtr_rq);
+	if(scb->rtr_owed == SNA_RM_TRUE)
+	{
+		if((get_session = get_waiting_get_session()) != NULL)
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			rtr_rsp = (struct sna_rtr_rsp *)kmalloc(sizeof(rtr_rsp), GFP_ATOMIC);
+			rtr_rsp->rti = POS;
+			rtr_rsp->sense = 0x00000000;
+			sna_hs(rtr_rsp);
+			remove_get_session_wait(get_session);
+			sna_get_session_proc(get_session);
+		}
+		else
+		{
+			rtr_rsp = (struct sna_rtr_rsp *)kmalloc(sizeof(rtr_rsp), GFP_ATOMIC);
+			rtr_rsp->rti = NEG;
+			rtr_rsp->sense = 0x8190000;
+			send_to_hs(rtr_rsp);
+			bis_send = sna_should_send_bis(rtr_rq->hs_id);
+			if(bis_send != NULL)
+				sna_send_bis(rtr_rq->hs_id);
+			else
+				sna_enqueue_free_scb(scb->hs_id);
+		}
+		scb->rtr_owed = SNA_RM_FALSE;
+	}
+	else
+		sna_send_deactivate_session(ACTIVE, rtr_rq->hs_id, ABNORMAL, 0x2003000);
+
+	return (0);
+}
+
+static int sna_rtr_rsp_proc(struct sna_mu *mu)
+{
+	struct sna_rtr_rsp *rtr_rsp = (struct sna_rtr_rsp *)mu->record_ptr;
+
+	if(rtr_rsp->rti == NEG && fsm_bis == RESET)
+	{
+		bis_send = sna_should_send_bis(rtr_rsp->hs_id);
+		if(bis_send != NULL)
+			sna_send_bis(rtr_rsp->hs_id);
+		else
+		{
+			sna_enqueue_free_scb(scb->hs_id);
+			sna_dequeue_waiting_req(rtr_rsp->hs_id);
+		}
+	}
+
+	kfree(rtr_rsp);
+
+	return (0);
+}
+
+static int sna_security_proc(struct sna_mu *mu)
+{
+	struct sna_lucb *lucb;
+	struct sna_scb *scb;
+
+	scb = sna_search_scb(mu->layer.hs_to_rm.hs_id);
+	remove_random_data();
+
+	if(sna_fsm_scb_status() != PENDING_FMH12
+		|| fmh12->length != 10
+		|| fmh12->security_reply != expected)
+	{
+		sna_send_deactivate_session(ACTIVE, scb->hs_id, ABNORMAL, 
+			0x080F6051);
+	}
+	else
+		sna_fsm_scb_status(R, FMH_12, UNDEFINED);
+
+	bm_free(FREE_BUFFER, mu);
+
+	return (0);
+}
+
+static int sna_send_bis(__u8 hs_id)
+{
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			sna_send_bis_rq(hs_id);
+			break;
+
+		case (BIS_RCVD):
+			sna_send_bis_reply(hs_id);
+			break;
+
+		default:
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_bis_reply(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_reply *bis_reply;
+
+	sna_fsm_bis(s, BIS_REPLY, hs_id);
+
+	bis_reply = (struct sna_bis_reply *)kmalloc(sizeof(bis_reply), GFP_ATOMIC);
+	send_to_hs(bis_reply);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == FREE_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlosers++;
+
+	return (0);
+}
+
+static int sna_send_bis_rq(__u8 hs_id)
+{
+	struct sna_mode *mode;
+	struct sna_bis_rq *bis_rq;
+
+	bis_rq = (struct sna_bis_rq *)kmalloc(sizeof(bis_rq), GFP_ATOMIC);
+	sna_send_to_hs(bis_rq);
+
+	sna_fsm_bis(s, bis_rq, hs_id);
+
+	mode = sna_search_mode(hs_id);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->termination.conwinners++;
+	else
+		mode->termination.conlossers++;
+
+	if(pending_cnos(hs_id))
+		discard_all_queued(rm_deactivate_session);
+	else
+		mode->termnination.sessions--;
+
+	return (0);
+}
+
+static int sna_send_deactivate_session(__u8 status, __u8 correlator, __u8 type, 
+	__u32 sense)
+{
+	struct sna_pending_activation *pending;
+	struct sna_deactivate_session *deactivate;
+	struct sna_session_deactivated *deactivated;
+	struct sna_mode *mode;
+	struct sna_scb *scb;
+
+	switch(status)
+	{
+		case (PENDING):
+			pending = sna_search_pending(correlator);
+			if(pending != NULL)
+			{
+				deactivate = (struct sna_deactivate_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+				deactivate->status 	= PENDING;
+				deactivate->correlator 	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+				send_to_sm(deactivate);
+
+				mode = sna_search_mode();
+				mode->pending.sessions--;
+
+				kfree(pending_activation);
+
+				if((mode->active.sessions + mode->pending.sessions) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						session_allocated = (struct sna_session_allocated *)kmalloc(sizeof(session_allocated), GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+
+				if((mode->active.conwinners + mode->pending.conwinners) == 0)
+				{
+					while((get_session = get_waiting_gsessions()) != NULL)
+					{
+						if(get_session->type != CONWINNER)
+						{
+							continue;
+						}
+
+						session_allocated = (struct sna_session_allocated *)kmalloc(sizeof(session_allocated), GFP_ATOMIC);
+						session_allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+						send_to_ps(session_allocated);
+						kfree(get_session);
+					}
+				}
+			}
+			break;
+
+		case (ACTIVE):
+			scb = sna_search_scb(correlator);
+			if(scb != NULL)
+			{
+				deactivate = (struct sna_deactiavte_session *)kmalloc(sizeof(deactivate), GFP_ATOMIC);
+				deactivate->hs_id	= correlator;
+				deactivate->type	= type;
+				deactivate->sense	= sense;
+
+				send_to_sm(deactivate_session);
+
+				deavtivated = (struct sna_session_deactivated *)kmalloc(sizeof(deactivated), GFP_ATOMIC);
+				if(type == NORMAL)
+					deactivated->reason = NORMAL;
+				else
+				{
+					deactivated->reason = ABNORMAL_NO_RETRY;
+					deactivated->sense = sense;
+				}
+				sna_session_deactivated_proc(deactivated);
+			}
+			break;
+	}
+
+	return (0);
+}
+
+static int sna_send_rtr_proc(struct sna_mu *mu)
+{
+	struct sna_send_rtr *send_rtr = (struct sna_send_rtr *)mu->record_type;
+	struct sna_scb *scb;
+	struct sna_rtr_rq *rtr_rq;
+
+	scb = sna_search_scb(send_rtr->hs_id);
+	if(scb != NULL)
+	{
+		if(scb->first_speaker == SNA_RM_TRUE && scb_is_free)
+		{
+			rtr_rq = (struct sna_rtr_rq *)kmalloc(sizeof(rtr_rq), GFP_ATOMIC);
+			sna_send_to_hs(rtr_rq);
+
+			scb->rtr_owed = SNA_RM_FALSE;
+			remove_from_free_pool(scb);
+		}
+	}
+
+	kfree(send_rtr);
+
+	return (0);
+}
+
+static int sna_session_activated_allocation(struct sna_get_session *get, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_session_allocated *allocated;
+
+	if(session == SNA_SESSION_BIDDER)
+	{
+		sna_fsm_rcb_status(s, get_session, UNDEFINED);
+	}
+
+	sna_set_rcb_and_scb_fields(get->rcb_id, hs_id);
+	sna_connect_rcb_and_scb(get->rcb_id, hs_id, NORMAL);
+
+	scb = sna_search_scb(hs_id);
+	allocated = (struct sna_session_allocated *)kmalloc(sizeof(allocated), GFP_ATOMIC);
+	allocated->rcode 		= OK;
+	allocated->send_ru_size 	= scb->send_ru_size;
+	allocated->limit_buf_pool_id 	= scb->limit_buf_pool_id;
+	allocated->perm_buf_pool_id 	= scb->perm_buf_pool_id;
+	allocated->in_conver 		= SNA_RM_TRUE;
+
+	send_to_ps(allocated);
+
+	return (0);
+}
+
+static int sna_session_activated_proc(struct sna_mu *mu)
+{
+	struct sna_session_activated *activated
+		= (struct sna_session_activated *)mu->record_ptr;
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(activated->lu_name, activated->mode_name);
+
+	if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+		mode->active.conwinners++;
+	else
+		mode->active.conlosers++;
+
+	mode->active.sessions++;
+
+	sna_successful_session_activation(activated->lu_name, 
+		activated->mode_name, activated->session_info);
+
+	kfree(activated);
+
+	return (0);
+}
+
+static int sna_session_deactivated_proc(struct sna_session_deactivated *deactivated)
+{
+	struct sna_mu *mu;
+	struct sna_get_session *get_session;
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+	struct sna_mode *mode;
+	struct sna_partner_lu *partner;
+	struct sna_conv_failure *conv_fail;
+
+	scb = sna_search_scb(deactivated->hs_id);
+	if(scb != NULL)
+	{
+		mode = sna_search_mode(deactivated->lu_name, deactivated->mode_name);
+		if(sna_fsm_scb_status() == IN_USE)
+		{
+			if((rcb = sna_search_rcb(scb->rcb_id)) != NULL)
+			{
+				if(rcb->tcb_id != NULL)
+				{
+					conv_fail = (struct sna_conv_fail *)kmalloc(sizeof(conv_fail), GFP_ATOMIC);
+					conv_fail->rcb_id = scb->rcb_id;
+					switch(deactivated->reason)
+					{
+						case (NORMAL):
+						case (ABNORMAL_RETRY):
+							conv_fail->reason = SON;
+							break;
+
+						case (ABNORMAL_NO_RETRY):
+							conv_fail->reason = PROTO_VIOLATION;
+							break;
+					}
+					send_to_ps(conv_fail);
+				}
+				else
+				{
+					mu = search_mu(rcb->tp_name, rcb->rcb_id);
+					kfree(rcb);
+					remove_queue(mu);
+					bm_free(FREE, mu);
+				}
+			}
+		}
+		else
+			remove_from_free_sess(session);
+
+		rcb = sna_search_rcb(deactivated->hs_id);
+		if(rcb != NULL)
+		{
+			if(sna_fsm_rcb_status() == PENDING_SCB)
+			{
+				rcb->hs_id = NULL;
+				sna_fsm_rcb_status(r, NEG_BID_RSP, UNDEFINED);
+				get_session = (struct sna_get_session *)kmalloc(sizeof(get_session), GFP_ATOMIC);
+				sna_get_session_proc(get_session);
+			}
+		}
+
+		if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+			mode->active.conwinners--;
+		else
+			mode->active.conlosers--;
+		mode->active.sessions--;
+
+		if(session->pending.deactivation == SNA_RM_TRUE)
+		{
+			if(mode->polarity == SNA_SESSION_FIRST_SPEAKER)
+				mode->termination.conwinners--;
+			else
+				mode->termination.conlosers--;
+		}
+
+		if(deactivated->reason != ABNORMAL_NO_RETRY)
+			sna_activate_needed_sessions(scb->lu_name, scb->mode_name);
+
+		if((mode->active.sessions + mode->pending.sessions) == 0)
+		{
+			if(partner->parallel == SNA_RM_FALSE)
+			{
+				if(waiting_request)
+					sna_activate_needed_sessions(partner->local_lu_name, mode->name);
+			}
+
+			while((get_session = get_sessions()) != NULL)
+			{
+				allocated = (struct sna_sesssion_allocated *)kmalloc(sizeof(allocated), GFP_ATOMIC);
+				allocated->rcode = UNSUCCESSFUL_NO_RETRY;
+				send_to_ps(allocated);
+				kfree(get_session);
+			}
+
+			while((rm_activate = get_rm_activate_pend()) != NULL)
+			{
+				rm_activated = (struct sna_rm_session_activated *)kmalloc(sizeof(rm_activated), GFP_ATOMIC);
+				rm_activated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+				send_to_ps(rm_activated);
+				kfree(rm_activate);
+			}
+		}
+
+		kfree(scb);
+	}
+
+	kfree(deactivated);
+
+	return (0);
+}
+
+static int sna_session_deactivation_polarity(unsigned char *lu_name, unsigned char *mode_name)
+{
+	struct sna_mode *mode;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->term_count == 0)
+		return (DEACTIVATE);
+	conwinner_cnt = mode->active.conwinners + mode->pending.conwinners 
+		- mode->terminator.conwinners;
+	conloser_cnt = mode->active.conlosers + mode->pending.conlosers 
+		- mode->termination.conlosers;
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		mode->term_count = 0;
+		return (SNA_SESSION_NONE);
+	}
+
+	if(conwinner_cnt <= mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_BIDDER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinner
+		&& conloser_cnt <= mode->min_conlosers)
+	{
+		return (SNA_SESSION_FIRST_SPEAKER);
+	}
+
+	if(conwinner_cnt > mode->min_conwinners
+		&& conloser_cnt > mode->min_conlosers)
+	{
+		return (SNA_SESSION_EITHER);
+	}
+	
+	return (0);
+}
+
+static int sna_set_rcb_and_scb_fields(__u8 rcb_id, __u8 hs_id)
+{
+	struct sna_scb *scb;
+	struct sna_rcb *rcb;
+
+	scb = sna_search_scb(hs_id);
+	scb->rcb_id = rcb_id;
+
+	rcb = sna_search_rcb(rcb_id);
+	rcb->hs_id = hs_id;
+
+	if(rcb->first_speaker)
+	{
+		sna_fsm_scb_status(s, get_session, undefined);
+		sna_fsm_rcb_status(s, get_session, undefined);
+	}
+	else
+	{
+		sna_fsm_scb_status(r, pos_bid_rsp, undefined);
+		sna_fsm_rcb_status(r, pos_bid_rsp, undefined);
+	}
+
+	return (0);
+}
+
+static int sna_should_send_bis(__u8 hs_id)
+{
+	struct sna_partner *plu;
+	struct sna_mode *mode;
+	int polarity;
+
+	mode = sna_search_mode(hs_id);
+	plu = mode->partner;
+
+	if(!waiting_req(mode) && plu->parallel == NOT_SUPPORTED)
+	{
+		if(waiting_req(plu))
+			return (SNA_RM_TRUE);
+	}
+
+	switch(sna_fsm_bis())
+	{
+		case (RESET):
+			polarity = sna_session_deactivation_polarity(lu_name, mode_name);
+			if(polarity == SNA_SESSION_EITHER 
+				|| polarity_mode->polarity)
+			{
+				if(mode->drain_self == SNA_RM_FALSE 
+					|| !waiting_req())
+					return (SNA_RM_TRUE);
+				if(pending_rm_deactivate_session)
+					return (SNA_RM_FALSE);
+				return (SNA_RM_FALSE);
+			}
+			break;
+
+		case (BIS_RCVD):
+			if(mode->drain_self == SNA_RM_FALSE || !waiting_req())
+				return (SNA_RM_TRUE);
+			else
+				return (SNA_RM_FALSE);
+
+		case (BIS_SENT):
+			return (SNA_RM_FALSE);
+
+		default:
+			return (-ERROR);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_proc(struct sna_start_tp *start_tp)
+{
+	struct sna_tp *tp;
+	struct sna_lucb *lucb;
+	struct sna_start_tp_reply *start_tp_reply;
+	int response_code;
+
+	response_code = OK;
+	tp = sna_search_tp(start_tp->target_tp_name);
+	if(tp == NULL)
+		response_code = TPN_NOT_RECOGNIZED;
+	else
+	{
+		if(tp->status == DISABLED_TEMPORARY)
+			response_code = TRANS_PGM_NOT_AVAILABLE_RETRY;
+		if(tp->status == DISABLED_PERMANENT)
+			response_code = TRANS_PGM_NOT_AVAIL_NO_RETRY;
+		if(tp->verify_pip == SNA_RM_TRUE && response_code == OK)
+		{
+			if(start_tp->pip_subs != tp->pip_subs)
+			{
+				if(tp->pip_subs == 0)
+					response_code = PIP_NOT_ALLOWED;
+				else
+					response_code = PIP_NOT_SPECIFIED_CORRECTLY;
+			}
+		}
+
+		if(response_code == OK)
+		{
+			err = start_tp_security_valid(start_tp, tp);
+			if(err < 0)
+				response_code = SECURITY_NOT_VALID;
+		}
+
+		if(response_code == OK && start_tp->fqlu_name != NULL
+			&& start_tp->fqlu_name == Not_proper_format)
+		{
+			response_code = INVALID_FULLY_QUALIFIED_LU_NAME;
+		}
+	}
+
+	if(reponse_code == OK)
+	{
+		if(start_tp->fq_lu_name == NULL)
+			start_tp->fq_lu_name = lucb->fq_lu_name;
+
+		if(tp->tp_cnt < tp->max_tp)
+		{
+			sna_create_tcb_and_ps(start_tp, tp);
+			if(start_tp->tcb_id != NULL)
+			{
+				send_to_ps(start_tp);
+				if(start_tp->reply == SNA_RM_TRUE)
+				{
+					start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+					start_tp_reply->rcode = response_code;
+					if(response_code == OK)
+						start_tp_reply->tcb_id = start_tp->tcb_id;
+					send_tp_caller(start_tp_reply);
+				}
+				kfree(start_tp);
+			}
+			else
+			{
+				if(tp->tp_cnt > 0)
+					queue(start_tp);
+				else
+				{
+					if(start_tp->reply == SNA_RM_TRUE)
+					{
+						start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+						start_tp_reply->rcode = PS_CREATION_FAILURE;
+						send_to_init(start_tp_reply);
+					}
+					kfree(start_tp);
+					sna_purge_queued_requests(tp);
+				}
+			}
+		}
+		else
+			queue(start_tp);
+	}
+	else
+	{
+		if(start_tp->reply == SNA_RM_TRUE)
+		{
+			start_tp_reply = (struct sna_start_tp_reply *)kmalloc(sizeof(struct sna_start_tp_reply), GFP_ATOMIC);
+			start_tp_reply->rcode = response_code;
+			start_tp_reply->tcb_id = NULL;
+			send_to_init(start_tp_reply);
+		}
+		kfree(start_tp);
+	}
+
+	return (0);
+}
+
+static int sna_start_tp_security_valid(struct sna_start_tp *start_tp)
+{
+	if(start_tp->security_select == NULL)
+	{
+		if(tp_requires_security)
+			return (SNA_RM_FALSE);
+		else
+			return (SNA_RM_TRUE);
+	}
+
+	if(start_tp->security.profile != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security.passwd != NULL
+		&& start_tp->security.user_id == NULL)
+	{
+		return (SNA_RM_FALSE);
+	}
+
+	if(start_tp->security_select ==SNA_SECURITY_PGM)
+	{
+		if(start_tp->security.user_id != NULL
+			&& start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(start_tp->security.user_id == NULL
+			|| (start_tp->security.passwd == NULL
+			&& tp_requires_security))
+		{
+			return (SNA_RM_FALSE);
+		}
+
+		if(!tp requires security
+			&& (start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL))
+		{
+			return (SNA_RM_TRUE);
+		}
+
+		if(start_tp->security is bad combination)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+	else
+	{
+		if(start_tp->security.user_id == NULL
+			|| start_tp->security.passwd == NULL)
+		{
+			return (SNA_RM_FALSE);
+		}
+
+	}
+
+	if(limit_access_to_tp)
+	{
+		if(sna_access_ok(start_tp->security.user_id, 
+			start_tp->security.profile)
+		{
+			return (SNA_RM_TRUE);
+		}
+		else
+		{
+			return (SNA_RM_FALSE);
+		}
+	}
+		
+	return (SNA_RM_TRUE);
+}
+
+static int sna_successful_session_activation(unsigned char *lu_name, 
+	unsigned char *mode_name, struct sna_session_information *info)
+{
+	struct sna_scb *scb;
+	struct sna_get_session *session;
+	struct sna_session_allocated *allocd;
+	struct sna_rm_hs_connected *connected;
+	struct sna_rm_activate_sesion *activate;
+	struct sna_rm_session_activated *activated;
+
+	sna_create_scb(lu_name, mode_name, info);
+	connected = (struct sna_rm_hs_connected *)kmalloc(sizeof(struct sna_rm_hs_connected), GFP_ATOMIC);
+	sna_send_to_hs(connected);
+
+	if(info->first_speaker != SNA_RM_TRUE && plu->parallel != SNA_RM_TRUE)
+	{
+		while((session = get_wait_sessions(CONWINNER)) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+			allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			remove_from_list(allocd);
+		}
+	}
+
+	if(info->primary_hs == SNA_RM_TRUE)
+	{
+		sna_fsm_scb_status(r, activated, PRI);
+		while(activated)
+		{
+			if(session == waiting)
+			{
+				if(session->security.level != waiting_req->security.level)
+				{
+					session->security.level = NONE;
+				}
+
+				if(session->sync_level != waiting_req->sync_level)
+				{
+					allocd = (struct sna_session_allocted *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+					allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+					send_to_ps(allocd);
+					kfree(session);
+				}
+				else
+				{
+					if(scb->random != NULL)
+					{
+						sec2 = (struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_ATOMIC);
+						sec2->send_parm.allocate = NO;
+						sec2->send_parm.fmh = YES;
+						sec2->send_parm.type = FLUSH;
+						sna_send_to_hs(sec2);
+						sna_session_activated_alloc(session, scb->hs_id);
+						kfree(session);
+					}
+				}
+			}
+			else
+			{
+				sna_fsm_scb_status(s, YEILD_SESSION, undefined);
+				if(scb->random_data != NULL)
+				{
+					sec2 = (struct sna_security_reply_2 *)kmalloc(sizeof(struct sna_security_reply_2), GFP_ATOMIC);
+					sec2->send_parm.allocate = NO;
+					sec2->send_parm.fmh = YES;
+					sec2->send_parm.type = DEALLOCATE_FLUSH;
+					sna_send_to_hs(sec2);
+				}
+				else
+				{
+					yield = (struct sna_yield_session *)kmalloc(struct sna_yield_session), GFP_ATOMIC);
+					sna_send_to_hs(yield);
+				}
+			}
+		}
+	}
+	else
+	{
+		if(scb->random_data != NULL)
+			sna_fsm_scb_status(r, activated, secure);
+		else
+			sna_fsm_scb_status(r, activated, sec);
+	}
+
+	activate = sna_rm_activate_pending();
+	if(activate != NULL)
+	{
+		activated = (struct sna_rm_session_activated *)kmalloc(sizeof(struct sna_rm_session_activated), GFP_ATOMIC);
+		activated->rcode = OK;
+		kfree(activate);
+	}
+
+	return (0);
+}
+
+static int sna_test_for_free_fsp_session(struct sna_allocate_rcb *rcb_alloc, struct sna_rcb_allocated *rcb_allocd)
+{
+	struct sna_rcb *rcb;
+	struct sna_scb *scb;
+
+	if((find_fsp(rcb_alloc->lu_name, rcb_alloc->mode_name)) != NULL)
+	{
+		create_scb(rcb_alloc, rcb_allocd);
+		if(rcb->security_select != plu->security_select)
+		{
+			rcb->security_select = NONE;
+		}
+		if(rcb_alloc->sync_level != plu->sync_level)
+		{
+			rcb_allocd->rcode = SYNC_LEVEL_NOT_SUPPORTED;
+		}
+		else
+		{
+			sna_set_rcb_and_scb_field(rcb->rcb_id, hs_id);
+			sna_connect_rcb_and_scb(rcb->rcb_id, hs_id);
+			rcb_allocd->rcode = OK;
+			rcb_allocd->send_ru_size = scb->send_ru_size;
+			rcb_allocd->limit_buf_pool_id = scb->limit_buf_pool_id;
+			rcb_allocd->perm_buf_pool_id = scb->perm_buf_pool_id;
+			dequeue_fs_pool();
+		}
+	}
+	else
+		rcb_allocd->rcode = UNSUCCESSFUL;
+
+	return (0);
+}
+
+static int sna_unsuccessful_session_activation(unsigned char *lu_name, unsigned char *mode_name, int err)
+{
+	struct sna_mode *mode;
+	struct sna_session_allocated *allocd;
+
+	mode = sna_search_mode(lu_name, mode_name);
+	if(mode->active.sessions == 0 && mode->pending.sessions == 0)
+	{
+		while((waiting = waiting_req(lu_name, mode_name)) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+
+			send_to_ps(allocd);
+			kfree(waiting);
+		}
+
+		sessions = get_wait_sessions();
+		if(plu->parallel != SNA_RM_TRUE && sessions != NULL)
+		{
+			sna_activate_needed_sessions(lu_name, mode_name);
+		}
+	}
+
+	while(pending_rm_activate_reqs > mode->pending.sessions)
+	{
+		activated = (struct sna_rm_session_activated *)kmalloc(sizeof(sna_rm_session_activated), GFP_ATOMIC);
+
+		if(err == CAN_RETRY)
+			activated->rcode = ACTIVATION_FAILURE_RETRY;
+		else
+			acitvated->rcode = ACTIVATION_FAILURE_NO_RETRY;
+
+		send_to_ps(activated);
+		kfree(activate);
+	}
+
+	if((mode->active.conwinners + mode->pending.conwinners) == 0)
+	{
+		while((get_session = get_wait_sessions()) != NULL)
+		{
+			allocd = (struct sna_session_allocated *)kmalloc(sizeof(struct sna_session_allocated), GFP_ATOMIC);
+			if(err == CAN_RETRY)
+				allocd->rcode = UNSUCCESSFUL_RETRY;
+			else
+				allocd->rcode = UNSUCCESSFUL_NO_RETRY;
+			send_to_ps(allocd);
+			kfree(get_session);
+		}
+	}
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session. */
+static int sna_fsm_scb_status(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a bidder half-session with respect to BIS_RQ and
+ * BIS_REPLY.
+ */
+static int sna_fsm_bis(int signal)
+{
+
+	return (0);
+}
+
+/* To remember the status of a conversation resource associated with a bidder
+ * half-session.
+ */
+static int sna_fsm_rcb_status(int signal)
+{
+
+	return (0);
+}
+
+struct sna_rcb *sna_search_rcb(__u8 id)
+{
+	struct sna_rcb *result = NULL;
+
+	return (result);
+}
+
+struct sna_scb *sna_search_scb(__u8 id)
+{
+	struct sna_scb *result = NULL;
+
+	return (result);
+}
+
+struct sna_tcb *sna_search_tcb(__u8 id)
+{
+	struct sna_tcb *result = NULL;
+
+	return (result);
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_rss.c linux/net/sna/sna_rss.c
--- linux-2.4.4/net/sna/sna_rss.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_rss.c	Mon May 14 21:12:12 2001
@@ -0,0 +1,119 @@
+/* sna_rss.c: Linux Systems Network Architecture implementation
+ * Route Selection Services.
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Bugs:
+ * - We do no weight calculations or tree building.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_rss_request_route(struct sna_rss_route *r)
+{
+
+	return (0);
+}
+
+int sna_rss_request_single_hop_route(struct sna_rq_single_hop_route *r)
+{
+	struct sna_rq_tg_vectors *tg;
+	int err;
+
+	sna_debug(5, "sna_rss_request_single_hop_route %s.%s\n",
+		r->dst_cp_name.net, r->dst_cp_name.name);
+
+	tg = (struct sna_rq_tg_vectors *)
+		kmalloc(sizeof(struct sna_rq_tg_vectors), GFP_ATOMIC);
+	memcpy(&tg->org_cp_name, &r->dst_cp_name, sizeof(struct sna_netid));
+	err = sna_tdm_request_tg_vectors(tg);
+	if(err < 0)
+		return (err);
+
+	memset(&r->rs, 0, sizeof(struct sna_cv_rs));
+	memcpy(&r->rs.tg_desc, &tg->tg_vectors->desc, 
+		sizeof(struct sna_tg_desc));
+
+	return (0);
+}
+
+int sna_rss_obtain_tg_vectors(void)
+{
+
+	return (0);
+}
+
+int sna_rss_select_tg_vector(void)
+{
+
+	return (0);
+}
+
+int sna_rss_build_rscv(void)
+{
+
+	return (0);
+}
+
+int sna_rss_obtain_trees(void)
+{
+
+	return (0);
+}
+
+int sna_rss_update_trees(void)
+{
+
+	return (0);
+}
+
+int sna_rss_update_resource_weights(void)
+{
+
+	return (0);
+}
+
+int sna_rss_create(struct sna_start_node *start)
+{
+
+	return (0);
+}
+
+int sna_rss_destroy(struct sna_delete_node *delete)
+{
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_sm.c linux/net/sna/sna_sm.c
--- linux-2.4.4/net/sna/sna_sm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_sm.c	Mon May 14 21:12:20 2001
@@ -0,0 +1,1984 @@
+/* sna_sm.c: Linux Systems Network Architecture implementation
+ * - SNA LU 6.2 Session Manager (SM)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/sna.h>
+
+#include <linux/llc.h>
+#include <net/llc.h>
+
+static bind_state bstate = BIND_RESET;
+
+static struct sna_lulu_cb *lulu_list = NULL;
+
+struct sna_lulu_cb *sna_sm_find_lulu_fqpcid(unsigned char *pcid)
+{
+	struct sna_lulu_cb *l;
+
+	sna_debug(5, "sna_sm_find_lulu_fqpcid\n");
+	for(l = lulu_list; l != NULL; l = l->next)
+		if(!strncmp(l->fqpcid, pcid, 8))
+			return (l);
+
+	return (NULL);
+}
+
+static int sna_sm_build_bind_user_data(__u8 *start)
+{
+	int len = 0;
+	unsigned char name[17];
+	unsigned char unknown[9]={0x00,0x50,0xAA,0x12,0x46,0x2D,0xCA,0x75,0xEA};
+        __u8 l, s;
+	__u16 i;
+
+	sna_debug(5, "sna_sm_build_bind_user_data\n");
+	i = 0;
+	memcpy(start + len, &i, sizeof(__u16));
+	len += 2;
+	l = 12;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 45;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 8;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x02;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "CPSVCMG", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 9;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x03;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	s = 0x01;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "1234567", 7);
+	memcpy(start + len, name, 7);
+	len += 7;
+	l = 13;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 0x04;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+	memcpy(start + len, name, 12);
+	len += 12;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	s = 19;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	memcpy(start + len, unknown, 9);
+	len += 9;
+	s = 0;
+	memcpy(start + len, &s, sizeof(__u8));
+	len += 1;
+	l = 10;
+	memcpy(start + len, &l, sizeof(__u8));
+	len += 1;
+	atoe_strncpy(name, "LNXSNA.IBM", 10);
+	memcpy(start + len, name, 10);
+	len += 10;
+
+	return (len);
+}
+
+static int sna_sm_build_bind_cv(__u8 type, __u8 *cv_start)
+{
+	int len = 0;
+	__u8 s, l;
+	unsigned char name[17], pcid[8];
+
+	sna_debug(5, "sna_sm_build_bind_cv\n");
+	switch(type)
+	{
+		case (CV_ROUTE_SEL):
+			s = CV_ROUTE_SEL;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 19;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x01;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 17;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x46;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 15;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x80;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			s = 0x00;	/* TG Number */
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 10;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.IBM", 10);
+			memcpy(cv_start + len, name, 10);
+			len += 10;
+			s = 0x00;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			break;
+
+		case (CV_COS_TPF):
+			s = 0x2C;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 9;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			s = 0x04;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 7;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "CPSVCMG", 7);
+			memcpy(cv_start + len, name, 7);
+			len += 7;
+			break;
+
+		case (CV_FQ_PCID):
+			s = 0x60;
+			memcpy(cv_start + len, &s, sizeof(__u8));
+			len += 1;
+			l = 21;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+
+			/* Copy pcid from lulu_cb here now */
+
+			memcpy(cv_start + len, pcid, 8);
+			len += 8;
+			l = 12;
+			memcpy(cv_start + len, &l, sizeof(__u8));
+			len += 1;
+			atoe_strncpy(name, "LNXSNA.EHEAD", 12);
+			memcpy(cv_start + len, name, 12);
+			len += 12;
+			break;
+	}
+
+	return (len);
+}
+
+/* Build +RSP(BIND). */
+static int sna_sm_build_bind_rsp_pos(struct sk_buff *skb, int t)
+{
+        struct ethhdr *eth_hdr = skb->mac.ethernet;
+        struct net_device *dev = skb->dev;
+	struct sna_rcb *rcb = NULL;
+	struct sk_buff *newskb;
+	struct sna_bind *bind;
+	int size, len = 0;
+
+	sna_debug(5, "sna_sm_build_bind_rsp\n");
+
+        /* Device + Datalink + XID */
+        size = dev->hard_header_len + LLC_TYPE2_SIZE + 250;
+        newskb = alloc_skb(size, GFP_ATOMIC);
+
+        skb_reserve(newskb, 200);
+	skb_reserve(newskb, sizeof(struct snarhdr));
+	skb_reserve(newskb, sizeof(struct sna_fid2));
+
+        skb_reserve(newskb, LLC_TYPE2_SIZE);
+        skb_reserve(newskb, dev->hard_header_len);
+        newskb->dev = dev;
+
+	if(t == BIND_S_BIND || t == BIND_S_PR_BIND
+		|| t == BIND_S_PR_BIND_W_AF)
+	{
+		if(t == BIND_S_BIND_W_AF)
+			bind = (struct sna_bind *)skb_push(newskb,
+                                sizeof(struct sna_bind) + 61 + 45 + 21);
+		else
+			bind = (struct sna_bind *)skb_push(newskb, 
+				sizeof(struct sna_bind) + 61 + 45);
+
+		memset(bind, 0, sizeof(struct sna_bind));
+		bind->request_code	= BIND_RQ;
+		bind->fm_profile	= FMH_19;
+		bind->ts_profile	= TSH_7;
+		bind->pri_flags		= 0xB0;
+		bind->sec_flags		= 0xB0;
+		bind->cm1_flags		= 0x50;
+		bind->cm2_flags		= 0xB3;
+		if(t == BIND_S_PR_BIND)
+		{
+			bind->sec_tx_win_size	= 0;
+			bind->sec_rx_win_size	= 0x80;
+		}
+		else
+		{
+//			if(t == BIND_S_PR_BIND_W_AF)
+//			{
+//				bind->sec_tx_win_size   = 0x01;
+ //                       	bind->sec_rx_win_size   = 0x81;
+//			}
+//			else
+//			{
+				bind->sec_tx_win_size 	= 0x07;
+				bind->sec_rx_win_size	= 0x87;
+//			}
+		}
+
+		if(t == BIND_S_PR_BIND_W_AF)
+		{
+			bind->shs_max_ru_size   = 0x86;
+                        bind->phs_max_ru_size   = 0x86;
+		}
+		else
+		{
+			bind->shs_max_ru_size	= 0x87;
+			bind->phs_max_ru_size	= 0x87;
+		}
+
+		if(t == BIND_S_PR_BIND)
+                {
+			bind->pri_tx_win_size	= 0x80;
+			bind->pri_rx_win_size	= 0;
+		}
+		else
+		{
+//			if(t == BIND_S_PR_BIND_W_AF)
+//			{
+//				bind->pri_tx_win_size   = 0x81;
+  //                              bind->pri_rx_win_size   = 0x01;
+//			}
+//			else
+//			{
+				bind->pri_tx_win_size	= 0x87;
+				bind->pri_rx_win_size	= 0x07;
+//			}
+		}
+		bind->lu_type		= 0x6;
+		bind->lu6_level		= 0x02;
+		bind->ps1_flags		= 0x16;
+		bind->ps2_flags		= 0x23;
+	
+		len += sna_sm_build_bind_user_data(&bind->raw);
+
+		if(t == BIND_S_PR_BIND_W_AF)
+			len += sna_sm_build_bind_cv(CV_ROUTE_SEL, 
+				&bind->raw + len); /*
++20 */
+
+		len += sna_sm_build_bind_cv(CV_COS_TPF, &bind->raw + len); /* +11 */
+       	 	len += sna_sm_build_bind_cv(CV_FQ_PCID, &bind->raw + len); /* +21 */
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		if(t == BIND_S_PR_BIND)
+                {
+			newskb->h.raw[0] = 0xEB;
+                	newskb->h.raw[1] = 0x80;
+                	newskb->h.raw[2] = 0x00;
+		}
+
+		if(t == BIND_S_PR_BIND_W_AF)
+		{
+			newskb->h.raw[0] = 0xEB;
+			newskb->h.raw[1] = 0x80;
+			newskb->h.raw[2] = 0x00;
+			newskb->nh.raw[2] = 0x02;
+                	newskb->nh.raw[3] = 0x01;
+		}
+	}
+	else
+	{
+		skb_push(newskb, 3);
+		newskb->data[0] = 0;
+		newskb->data[1] = 0;
+		newskb->data[2] = 1;
+
+		sna_dfc_init_th_rh(newskb, rcb);
+
+		newskb->h.raw[0] = 0x83;
+		newskb->h.raw[1] = 0x01;
+		newskb->h.raw[2] = 0x00;
+		newskb->nh.raw[0] = 0x2D;
+		newskb->nh.raw[1] = 0x00;
+                if(t == BIND_S_PR_FMD_W_AF)
+		{
+			newskb->nh.raw[2] = 0x00; // 0x02;
+                        newskb->nh.raw[3] = 0x01;
+		}
+		else
+		{
+			newskb->nh.raw[2] = 0x01;
+			newskb->nh.raw[3] = 0x00;
+		}
+		newskb->nh.raw[4] = 0x00;
+		newskb->nh.raw[5] = 0x00;
+	}
+
+	llc_data(0x04, 0x04, eth_hdr->h_source, newskb, dev);
+        return (0);
+}
+
+/* Check BIND for semantic and state errors, create a half-session process,
+ * reserve required buffers. If no errors occur, build and send a +RSP(BIND),
+ * update and save active session parameters, and initialize the half-session.
+ */
+static int sna_sm_process_bind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rq\n");
+	if(bstate == BIND_RESET)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_BIND);
+		bstate = BIND_S_BIND;
+		kfree_skb(skb);
+		return (0);
+	}
+
+	if(bstate == BIND_S_BIND)
+	{
+		/* Send +RSP BIND */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND);
+		bstate = BIND_S_PR_BIND;
+		kfree_skb(skb);
+		return (0);
+	}
+
+	if(bstate == BIND_S_PR_BIND)
+	{
+		/* Send +RSP FMD BIND */
+                sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD);
+		bstate = BIND_S_PR_FMD;
+		kfree_skb(skb);
+		return (0);
+	}	
+
+	if(bstate == BIND_S_PR_FMD)
+	{
+		/* Send BIND w/ real oaf/daf */
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_BIND_W_AF);
+		bstate = BIND_S_PR_BIND_W_AF;
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		kfree_skb(skb);
+		return (0);
+	}
+
+#ifdef NOT
+	if(bstate == BIND_S_PR_BIND_W_AF)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return (0);
+	}
+
+	if(bstate == BIND_S_PR_BIND_W_AF)
+	{
+		sna_sm_build_bind_rsp_pos(skb, BIND_S_PR_FMD_W_AF);
+		bstate = BIND_S_PR_FMD_W_AF;
+		return (0);
+	}
+#endif
+	kfree_skb(skb);
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_mu *mu_new;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_check_semantic(mu);
+        if(err < 0)
+        {
+                local->sense = err; ??
+                return (-?);
+        }
+
+        err = sna_bind_rq_state_error(mu);
+        if(err < 0)
+        {
+                local->sense = err;
+                return (-?);
+        }
+
+        plu->active_session_params.parallel = bind_rq_rcv->parallel;
+        lulu_cb = (struct sna_lulu_cb *)kmalloc(sizeof(lulu_cb), GFP_ATOMIC);
+        sna_init_lulu_cb_bind(mu, lulu_cb);
+        lulu_cb->hs_id = unique_hs_id();
+        sna_build_bind_rsp_pos(mu, lulu_cb, mu_new);
+        err = sna_reserve_constant_buffers(lulu_cb);
+        if(!err)
+                err = sna_reserver_variable_buffers(lulu_cb, bind_rq_rcv);
+        if(!err)
+        {
+                lulu_cb->session_id = sna_get_session_id();
+                sna_build_and_send_init_hs(lulu_cb, bind_image);
+        }
+
+        if(!err)
+        {
+                send_to_asm(mu_new);
+                fsm_status(mu_new, lulu_cb);
+        }
+        else
+        {
+                if(mu->bind_ru.fqpcid != NULL)
+                        sna_build_and_send_unbind_rq(mu,CLEANUP,local->sense);
+                else
+                {
+                        if(buffer_err == 0)
+                                bm(FREE, mu_new);
+                        sna_build_and_send_bind_rsp_neg(mu);
+                }
+
+                if(lulu_cb != NULL)
+                        sna_cleanup_lu_lu_session(lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Check if the received RSP(BIND) correlator with the previously sent BIND. If
+ * it does, delete pending random data used in LU-LU verification for the
+ * session (if present) and after additional processing (in case of a positive
+ * response) call the FSM. If it does not correlate, the RSP(BIND) is
+ * considered to be a stray one and is ignored (no action taken).
+ */
+static int sna_sm_process_bind_rsp(struct sk_buff *skb, 
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_bind_rsp\n");
+
+#ifdef NOT
+        struct sna_local *local;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_partner_lu *plu;
+
+        err = sna_correlate_bind_rsp(mu);
+        if(err >= 0)
+        {
+                plu->active_session_params.parallel = bind_rsp_rcv->parallel;
+                sna_remove_random(this_session);
+
+                if(mu->bind_rsp.type = POS)
+                {
+                        err = sna_check_semantic(mu);
+                        if(err)
+                                local->sense = err;
+
+                        err = sna_bind_rsp_state_error(mu, lulu_cb);
+
+                        if(err >= 0)
+                        {
+                                sna_reserve_variable_buffers(lulu_cb, bind_rsp_rcv);
+                                sna_build_and_send_init_hs(lulu_cb, bind_image);                        }
+                }
+
+                fsm_status(mu, lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Process a received UNBIND. SM always receives the entire UNBIND MU, since
+ * the PIU is not longer than 99 bytes and thus no reassembly by the ASM in
+ * needed. If a received UNBIND correlates to one of the active or pending
+ * active sessions, the FSM is called to clean up the session.
+ */
+static int sna_sm_process_unbind_rq(struct sk_buff *skb,
+	struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_unbind_rq\n");
+
+#ifdef NOT
+        struct sna_lu_lu_cb *lulu_cb;
+
+        correlate = sna_correlator_unbind_rq(mu);
+        sna_build_and_send_unbind_rsp(mu);
+
+        if(correlate)
+                fsm_status(mu, lulu_cb);
+#endif
+
+        return (0);
+}
+
+int sna_sm_xtract_bind_type(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_sm_xtract_bind_type\n");
+
+	return (0);
+}
+
+/* entry point for incomming binds. */
+int sna_sm_process_mu(struct sk_buff *skb, struct sna_lfsid_block *l)
+{
+	sna_debug(5, "sna_sm_process_mu\n");
+	switch(sna_sm_xtract_bind_type(skb))
+	{
+                case (SNA_BIND_RQ):
+                        sna_sm_process_bind_rq(skb, l);
+                        break;
+
+                case (SNA_BIND_RSP):
+                        sna_sm_process_bind_rsp(skb, l);
+                        break;
+
+                case (SNA_UNBIND_RQ):
+                        sna_sm_process_unbind_rq(skb, l);
+                        break;
+
+		case (SNA_UNBIND_RSP):
+                default:
+			kfree_skb(skb);
+			return (-1);
+        }
+
+        return (0);
+}
+
+/* Build and send a BIND. */
+static int sna_sm_build_and_send_bind_rq(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_mu *mu;
+        struct sna_bind_ru *bind_ru;
+
+        mu = bm(GET_BUFFER, demand, size, no_wait);     /* ??? */
+
+        mu->header_type                 = BIND_RQ_SEND;
+        mu->bind_rq_send.lu_id          = lulu_cb->lu_id;
+        mu->bind_rq_send.sender.type    = SM;
+        mu->bind_rq_send.lfsid          = lulu_cd->lfsid;
+        mu->bind_rq_send.tx_priority    = NETWORK;
+        mu->bind_rq_send.pc_id          = lulu_cd->pc_id;
+        mu->bind_rq_send.hs_id          = lulu_cd->hs_id;
+        mu->th.snf                      = find_unique(snf);
+
+        /* Set rest to default values in SNA Formats */
+
+        /* Set Bind_RU to defaults */
+
+        /* Insert random data into lucd->pending.random_data_list */
+
+        mu->dcf = (RH->size + RU->size);
+
+        send_to_asm(mu);
+#endif
+        return (0);
+}
+
+/* Get the address (LFSID structure) for the session. Create a half-session
+ * process. Reserve buffers for the session.
+ */
+static int sna_sm_prepare_to_send_bind(struct sna_lulu_cb *lulu_cb)
+{
+#ifdef NOT
+        struct sna_assign_lfsid *assign_lfsid;
+        struct sna_assign_lfsid_rsp *assign_lfsid_rsp;
+        struct sna_local *local;
+
+        assign_lfsid = (struct sna_assign_lfsid *)kmalloc(sizeof(struct sna_assign_lfsid), GFP_ATOMIC);
+        assign_lfsid->pc_id = lulu_cb->pc_id;
+        assign_lfsid->sm_process_id = lulu_cb->lu_id;
+        send_to_asm(assign_lfsid);
+
+        assign_lfsid_rsp = recv_from_asm();
+        if(assign_lfsid_rsp->sense != 0x00000000)
+                local->sense = assign_lfsid_rsp->sense;
+        else
+        {
+                lulu_cb->lfsid = assign_lfsid_rsp->lfsid;
+                /* Create a HS for this one ;) */
+                sna_reserve_constant_buffers(lulu_cb);
+                destroy(assign_lfsid_rsp);
+	}
+#endif
+
+	return (0);
+}
+
+/* Process a receieved CINIT_SIGNAL record. First, this signal must be
+ * correlated with a previously sent INIT_SIGNAL record. The correlation is
+ * based on the value of FQPCID. If the correlation fails, the session has
+ * already been brought down by the RM and a SESSEND_SIGNAL record is built
+ * and sent to SS.
+ */
+int sna_sm_process_cinit_signal(struct sna_cinit_signal *cinit_signal)
+{
+	sna_debug(5, "sna_sm_process_cinit_signal\n");
+
+#ifdef NOT
+        struct sna_init_signal *init_signal;
+        struct sna_partner_lu *plu;
+        struct sna_mode *mode;
+        struct sna_lu_lu_cb *lulu_cb;
+        struct sna_local *local;
+        struct sna_sessend_signal *sessend_signal;
+
+        err = sna_correlate_init(cinit_signal->fqpcid); ???
+        if(err < 0)
+        {
+                sessend_signal = (struct sna_sessend_signal *)kmalloc(sizeof(sessend_signal), GFP_ATOMIC);
+                sessend_signal->sense = 0x00000000;
+                sessend_signal->fqpcid = cinit_signal->fqpcid;
+                sessend_signal->pc_id = cinit_signal->pc_id;
+                send_to_ss(sessend_signal);
+        }
+        else
+        {
+                err = sna_lu_mode_session_limit_exceeded(plu->fq_lu_name, mode,
+lulu_cb->session_type, AT_LEAST_BIND_SENT);
+                if(err)
+                        ???
+
+                err = sna_check_buff_size();
+                err = sna_check_active_already();
+                if(err < 0)
+                        local->sense = 0x08050000;
+
+                if(errs >= 0)
+                {
+                        err = sna_prepare_to_send_bind(lulu_cb);
+                        if(!err)
+                                sna_build_and_send_bind_rq(lulu_cb);
+                }
+
+                fsm_status(cinit_signal, lulu_cb);
+        }
+#endif
+
+        return (0);
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of an ACTIVATE_SESSION received from RM.
+ */
+static int sna_sm_init_lulu_cb_act_sess(struct sna_sm_act_session_rq *as,
+        struct sna_lulu_cb *lulu)
+{
+	struct sna_plu_cb *plu;
+
+	sna_debug(5, "sna_sm_init_lulu_cb_act_sess\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+	if(!plu)
+		return (-ENOENT);
+
+	memcpy(&lulu->plu_netid, &plu->netid_plu, sizeof(struct sna_netid));
+	memcpy(&lulu->netid, &plu->netid, sizeof(struct sna_netid));
+	memcpy(&lulu->mode_name, &as->mode_name, SNA_RESOURCE_NAME_LEN);
+	lulu->polarity = as->polarity;
+
+        return (0);
+}
+
+/* Build and send an INIT_SIGNAL record to the control point. */
+static int sna_sm_build_and_send_init_sig(struct sna_lulu_cb *lulu)
+{
+        struct sna_init_signal *init;
+
+	sna_debug(5, "sna_sm_build_and_send_init_sig\n");
+        init = (struct sna_init_signal *)kmalloc(sizeof(struct sna_init_signal), GFP_ATOMIC);
+	init->sm_proc_id	= lulu->proc_id;
+	memcpy(&init->fqpcid, &lulu->fqpcid, 8);
+	memcpy(&init->slu_name, &lulu->plu_netid, sizeof(struct sna_netid));
+	memcpy(&init->plu_name, &lulu->netid, sizeof(struct sna_netid));
+	memcpy(&init->mode_name, &lulu->mode_name, SNA_RESOURCE_NAME_LEN);
+
+	sna_ss_process_init_signal(init);
+
+        return (0);
+}
+
+/* Determine whether or not session limits associated with a given (LU,
+ * mode name) pair are exceeded for the given state condition (FSM_STATUS for
+ * this session).
+ */
+static int sna_sm_lu_mode_session_limit_exceeded(struct sna_netid *plu_name,
+        struct sna_mode_cb *mode, int polarity, int state)
+{
+#ifdef NOT
+        if(state == SNA_SESSION_ACTIVE)
+        {
+                bidder.sessions = sna_active_bid_sessions(mode); ??
+                fsp.sessions    = sna_active_fsp_sessions(mode); ??
+        }
+        else
+        {
+                if(state == SNA_SESSION_AT_LEAST_BIND_SENT)
+                {
+                        bidder.sessions = sna_sent_bid_sessions(mode); ??
+                        fsp.sessions    = sna_sent_fsp_sessions(mode); ??
+                }
+                else
+                {
+                        bidder.sessions = sna_init_bid_sessions(mode);
+                        fsp.sessions    = sna_init_fsp_sessions(mode);
+                }
+        }
+
+        total_limit     = mode->session_limit;
+        fsp_limit       = mode->min_conwinners_limit;
+        bidder_limit    = mode->min_conlosers_limit;
+
+        if(fsp.sessions + bidder.sessions ? total_limit)
+                return (1);
+
+        if(fsp.sessions ? total_limit - bidder_limit
+                && session_type == FIRST_SPEAKER
+                && plu->parallel == TRUE)
+                return (1);
+
+        if(bidder.sessions ? total_limit - fsp_limit
+                && session_type == BIDDER)
+                return (1);
+#endif
+
+        return (0);
+}
+
+static int sna_sm_build_and_send_act_sess_rsp_neg(int correlator, int retry)
+{
+	return (0);
+}
+
+/* Get the fully-qualified procedure correlation identifier (FQPCID) from the
+ * session services (SS) component of the control point. Repeat requests if
+ * a duplicate FQPCID was received. An FQPCID is considered duplicate if its
+ * PCID matches that for another active or pending-active session at this LU.
+ */
+static int sna_sm_get_fqpcid(struct sna_lulu_cb *lulu)
+{
+	struct sna_assign_pcid *pcid;
+
+	sna_debug(5, "sna_sm_get_fqpcid\n");
+	pcid = (struct sna_assign_pcid *)kmalloc(sizeof(*pcid), GFP_ATOMIC);
+	pcid->sm_proc_id	= lulu->proc_id;
+        pcid->duplicate_pcid	= 0;
+	sna_ss_assign_pcid(pcid);
+
+	while(sna_sm_find_lulu_fqpcid(pcid->fqpcid) != NULL)
+	{
+		pcid->duplicate_pcid = 1;
+		sna_ss_assign_pcid(pcid);
+	}
+
+	memcpy(&lulu->fqpcid, &pcid->fqpcid, 8);
+	kfree(pcid);
+        return (0);
+}
+
+/* Process an ACTIVATE_SESSION record received from RM. That includes checking
+ * for a session limit to be exceeded (since RM does not know whether the
+ * session limit is exceeded when it sends ACTIVATE_SESSION to SM), creating
+ * and initializing of the LULU_CB control block, getting an FQPCID for the
+ * session from SS, and sending an INIT_SIGNAL record to SS.
+ */
+int sna_sm_process_activation_session(struct sna_sm_act_session_rq *as)
+{
+        struct sna_plu_cb *plu;
+        struct sna_mode_cb *mode;
+
+	sna_debug(5, "sna_sm_process_activation_session\n");
+	plu = sna_rm_find_remote_lu(&as->plu_netid);
+        if(!plu)
+        	return (-ENOENT);
+        mode = sna_rm_find_mode(as->mode_name);
+        if(!mode)
+                return (-ENOENT);
+
+        if(sna_sm_lu_mode_session_limit_exceeded(&as->plu_netid, mode, 
+		as->polarity, SNA_SESSION_AT_LEAST_INIT_SENT))
+                sna_sm_build_and_send_act_sess_rsp_neg(as->correlator, 
+			SNA_ACT_SESS_RETRY);
+        else
+        {
+		struct sna_lulu_cb *lulu;
+                lulu = (struct sna_lulu_cb *)kmalloc(sizeof(struct sna_lulu_cb),
+			GFP_ATOMIC);
+                sna_sm_get_fqpcid(lulu);
+                sna_sm_init_lulu_cb_act_sess(as, lulu);
+
+		sna_sm_build_and_send_init_sig(lulu);
+        }
+
+        return (0);
+}
+
+#ifdef CONFIG_SM
+/* LU session manager (SM) is responsible for creating the RM process and for
+ * activating and deactivating sessions between this LU and another LU. There
+ * is one SM process per LU in the node, and it is created and destroyed when
+ * the LU is created and destroyed. SM receives records from the resource
+ * manager (RM), the half-session (HS), the address space manager (ASM), and
+ * the session services (SS) processes. When the records are received, they
+ * are routed to the appropriate procedures when they are processed. SM uses
+ * process data (called LOCAL) that can be accessed by any procedure in the
+ * SM process.
+ */
+static int sna_sm_create(unsigned char *data)
+{
+	struct sna_local *local;
+	struct sna_lucb *lucb;
+	struct sna_partner_lu *plu;
+	struct sna_mode *mode;
+	struct sna_lulu_cb *lulu_cb;
+	struct sna_rm_create_parms *rm_create_parms;
+	struct sna_rm_created *rm_created;
+	struct sna_sm_create_parms *sm_create_parms;
+
+	/* Creation time logic... need to seperate */
+	sm_create_parms = (struct sna_sm_create_parms *)data;
+	rm_create_parms = (struct sna_rm_create_parms *)kmalloc(sizeof(rm_create_parms), GFP_ATOMIC);
+	rm_create_parms->lucb_list_ptr = sm_create_parms->lucb_list_ptr;
+	rm_create_parms->lu_id = sm_create_parms->lu_id;
+	err = sna_rm_init(rm_create_parms);
+	if(err >= 0)
+	{
+		rm_created = (struct sna_rm_created *)kmalloc(sizeof(rm_created), GFP_ATOMIC);
+		rm_created->lu_id = sm_create_parms->lu_id;
+		sent_to_nof(rm_created); /* OhOh troubles abrew */
+	}
+	else
+		sna_sm_abend();
+
+	err = bm(CREATE_BUF_POOL, permanent, MAX_RU, 5);
+	if(err < 0)
+		sna_sm_abend();
+
+	/* Runtime stuff... should be here */
+	while(SM_exists)	/* This will not loop, but be always called */
+	{
+		local->sense = 0x00000000;
+		switch(data_from)
+		{
+			case (RM):
+				sna_process_record_from_rm(rm_to_sm_record);
+				break;
+
+			case (HS):
+				sna_process_record_from_hs(hs_to_sm_record);
+				break;
+
+			case (ASM):
+				sna_process_record_from_asm(asm_to_sm_record);
+				break;
+
+			case (SS):
+				sna_process_record_from_ss(ss_to_sm_record);
+				break;
+
+			default:
+				printk("Hmm, Hmm, Cookies!\n");
+				toss_record();
+		}
+	}
+
+	return (0);
+}
+
+/* Route records received from RM to appropriate procedures. */
+static int sna_process_record_from_rm(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (ACTIVATE_SESSION):
+			sna_process_activate_session(activate_session);
+			break;
+
+		case (DEACTIVATE_SESSION):
+			sna_process_deactivation_session(deactivate_session);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Route records received from the half-session (HS) process to the
+ * appropriate procedures.
+ */
+static int sna_process_record_from_hs(unsigned char *record)
+{
+	switch(record_type)
+	{
+		case (INIT_HS_RSP):
+			sna_process_init_hs_rsp(init_hs_rsp);
+			break;
+
+		case (ABORT_HS):
+			sna_process_abort_hs(abort_hs);
+			break;
+
+		case (ABEND_NOTIFICATION):
+			sna_process_abend_notification(abend_notification);
+			break;
+
+		default:
+			toss_record();
+	}
+
+	return (0);
+}
+
+/* Determine if there is a state error on receipt of a BIND. */
+static int sna_bind_rq_state_err(struct sna_mu *mu)
+{
+	struct sna_parnter_lu *plu;
+	struct sna_mode *mode;
+	struct sna_bind_ru *bind_ru;
+	struct sna_lucb *lucb;
+	struct sna_local *local;
+
+	plu = search_plu(mu->plu_name);
+	if(plu != NULL)
+	{
+		local->sense = (0x0835 | offset_to_plu_name);
+		return (TRUE);
+	}
+
+	if(plu->lu_name != lucb->lu_name)
+	{
+		local->sense = 0x083B0001;
+		return (TRUE);
+	}
+
+	if(lucb->security_select != plu->security_select)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	mode = search_mode(mu->mode_name);
+	if(mode == NULL)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(plu->parallel != TRUE && mode->min_conwinners == 1)
+		local->session_type = FIRST_SPEAKER;
+	else /* Use value in bind */
+	{
+		if(mu->first_speaker == TRUE)
+			local->session_type = FIRST_SPEAKER;
+		else
+			local->session_type = BIDDER;
+	}
+
+	limit = sna_bind_session_limit_exceeded(plu->fqlu_name, mode, local->session_type);
+	if(limit == EXCEEDED)
+		return (TRUE);
+
+	if(plu->parallel != TRUE && another_pending_req() == TRUE)
+	{
+		/* Bind winner is the one with the longer LU name ;) */
+	}
+
+	/*
+	 * Consistency checks on PS usage fields
+	 */
+
+	err = check_sync_levels(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_parallel_level(plu, mode);
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_cnos();
+	if(err < 0)
+	{
+		local->sense = 0x08350000;
+		return (TRUE);
+	}
+
+	err = check_conv_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	err = check_verif_security();
+	if(err < 0)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(mu->bind.conv_secure == FALSE && mu->bind.alverified == TRUE)
+	{
+		local->sense = 0x0835001A;
+		return (TRUE);
+	}
+
+	if(mu->bind.crypto == TRUE && mu->bind.cryptopts == NULL)
+	{
+		local->sense = 0x08480000;
+		return (TRUE);
+	}
+
+	/*
+	 * One whole If-Else pair here
+	 */
+
+	err = check_session_id();
+	if(err < 0)
+	{
+		local->sense = 0x08520001;
+		return (TRUE);
+	}
+
+	if(plu->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->segments == FALSE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002A;
+		return (TRUE);
+	}
+
+	if(lucb->seg_reassm != TRUE && send_ru_size_lower_bound)
+	{
+		local->sense = 0x0877002B;
+		return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/* Perform state error checking on a received +RSP(BIND). */
+static int sna_bind_rsp_state_err(struct sna_mu *mu, struct sna_lu_lu_cb *lulucb)
+{
+	struct sna_local *local;
+	struct sna_partner_lu *plu;
+	struct sna_bind_ru *bind_ru;
+	struct sna_mode *mode;
+
+	/* Pacing and Max. RU size checks */
+	if(bind->pace != rsp->pace)
+	{
+		local->sense = 0x08350008 or 0x0835000C;
+		return (TRUE);
+	}
+
+	if(rsp->adaptive_pace != TRUE)
+	{
+		if(rsp->second.send_window != bind->second.send_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		/* 0 is infinately large */
+		if(rsp->second.recv_window > bind->second.recv_window)
+		{
+			local->sense = 0x08350008;
+			return (TRUE);
+		}
+
+		if(rsp->primary.send_window > bind->primary.send_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+
+		if(rsp->primary.recv_window != bind->primary.recv_window)
+		{
+			local->sense = 0x0835000C;
+			return (TRUE);
+		}
+	}
+
+	/* Determine if within bounds for send/recv wins */
+	err = check_ru_bounds();
+	if(err < 0)
+	{
+		if(secondary_out_bounds)
+			local->sense = 0x0835000A;
+		else
+			local->sense = 0x0835000B;
+
+		return (TRUE);
+	}
+
+	/* PS usage checks */
+	if(other_active_sessions(plu) && conv_security != plu->conv_security)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && alrdy_verified != plu->alrdy_verified)
+	{
+		local->sense = 0x080F6051;
+		return (TRUE);
+	}
+
+	if(other_active_sessions(plu) && sync != plu->sync)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+	else
+	{
+		if(rsp->sync == (CONFIRM|SYNCPOINT|BACKOUT)
+			&& bind->sync == (CONFIRM))
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel != TRUE)
+	{
+		if(rsp->sess_reinit == NONOPCTRL
+			&& bind->sess_reinit == OPCTRL)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == SECONDARY
+			&& bind->sess_reinit == PRIMARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+
+		if(rsp->sess_reinit == PRIMARY
+			&& bind->sess_reinit == SECONDARY)
+		{
+			local->sense = 0x08350018;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->parallel_opts != bind->parallel_opts
+		&& rsp->chg_sess != bind->chg_sess)
+	{
+		local->sense = 0x08350018;
+		return (TRUE);
+	}
+
+	/* Contention winner checks */
+	if(rsp->parallel == TRUE)
+	{
+		if(rsp->contention_winner != bind->contention_winner)
+		{
+			local->sense = 0x08035007;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(rsp->contention_winner == PRIMARY
+			&& bind->contention_winner == SECONDARY)
+		{
+			local->sense = 0x08350007;
+			return (TRUE);
+		}
+	}
+
+
+	if(rsp->contention_winner == PRIMARY)
+		local->session_type = FIRST_SPEAKER;
+	else
+		local->session_type = BIDDER;
+
+	limit = sna_mode_session_limit_exceeded(plu->fqlu_name, mode, local->session_type, active);
+	if(limit == EXCEEDED)
+	{
+		return(TRUE);
+	}
+
+	/* Crypto checks */
+	if(rsp->cryptopts != bind->cryptopts)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	/* User data subfield checks */
+	if(rsp->mode_name != bind->mode->name)
+	{
+		local->sense = 0x0835xxxx;
+		return (TRUE);
+	}
+
+	if(lulu_cb->random != NULL)
+	{
+		if(rsp->security == NULL || is_incorrect)
+		{
+			local->sense = 0x080F6051;
+			return (TRUE);
+		}
+	}
+
+	/* User data subfield - session_id checks */
+	if(rsp->session_id != 0x02)
+	{
+		if(rsp->session_id != 0x00 || rsp->session_id != 0xF0
+			|| rsp->session_id != bind->session_id)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+	else
+	{
+		if(plu->fq_pcid != TRUE)
+		{
+			local->sense = 0x0835xxxx;
+			return (TRUE);
+		}
+	}
+
+	if(rsp->session_id != NULL)
+	{
+		if(rsp->sessiond_id == 0x02)
+			lulu_cb->session_id = fq_pcid->pcid;
+		else
+			lulu_cb->session_id = rsp->session_id;
+
+		if(sna_id_unique(SESSION, lulu_cb->session_id) < 0)
+		{
+			local->sense = 0x8520001;
+			return (TRUE);
+		}
+	}
+
+	/* URC Checks */
+	if(rsp->urc != bind->urc)
+		return (TRUE);
+
+	return (FALSE);
+}
+
+/* Betermine whether or not session limits are exceeded for a received BIND. */
+static int sna_bind_session_limit_exceeded(unsigned char *plu_fqlu_name, 
+	struct sna_mode *mode, int type)
+{
+	struct sna_local *local;
+
+	if(mode->cnos_negotiation_in_progress == TRUE
+		&& prop_slimit > curr_slimit)
+	{
+		if(mode->active.sessions ? proposed.slimit)
+		{
+			local->sense = 0x08050000;
+			return (TRUE);
+		}
+		else
+		{
+			if((mode->active.sessions + mode->pending.sessions)
+				? proposed.slimit)
+			{
+				local->sense = 0x08050000;
+				return (TRUE);
+			}
+		}
+	}
+	else
+	{
+		limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, ACTIVE);
+		if(limit == EXCEEDED)
+		{
+			local->rcode = TRUE;
+		}
+		else
+		{
+			limit = sna_lu_mode_session_limit_exceeded(plu_fqlu_name, mode, type, AT_LEAST_BIND_SENT);
+			if(limit == EXCEEDED)
+				local->check_winner_flag = TRUE;
+		}
+	}
+
+	/* Check for BIND race conditions */
+	if(local->check_winner_flag == TRUE)
+	{
+		/* Fake for now */
+		if(session->lu_name > plu_fq_lu_name)
+			local->rcode = TRUE;
+		else
+		{
+			local->sense = 0x00000000;
+			local->rcode = FALSE;
+		}
+	}
+
+	return (local->rcode);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (negative) to RM. */
+static int sna_build_and_send_act_sess_rsp_neg(__u8 correlator, int err)
+{
+	struct sna_activate_session_rsp *act_rsp;
+
+	act_rsp = (struct sna_activate_session_rsp *)kmalloc(sizeof(act_rsp), GFP_ATOMIC);
+	act_rsp->correlator = correlator;
+	act_rsp->type = NEG;
+	act_rsp->err_type = err;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send ACTIVATE_SESSION_RSP (positive) to RM. This completes
+ * (from the SM's standpoint) the session initiation activity triggered by
+ * the ACTIVATE_SESSION record received by SM from RM.
+ */
+static int sna_build_and_send_act_sess_rsp_pos(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_actiavte_session_rsp *act_rsp;
+
+	act_rsp = (struct sna_activate_session_rsp *)kmalloc(sizeof(struct sna_activate_session_rsp), GFP_ATOMIC);
+	act_rsp->correlator = lulu_cb->correlator;
+	act_rsp->type = POS;
+
+	act_rsp->session_information.hs_id = lulu_cb->hs_id;
+	act_rsp->session_information.hs_type = PRI;
+	act_rsp->session_information.bracket_type = lulu_cb->session_type;
+
+	act_rsp->session_information.send_ru_size = neg_max_send_ru_size;
+	act_rsp->session_information.perm_buf_pool_id = perm_buf_pool_id;
+	act_rsp->session_information.limit_buf_pool_id = limit_buf_pool_id;
+
+	act_rsp->session_informtaion.session_id = lulu_cb->session_id;
+
+	act_rsp->session_information.random_data = lulu_cb->random_data;
+	act_rsp->session_information.limit_resource = lulu_cb->limit_resource;
+
+	send_to_rm(act_rsp);
+
+	return (0);
+}
+
+/* Build and send a -RSP(BIND). */
+static int sna_build_and_send_bind_rsp_neg(unsigned char *buf)
+{
+	struct sna_mu *mu;
+
+	mu->header_type = BIND_RSP_SEND;
+	mu->bind_rsp_send.sender.id = lu_id;
+	mu->bind_rsp_send.sener.type = SM;
+	mu->bind_rsp_send.lfsid = bind->lfsid;
+	mu->bind_rsp_send.pc_id = bind->pc_id;
+	mu->bind_rsp_send.tx_priority = LOW;
+	mu->bind_rsp_send.free_lfsid = YES;
+	mu->bind_rsp_send.hs_id = NULL;
+
+	/* Set TH and RH fields to default 3.5.9 SNA formats */
+
+	/* Set RU */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a FREE_LFSID record to the control point. This is
+ * necessary when SM asked ASM to give SM an LFSID for a session, and SM
+ * received ASSIGN_LFSID_RSP, but could not send a BIND (because, for
+ * example, SM cannot get a buffer for it). In this case, SM explicity asks
+ * ASM to free the LFSID by sending the FREE_LFSID record to it. If SM sends
+ * a BIND successfully, it later sends an UNBIND or a RSP(UNBIND) to ASM
+ * and sets the FREE_LFSID variable to YES in them.
+ */
+static int sna_build_and_send_free_lfsid(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_free_lfsid *free_lfsid;
+
+	free_lfsid = (struct sna_free_lfsid *)kmalloc(sizeof (sna_free_lfsid), GFP_ATOMIC);
+	free_lfsid->pc_id = lulu_cb->pc_id;
+	free_lfsid->lfsid = lulu_cb->lfsid;
+
+	send_to_asm(free_lfsid);
+
+	return (0);
+}
+
+/* Build an INIT_HS (Initialize Half-Session) record and send it to the
+ * half-session designated by the passed LULU_CB.
+ */
+static int sna_build_and_send_init_hs(struct sna_lulu_cb *lulu_cb, 
+	unsigned char *bind_image)
+{
+	struct sna_local *local;
+	struct sna_init_hs *init_hs;
+
+	init_hs = (struct sna_init_hs *)kmalloc(sizeof(struct sna_init_hs), GFP_ATOMIC);
+	init_hs->pc_id	= lulu_cb->pc_id;
+	init_hs->lfsid			= lulu_cb->lfsid;
+	init_hs->hs_type		= lulu_cb->hs_type;
+	init_hs->dynamic_pool_id	= lulu_cb->dynamic_pool_id;
+	init_hs->dem_lim_pool_id	= lulu_cb->dem_lim_pool_id;
+	init_hs->tx_priority		= lulu_cb->tx_priority;
+	init_hs->short_bind_image	= bind_image;
+
+	if(lulu_cb->adaptive_pace == TRUE)
+	{
+		init_hs->short_bind_image.sec_send_window_size 	= 1;
+		init_hs->short_bind_image.pri_send_window_size 	= 1;
+		init_hs->short_bind_image.sec_rcv_window_size	= 1;
+		init_hs->short_bind_image.pri_rcv_window_size	= 1;
+	}
+
+	err = send_to_hs(init_hs);
+	if(err == ABEND)
+	{
+		destroy(init_hs);
+		local->sense = 0x0812000D;
+	}
+
+	return (0);
+}
+
+/* Build and send a PC_HS_DISCONNECT record to ASM. This is done only after
+ * a PLU receives a -RSP(BIND). If, instead, SM receives an UNBIND, it sends
+ * a RSP(UNBIND), asking ASM to free LFSID, thus disconnecting PC and HS.
+ */
+static int sna_build_and_send_pc_hs_disconnect(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_msg_queue *msg = NULL;
+
+	msg->cmd 	= SNA_PC_HS_DISCONNECT;
+	msg->pc_id	= lulu_cb->pc_id;
+	msg->lfsid	= lulu_cb->lfsid;
+
+	sna_asm(msg);
+
+	return (0);
+}
+
+/* Build and send SESSION_ACTIVATED to RM to indicate that a new session
+ * has become active and to give RM the information about this session.
+ */
+static int sna_build_and_send_sess_activated(struct sna_lulu_cb *lulu_cb)
+{
+	struct sna_session_activated *activated;
+
+	activated = (struct sna_session_activated *)kmalloc(sizeof(struct sna_session_activated), GFP_ATOMIC);
+
+	activated->session_information.hs_id = lulu_cb->hs_id;
+	activated->session_information.hs_type = SEC;
+	activated->session_information.bracket_type = lulu_cb->session_type;
+
+	activated->session_information.send_ru_size = neg_max_send_ru_size;
+	activated->session_information.perm_buf_pool_id = lulu_cb->perm_pool_id;
+	actiavted->session_information.limit_buf_pool_id = lulu_cb->dem_lim_pool_id;
+	activated->session_information.session_id = lulu_cb->session_id;
+
+	/* Send to RM for FMH-12 info */
+
+	activated->session_information.random_data = lulu_cb->random;
+	activated->lu_name = lulu_cb->local_partner_lu_name;
+	activated->mode_name = lulu_cb->mode_name;
+	activated->session_information.limit_resource = lulu_cb->limit_resource;
+
+	err = send_to_rm(activated);
+	if(err < 0)
+		destroy(activated);
+
+	return (0);
+}
+
+/* Build and send SESSION_DEACTIVATED to RM to indicate that an active session
+ * has been deactivated.
+ */
+static int sna_build_and_send_sess_deactivated(__u8 hs_id, __u8 reason, 
+	__u8 sense)
+{
+	struct sna_session_deactivated *deactivated;
+
+	deactivated = (struct sna_session_deactivated *)kmalloc(sizeof(struct sna_session_deactivated), GFP_ATOMIC);
+	deactivated->hs_id 	= hs_id;
+	deactivated->reason 	= reason;
+	if(reason != NORMAL)
+		deactivated->sense = sense;
+
+	err = send_to_rm(deactivated);
+	if(err < 0)
+		destroy(deactivated);
+
+	return (0);
+}
+
+/* Build and send a SESSEND_SIGNAL record to the control point. This record
+ * can be sent by both PLU and SLU when the session is brought down. The PLU
+ * sends it, however, only if it has previously received a CINIT_SIGNAL
+ * record. The SLU sends it only if it has already sent a SESSST_SIGNAL
+ * record to SS.
+ */
+static int sna_build_and_send_sessend_sig(struct sna_lulu_cb *lulu_cb, 
+	__u8 sense)
+{
+	struct sna_sessend_signal *sessend_signal;
+
+	sessend_signal = (struct sna_sessend_signal *)kmalloc(sizeof(struct sna_sessend_signal), GFP_ATOMIC);
+
+	sessend_signal->sense = sense;
+	sessend_signal->fqpcid = lulu_cb->fqpcid;
+	sessend_signal->pc_id = lulu_cb->pc_id;
+
+	send_to_ss(sessend_signal);
+
+	return (0);
+}
+
+/* Build and send a SESSST_SIGNAL record to the control point. This record is
+ * sent by the SLU when it receives the INIT_HS_RSP record from the half-session
+ * process. The PLU does not need to send it, since its local SS sends a
+ * CINIT_SIGNAL to SM and assumes that the session will be activated.
+ */
+static int sna_build_and_send_sessst_sig(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_sessst_signal *sessst_signal;
+
+	sessst_signal = (struct sna_sessst_signal *)kmalloc(sizeof(struct sna_sessst_signal), GFP_ATOMIC);
+
+	sessst_signal->pc_id = lulu_cd->pc_id;
+
+	send_to_ss(sessst_signal);
+
+	return (0);
+}
+
+/* Build and send an UNBIND. */
+static int sna_build_and_send_unbind_rq(unsigned char *buf, __u8 cleanup, 
+	__u8 sense)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	mu->header_type = UNBIND_RQ_SEND;
+	mu->unbind_rq_send.sender.id = local->lu_id;
+	mu->unbind_rq_send.sender.type = SM;
+	mu->unbind_rq_send.lfsid = lulu_cb->lfsid;
+	mu->unbind_rq_send.pc_id = lulu_cd->pc_id;
+	mu->unbind_rq_send.tx_priority = lulu_cd->tx_priority;
+	mu->unbind_rq_send.free_lfsid = YES;
+	mu->unbind_rq_send.hs_id = lulu_cd->hs_id;
+
+	/* Set TH and RH fields to default */
+
+	/* Set RU of unbind mu to defaults, using sense and type passed */
+
+	mu->dcf = (RH->size + RU->size);
+
+	send_to_asm(mu);
+
+	return (0);
+}
+
+/* Build and send a RSP(UNBIND). */
+static int sna_build_and_send_unbind_rsp(struct sna_mu *mu)
+{
+	struct sna_lu_lu_cb *lulu_cb
+	struct sna_mu *mu_new;
+	int unbind_type;
+
+	if(determine_how_unbind_was_recieved() == EXR || length_err)
+		unbind_type = NEG;
+	else
+		unbind_type = POS;
+
+	mu_new = bm(GET_BUFFER, demand, size, no_wait);
+	if(mu != NULL)
+	{
+		mu_new->header_type = UNBIND_RSP_SEND;
+		mu_new->unbind_rsp_send.lu_id = lulu_cb->lu_id;
+		mu_new->unbind_rsp_send.sender.type = SM;
+
+		if(unbind correlated to a specific session)
+		{
+			mu_new->unbind_rsp_send.hs_id = lulu_cb->hs_id;
+			mu_new->unbind_rsp_send.tx_priority = lulu_cb->tx_priority;
+		}
+		else
+		{
+			mu_new->unbind_rsp_send.hs_id = NULL;
+			mu_new->unbind_rsp_send.tx_priority = LOW;
+		}
+
+		mu_new->unbind_rsp_send.free_lfsid = YES;
+		mu_new->pc_id = mu->pc_id;
+		mu_new->lfsid = mu->lfsid;
+		mu_new->th.snf = mu->th.snf;
+
+		/* Set TH and RH to defaults */
+
+		if(type == POS)
+			mu_new->ru.type = POS;
+		else
+			mu_new->ru.type = NEG;
+
+		mu->dcf = (RH->size + RU->size);
+
+		send_to_asm(mu);
+	}
+	else
+		/* IBM.. Duh do nothing */
+
+	return (0);
+}
+
+/* Clean up LU-LU session. */
+static int sna_cleanup_lu_lu_session(struct sna_lu_lu_cb *lulu_cb)
+{
+	if(sesst_signal was sent || cinit_signal was recieved)
+		sna_build_and_send_sessend_sig(lulu_cb);
+
+	sna_unreserve_buffers(lulu_cb);
+	hs = sna_hs_unlink(lulu_cb->hs_id);
+	sna_hs_destroy(hs);
+
+	random = sna_random_unlink(lulu_cb->random);
+	sna_random_destroy(random);
+
+	lulu_cb = sna_lulu_cb_unlink(lulu_cb);
+	sna_lulu_cb_destroy(lulu_cb);
+
+	return (0);
+}
+
+/* Check if the received RSP(BIND) correlates with a previously sent BIND. */
+static int sna_correlate_bind_rsp(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Check if the received RSP(UNBIND) correlates with a know session. */
+static int sna_correlate_unbind_rq(struct sna_mu *mu)
+{
+
+	return 0;
+}
+
+/* Initialize an LULU_CB for an LU-LU session being activated as a result
+ * of receiving a BIND.
+ */
+static int init_lulu_cd_bind(struct sna_mu *mu, struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_partner_lu *plu;
+	struct sna_local *local;
+
+	plu = search_plu(mu->bind_ru.plu_name);
+	lulu_cb->local_partner_lu_name = plu->local_lu_name;
+	lulu_cb->fq_partner_lu_name = local->user_data.pluname.name;
+	lulu_cb->mode_name = mu->bind_ru.mode_name;
+	lulu_cb->hs_type = SEC;
+
+	if(plu->parallel != TRUE && mode->min_conwinners_limit == 1)
+		lulu_cb->session_type = FIRST_SPEAKER;
+	else
+	{
+		if(bind->secondary == CONWINNER)
+			lulu_cb->session_type = FIRST_SPEAKER;
+		else
+			lulu_cb->session_type = BIDDER;
+	}
+
+	lulu_cb->pc_id = mu->bind_ru.pc_id;
+	lulu_cb->pc_characteristics = mu->bind_ru.pc_characteristics;
+	lulu_cb->lfsid = mu->bind_ru.lfsid;
+
+	if(mu->bind_ru.cos != NULL)
+		lulu_cb->tx_priority = mu->bind_ru.cos.tx_priority;
+
+	if(mu->bind_ru.fqpcid != NULL)
+		lulu_cb->fqpcid = mu->bind_ru.fqpcid;
+	else
+		lulu_cb->fqpcid = sna_get_fqpcid(lulu_cb);
+
+	return (0);
+}
+
+/* Process an abend notification record from a child process (RM or HS). */
+static int sna_process_abend_notification(struct sna_abend_notification *abend)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	switch(abend->abend_process)
+	{
+		case (RM_PROCESS_VARIABLE):
+			for(lu = local->lulu_cb_list; lu != NULL; lu = lu->next)
+			{
+				fsm_status(abend, lulu_cb);
+			}
+			break;
+
+		case (HS_PROCESS_VARIABLE):
+			lu = search_lulu_cb(abend->hs_id);
+			if(lu != NULL)
+				fsm_status(abend, lulu_cb);
+			break;
+
+		default:
+			printk("Idiot\n");
+	}
+
+	return (0);
+}
+
+/* Process an ABORT_HS record received from LU-LU half-session. */
+static int sna_process_abort_hs(struct sna_abort_hs *abort_hs)
+{
+	struct sna_local *local;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(local->hs_id);
+	if(lulu_cb != NULL)
+		fsm_status(abort_hs, lulu_cb);
+
+	return (0);
+}
+
+/* Process a DEACTIVATION_SESSION record received from RM. */
+static int sna_process_deactivation_session(struct sna_deactivate_session *deactivate)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	if(deactivate->status == PENDING)
+		lulu_cb = search_lulu_cb(deactivate->correlator);
+	else
+		lulu_cb = search_lulu_cb(deactivate->hs_id);
+
+	if(lulu_cb)
+		fsm_status(deactivate, lulu_cb);
+
+	return (0);
+}
+
+/* Process an INIT_HS_RSP record received from a half-session. */
+static int sna_process_init_hs_rsp(struct sna_init_hs_rsp *init_hs_rsp)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	lulu_cb = search_lulu_cb(init_hs_rsp->hs_id);
+	if(lulu_cb)
+		fsm_status(init_hs_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received INIT_SIGNAL_NEG_RSP record from the SS component of
+ * the control point.
+ */
+static int sna_process_init_signal_neg_rsp(struct sna_init_signal_neg_rsp *init_signal_neg_rsp)
+{
+	struct sna_init_signal *init_signal;
+	struct sna_lu_lu_cb *lulu_cb;
+
+	init_signal = search_init_signal(init_signal_neg_rsp);
+	lulu_cb = search_lulu_cb(init_signal_neg_rsp->fqpcid);
+
+	if(init_signal && lulu_cb)
+		fsm_status(init_signal_neg_rsp, lulu_cb);
+
+	return (0);
+}
+
+/* Process a received LFSID_IN_USE record. This record is sent to SM by ASM
+ * so that ASM will know whether a given (LFSID, PC_ID) pair is
+ * currently in use. ASM must know before it sends a BIND to an appropriate
+ * LU. If the pair is in use, ASM will hold the BIND in order to avoid
+ * certain race conditions.
+ */
+static int sna_process_lfsid_in_use(struct sna_lfsid_in_use *lfsid_in_use)
+{
+	struct sna_lfsid_in_use_rsp *lfsid_in_use_rsp;
+
+	/* find activate or pending session ?? */
+	
+
+	lfsid_in_use_rsp = (struct sna_lfsid_in_use_rsp *)kmalloc(sizeof(lfsid_in_use_rsp), GFP_ATOMIC);
+
+	lfsid_in_use_rsp->pc_id = lfsid_in_use->pc_id;
+	lfsid_in_use_rsp->lfsid = lfsid_in_use->lfsid;
+
+	if(sna_find_session(PEND_ACTIVE, lfsid, pc_id))
+		lfsid_in_use_rsp->answer = YES;
+	else
+		lfsid_in_use_rsp->answer = NO;
+
+	send_to_asm(lfsid_in_use_rsp);
+
+	return (0);
+}
+
+/* Process a SESSION_ROUTE_INOP record received from ASM. */
+static int sna_process_session_route_inop(struct sna_session_route_inop *inop)
+{
+	struct sna_lu_lu_cb *lulu_cb;
+
+	for(lulu_cb = lulu_cb_list; lulu_cb != NULL; lulu_cb = lulu_cb->next)
+	{
+		if(inop->pc_id != lulu_cb->pc_id)
+			continue;
+
+		fsm_status(inop, lulu_cb);
+	}
+
+	return (0);
+}
+
+/* Increment the size of the permanent buffer pool. Get a demand buffer for
+ * an UNBIND.
+ */
+static int sna_reserve_constant_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_local *local;
+
+	err = bm(ADJUST_BUF_POOL, lulu_cb->perm_buf_pool_id, 1);
+
+	if(more_buffs_avail())
+	{
+		lulu_cb->perm_pool_adjusted_up = YES;
+		bm(GET_BUFFER, demand, size, no_wait);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Reserve a dynamic buffer pool, and a limited buffer pool. */
+static int sna_reserve_variable_buffers(struct sna_lu_lu_cb *lulu_cb)
+{
+	struct sna_mu *mu;
+	struct sna_local *local;
+
+	if(bind_rsp_rcv->adaptive_pace == SUPPORTED)
+	{
+		err = bm(CREATE_BUF_POOL, vary_dynamic, lulu_cb->hs_id, capacity, size, num_bufs);
+		if(err > 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size, num_bufs);
+	}
+	else
+	{
+		err = bm(CREATE_BUF_POOL, fixed_dynamic, lulu_cb->hs_id, capacity, size);
+		if(err < 0)
+			err = bm(CREATE_BUF_POOL, limited, lulu_cb->hs_id, capacity, size);
+	}
+
+	if(err < 0)
+		local->sense = 0x0812000D;
+
+	return (0);
+}
+
+/* Unreserve (ie. release previously reserved buffers) appropriate buffers
+ * for the session.
+ */
+static int sna_unreserve_buffers(struct sna_lu_lu_cb *lulu_cb, 
+	__u8 perm_buf_pool_id)
+{
+	int size;
+
+	size = size_of_perm_buf - activted_pool_size;
+
+	if(size)
+		bm(ADJUST_BUF_POOL, perm_buf_pool_id, size);
+
+	if(demand_buf_reserverd_unbind)
+		bm(FREE, unbind);
+
+	return (0);
+}
+
+static int sna_fsm_status()
+{
+
+	/* Finite State Machines are Pass 3 so hold on here */
+
+	return 0;
+}
+
+#endif
diff -ruN linux-2.4.4/net/sna/sna_ss.c linux/net/sna/sna_ss.c
--- linux-2.4.4/net/sna/sna_ss.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_ss.c	Mon May 14 21:12:32 2001
@@ -0,0 +1,528 @@
+/* sna_ss.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+static struct sna_ss_pinfo *ss_clients = NULL;
+
+int sna_ss_insert(struct sna_ss_pinfo *ss)
+{
+        sna_debug(10, "sna_ss_insert\n");
+        ss->next = ss_clients;
+        ss_clients = ss;
+
+        return (0);
+}
+
+struct sna_ss_pinfo *sna_ss_find(char *name)
+{
+        struct sna_ss_pinfo *f;
+
+        sna_debug(5, "sna_ss_find\n");
+        for(f = ss_clients; f != NULL; f = f->next)
+                if(!strncmp(f->netid.name, name, SNA_NODE_NAME_LEN))
+                        break;
+	return (f);
+}
+
+int sna_ss_shutdown(void)
+{
+        struct sna_ss_pinfo *d;
+        struct sna_ss_pinfo **clients = &ss_clients;
+        unsigned long flags;
+
+        sna_debug(5, "sna_ss_shutdown\n");
+        save_flags(flags);
+        cli();
+
+        while((d = *clients) != NULL)
+        {
+                *clients = d->next;
+                kfree(d);
+        }
+
+        restore_flags(flags);
+
+        return (0);
+}
+
+int sna_ss_create(struct sna_start_node *start)
+{
+	struct sna_ss_pinfo *ss;
+
+	sna_debug(5, "sna_ss_create %s\n", start->netid.name);
+	ss = sna_ss_find(start->netid.name);
+	if(ss)
+		return (-EEXIST);
+	ss=(struct sna_ss_pinfo*)kmalloc(sizeof(struct sna_ss_pinfo),
+		GFP_ATOMIC);
+	memcpy(&ss->netid, &start->netid, sizeof(struct sna_netid));
+	ss->next = NULL;
+	ss->prev = NULL;
+
+        sna_ss_insert(ss);
+	return (0);
+}
+
+int sna_ss_destroy(struct sna_delete_node *delete)
+{
+        struct sna_ss_pinfo *ss, **clients = &ss_clients;
+
+        sna_debug(5, "sna_ss_destroy\n");
+        while((ss = *clients) != NULL)
+        {
+                if(!strncmp(ss->netid.name, delete->netid.name, 8))
+                {
+                        *clients = ss->next;
+                        kfree(ss);
+                        return (0);
+                }
+                clients = &ss->next;
+        }
+
+        return (-ENOENT);
+}
+
+int sna_ss_act_cp_cp_session(void)
+{
+
+	return (0);
+}
+
+int sna_ss_deact_cp_cp_session(void)
+{
+
+	return (0);
+}
+
+int sna_ss_act_control_sessions(void)
+{
+
+	return (0);
+}
+
+int sna_ss_deact_control_sessions(void)
+{
+
+	return (0);
+}
+
+int sna_ss_update_node_authorization(void)
+{
+
+	return (0);
+}
+
+int sna_ss_update_search_control_vectors(void)
+{
+
+	return (0);
+}
+
+int sna_ss_process_sesst_signal(void)
+{
+
+	return (0);
+}
+
+int sna_ss_process_sessend_signal(void)
+{
+
+	return (0);
+}
+
+int sna_ss_isr_init(void)
+{
+
+	return (0);
+}
+
+int sna_ss_isr_sessend(void)
+{
+
+	return (0);
+}
+
+static __u32 sna_pc_system_id  = 1;
+static unsigned long hash1, hash2;
+
+/*
+  Returns a string of 0 and 1 characters, representing the provided 64bit
+  number in binary.
+*/
+void
+rl_binary(unsigned char * number, unsigned char * result)
+{
+  int curbyte;
+  int resultidx;
+  unsigned char curbit;
+
+  resultidx = 63;
+  result[64] = '\0';
+
+  for(curbyte=0; curbyte < 8; curbyte++)
+    {
+      for(curbit = 0; curbit < 8; curbit++)
+        {
+          result[resultidx] = (number[curbyte] & (1<<curbit)) ? '1' : '0';
+          resultidx--;
+        }
+    }
+}
+
+
+/*
+  Subtracts two 64bit numbers.  The top value must be >= the bottom.
+ */
+void
+rl_sub(unsigned char * top, unsigned char * bottom)
+{
+  unsigned int curbyte;
+  int borrowed;
+  int curtop;
+
+  if(top[7] < bottom[7])
+    {
+      return;
+    }
+
+  borrowed = 0;
+
+  for(curbyte = 0; curbyte < 8; curbyte++)
+    {
+      curtop = top[curbyte];
+
+      if(borrowed)
+        {
+          if(curtop == 0)
+            {
+              curtop = 0xFF;
+              borrowed = 1;
+            } else {
+              curtop = curtop--;
+              borrowed = 0;
+            }
+        }
+
+      if(curtop < bottom[curbyte])
+        {
+          curtop = curtop + 0x100;
+          borrowed = 1;
+        }
+      curtop = curtop - bottom[curbyte];
+      top[curbyte] = curtop;
+    }
+}
+
+/*
+  Shifts the 64bit number one byte to the left.  Zero is inserted in the lsb.
+*/
+int rl_left(unsigned char * number)
+{
+        int carry;
+        unsigned char mask;
+        int curbyte;
+
+        if(number[7] & 0x80)
+                carry = 1;
+        else
+                carry = 0;
+
+        for(curbyte = 7; curbyte >= 0; curbyte--)
+        {
+                if(curbyte > 0)
+                {
+                        mask = (number[curbyte-1] & 0x80) ? 0x01 : 0x00;
+                        number[curbyte] = (number[curbyte] << 1) | mask;
+                }
+                else
+                        number[curbyte] <<= 1;
+        }
+
+        return(carry);
+}
+
+/*
+  Shifts the 64bit number one bit to the right.  Zero is inserted as the msb
+ */
+void
+rl_right(unsigned char * number)
+{
+  unsigned char mask;
+  int curbyte;
+
+  for(curbyte = 0; curbyte < 8; curbyte++)
+    {
+      if(curbyte < 7)
+        {
+          mask = (number[curbyte+1] & 0x01) ? 0x80 : 0x00;
+          number[curbyte] = (number[curbyte] >> 1) | mask;
+        } else {
+          number[curbyte] >>= 1;
+        }
+    }
+}
+
+/*
+  Shifts the divisor to the left as necessary to align the most signifcant
+  bit with the msb of the dividend.
+ */
+void
+rl_align(unsigned char * dividend, unsigned char * divisor)
+{
+  int maxbyte;
+  int maxbit;
+
+  for(maxbyte = 7; maxbyte >= 0; maxbyte--)
+    {
+      if(dividend[maxbyte] > 0)
+        break;
+    }
+
+  for(maxbit = 8; maxbit >= 0; maxbit--)
+    {
+      if( dividend[maxbyte] & (1 << maxbit) )
+        {
+          break;
+        }
+    }
+  while( !(divisor[maxbyte] & (1 << maxbit)))
+  {
+    rl_left(divisor);
+  }
+}
+
+/*
+  Returns true if the dividend is greater than or equal to the divisor.
+ */
+int
+rl_lt(unsigned char * dividend, unsigned char * divisor)
+{
+  int maxbyte;
+  int curbyte;
+
+  for(maxbyte = 7; maxbyte > 0; maxbyte--)
+    {
+      if( (dividend[maxbyte] != 0) || (divisor[maxbyte] != 0) )
+        {
+          break;
+        }
+    }
+
+  for(curbyte = maxbyte; curbyte > 0; curbyte--)
+    {
+      if(dividend[curbyte] == divisor[curbyte])
+        {
+          continue;
+        } else {
+          return(dividend[curbyte] >= divisor[curbyte]);
+        }
+    }
+  return(0);
+}
+
+/*
+  Divides two 64 bit numbers.  The numbers need to be passed as 8 element
+  arrays of unsigned char.  The quotient is returned in quotient, and the
+  remainder is returned in dividend.  The divisor is shifted during the
+  division, so don't count on it having the same value after invocation.
+ */
+void rl_div(unsigned char * dividend, unsigned char * divisor,
+       unsigned char * quotient)
+{
+  unsigned char tempdiv[8];
+  int curbyte;
+
+  memset(quotient, 0, 8);
+
+  for(curbyte=0; curbyte < 8; curbyte++)
+    {
+      tempdiv[curbyte] = divisor[curbyte];
+    }
+
+  rl_align(dividend, divisor);
+
+  do {
+
+    if( rl_lt(dividend, divisor) )
+      {
+        rl_sub(dividend, divisor);
+        rl_left(quotient);
+        quotient[0] = quotient[0] | 0x01;
+      } else {
+        rl_left(quotient);
+      }
+    rl_right(divisor);
+
+  } while(rl_lt(dividend, tempdiv));
+}
+
+/* Generates a FQPCID in the and returns it in the correct order. */
+int sna_ss_generate_pcid(char *net, char *name)
+{
+        unsigned char prime1[8] = {0xC7,0xFF,0xFF,0x0F,0x00,0x00,0x00,0x00};
+        unsigned char prime2[8] = {0x1F,0x88,0x53,0x7E,0x00,0x00,0x00,0x00};
+        unsigned char pname[8], pnet[8], fname[8], fnet[8];
+        unsigned char quotient[8], dividend[8], dividend2[8];
+        unsigned long scratch1;
+        struct timeval time;
+        int i;
+
+        /* Dividend */
+        atoe_strncpy(pname, name, strlen(name));
+        for(i = strlen(name); i < 8; i++)
+                pname[i] = 0x40;
+        for(i = 0; i < 8; i++)          /* reverse order */
+                fname[i] = pname[7-i];
+        atoe_strncpy(pnet, net, strlen(net));
+        for(i = strlen(net); i < 8; i++)
+                pnet[i] = 0x40;
+        etor_strncpy(pnet, pnet, 8);
+        for(i = 0; i < 8; i++)          /* reverse order */
+                fnet[i] = pnet[7-i];
+        for(i = 0; i < 8; i++)
+                dividend[i] = fname[i] ^ fnet[i];
+        memcpy(dividend2, dividend, 8);
+
+        /* Hash 1 */
+        rl_div(dividend2, prime1, quotient);
+        memcpy(&hash1, dividend2, sizeof(unsigned long));
+        scratch1 = (hash1 ^ (unsigned short)hash1) << 2;
+        set_bit(16, &scratch1);
+        set_bit(17, &scratch1);
+        set_bit(30, &scratch1);
+        set_bit(31, &scratch1);
+        hash1 = (scratch1 | (unsigned short)hash1);
+        hash1 += htonl(sna_pc_system_id++);
+
+        sna_debug(5, "HASH1 - %04lX\n", hash1);
+
+        /* Hash 2 */
+        memcpy(dividend2, dividend, 8);
+        rl_div(dividend2, prime2, quotient);
+        memcpy(&hash2, dividend2, sizeof(unsigned long));
+
+        do_gettimeofday(&time);
+        hash2 += time.tv_sec;
+
+        sna_debug(5, "HASH2 - %04lX\n", hash2);
+
+        return (0);
+}
+
+int sna_ss_update_pcid(unsigned char *r)
+{
+        unsigned char result[8], scratch2[8];
+        unsigned long nhash1, nhash2;
+
+        hash2++;
+
+        /* Generate final pcid */
+        memcpy(scratch2, &hash1, 4);
+        memcpy(scratch2 + 4, &hash2, 4);
+        nhash1 = ntohl(hash1);
+        nhash2 = ntohl(hash2);
+        memcpy(result, &nhash1, 4);
+        memcpy(result + 4, &nhash2, 4);
+        strncpy(r, result, 8);
+
+        return (0);
+}
+
+int sna_ss_assign_pcid(struct sna_assign_pcid *pcid)
+{
+//	struct sna_lulu_cb *lulu;
+
+	sna_debug(5, "sna_ss_assign_pcid\n");
+/*
+	lulu = sna_sm_find_lulu(pcid->sm_proc_id);
+	if(!lulu)
+		return (-ENOENT);
+
+	sna_ss_generate_pcid(lulu->netid.net, lulu->netid.name);
+	sna_ss_update_pcid(pcid->fqpcid);
+*/
+	pcid->duplicate_pcid = 0;	/* reset */
+        return (0);
+}
+
+int sna_ss_process_init_signal(struct sna_init_signal *init)
+{
+	struct sna_cos_tpf_vector *cos;
+	struct sna_rq_single_hop_route *rt;
+	struct sna_activate_route *as;
+	struct sna_cinit_signal *cinit;
+	struct sna_netid *netid;	
+	int err = 0;
+
+	sna_debug(5, "sna_ss_process_init_signal %s %s\n",
+		sna_pr_netid(&init->plu_name), sna_pr_netid(&init->slu_name));
+
+	cos = (struct sna_cos_tpf_vector *)kmalloc(sizeof(*cos), GFP_ATOMIC);
+	memcpy(&cos->mode_name, &init->mode_name, SNA_RESOURCE_NAME_LEN);
+	err = sna_cosm_cos_tpf_vector(cos);
+	if(err < 0)
+		return (err);
+
+	rt = (struct sna_rq_single_hop_route *)kmalloc(sizeof(*rt), GFP_ATOMIC);
+	memcpy(&rt->dst_cp_name, &init->plu_name, sizeof(struct sna_netid));
+	err = sna_rss_request_single_hop_route(rt);
+	if(err < 0)
+		return (err);
+
+	as = (struct sna_activate_route *)kmalloc(sizeof(*as), GFP_ATOMIC);
+	as->tg_id = rt->rs.tg_desc.id.tg_number;
+	memcpy(&as->pc_id, &init->fqpcid, 8);
+	netid = sna_char_to_netid(rt->rs.tg_desc.id.pcp_name);
+//	memcpy(&as->cp_name, netid, sizeof(struct sna_netid));
+	memcpy(&as->cp_name, &init->slu_name, sizeof(struct sna_netid));
+	err = sna_cs_activate_route(as);		/* XID */
+	if(err < 0)
+		return (err);
+
+	cinit = (struct sna_cinit_signal *)kmalloc
+		(sizeof(struct sna_cinit_signal), GFP_ATOMIC);
+	err = sna_sm_process_cinit_signal(cinit);	/* BIND */
+	if(err < 0)
+		return (err);
+
+	kfree(cos);
+        kfree(rt);
+        kfree(as);
+	kfree(cinit);
+
+        return (err);
+}
diff -ruN linux-2.4.4/net/sna/sna_tc.c linux/net/sna/sna_tc.c
--- linux-2.4.4/net/sna/sna_tc.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_tc.c	Mon May 14 21:12:42 2001
@@ -0,0 +1,913 @@
+/* sna_tc.c: Linux Systems Network Architecture implementation
+ * - SNA Transmission Control (TC)
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/skbuff.h>
+#include <linux/stat.h>
+#include <linux/if_ether.h>
+#include <linux/sna.h>
+
+int sna_tc_rcv(struct sk_buff *skb, struct sna_lfsid *lfsid)
+{
+	sna_debug(5, "sna_tc_rcv\n");
+	sna_dfc_rcv(skb);
+
+	return (0);
+}
+
+int sna_tc_send_mu(struct sk_buff *skb)
+{
+	sna_debug(5, "sna_tc_send_mu\n");
+
+	kfree_skb(skb);
+
+#ifdef NOT
+	int i;
+
+	if(sna_debug_level > 5)
+	{
+		printk("sna_tc_send_mu\n");
+		hexdump(skb->data, skb->len);
+		printk("Sizeof TH %d, RH %d, FMH %d\n", 
+			sizeof(struct sna_fid2), sizeof(struct snarhdr), 
+			sizeof(struct sna_fmh5)); 
+	}
+
+	skb = skb_unshare(skb, GFP_ATOMIC);
+	if(!skb)
+		return (-1);
+
+	for(i = 0; i < 1000; i++)
+		schedule();
+	sna_tc_rcv(skb);
+#endif
+
+	return (0);
+}
+
+int sna_tc_init(void)
+{
+	return (0);
+}
+
+#if defined(CONFIG_SNA_HS) || defined(CONFIG_SNA_HS_MODULE)
+
+extern __u16 sys_snf_ids;
+
+/* Initialize the Transmission Control layer. */
+int sna_tc_init(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->hs_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+
+	if(init_hs->type == SNA_HS_PRI)
+		tcb->max_rcv_ru_size 
+			= init_hs->bind.sec_hs_max_ru_size_sent;
+	else
+		tcb->max_rcv_ru_size
+			= init_hs->bind.pri_hs_max_ru_size_sent;
+	tcb->sqn_rcv_cnt = 0;
+
+	tcb->ccb.caller			= SNA_HS;
+	tcb->ccb.lfsid			= init_hs->lfsid;
+	tcb->ccb.pc_id			= init_hs->pc_id;
+	tcb->ccb.perm_buf_pool_id	= init_hs->perm_buf_pool_id;
+	tcb->ccb.dynamic_buf_pool_id	= init_hs->dynamic_buf_pool_id;
+	tcb->ccb.limit_buf_pool_id	= init_hs->limit_buf_pool_id;
+	tcb->ccb.tx_priority 		= init_hs->tx_priority;
+	tcb->ccb.num_bufs_per_ru	= 1;
+	tcb->ccb.send_pacing.rlwi	= SNA_CCB_NO_RLW;
+	tcb->ccb.send_pacing.rpc	= 0;
+	tcb->ccb.receive_pacing.rpc	= 0;
+
+	if(init_hs->type == SNA_HS_PRI)
+	{
+		tcb->ccb.send_pacing.nws	= init_hs->bind.pri_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.pri_rws;
+	}
+	else
+	{
+		tcb->ccb.send_pacing.nws 	= init_hs->bind.sec_sws;
+		tcb->ccb.receive_pacing.nws 	= init_hs->bind.sec_rws;
+	}
+
+	if(init_hs->bind.adapt_pace == SNA_RU_BIND_ADAPT_NO_SUPP)
+		tcb->ccb.send_pacing.type = SNA_PACING_TYPE_ADAPTIVE;
+	else
+	{
+		tcb->ccb.receive_pacing.type = SNA_PACING_TYPE_FIXED;
+		if(tcb->ccb.send_pacing.nws > 0)
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_FIXED;
+		else
+			tcb->ccb.send_pacing.type = SNA_PACING_TYPE_NONE;
+	}
+
+	tcb->ccb.send_pacing.first_ws = tcb->ccb.send_pacing.nws;
+	tcb->ccb.receive_pacing.unsolicited_ipm_outstanding	= 0;
+	tcb->ccb.receive_pacing.adjust_ipm_ack_outstanding	= 0;
+	tcb->ccb.receive_pacing.unsolicited_nws 		= 0;
+	tcb->ccb.reserve_flag 					= 0;
+
+	if(init_hs->bind.whole_biu)
+		tcb->segmenting_supported = 0;
+	else
+		tcb->segmenting_supported = 1;
+
+	tcb->crypto = 0;
+	if(init_hs->bind.crypto.sess_level_crypto == SNA_RU_CRYPTO_MANDATORY)
+	{
+		tcb->crypto = 1;
+		sna_tc_exchange_crv(init_hs);
+	}
+
+	return (0);
+}
+
+/* Handle the exchange of the Cryptograhpy Verification (CRV) request. */
+static int sna_tc_exchange_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_hs_local *local = sna_hs_find_local(init_hs->pc_id);
+	struct sna_tc_cb *tcb = &local->tcb;
+	struct sna_mu *mu = NULL;
+	int err;
+
+	if(init_hs->type == SNA_HS_PRI)
+	{
+		mu = sna_tc_build_crv(init_hs);
+		local->tcb.ccb.caller = SNA_HS;
+		sna_send_mu(mu, &tcb->ccb);
+
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+
+		err = sna_tc_crv_format_chk(mu);
+		if(err == 0)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		sna_free_buffer(mu);
+	}
+	else
+	{
+		mu = sna_catch_mu(local);	/* Spin till rcv the CRV. */
+		err = sna_tc_crv_format_chk(mu);
+		if(err == 0)
+		{
+			/* Check the crypto test values. */
+			if(err)
+			{
+				local->sense = 0x08350001;
+				sna_free_buffer(mu);
+			}
+			else
+			{
+				local->sense = 0;
+				mu->biu->rh.rh.rsp_h.rri = SNA_RH_RRI_RSP;
+				mu->biu->rh.rh.rsp_h.rti = SNA_RH_RTI_POS;
+				local->tcb.ccb.caller = SNA_HS;
+				sna_send_mu(mu, &tcb->ccb);
+			}
+		}
+	}
+
+	return (0);
+}
+
+/* Build and MU (containing the CRV request) by appropriately initializing
+ * the TH, RH, and RU fields.
+ */
+static struct sna_mu *sna_tc_build_crv(struct sna_init_hs *init_hs)
+{
+	struct sna_mu *mu = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	mu = sna_get_buffer(SNA_BM_TYPE_DEMAND, init_hs->dynamic_buf_pool_id, 
+		0, SNA_BM_NO_WAIT);
+
+	mu->biu->th.fid.fid0.efi 		= SNA_TH_EFI_EXP;
+	mu->biu->th.fid.fid0.snf.number 	= *(__u16 *)jiffies;
+	mu->biu->th.fid.fid0.mpf		= SNA_TH_MPF_WHOLE_BIU;
+
+	req_h->rri	= SNA_RH_RRI_REQ;
+	req_h->ru	= SNA_RH_RU_SC;
+	req_h->fi	= SNA_RH_FI_FMH;
+	req_h->sdi	= SNA_RH_SDI_NO_SD;
+	req_h->bci	= SNA_RH_BCI_BC;
+	req_h->eci	= SNA_RH_ECI_EC;
+	SNA_DFC_SET_RQD1(req_h);
+	req_h->rlwi	= SNA_RH_RLWI_NO_RLW;
+	req_h->qri	= SNA_RH_QRI_NO_QR;
+	req_h->pi	= SNA_RH_PI_NO_PAC;
+	req_h->bbi	= SNA_RH_BBI_NO_BB;
+	req_h->cdi	= SNA_RH_CDI_NO_CD;
+	req_h->csi	= SNA_RH_CSI_CODE0;
+	req_h->edi	= SNA_RH_EDI_NO_ED;
+	req_h->pdi	= SNA_RH_PDI_NO_PD;
+	req_h->cebi	= SNA_RH_CEBI_NO_CEB;
+
+	/* More crypto stuff.. */
+
+	return (mu);
+}
+
+/* Check the RH bits of the CRV request or RSP(CRV) received from path_control
+ * (from the partner half_session).
+ */
+static int sna_tc_crv_format_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	int length;
+
+	/* Calculate the length of the RU data. */
+	length = 0;
+
+	if(req_h->rri == SNA_RH_RRI_REQ)
+	{
+		if(local->half_session == SNA_HS_PRI)
+			local->sense = 0x20090000;
+		if(req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if((req_h->sdi == SNA_RH_SDI_NO_SD && length < 1)
+			|| (req_h->sdi == SNA_RH_SDI_SD && length < 5))
+			local->sense = 0x10020000;
+		if((req_h->sdi == SNA_RH_SDI_NO_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if(req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+
+		if(req_h->sdi == SNA_RH_SDI_SD)
+			local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+		if(req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if(req_h->eci == SNA_RH_ECI_NO_EC)
+			local->sense = 0x400B0000;
+		if(SNA_DFC_RQD1(req_h))
+			local->sense = 0x40140000;
+		if(th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if(req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if(req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+		if(req_h->bbi == SNA_RH_BBI_BB)
+			local->sense = 0x400C0000;
+		if(req_h->ebi == SNA_RH_EBI_EB)
+			local->sense = 0x400C0000;
+		if(req_h->cdi == SNA_RH_CDI_CD)
+			local->sense = 0x400D0000;
+		if(req_h->csi == SNA_RH_CSI_CODE1)
+			local->sense = 0x40100000;
+		if(req_h->edi == SNA_RH_EDI_ED)
+			local->sense = 0x40160000;
+		if(req_h->pdi == SNA_RH_PDI_PD)
+			local->sense = 0x40170000;
+		if(req_h->cebi == SNA_RH_CEBI_CEB)
+			local->sense = 0x400C0000;
+	}
+	else	/* CRV Response */
+	{
+		if(local->half_session == SNA_HS_SEC)
+			local->sense = 0x20090000;
+		if(req_h->ru != SNA_RH_RU_SC)
+			local->sense = 0x20090000;
+		if((rsp_h->rti && length < 1) 
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && length < 5))
+			local->sense = 0x10020000;
+		if((req_h->sdi != SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0)
+			||(req_h->sdi == SNA_RH_SDI_SD 
+			&& mu->biu->ru.ru.crv.rq_code != 0xC0))
+			local->sense = 0x20090000;
+		if(req_h->fi == SNA_RH_FI_NO_FMH)
+			local->sense = 0x400F0000;
+		if(req_h->bci == SNA_RH_BCI_NO_BC)
+			local->sense = 0x400B0000;
+		if(req_h->eci == SNA_RH_ECI_NO_EC)
+			local->sense = 0x400B0000;
+		if(th->efi != SNA_TH_EFI_EXP)
+			local->sense = 0x40110000;
+		if(req_h->dr1i != SNA_RH_DR1I_DR1 
+			|| req_h->dr2i == SNA_RH_DR2I_DR2)
+			local->sense = 0x40140000;
+		if((rsp_h->rti == SNA_RH_RTI_POS && req_h->sdi == SNA_RH_SDI_SD)
+			|| (rsp_h->rti == SNA_RH_RTI_NEG && req_h->sdi== SNA_RH_SDI_NO_SD))
+			local->sense = 0x40130000;
+		if(req_h->qri == SNA_RH_QRI_QR)
+			local->sense = 0x40150000;
+		if(req_h->pi == SNA_RH_PI_PAC)
+			local->sense = 0x40080000;
+	}
+	
+	return (0);
+}
+
+/* Send the input MU to path control. */
+int sna_send_mu(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_req_h *rh = &mu->biu->rh.rh.req_h;
+	int err = 0;
+
+	if(th->efi == SNA_TH_EFI_EXP)
+		sna_send_to_pc(mu, cb);
+	if(th->mpf == SNA_TH_MPF_EBIU || rh->rri == SNA_RH_RRI_REQ)
+	{
+		if(local->tcb.ccb.caller == SNA_HS)
+		{
+			if(rh->ru == SNA_RH_RU_FMD)
+			{
+				/* sna_pad_mu(mu); */
+				rh->pdi = SNA_RH_PDI_PD;
+			}
+			else
+				rh->pdi = SNA_RH_PDI_NO_PD;
+
+			err = sna_des_encipher(mu);
+			if(err)
+				local->sense = 0x8480000;
+			else
+				local->sense = 0x0000000;
+		}
+
+		if(err)
+			sna_free_buffer(mu);
+		else
+		{
+			rh->edi = SNA_RH_EDI_ED;
+			if(cb->send_pacing.type != SNA_PACING_TYPE_NONE)
+			{
+				if(sna_hs_pacing_queue_empty 
+					|| (th->mpf == SNA_TH_MPF_BBIU
+					&& cb->send_pacing.rpc 
+					+ cb->send_pacing.nws == 0))
+				{
+					sna_hs_pacing_queue_tail(mu);
+				}
+			}
+			else
+				sna_send_to_pc(mu, cb);
+		}
+	}
+
+	if(rh->rri == SNA_RH_RRI_RSP)
+	{
+		if(cb->send_pacing.type == SNA_PACING_TYPE_NONE
+			|| sna_hs_pacing_queue_empty(mu) 
+			|| rh->qri == SNA_RH_QRI_NO_QR)
+		{
+			sna_send_to_pc(mu, cb);
+		}
+		else
+			sna_hs_pacing_queue_tail(mu);
+	}
+
+	return (0);
+}
+
+/* Update the send pacing counts in the common control block and set the
+ * pacing bits (rh->pi and rh->rlwi of the MU being sent) to the
+ * appropriate values.
+ */
+static int sna_send_pacing(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+
+	if(cb->send_pacing.rpc > 0)
+		cb->send_pacing.rpc--;
+	else
+	{
+		cb->send_pacing.rpc		= cb->send_pacing.nws - 1;
+		cb->send_pacing.nws 		= 0;
+		mu->biu->rh.rh.req_h.pi		= SNA_RH_PI_PAC;
+		mu->biu->rh.rh.req_h.rlwi 	= cb->send_pacing.rlwi;
+		cb->send_pacing.rlwi		= SNA_CCB_NO_RLW;
+	}
+
+	return (0);
+}
+
+/* Send an MU to path control. */
+static int sna_send_to_pc(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_ipm_extension *ipm_ext = NULL;
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_msg_queue *msg = NULL;
+	int err;
+
+	mu->header_type = SNA_MU_HS_TO_PC;
+	mu->layer.hs_to_pc.lfsid = cb->lfsid;
+	mu->layer.hs_to_pc.tx_priority = cb->tx_priority;
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		if((req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC) 
+			|| req_h->dr1i == SNA_RH_DR1I_NO_DR1
+			|| (req_h->dr2i == SNA_RH_DR2I_NO_DR2 
+			&& cb->send_pacing.type == SNA_PACING_TYPE_ADAPTIVE))
+		{
+			if(ipm_ext->type != SNA_IPM_TYPE_RESET_ACK)
+				mu->layer.hs_to_pc.tx_priority 
+					= SNA_TP_NETWORK;
+		}
+		else
+		{
+			if(th->efi != SNA_TH_EFI_EXP && cb->send_pacing.type 
+				!= SNA_PACING_TYPE_NONE)
+				sna_send_pacing(mu);
+		}
+
+		msg->mu = mu;
+		err = sna_pc(msg);
+		if(err)
+			sna_free_buffer(mu);
+	}
+
+	return (0);
+}
+
+/* Receive an MU sent from path control. */
+int sna_tc_rcv(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_mu *wmu;
+
+	sna_tc_segment_rcv_chk(mu);
+	if(local->sense != 0x00000000)
+		return (-1);
+
+	if(th->efi == SNA_TH_EFI_NORM && th->mpf == SNA_TH_MPF_BBIU)
+		sna_rcv_pacing(mu, &local->tcb.ccb);
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		wmu = sna_segment_reassembly(mu);
+		if(local->sense == 0x00000000)
+		{
+			if(wmu)
+			{
+				sna_tc_biu_rcv_chk(mu);
+				if(local->sense == 0x00000000)
+				{
+					if(th->efi == SNA_TH_EFI_NORM)
+					{
+						if(req_h->edi == SNA_RH_EDI_ED
+							&& mu->biu->ru.ru.raw != NULL
+							&& req_h->ru == SNA_RH_RU_FMD)
+						{
+							sna_tc_decipher_ru(mu);
+
+							if(local->sense == 0x00000000)
+							{
+								/* Must wrap to 0 after 65535 */
+								local->sqn_rcv_cnt++;
+							}
+
+							sna_dfc_rcv(mu);
+						}
+						else
+						{
+							if(req_h->rri == SNA_RH_RRI_RSP && req_h->pi == SNA_RH_PI_PAC)
+							{
+								sna_rcv_pacing_rsp(mu, &local->tcb.ccb);
+								if(mu != NULL)
+									sna_dfc_rcv(mu);
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return (0);
+}
+
+/* Perform receive checks on all segments received from PC. */
+static int sna_tc_segment_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(local->segmenting_supported && th->mpf == SNA_TH_MPF_NO_BIU)
+	{
+		local->sense = 0x80070001;
+	}
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(SNA_DFC_RQD(req_h)
+		|| (th->mpf == SNA_TH_MPF_BBIU && local->segmenting_supported))
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(th->mpf == SNA_TH_MPF_EBIU && !local->segmenting_supported)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if((th->mpf == SNA_TH_MPF_EBIU && th->mpf == SNA_TH_MPF_BBIU) 
+		!= th->mpf == SNA_TH_MPF_EBIU)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(mu->dcf < 10)
+	{
+		local->sense = 0x80070000;
+	}
+
+	if(th->mpf == SNA_TH_MPF_BBIU && local->sense == 0x00000000)
+		sna_mu_pacing_chk(mu);
+
+	return (0);
+}
+
+/* This procedure performs receive checks on BIUs. */
+static int sna_tc_biu_rcv_chk(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	__u8 ru_len;
+
+	if(req_h->ru != SNA_RH_RU_FMD || req_h->ru != SNA_RH_RU_DFC)
+		local->sense = 0x10070000;
+	else
+	{
+		ru_len = 0;
+		if(req_h->sdi == SNA_RH_SDI_SD)
+			ru_len += 4;
+		if(req_h->ru == SNA_RH_RU_DFC)
+			ru_len += 1;
+		if(mu->dcf < ru_len + 3)
+			local->sense = 0x1002000;
+		else
+		{
+			if(req_h->sdi == SNA_RH_SDI_SD)
+			{
+					local->sense = *(__u32 *)mu->biu->ru.ru.raw;
+			}
+			else
+			{
+				if(th->efi == SNA_TH_EFI_NORM)
+				{
+					if(th->snf.number != local->sqn_rcv_cnt + 1)
+						local->sense = 0x2001000;
+					if(local->crypto)
+					{
+						if(req_h->ru == SNA_RH_RU_FMD)
+						{
+							if(mu->biu->ru.ru.raw != NULL
+								&& local->sense == 0x00000000)
+							{
+								if(req_h->edi != SNA_RH_EDI_ED)
+									local->sense = 0x08090000;
+								else
+								{
+									if(!(mu->dcf % 8))
+										local->sense = 0x10010000;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	return (0);
+}
+
+static int sna_mu_pacing_chk(struct sna_mu *mu)
+{
+	struct sna_ipm_extension *ipm_extension = NULL;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+
+	if(th->efi == SNA_TH_EFI_NORM)
+	{
+		if(local->tcb.ccb.receive_pacing.rpc == 0)
+		{
+			if(local->tcb.ccb.receive_pacing.nws == 0)
+				local->sense = 0x20110000;
+			else
+			{
+				if(mu->biu->rh.rh.rsp_h.pi != SNA_RH_PI_PAC)
+					local->sense = 0x20110000;
+			}
+		}
+		else
+		{
+			if(mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC)
+				local->sense = 0x20110002;
+		}
+
+		return (0);
+	}
+
+	if(local->tcb.ccb.send_pacing.type == SNA_PACING_TYPE_ADAPTIVE 
+		&& mu->biu->rh.rh.rsp_h.pi == SNA_RH_PI_PAC)
+	{
+		if(SNA_IPM_FORMAT_0)
+		{
+			if(mu->dcf < sizeof(struct sna_rh)
+				+ sizeof(struct sna_ipm_extension))
+			{
+				local->sense = 0x10020000;
+			}
+			else
+			{
+				if(ipm_extension->format_indicator
+					!= SNA_IPM_FORMAT_0)
+				{
+					local->sense = 0x10010003;
+				}
+			}
+		}
+		else
+		{
+			switch(ipm_extension->type)
+			{
+				case (SNA_IPM_TYPE_SOLICITED):
+					if(ipm_extension->nws == 0
+					|| mu->biu->ru.ru.ipm.rwi == SNA_IPM_RWI_RESET_WINDOW)
+					{
+						local->sense = 0x10010003;
+					}
+					else
+					{
+						if(local->tcb.ccb.send_pacing.nws > 0)
+						{
+							local->sense = 0x20110001;
+						}
+					}
+					break;
+
+				case (SNA_IPM_TYPE_UNSOLICITED):
+					if(ipm_extension->rwi != SNA_IPM_RWI_RESET_WINDOW)
+						local->sense = 0x10010003;
+					break;
+
+				case (SNA_IPM_TYPE_RESET_ACK):
+					if(local->tcb.ccb.receive_pacing.unsolicited_ipm_outstanding)
+						local->sense = 0x20110001;
+					break;
+
+				default:
+					local->sense = 0x10010003;
+					break;
+			}
+		}
+	}
+
+	local->sense = 0x20110003;
+
+	return (0);
+}
+
+/* This procedure updates the receive pacing counts in the local->common_cb
+ * and determines the type of buffer reserve action to request of the BM.
+ * This procedure is never called when the reidual pacing count and the
+ * next-window size are both 0.
+ */
+static int sna_rcv_pacing(struct sna_mu *mu, 
+	struct sna_common_cb *common_cb)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+
+	if(req_h->pi != SNA_RH_PI_PAC)
+	{
+		common_cb->receive_pacing.rpc++;
+		common_cb->reserve_flag = SNA_CCB_NO;
+	}
+	else
+	{
+		common_cb->receive_pacing.rpc = common_cb->receive_pacing.nws-1;
+		common_cb->receive_pacing.nws = 0;
+		if(req_h->rlwi == SNA_RH_RLWI_RLW)
+			common_cb->reserve_flag = SNA_CCB_MORE;
+		else
+			common_cb->reserve_flag = SNA_CCB_ALL;
+	}
+
+	return (0);
+}
+
+/* This procedure copies normal-flow request MUs from link buffer to a
+ * dynamic buffer. This procedure is called to reassemble segments into a
+ * whole BIU.
+ */
+static struct sna_mu *sna_segment_reassembly(struct sna_mu *mu)
+{
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_mu *wmu = NULL;
+
+	if(th->mpf == SNA_TH_MPF_BBIU)
+	{
+		if(sizeof(mu->biu->ru) > 0)
+			local->sense = 0x10020000;
+		else
+		{
+			wmu = sna_get_buffer(SNA_BM_TYPE_DEMAND, 
+				local->tcb.ccb.limit_buf_pool_id, 0,
+				SNA_BM_NO_WAIT);
+		}
+
+		sna_free_buffer(mu);
+	}
+	else
+	{
+		/* Theres more. */
+		sna_free_buffer(mu);
+	}
+
+	if(th->mpf == SNA_TH_MPF_EBIU)
+	{
+		th->mpf = SNA_TH_MPF_EBIU;
+	}
+
+	if(local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding)
+	{
+		sna_adjust_buf_pool(local->perm_buf_pool_id, SNA_BM_TYPE_PERM,
+			0);
+		local->tcb.ccb.receive_pacing.adjust_ipm_ack_outstanding = 0;
+	}
+
+	return (wmu);
+}
+
+/* This procedure updates pacing counts in the local->common_cb, sends
+ * reset acknowledgments to unsolicited IPMs and sends MUs to path_control
+ * if possible.
+ */
+static int sna_rcv_pacing_rsp(struct sna_mu *mu, struct sna_common_cb *cb)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_ipm_extension *ipm_ex = NULL;
+	struct sna_rsp_h *rsp_h = &mu->biu->rh.rh.rsp_h;
+
+	switch(rsp_h->pi)
+	{
+		case (SNA_PACING_TYPE_ADAPTIVE):
+			if(ipm_ex->type == SNA_IPM_TYPE_RESET_ACK)
+			{
+				cb->receive_pacing.rpc = 0;
+				cb->receive_pacing.nws 
+					= cb->receive_pacing.unsolicited_nws;
+				cb->receive_pacing.unsolicited_ipm_outstanding = 0;
+				sna_free_buffer(mu);
+
+				if(1)
+					sna_adjust_buf_pool(local->tcb.ccb.dynamic_buf_pool_id, SNA_BM_TYPE_DEMAND, 0);
+				else
+					cb->receive_pacing.adjust_ipm_ack_outstanding = 1;
+			}
+
+			if(ipm_ex->type == SNA_IPM_TYPE_SOLICITED)
+			{
+				if(sna_hs_pacing_queue_empty(mu))
+				{
+					if(cb->send_pacing.rpc == 0)
+						cb->send_pacing.rlwi
+							= SNA_CCB_RLW;
+					sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id, SNA_BM_TYPE_LIMIT, 0);
+					cb->send_pacing.nws = ipm_ex->nws;
+					sna_free_buffer(mu);
+				}
+			}
+
+			if(ipm_ex->type == SNA_IPM_TYPE_UNSOLICITED)
+			{
+				mu = sna_get_buffer(SNA_BM_TYPE_DEMAND,
+					local->tcb.ccb.limit_buf_pool_id,
+					0, SNA_BM_NO_WAIT);
+				cb->send_pacing.nws = mu->biu->ru.ru.ipm.nws;
+				cb->send_pacing.rpc = 0;
+				ipm_ex->type 	= SNA_IPM_TYPE_RESET_ACK;
+				ipm_ex->rwi 	= SNA_IPM_RWI_NO_RESET_WINDOW;
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case (SNA_PACING_TYPE_NONE):
+			while(sna_hs_pacing_queue_empty(mu))
+			{
+				sna_hs_pacing_dequeue(mu);
+				sna_send_to_pc(mu, cb);
+			}
+			break;
+
+		case (SNA_PACING_TYPE_FIXED):
+			cb->send_pacing.nws = cb->send_pacing.first_ws;
+			if(rsp_h->dr1i == SNA_RH_DR1I_NO_DR1 
+				|| rsp_h->dr2i == SNA_RH_DR2I_NO_DR2)
+			{
+				sna_free_buffer(mu);
+			}
+			sna_adjust_buf_pool(local->tcb.ccb.limit_buf_pool_id,
+				SNA_BM_TYPE_LIMIT, 0);
+			break;
+	}
+
+	return (0);
+}
+
+/* This procedure receives buffers_reserved signals from the
+ * BM, updates the appropriate pacing counts in the local->common_cb
+ * and builds and sends the appropriate pacing response.
+ */
+int sna_buffers_reserved(struct sna_mu *mu)
+{
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	struct sna_common_cb *cb = &local->tcb.ccb;
+	struct sna_fid0 *th = &mu->biu->th.fid.fid0;
+	struct sna_ipm_extension *ipm_ex = NULL;
+
+	if(1)	/* reserved_buf_reduce. */
+	{
+		cb->receive_pacing.unsolicited_ipm_outstanding = 1;
+		cb->receive_pacing.unsolicited_nws = 0;
+		mu->dcf = sizeof(struct sna_req_h) + sizeof(struct sna_ru_ipm);
+		ipm_ex->type = SNA_IPM_TYPE_UNSOLICITED;
+		ipm_ex->rwi = SNA_IPM_RWI_RESET_WINDOW;
+		ipm_ex->format_indicator = SNA_IPM_FORMAT_0;
+		ipm_ex->nws = cb->receive_pacing.nws;
+	}
+	else
+		mu->dcf = th->dcf;
+
+	th->mpf		= SNA_TH_MPF_WHOLE_BIU;
+	th->efi 	= SNA_TH_EFI_EXP;
+	th->snf.number 	= 0;
+
+	sna_send_to_pc(mu, cb);
+
+	return (0);
+}
+
+/* Decipher an enciphered message. */
+static int sna_tc_decipher_ru(struct sna_mu *mu)
+{
+	struct sna_req_h *req_h = &mu->biu->rh.rh.req_h;
+	struct sna_hs_local *local = sna_hs_find_local(mu->hs_id);
+	int err;
+	__u8 len, pad_cnt = 0;
+
+	err = sna_des_decipher(mu);
+	if(err)
+		local->sense = 0x08480000;
+	else
+	{
+		if(req_h->pdi == SNA_RH_PDI_PD)
+		{
+			len = mu->dcf - sizeof(mu->biu->ru);
+			pad_cnt = mu->biu->ru.ru.raw[len];
+			if(pad_cnt < 1 || pad_cnt > 7)
+				local->sense = 0x10010000;
+			else
+			{
+				mu->dcf -= pad_cnt;
+				req_h->pdi = SNA_RH_PDI_NO_PD;
+			}
+		}
+	}
+
+	return (0);
+}
+
+#endif /* CONFIG_SNA_LU62_HS || CONFIG_SNA_LU62_HS_MODULE */
diff -ruN linux-2.4.4/net/sna/sna_tdm.c linux/net/sna/sna_tdm.c
--- linux-2.4.4/net/sna/sna_tdm.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_tdm.c	Mon May 14 21:12:49 2001
@@ -0,0 +1,429 @@
+/* sna_tdm.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+/*
+ * Bugs:
+ * - process TDUs
+ * - Garbage collection
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+#include <linux/ctype.h>
+
+static struct sna_tdm_node_cb *node_list = NULL;
+static struct sna_tdm_an_cb *ancb_list 	 = NULL;
+
+unsigned char sna_system_tg_num_id	 = 1;
+
+int sysctrl_co_max_retries		 = CO_MAX_RETRIES;
+
+struct sna_tdm_node_cb *sna_tdm_find_node_entry(struct sna_netid *netid)
+{
+	struct sna_tdm_node_cb *n;
+
+	sna_debug(5, "sna_tdm_find_node_entry %s\n", sna_pr_netid(netid));
+	for(n = node_list; n != NULL; n = n->next)
+		if(!strncmp(n->netid.net, netid->net, SNA_RESOURCE_NAME_LEN)
+			&& !strncmp(n->netid.name, netid->name, SNA_RESOURCE_NAME_LEN))
+			return (n);
+
+	return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_mac(char *mac)
+{
+	struct sna_tdm_node_cb *n;
+
+        sna_debug(5, "sna_tdm_find_tg_by_mac (%s)\n", sna_pr_ether(mac));
+        for(n = node_list; n != NULL; n = n->next)
+        {
+                struct sna_tg_cb *t;
+
+                for(t = n->tg_list; t != NULL; t = t->next)
+                        if(!memcmp(t->tg_vector.desc.dlc.mac,mac,MAX_ADDR_LEN))
+                                return (t);
+        }
+
+        return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg_by_id(unsigned char tg_num)
+{
+	struct sna_tdm_node_cb *n;
+
+	sna_debug(5, "sna_tdm_find_tg_by_id\n");
+	for(n = node_list; n != NULL; n = n->next)
+	{
+		struct sna_tg_cb *t;
+
+        	for(t = n->tg_list; t != NULL; t = t->next)
+		{
+			printk("%d %d\n", t->tg_vector.desc.id.tg_number, tg_num);
+                	if(t->tg_vector.desc.id.tg_number == tg_num)
+                        	return (t);
+		}
+	}
+
+	return (NULL);
+}
+
+struct sna_tg_cb *sna_tdm_find_tg(struct sna_tdm_node_cb *n, 
+	unsigned char tg_num)
+{
+	struct sna_tg_cb *t;
+
+	sna_debug(5, "sna_tdm_find_tg %d\n", tg_num);
+	for(t = n->tg_list; t != NULL; t = t->next)
+	        if(t->tg_vector.desc.id.tg_number == tg_num)
+	                return (t);
+
+	return (NULL);
+}
+
+int sna_tdm_cp_status(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_init_tg_update(struct sna_tg_update *tg)
+{
+	sna_debug(5, "sna_tdm_init_tg_update\n");
+	tg->node_type			= 0;
+	tg->routing			= 0;
+	tg->tg_desc.type		= 0;
+	tg->tg_desc.id.type		= 0;
+	tg->tg_desc.id.tg_number	= 0;
+	tg->tg_desc.id.pcp_len		= 0;
+	tg->tg_desc.id.pcp_name		= NULL;
+	tg->tg_desc.id.pcp_name_id_cn	= 0;
+	tg->tg_desc.id.more_cfg_info	= 0;
+	tg->tg_desc.id.hpr_support	= 0;
+	tg->tg_desc.id.tg_type		= 0;
+	tg->tg_desc.id.intersubnet_tg	= 0;
+	tg->tg_desc.id.rtp_support	= 0;
+	tg->tg_desc.id.subarea_number	= 0;
+	tg->tg_desc.dlc.type		= 0;
+	tg->tg_desc.dlc.lsap		= 0;
+	memset(tg->tg_desc.dlc.mac, 0, MAX_ADDR_LEN);
+	tg->tg_chars.type		= 0;
+	tg->tg_chars.rsn		= 0;
+	tg->tg_chars.status		= 0;
+	tg->tg_chars.garbage		= 0;
+	tg->tg_chars.quiescing		= 0;
+	tg->tg_chars.cpcp_session	= 0;
+	tg->tg_chars.effective_capacity	= 0;
+	tg->tg_chars.cost_per_connect	= 0;
+	tg->tg_chars.cost_per_byte	= 0;
+	tg->tg_chars.security		= 0;
+	tg->tg_chars.propagation_delay	= 0;
+	tg->tg_chars.user1		= 0;
+	tg->tg_chars.user2		= 0;
+	tg->tg_chars.user3		= 0;
+
+	return (0);
+}
+
+int sna_tdm_tg_update(struct sna_tg_update *utg)
+{
+	struct sna_tdm_node_cb *cb;
+	struct sna_tg_cb *tg;
+	struct sna_netid *pcp_name;
+
+	sna_debug(5, "sna_tdm_tg_update %s\n", utg->tg_desc.id.pcp_name);
+	pcp_name = sna_char_to_netid(utg->tg_desc.id.pcp_name);
+//	sna_debug(5, "(%s) (%s)\n", pcp_name->net, pcp_name->name);
+
+	cb = sna_tdm_find_node_entry(pcp_name);
+	if(!cb)
+		return (-ENOENT);
+	tg = sna_tdm_find_tg(cb, utg->tg_desc.id.tg_number);
+	if(!tg)
+	{
+		tg = (struct sna_tg_cb *)kmalloc(sizeof(struct sna_tg_cb),
+			GFP_ATOMIC);
+		init_timer(&tg->co_retry);
+		init_waitqueue_head(&tg->sleep);
+        	tg->co_retry.function   = sna_cs_connect_out;
+        	tg->co_retry.data       = (unsigned long)tg;
+        	tg->co_interval         = CO_TIMEOUT;
+        	tg->co_retries          = 0;
+        	tg->co_max_retries      = sysctrl_co_max_retries;
+		tg->cos_list		= NULL;
+		tg->next		= cb->tg_list;
+		cb->tg_list		= tg;
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+		tg->tg_vector.desc.id.tg_number = sna_system_tg_num_id++;
+
+		/* init xid information for this transmission group */
+		tg->xid_info = (struct sna_xid_info *)kmalloc(sizeof(struct sna_xid_info), GFP_ATOMIC);
+		init_timer(&tg->xid_info->xid_timer);
+		tg->xid_info->xid_timer.function = sna_cs_connect_out;
+		tg->xid_info->xid_timer.data = (unsigned long)tg;
+		tg->xid_info->xid_retry_interval = 3 * HZ;	/* 3 secs */
+		tg->xid_info->xid_retry_limit = 10;
+		tg->xid_info->xid_retries = 0;
+		tg->xid_info->last_tx_xid = NULL;
+		tg->xid_info->last_rx_xid = NULL;
+		tg->xid_info->xid_status        = XID_RESET;
+	}
+	else
+	{
+		memcpy(&tg->tg_vector.desc, &utg->tg_desc, 
+			sizeof(struct sna_tg_desc));
+	}
+
+	do_gettimeofday(&tg->updated);
+	tg->dev				= utg->dev;
+	tg->lsap			= utg->lsap;
+	tg->partner_node_type    	= utg->node_type;
+        tg->intermediate_routing 	= utg->routing;
+	tg->tg_vector.desc.id.pcp_name 	= utg->tg_desc.id.pcp_name;
+        utg->tg_desc.id.pcp_name 	= NULL;
+	memcpy(&tg->tg_vector.chars,&utg->tg_chars,sizeof(struct sna_tg_chars));
+
+	sna_debug(5, "It is %s %d %d\n", tg->tg_vector.desc.id.pcp_name,
+		strlen(tg->tg_vector.desc.id.pcp_name), 
+		tg->tg_vector.desc.id.pcp_len);
+
+//	sna_rss_resource_updates();
+	kfree(utg);
+
+	return (tg->tg_vector.desc.id.tg_number);	/* TG Number */
+}
+
+int sna_tdm_define_node_chars(struct sna_define_node_chars *n)
+{
+	struct sna_tdm_node_cb *cb;
+
+	sna_debug(5, "sna_tdm_define_node_chars\n");
+	cb = sna_tdm_find_node_entry(&n->cp_name);
+	if(!cb)
+	{
+		cb = (struct sna_tdm_node_cb *)kmalloc(sizeof(struct sna_tdm_node_cb), GFP_ATOMIC);
+		memcpy(&cb->netid, &n->cp_name, sizeof(struct sna_netid));
+		memset(&cb->node_vector, 0, sizeof(struct sna_node_vector));
+		cb->tg_list	= NULL;
+		cb->cos_list	= NULL;
+		cb->next	= node_list;
+		node_list	= cb;
+	}
+	do_gettimeofday(&cb->updated);
+	memcpy(&cb->node_vector.desc.cp_name, &n->cp_name,
+		sizeof(struct sna_netid));
+	cb->node_vector.chars.info.route_resistance 	= n->route_resistance;
+	cb->node_vector.chars.info.quiescing		= n->quiescing;
+//	sna_rss_resource_updates();
+
+	return (0);
+}
+
+int sna_tdm_node_congenstion(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_query_cpname(void)
+{
+
+	return (0);
+}
+
+/* Returned last FRSN recieved for cp_name specified */
+unsigned long sna_tdm_request_last_frsn(struct sna_netid *cp_name)
+{
+	struct sna_tdm_node_cb *cb;
+
+	cb = sna_tdm_find_node_entry(cp_name);
+	if(!cb)
+		return (-ENOENT);
+	return (cb->frsn);
+}
+
+/* This only returns the first TG found and does not check for any
+ * options.
+ */
+int sna_tdm_request_tg_vectors(struct sna_rq_tg_vectors *v)
+{
+	struct sna_tdm_node_cb *cb;
+
+	sna_debug(5, "sna_tdm_request_tg_vectors %s.%s\n",
+		v->org_cp_name.net, v->org_cp_name.name);
+
+	cb = sna_tdm_find_node_entry(&v->org_cp_name);
+	if(!cb)
+		return (-ENOENT);
+
+	v->tg_vectors = (struct sna_tg_vector *)
+		kmalloc(sizeof(struct sna_tg_vector), GFP_ATOMIC);
+	memcpy(v->tg_vectors, &cb->tg_list->tg_vector, 
+		sizeof(struct sna_tg_vector));
+	v->tg_vectors->desc.id.pcp_name = (unsigned char *)
+		kmalloc(v->tg_vectors->desc.id.pcp_len + 1, GFP_ATOMIC);
+	strcpy(v->tg_vectors->desc.id.pcp_name, 
+		cb->tg_list->tg_vector.desc.id.pcp_name);
+
+	return (0);
+}
+
+int sna_tdm_garbage_collection(void)
+{
+
+	return (0);
+}
+
+int sna_tdm_tdu_chk_errors(void)
+{
+
+	return (0);
+}
+
+#ifdef CONFIG_PROC_FS
+int sna_tdm_get_info(char *buffer, char **start,
+        off_t offset, int length)
+{
+        struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s\n", "NetID.Node");
+        for(c = node_list; c != NULL; c = c->next)
+        {
+                len += sprintf(buffer + len, "%-18s\n",sna_pr_netid(&c->netid));
+
+                /* Are we still dumping unwanted data then discard the record */                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+
+int sna_tdm_get_info_tg(char *buffer, char **start,
+        off_t offset, int length)
+{
+	struct sna_tdm_node_cb *c;
+        off_t pos = 0, begin = 0;
+        int len = 0;
+
+	len += sprintf(buffer, "%-18s%5s%4s%7s%8s%10s%5s%5s%4s%4s%9s%18s%6s%6s%6s\n",
+                "NetID.Node", "type", "tgn", "status", "garbage",
+		"quiescing", "cpcp", "ecap", "cpc",
+		"cpb", "security", "propagation_delay",
+		"user1", "user2", "user3");
+
+        for(c = node_list; c != NULL; c = c->next)
+        {
+		struct sna_tg_cb *t;
+
+		for(t = c->tg_list; t != NULL; t = t->next)
+		{
+                	len += sprintf(buffer + len, "%-18s", 
+				sna_pr_netid(&c->netid));
+			len += sprintf(buffer + len, "%5d%4d%7d%8d%10d%5d"
+				"%5d%4d%4d%9d%18d%6d%6d%6d\n",
+				t->tg_vector.desc.id.type,
+				t->tg_vector.desc.id.tg_number,
+				t->tg_vector.chars.status,
+				t->tg_vector.chars.garbage,
+				t->tg_vector.chars.quiescing,
+				t->tg_vector.chars.cpcp_session,
+				t->tg_vector.chars.effective_capacity,
+				t->tg_vector.chars.cost_per_connect,
+				t->tg_vector.chars.cost_per_byte,
+				t->tg_vector.chars.security,
+				t->tg_vector.chars.propagation_delay,
+				t->tg_vector.chars.user1,
+				t->tg_vector.chars.user2,
+				t->tg_vector.chars.user3);
+
+			pos = begin + len;
+                	if(pos < offset)
+                	{
+                        	len = 0; 
+				begin = pos;
+                	}
+                	if(pos > offset + length) 
+                        	break;
+		}
+        }
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */
+        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+        if(len < 0)
+                len = 0;
+
+        return (len);
+}
+#endif
+
+
+int sna_tdm_create(struct sna_start_node *start)
+{
+
+	return (0);
+}
+
+int sna_tdm_destroy(struct sna_delete_node *delete)
+{
+	struct sna_tdm_node_cb *cb;
+	struct sna_tg_cb *t;
+
+	for(cb = node_list; cb != NULL; cb = cb->next)
+	{
+		for(t = cb->tg_list; t != NULL; t = t->next)
+			kfree(t);
+		kfree(cb);
+	}
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sna_trs.c linux/net/sna/sna_trs.c
--- linux-2.4.4/net/sna/sna_trs.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sna_trs.c	Mon May 14 21:13:00 2001
@@ -0,0 +1,57 @@
+/* sna_trs.c: Linux Systems Network Architecture implementation
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+#include <linux/in.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/route.h>
+#include <linux/inet.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/sock.h>
+#include <linux/sna.h>
+
+int sna_trs_create(struct sna_start_node *start)
+{
+	sna_debug(5, "sna_trs_create\n");
+	sna_cosm_create(start);
+	sna_rss_create(start);
+	sna_tdm_create(start);
+
+	return (0);
+}
+
+int sna_trs_destroy(struct sna_delete_node *delete)
+{
+	sna_debug(5, "sna_trs_destroy\n");
+	sna_tdm_destroy(delete);
+	sna_rss_destroy(delete);
+	sna_cosm_destroy(delete);
+
+	return (0);
+}
diff -ruN linux-2.4.4/net/sna/sysctl_net_sna.c linux/net/sna/sysctl_net_sna.c
--- linux-2.4.4/net/sna/sysctl_net_sna.c	Wed Dec 31 16:00:00 1969
+++ linux/net/sna/sysctl_net_sna.c	Mon May 14 21:13:12 2001
@@ -0,0 +1,365 @@
+/* sysctl_net_sna.c: Linux Systems Network Architecture implementation
+ * - SysCtrl user interface to Linux-SNA
+ *
+ * Author:
+ * Jay Schulist         <jschlst@samba.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * None of the authors or maintainers or their employers admit
+ * liability nor provide warranty for any of this software.
+ * This material is provided "as is" and at no charge.
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+extern __u32   	sysctl_max_link_stations_cnt;
+extern __u32   	sysctl_max_lu_cnt;
+extern __u32   	sysctl_max_mode_cnt;
+extern __u32   	sysctl_max_inbound_activations;
+extern __u32   	sysctl_max_outbound_activations;
+extern __u32   	sysctl_max_retry_limit;
+extern __u32   	sysctl_max_btu_size;
+extern __u32   	sysctl_max_tx_ru_size;
+extern __u32   	sysctl_max_rx_ru_size;
+extern __u32   	sysctl_max_auto_activation_limit;
+extern __u32   	sysctl_bind_pacing_cnt;
+extern __u8    	sna_debug_level;
+
+/* XID sysctls */
+extern __u32	sysctl_xid_idle_limit;
+extern __u32	sysctl_xid_retry_interval;
+extern __u32	sysctl_xid_retry_limit;
+
+extern int	sysctrl_co_max_retries;
+
+#ifdef CONFIG_SNA_LAR
+extern __u8	sysctrl_find_timer_expire;
+extern __u8	sysctrl_find_count;
+extern __u8	sysctrl_ad_timer_expire;
+extern __u8	sysctrl_ad_count;
+extern __u8	sysctrl_solicit_timer_expire;
+extern __u8	sysctrl_query_timer_expire;
+#endif
+
+#ifdef CONFIG_SYSCTL
+ctl_table sna_bm_table[] = {
+	{0}
+};
+
+static ctl_table sna_bm_dir_table[] = {
+	{NET_SNA_BM, "sna-bm", NULL, 0, 0555, sna_bm_table},
+	{0}
+};
+
+ctl_table sna_pc_table[] = {
+	{0}
+};
+
+ctl_table sna_pc_dir_table[] = {
+	{NET_SNA_PC, "sna-pc", NULL, 0, 0555, sna_pc_table},
+	{0}
+};
+
+ctl_table sna_nof_table[] = {
+	{0}
+};
+
+ctl_table sna_nof_dir_table[] = {
+	{NET_SNA_NOF, "sna-nof", NULL, 0, 0555, sna_nof_table},
+	{0}
+};
+
+ctl_table sna_asm_table[] = {
+	{0}
+};
+
+ctl_table sna_asm_dir_table[] = {
+	{NET_SNA_NOF, "sna-asm", NULL, 0, 0555, sna_asm_table},
+	{0}
+};
+
+ctl_table sna_cosm_table[] = {
+	{0}
+};
+
+ctl_table sna_cosm_dir_table[] = {
+	{NET_SNA_COSM, "sna-cosm", NULL, 0, 0555, sna_cosm_table},
+	{0}
+};
+
+ctl_table sna_cs_table[] = {
+	{0}
+};
+
+ctl_table sna_cs_dir_table[] = {
+	{NET_SNA_CS, "sna-cs", NULL, 0, 0555, sna_cs_table},
+	{0}
+};
+
+ctl_table sna_dlc_table[] = {
+	{0}
+};
+
+ctl_table sna_dlc_dir_table[] = {
+	{NET_SNA_DLC, "sna-dlc", NULL, 0, 0555, sna_dlc_table},
+	{0}
+};
+
+ctl_table sna_ds_table[] = {
+	{0}
+};
+
+ctl_table sna_ds_dir_table[] = {
+	{NET_SNA_DS, "sna-ds", NULL, 0, 0555, sna_ds_table},
+	{0}
+};
+
+ctl_table sna_isr_table[] = {
+	{0}
+};
+
+ctl_table sna_isr_dir_table[] = {
+	{NET_SNA_ISR, "sna-isr", NULL, 0, 0555, sna_isr_table},
+	{0}
+};
+
+ctl_table sna_trs_table[] = {
+	{0}
+};
+
+ctl_table sna_trs_dir_table[] = {
+	{NET_SNA_TRS, "sna-trs", NULL, 0, 0555, sna_trs_table},
+	{0}
+};
+
+static ctl_table sna_appn_dir_table[] = {
+	{NET_SNA_PC, "sna-appn", NULL, 0, 0555, sna_pc_dir_table},
+        {NET_SNA_NOF, "sna-appn", NULL, 0, 0555, sna_nof_dir_table},
+        {NET_SNA_ASM, "sna-appn", NULL, 0, 0555, sna_asm_dir_table},
+        {NET_SNA_COSM, "sna-appn", NULL, 0, 0555, sna_cosm_dir_table},
+        {NET_SNA_CS, "sna-appn", NULL, 0, 0555, sna_cs_dir_table},
+        {NET_SNA_DLC, "sna-appn", NULL, 0, 0555, sna_dlc_dir_table},
+        {NET_SNA_DS, "sna-appn", NULL, 0, 0555, sna_ds_dir_table},
+        {NET_SNA_ISR, "sna-appn", NULL, 0, 0555, sna_isr_dir_table},
+	{NET_SNA_TRS, "sna-appn", NULL, 0, 0555, sna_trs_dir_table},
+	{0}
+};
+
+ctl_table sna_cpic_table[] = {
+	{0}
+};
+
+ctl_table sna_cpic_dir_table[] = {
+	{NET_SNA_CPIC, "sna-cpic", NULL, 0, 0555, sna_cpic_table},
+	{0}
+};
+
+ctl_table sna_hpr_table[] = {
+	{0}
+};
+
+ctl_table sna_hpr_dir_table[] = {
+	{NET_SNA_HPR, "sna-hpr", NULL, 0, 0555, sna_hpr_table},
+	{0}
+};
+
+ctl_table sna_mptn_appletalk_table[] = {
+	{0}
+};
+
+ctl_table sna_mptn_appletalk_dir_table[] = {
+	{NET_SNA_MPTN_APPLETALK, "sna-appletalk", NULL, 0, 0555,
+	sna_mptn_appletalk_table},
+	{0}
+};
+
+ctl_table sna_mptn_ipxspx_table[] = {
+	{0}
+};
+
+ctl_table sna_mptn_ipxspx_dir_table[] = {
+	{NET_SNA_MPTN_IPXSPX, "sna-ipx-spx", NULL, 0, 0555,
+	sna_mptn_ipxspx_table},
+	{0}
+};
+
+ctl_table sna_mptn_ipv4_table[] = {
+	{0}
+};
+
+ctl_table sna_mptn_ipv4_dir_table[] = {
+	{NET_SNA_MPTN_IPV4, "sna-ipv4", NULL, 0, 0555, sna_mptn_ipv4_table},
+	{0}
+};
+
+ctl_table sna_mptn_ipv6_table[] = {
+	{0}
+};
+
+ctl_table sna_mptn_ipv6_dir_table[] = {
+	{NET_SNA_MPTN_IPV6, "sna-ipv6", NULL, 0, 0555, sna_mptn_ipv6_table},
+	{0}
+};
+
+ctl_table sna_mptn_dir_table[] = {
+	{NET_SNA_MPTN_APPLETALK, "sna-mptn", NULL, 0, 0555, 
+	sna_mptn_appletalk_dir_table},
+	{NET_SNA_MPTN_IPXSPX, "sna-mptn", NULL, 0, 0555,
+	sna_mptn_ipxspx_dir_table},
+	{NET_SNA_MPTN_IPV4, "sna-mptn", NULL, 0, 0555,
+	sna_mptn_ipv4_dir_table},
+	{NET_SNA_MPTN_IPV6, "sna-mptn", NULL, 0, 0555,
+	sna_mptn_ipv6_dir_table},
+	{0}
+};
+
+ctl_table sna_lu_rm_table[] = {
+	{0}
+};
+
+ctl_table sna_lu_rm_dir_table[] = {
+	{NET_SNA_LU_RM, "sna-rm", NULL, 0, 0555, sna_lu_rm_table},
+	{0}
+};
+
+ctl_table sna_lu_sm_table[] = {
+	{0}
+};
+
+ctl_table sna_lu_sm_dir_table[] = {
+	{NET_SNA_LU_SM, "sna-sm", NULL, 0, 0555, sna_lu_sm_table},
+	{0}
+};
+
+ctl_table sna_lu_hs_table[] = {
+	{0}
+};
+
+ctl_table sna_lu_hs_dir_table[] = {
+	{NET_SNA_LU_HS, "sna-hs", NULL, 0, 0555, sna_lu_hs_table},
+	{0}
+};
+
+ctl_table sna_lu_ps_table[] = {
+	{0}
+};
+
+ctl_table sna_lu_ps_dir_table[] = {
+	{NET_SNA_LU_PS, "sna-ps", NULL, 0, 0555, sna_lu_ps_table},
+	{0}
+};
+
+ctl_table sna_lu_dir_table[] = {
+	{NET_SNA_LU_RM, "sna-lu", NULL, 0, 0555, sna_lu_rm_dir_table},
+	{NET_SNA_LU_SM, "sna-lu", NULL, 0, 0555, sna_lu_sm_dir_table},
+	{NET_SNA_LU_HS, "sna-lu", NULL, 0, 0555, sna_lu_hs_dir_table},
+	{NET_SNA_LU_PS, "sna-lu", NULL, 0, 0555, sna_lu_ps_dir_table},
+	{0}
+};
+
+#ifdef CONFIG_SNA_LAR
+ctl_table sna_lar_dir_table[] = {
+	{NET_SNA_LAR_FIND_TIMER_EXPIRE, "find_timer_expire",
+	&sysctrl_find_timer_expire, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{NET_SNA_LAR_FIND_COUNT, "find_retry_count",
+	&sysctrl_find_count, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{NET_SNA_LAR_AD_TIMER_EXPIRE, "advertise_timer_expire",
+	&sysctrl_ad_timer_expire, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{NET_SNA_LAR_AD_COUNT, "advertise_retry_count",
+	&sysctrl_ad_count, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{NET_SNA_LAR_SOLICIT_TIMER_EXPIRE, "solicit_timer_expire",
+	&sysctrl_solicit_timer_expire, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{NET_SNA_LAR_QUERY_TIMER_EXPIRE, "query_timer_expire",
+	&sysctrl_query_timer_expire, sizeof(__u8), 0644, NULL,
+	&proc_dointvec_jiffies},
+	{0}
+};
+#endif
+
+ctl_table sna_table[] = {
+	{NET_SNA_MAX_LINK_STATIONS, "max_link_station_count",
+        &sysctl_max_link_stations_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_LU, "max_lu_count",
+        &sysctl_max_lu_cnt, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_MODE, "max_mode_count", &sysctl_max_mode_cnt,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_XID_RETRY, "xid_retry_limit", &sysctl_xid_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_IDLE_LIMIT, "xid_idle_limit", &sysctl_xid_idle_limit,
+	sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_XID_RETRY_INTERVAL, "xid_retry_interval", 
+	&sysctl_xid_retry_interval, sizeof(__u32), 0644, NULL, 
+	&proc_dointvec_jiffies},
+        {NET_SNA_MIA, "max_inbound_activations",
+        &sysctl_max_inbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MOA, "max_outbound_activations",
+        &sysctl_max_outbound_activations, sizeof(__u32), 0644, NULL,
+        &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RETRY, "max_retry_limit", &sysctl_max_retry_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_BTU, "max_btu_size", &sysctl_max_btu_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_TX_RU, "max_tx_ru_size", &sysctl_max_tx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_MAX_RX_RU, "max_rx_ru_size", &sysctl_max_rx_ru_size,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_MAX_AUTO_ACT, "max_auto_activation_limit",
+        &sysctl_max_auto_activation_limit,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+        {NET_SNA_DEBUG, "debug_level", &sna_debug_level,
+        sizeof(__u32), 0644, NULL, &proc_dointvec_jiffies},
+	{NET_SNA_CO_MAX_RETRIES, "max_connect_out_retries",
+	&sysctrl_co_max_retries, 
+	sizeof(int), 0644, NULL, &proc_dointvec_jiffies},
+	{0}
+};
+
+static ctl_table sna_dir_table[] = {
+        {NET_SNA, "sna", NULL, 0, 0555, sna_table},
+	{NET_SNA_BM, "sna", NULL, 0, 0555, sna_bm_dir_table},
+	{NET_SNA_APPN, "sna", NULL, 0, 0555, sna_appn_dir_table},
+	{NET_SNA_CPIC, "sna", NULL, 0, 0555, sna_cpic_dir_table},
+	{NET_SNA_HPR, "sna", NULL, 0, 0555, sna_hpr_dir_table},
+	{NET_SNA_MPTN, "sna", NULL, 0, 0555, sna_mptn_dir_table},
+	{NET_SNA_LU, "sna", NULL, 0, 0555, sna_lu_dir_table},
+#ifdef CONFIG_SNA_LAR
+	{NET_SNA_LAR, "sna", NULL, 0, 0555, sna_lar_dir_table},
+#endif
+        {0}
+};
+
+static ctl_table sna_root_table[] = {
+        {CTL_NET, "net", NULL, 0, 0555, sna_dir_table},
+        {0}
+};
+
+static struct ctl_table_header *sna_table_header;
+
+void sna_register_sysctl(void)
+{
+	sna_table_header = register_sysctl_table(sna_root_table, 1);
+
+	return;
+}
+
+void sna_unregister_sysctl(void)
+{
+	unregister_sysctl_table(sna_table_header);
+
+	return;
+}
+#endif
diff -ruN linux-2.4.4/net/snap/Makefile linux/net/snap/Makefile
--- linux-2.4.4/net/snap/Makefile	Wed Dec 31 16:00:00 1969
+++ linux/net/snap/Makefile	Tue Jan  9 14:15:45 2001
@@ -0,0 +1,22 @@
+#
+# Makefile for the Linux SNAP protocol layer.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definition is now in the main makefile...
+
+O_TARGET := snap.o
+
+obj-y := psnap.o
+obj-m := $(O_TARGET)
+
+export-objs = psnap.o
+
+obj-$(CONFIG_SYSCTL) += sysctl_net_snap.o
+
+include $(TOPDIR)/Rules.make
+
+tar:
+		tar -cvf /dev/f1 .
diff -ruN linux-2.4.4/net/snap/psnap.c linux/net/snap/psnap.c
--- linux-2.4.4/net/snap/psnap.c	Wed Dec 31 16:00:00 1969
+++ linux/net/snap/psnap.c	Mon May 14 21:34:04 2001
@@ -0,0 +1,227 @@
+/* psnap.c: Sub Network Access Protocol (SNAP) data link layer.
+ *
+ * Alan Cox <Alan.Cox@linux.org>, from the 802.2 layer by Greg Page.
+ * Merged in additions from Greg Page's psnap.c.
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Changes:
+ * 20010108	Jay Schulist	Untied SNAP from the 802 directory.
+ *				Enabled SNAP to be compiled as a
+ *				loadable module. Added PROC
+ *				file system support.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/datalink.h>
+#include <net/llc.h>
+#include <net/psnap.h>
+#include <linux/mm.h>
+#include <linux/in.h>
+#include <linux/init.h>
+#include <net/llc.h>
+#include <linux/llc.h>
+#include <linux/proc_fs.h>
+
+static struct datalink_proto *snap_list = NULL;
+static struct datalink_proto *snap_dl = NULL;		/* 802.2 DL for SNAP */
+
+/* Find a snap client by matching the 5 bytes. */
+static struct datalink_proto *find_snap_client(unsigned char *desc)
+{
+	struct datalink_proto *proto;
+
+	for(proto = snap_list; proto != NULL 
+		&& memcmp(proto->type, desc, 5); proto = proto->next);
+		return proto;
+}
+
+/* A SNAP packet has arrived. */
+int snap_rcv(struct sk_buff *skb, struct net_device *dev,struct packet_type *pt)
+{
+	static struct packet_type psnap_packet_type =
+	{
+		0,
+		NULL,		/* All Devices */
+		snap_rcv,
+		NULL,
+		NULL,
+	};
+
+	struct datalink_proto *proto;
+
+	proto = find_snap_client(skb->h.raw);
+	if(proto != NULL)
+	{
+		/* Pass the frame on. */
+		skb->h.raw += 5;
+		skb->nh.raw += 5;
+		skb_pull(skb, 5);
+		if(psnap_packet_type.type == 0)
+			psnap_packet_type.type=htons(ETH_P_SNAP);
+
+		return (proto->rcvfunc(skb, dev, &psnap_packet_type));
+	}
+
+	skb->sk = NULL;
+	kfree_skb(skb);
+
+	return (0);
+}
+
+/* Put a SNAP header on a frame and pass to 802.2. */
+static void snap_datalink_header(struct datalink_proto *dl, struct sk_buff *skb,
+	unsigned char *dest_node)
+{
+	memcpy(skb_push(skb, 5), dl->type, 5);
+	snap_dl->datalink_header(snap_dl, skb, dest_node);
+}
+
+#ifdef CONFIG_PROC_FS
+static int snap_get_info(char *buffer, char **start, off_t offset, int length)
+{
+	struct datalink_proto *p;
+        off_t pos = 0, begin = 0;
+	int len = 0;
+
+        /* Output the SNAP data for the /proc filesystem. */
+        len += sprintf(buffer, "%-11s%-8s\n", "snap-id", "hdr_len");
+
+	for(p = snap_list; p != NULL; p = p->next)
+	{
+		len += sprintf(buffer + len, "%02X%02X%02X%02X%02X",
+			p->type[0], p->type[1], p->type[2], p->type[3],
+			p->type[4]);
+		len += sprintf(buffer + len, "%-8d\n", p->header_length);
+
+		/* Are we still dumping unwanted data then discard the record */
+                pos = begin + len;
+                if(pos < offset)
+                {
+                        len = 0;        /* Keep dumping into the buffer start */                        begin = pos;
+                }
+                if(pos > offset + length)       /* We have dumped enough */
+                        break;
+	}
+
+        /* The data in question runs from begin to begin+len */
+        *start = buffer + (offset - begin);     /* Start of wanted data */
+        len -= (offset - begin);   /* Remove unwanted header data from length */        if(len > length)
+                len = length;      /* Remove unwanted tail data from length */
+	if(len < 0)
+		len = 0;
+
+	return (len);
+}
+#endif /* CONFIG_PROC_FS */
+
+/* Register SNAP clients. We don't yet use this for IP. */
+struct datalink_proto *register_snap_client(unsigned char *desc, 
+	int (*rcvfunc)(struct sk_buff *, struct net_device *, 
+	struct packet_type *))
+{
+	struct datalink_proto *proto, *l;
+
+	if(find_snap_client(desc) != NULL)
+		return (NULL);
+
+	proto = (struct datalink_proto *)kmalloc(sizeof(*proto), GFP_ATOMIC);
+	if(proto != NULL)
+	{
+		memcpy(proto->type, desc, 5);
+		proto->type_len 	= 5;
+		proto->rcvfunc 		= rcvfunc;
+		proto->header_length 	= 5 + snap_dl->header_length;
+		proto->datalink_header 	= snap_datalink_header;
+		proto->string_name 	= "SNAP";
+		proto->next		= NULL;
+	}
+
+	if(snap_list == NULL)
+		snap_list = proto;
+        else
+        {
+                for(l = snap_list; l->next != NULL; l = l->next)
+                        ;
+		l->next = proto;
+        }
+
+	MOD_INC_USE_COUNT;
+
+	return (proto);
+}
+
+/* Unregister SNAP clients. Protocols no longer want to play with us ... */
+void unregister_snap_client(unsigned char *desc)
+{
+	struct datalink_proto **clients = &snap_list;
+	struct datalink_proto *tmp;
+	unsigned long flags;
+
+	save_flags(flags);
+	cli();
+
+	while((tmp = *clients) != NULL)
+	{
+		if(memcmp(tmp->type,desc,5) == 0)
+		{
+			*clients = tmp->next;
+			kfree(tmp);
+			break;
+		}
+		else
+			clients = &tmp->next;
+	}
+
+	restore_flags(flags);
+
+	MOD_DEC_USE_COUNT;
+
+	return;
+}
+
+/* Set up the SNAP layer. */
+int __init snap_init(void)
+{
+        snap_dl = register_8022_client(LLC_SAP_SNAP, snap_rcv, NULL);
+        if(snap_dl == NULL)
+        {
+                printk("SNAP - unable to register with 802.2\n");
+                return (-1);
+        }
+
+        snap_list = NULL;
+
+#ifdef CONFIG_PROC_FS
+        proc_net_create("snap", 0, snap_get_info);
+#endif /* CONFIG_PROC_FS */
+
+        printk(KERN_INFO "Sub-Network Access Protocol (SNAP) services v1.0 for Linux NET4.0\n");
+
+        return (0);
+}
+
+/* SNAP *can not* be unloaded until each client has been unregistered. */
+void __exit snap_exit(void)
+{
+#ifdef CONFIG_PROC_FS
+        proc_net_remove("snap");
+#endif /* CONFIG_PROC_FS */
+
+        unregister_8022_client(LLC_SAP_SNAP);
+        snap_dl = NULL;
+
+        return;
+}
+
+EXPORT_SYMBOL(register_snap_client);
+EXPORT_SYMBOL(unregister_snap_client);
+
+module_init(snap_init);
+module_exit(snap_exit);
diff -ruN linux-2.4.4/net/snap/sysctl_net_snap.c linux/net/snap/sysctl_net_snap.c
--- linux-2.4.4/net/snap/sysctl_net_snap.c	Wed Dec 31 16:00:00 1969
+++ linux/net/snap/sysctl_net_snap.c	Mon Jan  8 15:02:47 2001
@@ -0,0 +1,12 @@
+/* sysctl_net_snap.c: sysctl interface to net SNAP subsystem.
+ *
+ * Begun April 1, 1996, Mike Shaver.
+ * Added /proc/sys/net/snap directory entry (empty =) ). [JJS]
+ */
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+ctl_table snap_table[] = {
+	{0}
+};
diff -ruN linux-2.4.4/net/sysctl_net.c linux/net/sysctl_net.c
--- linux-2.4.4/net/sysctl_net.c	Thu Apr 19 08:38:50 2001
+++ linux/net/sysctl_net.c	Mon May 14 20:27:05 2001
@@ -23,7 +23,7 @@
 extern ctl_table core_table[];
 
 #ifdef CONFIG_NET
-extern ctl_table ether_table[], e802_table[];
+extern ctl_table ether_table[];
 #endif
 
 #ifdef CONFIG_IPV6
@@ -37,7 +37,6 @@
 ctl_table net_table[] = {
 	{NET_CORE,   "core",      NULL, 0, 0555, core_table},      
 #ifdef CONFIG_NET
-	{NET_802,    "802",       NULL, 0, 0555, e802_table},
 	{NET_ETHER,  "ethernet",  NULL, 0, 0555, ether_table},
 #endif
 #ifdef CONFIG_INET
